<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>待办事项</title>
      <link href="//post/todo.html"/>
      <url>//post/todo.html</url>
      
        <content type="html"><![CDATA[<h2 id="特殊记忆"><a href="#特殊记忆" class="headerlink" title="特殊记忆"></a>特殊记忆</h2><div style="display:flex;flex-direction:row; flex-wrap:wrap; align-items: flex-start"><img src="http://t-blog-images.aijs.top/img/20220731104741.png"  style="max-width: 100%; width: 400px"/><img src="http://t-blog-images.aijs.top/img/20220731105416.png" style="max-width: 100%; width: 400px;"/></div><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1. headless-recorder&#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;details&#x2F;122531766&#x2F;&#x2F; 3. 博客封面生成&#x2F;&#x2F;              https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7132111156554301471?share_token&#x3D;4d225658-a9a2-4288-bc4e-892ca5f361fa&#x2F;&#x2F; 4. 装饰器模式 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;decorator&#x2F;&#x2F; 5. iconfont自定义图标 （链接放错了，以后补上，先删掉了）&#x2F;&#x2F; 6. 函数式编程 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;function-production&#x2F;&#x2F; 7. 换肤 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;theme-scss&#x2F;&#x2F; 8.[x] vscode setting sync 另一台电脑配置无法同步到本电脑&#x2F;&#x2F; 9.[x]item2本机重新配置&#x2F;&#x2F; 10.[x]vscode 代码片段在md上失效了&#x2F;&#x2F; 11.[x]typescript 工具类型源码&#x2F;&#x2F; 12. react源码&#x2F;&#x2F; 13. ocr桌面端工具 可以借鉴：想使用 tauri 搞，没遇到好的截屏&#x2F;&#x2F;                     1. https:&#x2F;&#x2F;github.com&#x2F;wulkano&#x2F;Kap  react + Electron开发&#x2F;&#x2F;                     2. vscode插件 ImageToText&#x2F;&#x2F; 14.react源码 debugger https:&#x2F;&#x2F;blog.csdn.net&#x2F;lin_fightin&#x2F;article&#x2F;details&#x2F;125136985?spm&#x3D;1001.2014.3001.5502&#x2F;&#x2F; 15. [x]如何让一个知识点分析图动起来？ ppt动画&#x2F;&#x2F; 16. paste code to snippets 可以进一步优化&#x2F;&#x2F; 17. 进程的stdout信息 反应到pod上 然后被k8s的日志收集系统收集和处理后 存储在日志平台的 https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;92a4c11e77ba&#x2F;&#x2F; 18. [x]文件抓取缓存在指定文件夹下【优先级高】 fileName &#x3D;》download disk&#x2F;&#x2F; 19. node-kafka(以前我总听成 ‘卡不卡’， 我回‘不卡不卡’)&#x2F;&#x2F; 20. 封装公用预览组件，支持各种形式,pc、mobile&#x2F;&#x2F; 21. git https:&#x2F;&#x2F;blog.csdn.net&#x2F;Q1761991696&#x2F;article&#x2F;details&#x2F;123572766&#x2F;&#x2F; 22. [x]gif 播放控制&#x2F;&#x2F;                 方案1: png + gif :https:&#x2F;&#x2F;www.cnblogs.com&#x2F;volodya&#x2F;p&#x2F;15897439.html&#x2F;&#x2F;                 方案2: canvas : https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;d5cc47f6a998?utm_campaign&#x3D;haruki&#x2F;&#x2F;                 方案3: 静态图 + video 实现 知乎 https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;41543963&#x2F;&#x2F; 23. threejs https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7112696052884439070&#x2F;&#x2F; 24. [x]redux中间件，自动生成action、reducer、effect&#x2F;&#x2F; 25. ts. 直接在js中使用 requirets 代码丢了，要重写&#x2F;&#x2F; 26. 业务场景chat bot机器人&#x2F;&#x2F; 27. umd包 https:&#x2F;&#x2F;blog.csdn.net&#x2F;Luckyzhoufangbing&#x2F;article&#x2F;details&#x2F;109221059</code></pre><p>事项：</p><img src="http://t-blog-images.aijs.top/img/20220610103503.webp" width=300 height=/><p><a href="https://github.com/pipipi-pikachu/PPTist" target="_blank" >ppt</a></p><h2 id="好的博客"><a href="#好的博客" class="headerlink" title="好的博客"></a>好的博客</h2><p><a href="https://www.jianshu.com/u/99b8712e8850" target="_blank" >JerryWang_汪子熙 </a></p><h2 id="其他记录-未整理"><a href="#其他记录-未整理" class="headerlink" title="其他记录 未整理"></a>其他记录 未整理</h2><p><a href="https://juejin.cn/post/7107189225509879838" target="_blank" >ahooks 中那些控制“时机”的 hook 都是怎么实现的？</a></p><p>require-ts 项目丢了<br><img src="http://t-blog-images.aijs.top/img/202209021409257.webp" /></p><h2 id="待删除"><a href="#待删除" class="headerlink" title="待删除"></a>待删除</h2><ul><li><a href="http://t-blog-images.aijs.top/img/js">http://t-blog-images.aijs.top/img/js</a> 数组.png</li></ul><h2 id="vs-utils"><a href="#vs-utils" class="headerlink" title="vs-utils"></a>vs-utils</h2><ul><li>json 数据格式化</li><li>restful path format</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">POST &#x2F; api &#x2F; problem;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;api&#x2F;problem POST</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;api&#x2F;problem&#x2F;&#123;id&#125; POST</code></pre><ul><li>restful path to name</li></ul><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><ul><li>注重 设计模式、算法、源码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Todo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.系统学习 mysql 集合</title>
      <link href="//post/2022-11-30mysql-set.html"/>
      <url>//post/2022-11-30mysql-set.html</url>
      
        <content type="html"><![CDATA[<h2 id="并集-UNION"><a href="#并集-UNION" class="headerlink" title="并集 UNION"></a>并集 UNION</h2><p>MySQL UNION 运算符允许您将两个或多个查询结果集合并到一个结果集中<br>要使用 UNION 运算符组合<code>两个或多个查询的结果集</code>，必须遵循以下基本规则：</p><ul><li>首先，所有 SELECT 语句中出现的<code>列的数量和顺序 必须相同</code>。</li><li>其次，<code>列的数据类型必须相同或可转换</code>。</li><li><code>默认情况下，</code> 即使您未明确指定 <code>DISTINCT</code> 运算符<code>，UNION 运算符也会删除 重复的行</code>。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TABLE IF EXISTS t1;DROP TABLE IF EXISTS t2;CREATE TABLE t1 (    id INT PRIMARY KEY);CREATE TABLE t2 (    id INT PRIMARY KEY);INSERT INTO t1 VALUES (1),(2),(3);INSERT INTO t2 VALUES (2),(3),(4);SELECT idFROM t1UNION ALL -- 重复项出现在组合结果集中SELECT idFROM t2;</code></pre><h3 id="UNION-vs-JOIN"><a href="#UNION-vs-JOIN" class="headerlink" title="UNION vs. JOIN"></a>UNION vs. JOIN</h3><ul><li>JOIN 是水平组合结果集，</li><li>UNION 是垂直附加结果集。下图说明了 UNION 和之间的区别 JOIN：</li></ul><img src="http://t-blog-images.aijs.top/img/202211290935843.webp" /><h2 id="交集-MySQL-不支持-INTERSECT-操作符"><a href="#交集-MySQL-不支持-INTERSECT-操作符" class="headerlink" title="交集(MySQL 不支持 INTERSECT 操作符)"></a>交集(MySQL 不支持 INTERSECT 操作符)</h2><p>INTERSECT 运算符是一个集合运算符仅返回两个查询或多个查询的不同行。</p><p>以下说明了 INTERSECT 运算符的语法。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">(SELECT column_list FROM table_1)INTERSECT(SELECT column_list FROM table_2);</code></pre><p><code>INTERSECT</code> 运算符比较两个查询的结果，并返回作为由左，右输出的查询的不同的行。</p><p>要将 <code>INTERSECT</code> 运算符用于两个查询，应用以下规则：</p><ul><li>列的顺序和数量必须相同。</li><li>相应列的数据类型必须兼容。</li></ul><img src="http://t-blog-images.aijs.top/img/202211290938929.webp" style="width:500px;max-width:100%" /><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE t1 (    id INT PRIMARY KEY);CREATE TABLE t2 LIKE t1;INSERT INTO t1(id) VALUES(1),(2),(3);INSERT INTO t2(id) VALUES(2),(3),(4);-- MySQL不支持INTERSECT操作符(SELECT idFROM t1)INTERSECT(SELECT idFROM t2);</code></pre><h3 id="distinct-INNER-JOIN-模拟"><a href="#distinct-INNER-JOIN-模拟" class="headerlink" title="distinct + INNER JOIN 模拟"></a>distinct + INNER JOIN 模拟</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT DISTINCT   idFROM t1   INNER JOIN t2USING(id);</code></pre><h3 id="使用-IN-运算符和子查询模拟"><a href="#使用-IN-运算符和子查询模拟" class="headerlink" title="使用 IN 运算符和子查询模拟"></a>使用 IN 运算符和子查询模拟</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT DISTINCT    idFROM    t1WHERE    id IN    (SELECT id FROM t2);</code></pre><h2 id="差集-MINUS-mysql-不支持-MINUS）"><a href="#差集-MINUS-mysql-不支持-MINUS）" class="headerlink" title="差集 MINUS (mysql 不支持 MINUS）"></a>差集 MINUS (mysql 不支持 MINUS）</h2><p>MINUS 比较两个查询的结果，并返回第一个查询中不是由第二个查询输出的不同行。</p><p>以下说明了 MINUS 运算符的语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT column_list_1 FROM table_1MINUSSELECT columns_list_2 FROM table_2;</code></pre><p>使用 MINUS 运算符的查询的基本规则如下：</p><ul><li>数量和两列的顺序 <code>column_list_1</code> 和 <code>column_list_2</code> 必须相同。</li><li>两个查询中相应列的数据类型必须兼容。</li></ul><img src="http://t-blog-images.aijs.top/img/202211291001282.webp" style="width:500px;max-width:100%" /><p>假设我们有两个表 t1 并 t2 具有以下结构和数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE t1 (    id INT PRIMARY KEY);CREATE TABLE t2 (    id INT PRIMARY KEY);INSERT INTO t1 VALUES (1),(2),(3);INSERT INTO t2 VALUES (2),(3),(4);</code></pre><p>以下查询返回 t1 表的查询中的不同值，这些值在表的查询结果中找不到 t2。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT id FROM t1MINUSSELECT id FROM t2;</code></pre><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟 1"></a>模拟 1</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT idFROM t1LEFT JOIN t2 USING (id)WHERE t2.id IS NULL;</code></pre><h3 id="模拟-2"><a href="#模拟-2" class="headerlink" title="模拟 2"></a>模拟 2</h3>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.系统学习 mysql erd</title>
      <link href="//post/2022-11-30mysql-erd.html"/>
      <url>//post/2022-11-30mysql-erd.html</url>
      
        <content type="html"><![CDATA[<h2 id="ER"><a href="#ER" class="headerlink" title="ER"></a>ER</h2><h3 id="ER-实体关系-Entity-Relationship"><a href="#ER-实体关系-Entity-Relationship" class="headerlink" title="ER 实体关系 Entity Relationship"></a>ER 实体关系 Entity Relationship</h3><h3 id="ER-图鱼尾符号"><a href="#ER-图鱼尾符号" class="headerlink" title="ER 图鱼尾符号"></a>ER 图鱼尾符号</h3><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><img src="http://t-blog-images.aijs.top/img/202211281703920.webp" style="width:500px;max-width:100%" /><p><a href="https://blog.csdn.net/u014100552/article/details/120851258" target="_blank" >见</a></p><h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><img src="http://t-blog-images.aijs.top/img/202211281701016.webp" style="width:500px;max-width:100%" /><p><a href="https://www.yiibai.com/dbms/dbms-notation-of-er-diagram.html" target="_blank" >见</a></p><h2 id="vscode-vuerd-vscode-插件自动生成"><a href="#vscode-vuerd-vscode-插件自动生成" class="headerlink" title="vscode vuerd-vscode 插件自动生成"></a>vscode vuerd-vscode 插件自动生成</h2><p>这个图是自动生成的，</p><p>1 对多<br>0&#x2F;1 对多</p><p>这些事如何在 sql 中体现的？难道是对数据进行分析</p><img src="http://t-blog-images.aijs.top/img/202211301647189.webp" /><h2 id="vuerd-vscode-golang-实体生成（需要自己写脚本）"><a href="#vuerd-vscode-golang-实体生成（需要自己写脚本）" class="headerlink" title="vuerd-vscode golang 实体生成（需要自己写脚本）"></a>vuerd-vscode golang 实体生成（需要自己写脚本）</h2><p><strong>vuerd-vscode 源码看下，是否有搂表的代码</strong></p><img src="http://t-blog-images.aijs.top/img/202211301716008.webp" /><p><span style="color: red">以下内容不完整，我还没改呢，暂时先放着，有空的时候来写</span></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[DATA]  .reduce((buffer, data) &#x3D;&gt; &#123;    const state &#x3D; data.state;    const helper &#x3D; data.helper;    const dataTypes &#x3D; data.dataTypes;    const tableState &#x3D; state.tableState;    const canvasState &#x3D; state.canvasState;    &#x2F;&#x2F; 类型映射    const convertTypeMap &#x3D; &#123;      int: &quot;number&quot;,      long: &quot;number&quot;,      float: &quot;number&quot;,      double: &quot;number&quot;,      decimal: &quot;number&quot;,      boolean: &quot;boolean&quot;,      string: &quot;string&quot;,      lob: &quot;string&quot;,      date: &quot;string&quot;,      dateTime: &quot;string&quot;,      time: &quot;string&quot;,    &#125;;    const getType &#x3D; (name) &#x3D;&gt; &#123;      const dataType &#x3D; dataTypes.find(        (dataType) &#x3D;&gt;          name.toLowerCase().indexOf(dataType.name.toLowerCase()) &#x3D;&#x3D;&#x3D; 0      );      return dataType ? dataType.type : &quot;string&quot;;    &#125;;    const getNameCase &#x3D; (name, nameCase) &#x3D;&gt; &#123;      let changeName &#x3D; name;      switch (nameCase) &#123;        case &quot;camelCase&quot;:          changeName &#x3D; helper.camelCase(name);          break;        case &quot;pascalCase&quot;:          changeName &#x3D; helper.pascalCase(name);          break;        case &quot;snakeCase&quot;:          changeName &#x3D; helper.snakeCase(name);          break;      &#125;      return changeName;    &#125;;    const orderByNameASC &#x3D; (tables) &#x3D;&gt;      tables.sort((a, b) &#x3D;&gt; &#123;        const nameA &#x3D; a.name.toLowerCase();        const nameB &#x3D; b.name.toLowerCase();        if (nameA &lt; nameB) &#123;          return -1;        &#125; else if (nameA &gt; nameB) &#123;          return 1;        &#125;        return 0;      &#125;);    &#x2F;&#x2F; 格式化表    function formatTable(table) &#123;      const tableName &#x3D; getNameCase(table.name, canvasState.tableCase);      if (table.comment.trim() !&#x3D;&#x3D; &quot;&quot;) &#123;        buffer.push(&#96;&#x2F;&#x2F; $&#123;table.comment&#125;&#96;);      &#125;      buffer.push(&#96;type $&#123;tableName&#125; &#123;&#96;);      table.columns.forEach((column) &#x3D;&gt; &#123;        formatColumn(column);      &#125;);      buffer.push(&#96;&#125;&#96;);    &#125;    &#x2F;&#x2F; 格式化列    function formatColumn(column) &#123;      const columnName &#x3D; getNameCase(column.name, canvasState.columnCase);      &#x2F;&#x2F; 生成类型      const typeName &#x3D; getType(column.dataType);      if (column.comment.trim() !&#x3D;&#x3D; &quot;&quot;) &#123;        buffer.push(&#96;  &#x2F;&#x2F; $&#123;column.comment&#125;&#96;);      &#125;      buffer.push(        &#96;  $&#123;columnName&#125;: $&#123;convertTypeMap[typeName]&#125;$&#123;          column.option.notNull ? &quot;&quot; : &quot; | null&quot;        &#125;;&#96;      );    &#125;    orderByNameASC(tableState.tables);    tableState.tables.forEach((table) &#x3D;&gt; &#123;      formatTable(table);      buffer.push(&quot;&quot;);    &#125;);    return buffer;  &#125;, [])  .join(&quot;\n&quot;);</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/u014100552/article/details/120851258" target="_blank" >ER 图鱼尾符号</a></p><p><a href="https://www.yiibai.com/dbms/dbms-notation-of-er-diagram.html" target="_blank" >ER 图的表示法</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.系统学习 mysql 事务</title>
      <link href="//post/2022-11-30mysql-%E4%BA%8B%E5%8A%A1.html"/>
      <url>//post/2022-11-30mysql-%E4%BA%8B%E5%8A%A1.html</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="为什么需要事务"><a href="#为什么需要事务" class="headerlink" title="为什么需要事务"></a>为什么需要事务</h3><p>MySQL 事务允许您执行一组 MySQL 操作，<code>以确保数据库永远不会包含部分操作的结果</code>。</p><ul><li>在一组操作中，如果其中一个操作失败，则会发生回滚以将数据库还原到其原始状态。</li><li>如果没有发生错误，则将整个语句集提交给数据库。</li></ul><h3 id="事务特点"><a href="#事务特点" class="headerlink" title="事务特点"></a>事务特点</h3><p>事务是必须满足 4 个条件<code>(ACID)</code>：</p><p><code>原子性(Atomicity)</code>: 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p><code>一致性(Consistency)</code>:在事务开始之前和事务结束以后，数据库的完整性没有被破坏。应用系统应该从一个正确的状态到另一个正确的状态,这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p><code>隔离性(Isolation)</code>:数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。防止出现：<code>脏读、幻读、不可重复读</code>。</p><p><code>持久性(Durability)</code>:事务处理结束后，对数据的修改就是永久的。<br>————————————————<br>版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xyy1028/article/details/106165503">https://blog.csdn.net/xyy1028/article/details/106165503</a></p><h3 id="mysql-隔离机制"><a href="#mysql-隔离机制" class="headerlink" title="mysql 隔离机制"></a>mysql 隔离机制</h3><p><strong>为了实现事务隔离性</strong></p><img src="http://t-blog-images.aijs.top/img/202211291432266.webp" style="width:500px;max-width:100%" /><p><a href="https://blog.csdn.net/qq_45830276/article/details/125246751" target="_blank" >见</a></p><h3 id="并发导致事务隔离性出问题"><a href="#并发导致事务隔离性出问题" class="headerlink" title="并发导致事务隔离性出问题"></a>并发导致事务隔离性出问题</h3><p>a.如果两个事务<code>并发的修改</code>则必须隔离开。</p><p>b.如果两个事务<code>并发的查询</code>则完全不用隔离。</p><p>c.<code>如果一个事务修改，另一个事务查询</code>，则可能出现<code>脏读、不可重复读、幻读</code>的情况，隔离级别主要针对这种情况。</p><h3 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h3><ol><li><p><code>脏读</code>：一个事务读取到另一个事务未提交的数据。</p></li><li><p><code>不可重复读</code>：一个事务读取到另一个事务已经提交的数据。例如事务 A 读取了一条记录，此时事务 B 修改了该条数据并提交成功，事务 A 再次查询该条数据发现与第一次读取的不一样，即为不可重复度（同一个事务内重复读取的数据不一样，则理解成不可重复读）。</p></li><li><p><code>幻读</code>：一个事务读取到另一个事务已经提交的数据，但与不可重复读不同的是，不可重复读的原因在于 update，而幻读源于其他事务 insert 或 delete 了记录导致记录条数不一致。</p></li></ol><ul><li><code>不可重复读的原因在于 update</code>，</li><li><code>幻读源于其他事务 insert 或 delete 了记录导致记录条数不一致。</code></li></ul><p><a href="https://blog.csdn.net/xyy1028/article/details/106165503" target="_blank" >见</a></p><h3 id="针对上面的三个问题，四大隔离级别："><a href="#针对上面的三个问题，四大隔离级别：" class="headerlink" title="针对上面的三个问题，四大隔离级别："></a>针对上面的三个问题，四大隔离级别：</h3><p><code>读未提交(read uncommitted)</code> : 不作任何隔离，具有脏读、不可重复读、幻读问题</p><p><code>读已提交(read committed) </code>: 可防止脏读，不能防止不可重复读和幻读问题</p><p><code>可重复读(repeatable read) </code>: 可以防止脏读、不可重复读，不能防止幻读问题（mysql 默认是这个隔离级别）</p><p><code>串行化(serializable) </code>: 数据库运行在串行化，上述问题都可以防止，只是性能非常低<br>————————————————<br>版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xyy1028/article/details/106165503">https://blog.csdn.net/xyy1028/article/details/106165503</a></p><img src="http://t-blog-images.aijs.top/img/202211291432266.webp" style="width:500px;max-width:100%" /><h3 id="这几个级别是什么意思，为什么这么命名？"><a href="#这几个级别是什么意思，为什么这么命名？" class="headerlink" title="这几个级别是什么意思，为什么这么命名？"></a>这几个级别是什么意思，为什么这么命名？</h3><ul><li><code>读未提交(read uncommitted)</code> 事务 A 读到了事务 B 未提交的数据</li><li><code>读已提交(read committed) </code> 事务 A 读到了事务 B 已提交的数据</li><li><code>可重复读(repeatable read) </code>，事务 A 读到了快照，与事务 B 操作无关</li></ul><h3 id="可重复读级别出现读不到，但却可更新"><a href="#可重复读级别出现读不到，但却可更新" class="headerlink" title="可重复读级别出现读不到，但却可更新"></a>可重复读级别出现读不到，但却可更新</h3><p>为什么是这样呢？</p><p>要了解这个原因,则还需要知道另一个概念:<code>MVCC</code></p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="为什么存在"><a href="#为什么存在" class="headerlink" title="为什么存在"></a>为什么存在</h4><p>是为了解决<code>rc</code>和<code>rr</code>现象，效率高开销低，避免加锁，设计的</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>MVCC 全称 Mutli Version Concurreny Control，多版本并发控制，是 MySQL 中基于<code>乐观锁</code>理论实现隔离级别的方式，用于实现<code>读已提交(read committed)</code>和<code>可重复读(repeatable read)</code>隔离级别的实现。<br>它通过行的多版本控制方式来读取当前执行时间数据库中的行数据。原理是<code>将数据保存在某个时间点(版本号)的快照来实现的</code>，MySQL 中 MVCC 的实现方式是在数据库保存最新版本的数据，但是会在使用 undo 时动态重构旧版本数据。这样就可以实现不加锁读。</p><p>MVCC 可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此效率高开销低。MVCC 实现了非阻塞的读操作，写操作也只锁定必要的行。</p></blockquote><h4 id="InnoDB-的-MVCC-实现机制"><a href="#InnoDB-的-MVCC-实现机制" class="headerlink" title="InnoDB 的 MVCC 实现机制"></a>InnoDB 的 MVCC 实现机制</h4><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。<br>这两个列，<br>一个保存了行的创建时间，<br>一个保存行的过期时间（或删除时间）。</p><p>当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在可重复读(repeatable read)隔离级别下，MVCC 具体是如何操作的：</p></blockquote><h4 id="MySQL-中，会在表中每一条数据后面添加两个隐藏字段"><a href="#MySQL-中，会在表中每一条数据后面添加两个隐藏字段" class="headerlink" title="MySQL 中，会在表中每一条数据后面添加两个隐藏字段:"></a>MySQL 中，会在表中每一条数据后面添加两个隐藏字段:</h4><p><em>创建版本号：</em> 创建一行数据时，将当前系统版本号作为创建版本号赋值<br><em>删除版本号：</em> 删除一行数据时，将当前系统版本号作为删除版本号赋值</p><h4 id="在-RR-隔离级别下，MVCC-的操作如下"><a href="#在-RR-隔离级别下，MVCC-的操作如下" class="headerlink" title="在 RR 隔离级别下，MVCC 的操作如下:"></a>在 RR 隔离级别下，MVCC 的操作如下:</h4><p>select 读取数据的规则必须同时满足以下两个条件：</p><p><em>a. 创建版本号 &lt;&#x3D; 当前事务版本号:</em></p><p>InnoDB 只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务本身插入或者修改过的。（这也是我们为什么在可重复读隔离级别下,读操作不会查到其他事务新增的数据,但是进行修改操作后却读出了三条数据的原因）</p><p><em>b. 删除版本号为空 或 &gt; 当前事务版本号:</em></p><p>这可以确保事务读取到的行，在事务开始之前未被删除。</p><p><code>insert 操作:</code><br>InnoDB 为新插入的每一行保存当前系统版本号作为行的创建版本号。</p><p><code>delete 操作:</code><br>InnoDB 为删除的每一行保存当前系统版本号作为行的删除版本号。</p><p><code>update 操作:</code><br>插入一条新记录，保存当前系统版本号为行创建版本号，同时保存当前系统版本号到原来的行删除版本号，实际上这里的更新是通过 delete 和 insert 实现的。</p><h4 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h4><p>MVCC 机制虽然让数据可重复读</p><ul><li>有时我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它<code>快照读(snapshot read)</code>，</li><li>而读取数据库最新版本数据的方式，叫<code>当前读 (current read)</code>。</li></ul><h4 id="快照读："><a href="#快照读：" class="headerlink" title="快照读："></a>快照读：</h4><p><code>当执行 select 操作时 innodb 默认会执行快照读</code>，会记录下这次 select 后的结果，之后 select 的时候就会返回这次快照的数据，即使其他事务提交了也不会影响当前 select 的数据，这就实现了可重复读了。</p><p>如上所示，开启了事务 A、B、C，</p><ol><li>这时候事务 A 插入了一条数据然后提交,</li><li>然后事务 C 这时候执行 select，那么返回的数据中就会有事务 A 添加的那条数据。</li><li>但是之后无论再有其他事务插入并提交数据都没有关系，因为快照已经生成了，事务 C 后面的 select 都是根据快照来的。</li></ol><h4 id="当前读："><a href="#当前读：" class="headerlink" title="当前读："></a>当前读：</h4><p><code>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。</code><br>在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。<br>假设要更新一条记录，但是在另一个事务中已经删除掉这条数据并且提交了，如果更新就会产生冲突，所以在 update 的时候需要知道最新的数据。</p><h4 id="select-的当前读需要手动的加锁："><a href="#select-的当前读需要手动的加锁：" class="headerlink" title="select 的当前读需要手动的加锁："></a>select 的当前读需要手动的加锁：</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select _ from user lock in share mode;select _ from user for update;</code></pre><p>综上所述，在快照读读情况下，MySQL 通过 MVCC 可以避免幻读。但是在当前读情况下幻读依然存在，所以说 MVCC 对于幻读的解决是不彻底的</p><p>————————————————<br>版权声明：本文为 CSDN 博主「纯洁的小魔鬼」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xyy1028/article/details/106165503">https://blog.csdn.net/xyy1028/article/details/106165503</a></p><h4 id="那么如何彻底解决幻读"><a href="#那么如何彻底解决幻读" class="headerlink" title="那么如何彻底解决幻读"></a>那么如何彻底解决幻读</h4><p><strong>法一：</strong>使用串行化读的隔离级别，但该方法效率太低。</p><p><strong>法二：</strong>我们先大概看看 mysql InnoDB 引擎下的行锁:</p><p><code>Record lock：</code>单个行记录上的锁<br><code>Gap lock：</code>间隙锁，锁定一个范围，不包括记录本身<br><code>Next-key lock：</code>Record + Gap 锁定一个范围，包含记录本身 <a href="https://www.zhihu.com/question/437140380#:~:text=%23-,%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F,-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB" target="_blank" ><code>【可能导致死锁现象】</code></a></p><p>在纯粹的读操作时,Innodb 用 MVCC 解决幻读问题,新的 insert 和 update 不会阻塞。<br>在涉及到写操作时,Innodb 用 MVCC 和 Next-key lock 解决幻读问题,新的 insert 和 update 会阻塞。</p><p>当我们为 select 后加上 for update 或者 lock in share mode,则查找到的行会被加上 Next-key lock</p><h3 id="表锁定"><a href="#表锁定" class="headerlink" title="表锁定"></a>表锁定</h3><ul><li><code>读锁</code>是<code>“共享”锁</code>，它可以防止正在获取写锁，但不能锁定其他读锁。</li><li><code>写锁</code>是<code>“独占”锁</code>，可以防止任何其他类型的锁。</li><li>如果会话正常或异常终止，MySQL 将<code>隐式释放所有锁</code>。此功能也与 WRITE 锁相关。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 要锁定表，请在LOCK TABLES关键字后指定其名称。此外，您可以指定锁的类型，可以是   READ或  WRITE。LOCK TABLES table_name [READ | WRITE]-- 要释放表的锁，请使用以下语句：UNLOCK TABLES;-- SHOW PROCESSLIST查看详细信息。mysql&gt; SHOW PROCESSLIST;+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+| Id   | User | Host            | db        | Command | Time | State                        | Info                            |+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+| 4884 | root | localhost:64108 | mysqldemo | Sleep   | 1479 |                              | NULL                            || 4892 | root | localhost       | mysqldemo | Query   |    0 | init                         | SHOW PROCESSLIST                || 4896 | root | localhost       | mysqldemo | Query   |   97 | Waiting for table level lock | INSERT INTO tbl(col) VALUES(20) |+------+------+-----------------+-----------+---------+------+------------------------------+---------------------------------+3 rows in set (0.00 sec)</code></pre><h3 id="行锁-x2F-记录锁-x2F-间隙锁-x2F-表锁"><a href="#行锁-x2F-记录锁-x2F-间隙锁-x2F-表锁" class="headerlink" title="行锁&#x2F;记录锁&#x2F;间隙锁&#x2F;表锁"></a>行锁&#x2F;记录锁&#x2F;间隙锁&#x2F;表锁</h3><ul><li>行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from performance_schema.data_locks\G;-- 这条语句，查看事务执行 SQL 过程中加了什么锁</code></pre><p>LOCK_TYPE 中的 <code>RECORD 表示行级锁，而不是记录锁的意思</code>，</p><p>通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p><ul><li>如果 LOCK_MODE 为 <code>X</code>，说明是 X 型的 next-key 锁；</li><li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是 X 型的记录锁；</li><li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是 X 型的间隙锁；</li></ul><p>作者：小林 coding<br>链接：<a href="https://www.zhihu.com/question/437140380/answer/2619527535">https://www.zhihu.com/question/437140380/answer/2619527535</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="锁的退化"><a href="#锁的退化" class="headerlink" title="锁的退化"></a>锁的退化</h3><ul><li>如果表中最后一个记录的 order_no 为 1005，那么等值查询 order_no &#x3D; 1006（不存在），就是 next key lock，如上面事务 A 的情况。</li><li>如果表中最后一个记录的 order_no 为 1010，那么等值查询 order_no &#x3D; 1006（不存在），就是间隙锁</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id &#x3D; 1008 的记录就会被锁住：--Insert into t_order (order_no, create_date) values (1008, now());</code></pre><p><strong>而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。</strong><br><strong>而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select … for update 语句并不会相互影响。</strong></p><p>作者：小林 coding<br>链接：<a href="https://www.zhihu.com/question/437140380/answer/2619527535">https://www.zhihu.com/question/437140380/answer/2619527535</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="MySQL-死锁产生的原因和解决方法"><a href="#MySQL-死锁产生的原因和解决方法" class="headerlink" title="MySQL 死锁产生的原因和解决方法"></a>MySQL 死锁产生的原因和解决方法</h3><h4 id="产生的条件"><a href="#产生的条件" class="headerlink" title="产生的条件"></a>产生的条件</h4><p>因争夺资源而造成的一种互相等待的现象</p><p><strong>死锁的四个必要条件</strong>：<code>互斥</code>、<code>占有且等待</code>、<code>不可强占用</code>、<code>循环等待</code>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p><a href="https://blog.csdn.net/java1527/article/details/127105144" target="_blank" >MySQL 死锁产生的原因和解决方法</a></p><h4 id="规避措施"><a href="#规避措施" class="headerlink" title="规避措施"></a>规避措施</h4><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ul><li><code>设置事务等待锁的超时时间</code>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li><li><code>开启主动死锁检测</code>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li></ul><p>作者：小林 coding<br>链接：<a href="https://www.zhihu.com/question/437140380/answer/2619527535">https://www.zhihu.com/question/437140380/answer/2619527535</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/xyy1028/article/details/106165503" target="_blank" >Mysql 事务</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.系统学习 mysql CRUD</title>
      <link href="//post/2022-11-30mysql-crud.html"/>
      <url>//post/2022-11-30mysql-crud.html</url>
      
        <content type="html"><![CDATA[<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="INSERT-x2F-INSERT-INTO-SELECT"><a href="#INSERT-x2F-INSERT-INTO-SELECT" class="headerlink" title="INSERT &#x2F; INSERT INTO SELECT"></a>INSERT &#x2F; INSERT INTO SELECT</h3><ul><li>单行插入</li><li>多行插入</li><li>默认值插入</li><li>日期值插入</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 单行&#x2F;多行插入INSERT INTO table_name(c1,c2,...)VALUES(v1,v2,..);-- 多行插入INSERT INTO table_name(column_list)SELECT   select_listFROM   another_table;</code></pre><h2 id="DELETE-x2F-ON-DELETE-CASCADE-x2F-DELETE-JOIN"><a href="#DELETE-x2F-ON-DELETE-CASCADE-x2F-DELETE-JOIN" class="headerlink" title="DELETE &#x2F; ON DELETE CASCADE &#x2F; DELETE JOIN"></a>DELETE &#x2F; ON DELETE CASCADE &#x2F; DELETE JOIN</h2><ul><li>从表中删除数据外，DELETE 语句还返回已删除的行数</li><li>要使用单个 DELETE 语句从多个表中删除数据，请使用 DELETE JOIN 我们将在下一个教程中介绍的语句。</li><li>要删除表中的所有行而不需要知道删除了多少行，您应使用 TRUNCATE TABLE 语句来获得更好的性能。</li><li>对于具有外键约束的表，当从父表中删除行时，将使用 ON DELETE CASCADE 选项自动删除子表中的行。</li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：WHERE 子句是可选项。如果省略 WHERE 子句，DELETE 语句将删除表中的所有行。</p></div><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELETE FROM table_nameWHERE condition;-- DELETE语句选择客户France，按信用额度从低到高对其进行排序，并删除前5个客户：DELETE FROM customersWHERE country &#x3D; &#39;France&#39;ORDER BY creditLimitLIMIT 5;</code></pre><h3 id="跨表删除"><a href="#跨表删除" class="headerlink" title="跨表删除"></a>跨表删除</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- ON DELETE CASCADE-- 关联表父表删除，子表也删除-- 多个相关表的单个DELETE语句，子表具有对外键的 ON DELETE CASCADE引用操作-- 使用INNER JOIN语句中的子句DELETE删除表中的行和另一个表中的匹配行</code></pre><h3 id="关联表删除"><a href="#关联表删除" class="headerlink" title="关联表删除"></a>关联表删除</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TABLE IF EXISTS t1, t2;CREATE TABLE t1 (    id INT PRIMARY KEY AUTO_INCREMENT);CREATE TABLE t2 (    id VARCHAR(20) PRIMARY KEY,    ref INT NOT NULL);INSERT INTO t1 VALUES (1),(2),(3);INSERT INTO t2(id,ref) VALUES(&#39;A&#39;,1),(&#39;B&#39;,2),(&#39;C&#39;,3);-- 删除t1表中id为1的行，并使用DELETE...INNER JOIN语句删除在t2表中ref &#x3D; 1的行DELETE t1,t2 FROM t1        INNER JOIN    t2 ON t2.ref &#x3D; t1.idWHERE    t1.id &#x3D; 1;-- 声明返回以下消息：-- 2 row(s) affected-- 它表明已删除了两行。</code></pre><h3 id="使用-LEFT-JOIN-删除-JOIN"><a href="#使用-LEFT-JOIN-删除-JOIN" class="headerlink" title="使用 LEFT JOIN 删除 JOIN"></a>使用 LEFT JOIN 删除 JOIN</h3><p><strong>语法</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 使用SELECT语句中的 LEFT JOIN子句来查找左表中的行，这些行在右表中有或没有匹配的行。-- 使用DELETE语句中的LEFT JOIN子句删除表（左表）中的行，这些行在另一个表（右表）中没有匹配的行DELETE T1FROM T1        LEFT JOIN    T2 ON T1.key &#x3D; T2.keyWHERE    T2.key IS NULL;</code></pre><p><strong>例子</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 每个客户都有零个或多个订单。但是，每个订单属于一个且只有一个客户。-- 我们可以使用DELETE和 LEFT JOIN子句来清理客户主数据。以下语句删除未下订单的客户：DELETE customersFROM customers        LEFT JOIN    orders ON customers.customerNumber &#x3D; orders.customerNumberWHERE    orderNumber IS NULL;</code></pre><p>在这个声明中：</p><ul><li>首先，指定从中删除数据的表。</li><li>其次，使用条件指定 WHERE 子句中要删除的行。如果行符合条件，则将删除行。</li><li>注意：WHERE 子句是可选项。如果省略 WHERE 子句，DELETE 语句将删除表中的所有行。</li><li><code>返回删除行</code>: 除了从表中删除数据外，DELETE 语句还返回已删除的行数。</li><li><code>多表删除</code>: 要使用单个 DELETE 语句从多个表中删除数据，请使用 DELETE JOIN 我们将在下一个教程中介绍的语句。</li><li><code>提高删除性能</code>: 要删除表中的所有行而不需要知道删除了多少行，您应使用 TRUNCATE TABLE 语句来获得更好的性能。</li><li><code>约束删除</code>: 对于具有外键约束的表，当从父表中删除行时，将使用 <code>ON DELETE CASCADE</code> 选项自动删除子表中的行。</li></ul><p><strong>这里有个问题，</strong></p><ul><li><code>不自动删除子表</code>: 如果不想删除对应的子表，应该先取消关联，然后执行删除</li><li><code>自动删除子表</code>: <code>ON DELETE CASCADE</code> 选项自动删除子表中的行</li></ul><p><a href="https://www.begtut.com/mysql/mysql-on-delete-cascade.html#:~:text=%E6%9F%A5%E6%89%BE%E5%8F%97MySQL%20ON%20DELETE%20CASCADE%E6%93%8D%E4%BD%9C%E5%BD%B1%E5%93%8D%E7%9A%84%E8%A1%A8%E7%9A%84%E6%8F%90%E7%A4%BA" target="_blank" >查找受 MySQL ON DELETE CASCADE 操作影响的表的提示, 没懂(TODO:)</a></p><h2 id="UPDATE-x2F-UPDATE-JOIN"><a href="#UPDATE-x2F-UPDATE-JOIN" class="headerlink" title="UPDATE &#x2F; UPDATE JOIN"></a>UPDATE &#x2F; UPDATE JOIN</h2><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p><a href="https://www.begtut.com/mysql/mysql-update-join.html" target="_blank" >感觉不是很懂(TODO:)</a></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 用UPDATE语句更新表中的现有数据UPDATE [LOW_PRIORITY] [IGNORE] table_nameSET    column_name1 &#x3D; expr1,    column_name2 &#x3D; expr2,    ...[WHERE    condition];</code></pre><p>UPDATE 声明：</p><ul><li>首先，指定要在 UPDATE 关键字后更新数据的表名。</li><li>其次，SET 子句指定要修改的列和新值。要更新多个列，请使用逗号分隔的分配列表。您可以以文字值，表达式或子查询的形式在每列的赋值中提供值。</li><li>第三，使用 WHERE 子句中的条件指定要更新的行。WHERE 子句是可选项。<span style="color: red">如果省略 WHERE 子句，UPDATE 语句将更新表中的所有行</span>。</li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意： WHERE 子句非常重要，您可能只想改变一行; <span style="color: red">但是，您可能会忘记 WHERE 子句并意外更新表的所有行</span>。</div><p>MySQL 在 UPDATE 语句中支持两个修饰符。</p><ul><li><code>LOW_PRIORITY</code> 修正指示 <code>UPDATE</code> 延迟更新，<code>直到没有连接从表中读取数据的语句</code>。</li><li><code>LOW_PRIORITY</code> 只对表级锁的存储引擎使用生效，例如，MyISAM 数据，MERGE，MEMORY。</li><li><code>IGNORE</code> 修改使 UPDATE 语句继续更新，即使发生错误的行。导致错误（例如重复键冲突）的行不会更新。</li></ul><h3 id="使用查询结果作为更新后的值-找现成的用"><a href="#使用查询结果作为更新后的值-找现成的用" class="headerlink" title="使用查询结果作为更新后的值(找现成的用)"></a>使用查询结果作为更新后的值(找现成的用)</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE customersSET    salesRepEmployeeNumber &#x3D; (SELECT            employeeNumber        FROM            employees        WHERE            jobtitle &#x3D; &#39;Sales Rep&#39;        LIMIT 1)WHERE    salesRepEmployeeNumber IS NULL;</code></pre><h3 id="UPDATE-JOIN"><a href="#UPDATE-JOIN" class="headerlink" title="UPDATE JOIN"></a>UPDATE JOIN</h3><p>跨表更新</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE T1, T2,[INNER JOIN | LEFT JOIN] T1 ON T1.C1 &#x3D; T2. C1SET T1.C2 &#x3D; T2.C2,    T2.C3 &#x3D; exprWHERE condition-- 这个与下面那个等效（骚操作？）UPDATE T1, T2SET T1.c2 &#x3D; T2.c2,      T2.c3 &#x3D; exprWHERE T1.c1 &#x3D; T2.c1 AND condition-- 此UPDATE  语句UPDATE JOIN  与隐式INNER JOIN  子句的作用相同UPDATE T1,T2INNER JOIN T2 ON T1.C1 &#x3D; T2.C1 --这句SET T1.C2 &#x3D; T2.C2,      T2.C3 &#x3D; exprWHERE condition-- 让我们看一下使用UPDATE JOIN  语句进行更好理解的一些示例-- INNER JOINUPDATE employees        INNER JOIN       merits        ON employees.performance &#x3D; merits.performanceSET    salary &#x3D; salary + salary * percentage;-- LEFT JOINUPDATE  employees  LEFT JOIN merits ON employees.performance &#x3D; merits.performanceSET  salary &#x3D; salary + salary * 0.015WHERE  merits.percentage IS NULL;</code></pre><h2 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h2><p>MySQL REPLACE 语句是标准 SQL 的 MySQL 扩展。MySQL REPLACE 语句的工作原理如下：</p><ul><li>如果<code>新行已不存在</code>，则 MySQL REPLACE 语句<code>将插入新行</code>。</li><li>如果<code>新行已存在</code>，则 REPLACE 语句首<code>先删除旧行，然后插入新行</code>。在某些情况下，REPLACE 语句仅更新现有行。</li><li>要确定表中是否已存在新行，MySQL <code>使用 PRIMARY KEY 或 UNIQUE KEY 索引。如果表没有这些索引之一，则 REPLACE 语句等同于 INSERT 语句</code>。</li></ul><p>使用 MySQL REPLACE 的语句，<em>你需要有至少两个 INSERT 和 DELETE 权限。</em></p><p>注意：有一个 REPLACE 字符串函数 ，它不是 REPLACE 本教程中介绍的语句。</p><ul><li><em>和插入语法类似， 除了关键字 INSERT 被关键字替换 REPLACE</em></li><li>未出现在 REPLACE 语句中的列的默认值将插入到相应的列中。如果列具有 NOT NULL 属性且没有默认值，并且您未在 REPLACE 语句中指定值，则 MySQL 将引发错误</li></ul><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>REPLACE 语句的第一种形式类似于 INSERT 语句，除了关键字 INSERT 被关键字替换 REPLACE 如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">REPLACE INTO table_name(column_list)VALUES(value_list);</code></pre><p>例如，如果要在 cities 表中插入新行，请使用以下查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">REPLACE INTO cities(name,population)VALUES(&#39;Phoenix&#39;,1321523);</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>注意：</p><p>REPLACE 和 INSERT 语句之间的区别。</p><ol><li>未出现在 REPLACE 语句中的列的默认值将插入到相应的列中。</li><li>如果列具有 NOT NULL 属性且没有默认值，并且您未在 REPLACE 语句中指定值，则 MySQL 将引发错误。</li></ol></p></div><p>例如，在以下语句中，我们仅指定 name 列的值，而不是 population 列。MySQL 引发错误消息。因为 population 列不接受 NULL 值，所以我们在定义 cities 表时没有为它指定默认值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">REPLACE INTO cities(name)VALUES(&#39;Houston&#39;);</code></pre><p>这是 MySQL 发出的错误消息：</p><pre class="line-numbers language-none"><code class="language-none">Error Code: 1364. Field &#39;population&#39; doesn&#39;t have a default value</code></pre><h3 id="UPDATE-1"><a href="#UPDATE-1" class="headerlink" title="UPDATE"></a>UPDATE</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 例如，如果要更新Phoenix城市的人口1768980，请使用以下REPLACE语句：REPLACE INTO citiesSET id &#x3D; 4,    name &#x3D; &#39;Phoenix&#39;, -- 如果注释这里也会出现null    population &#x3D; 1768980;-- 与UPDATE语句不同，如果未在SET子句中指定列的值，则REPLACE语句将使用列的默认值。mysql&gt; select * from cities;+----+-----------+------------+| id | name      | population |+----+-----------+------------+|  1 | New York  |    1008256 ||  2 | hello     |        120 ||  3 | San Diego |    1223405 ||  4 | Phoenix   |    1321523 ||  5 | New York  |    1008256 |+----+-----------+------------+5 rows in set (0.00 sec)mysql&gt; REPLACE INTO cities SET id &#x3D; 4,      population &#x3D; 1768980; ;Query OK, 2 rows affected (0.02 sec)ERROR:No query specifiedmysql&gt; select * from cities;+----+-----------+------------+| id | name      | population |+----+-----------+------------+|  1 | New York  |    1008256 ||  2 | hello     |        120 ||  3 | San Diego |    1223405 ||  4 | NULL      |    1768980 ||  5 | New York  |    1008256 |+----+-----------+------------+5 rows in set (0.00 sec)</code></pre><h3 id="REPLACE-INTO-和-SELECT"><a href="#REPLACE-INTO-和-SELECT" class="headerlink" title="REPLACE INTO 和 SELECT"></a>REPLACE INTO 和 SELECT</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">REPLACE INTO table_1(column_list)SELECT column_listFROM table_2WHERE where_condition;-- 假设您要复制id值为1的城市，请将REPLACE INTO SELECT语句用作以下查询：REPLACE INTO cities(name,population)SELECT name,population FROM citiesWHERE id &#x3D; 1;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.系统学习 mysql 约束</title>
      <link href="//post/2022-11-30mysql-%E7%BA%A6%E6%9D%9F.html"/>
      <url>//post/2022-11-30mysql-%E7%BA%A6%E6%9D%9F.html</url>
      
        <content type="html"><![CDATA[<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="非空-not-null"><a href="#非空-not-null" class="headerlink" title="非空 not null"></a>非空 not null</h3><p>NOT NULL 约束是列约束，迫使一列的值非 NULL 值。</p><p>NOT NULL 约束的语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">column_name data_type NOT NULL DEFAULT value;-- 列 NOT NULL 只包含一个约束，它指定列不得包含任何 NULL 值的规则。-- 建表语句非空约束CREATE TABLE tasks (    id INT AUTO_INCREMENT PRIMARY KEY,    title VARCHAR(255) NOT NULL,    start_date DATE NOT NULL,    end_date DATE);-- 第三，将NOT NULL约束添加到end_date列。为此，您使用以下ALTER TABLE语句：ALTER TABLE table_nameCHANGE old_column_name new_column_name new_column_definition;</code></pre><h3 id="主键-primary-key-（1-个、可组合）"><a href="#主键-primary-key-（1-个、可组合）" class="headerlink" title="主键 primary key （1 个、可组合）"></a>主键 primary key （1 个、可组合）</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 列尾增加主键约束CREATE TABLE users(   user_id INT AUTO_INCREMENT PRIMARY KEY,   username VARCHAR(40),   password VARCHAR(255),   email VARCHAR(255));-- 语句尾部增加约束CREATE TABLE roles(   role_id INT AUTO_INCREMENT,   role_name VARCHAR(50),   PRIMARY KEY(role_id));-- 组合主键CREATE TABLE user_roles(   user_id INT NOT NULL,   role_id INT NOT NULL,  --  组合   PRIMARY KEY(user_id,role_id),   FOREIGN KEY(user_id) REFERENCES users(user_id),   FOREIGN KEY(role_id) REFERENCES roles(role_id));-- 增加主键约束ALTER TABLE table_nameADD PRIMARY KEY(primary_key_column);-- 与PRIMARY索引不同-- MySQL允许UNIQUE索引中有NULL值。-- 表可以有多个UNIQUE索引。-- 为username列添加 UNIQUE 索引。ALTER TABLE usersADD UNIQUE INDEX username_unique (username ASC) ;-- 为email列添加 UNIQUE 索引。ALTER TABLE usersADD UNIQUE INDEX email_unique (email ASC) ;</code></pre><h3 id="外键-foreign-key-（可多个、可组合）"><a href="#外键-foreign-key-（可多个、可组合）" class="headerlink" title="外键 foreign key （可多个、可组合）"></a>外键 foreign key （可多个、可组合）</h3><p><strong>不同表外键</strong></p><ul><li>customers 表和 orders 表<code>之间的关系是一对多</code></li><li>customers 表称为<code>父表</code>，orders 表称为<code>子表</code></li></ul><p><strong>相同表外键</strong></p><ul><li>子表和父表是相同的,<code>自关联</code></li></ul><p><strong>存在形式</strong></p><ul><li>外键可以是一个列或一组列。子表中的列通常引用父表中的主键列。</li><li>表可以具有多个外键，子表中的每个外键可以引用不同的父表。</li></ul><p><strong>操作</strong></p><ul><li>建表时外键约束语句</li><li>加列时外键约束语句</li><li>增加外键约束</li><li>删除外键约束</li><li>组合外键约束</li></ul><p><strong>ON DELETE&#x2F;ON UPDATE</strong></p><ul><li><em>ON DELETE</em> 子句允许您定义<code>删除父表中的记录时子表中记录的内容</code>。如果省略 ON DELETE 子句并删除父表中包含子表中记录的记录，MySQL 将拒绝删除。此外，MySQL 还为您提供操作，以便您可以使用其他选项，例如 - <code>ON DELETE CASCADE</code>要求 MySQL 删除子表中的记录，当父表中的记录被删除时，记录将引用父表中的记录</li><li><code>ON DELETE SET NULL</code> 不希望删除子表中的相关记录。MySQL 会将子表中的外键列值设置为 NULL 删除父表中的记录时，条件是子表中的外键列必须接受 NULL 值</li><li><code>ON DELETE NO ACTION</code> 或 <code>ON DELETE RESTRICT</code> 操作，MySQL 将拒绝删除。<br/><br/></li><li><em>ON UPDATE</em> 子句使您可以指定<code>更新父表中的行时子表中的行会发生什么</code>。您可以省略 ON UPDATE 子句，以便在更新父表中的行时让 MySQL 拒绝对子表中行的任何更新。</li><li><code>ON UPDATE CASCADE</code> 操作允许您执行跨表更新，并且当更新父表</li><li><code>ON UPDATE SET NULL</code> 中的行时，操作会将子表中的行中的值重置为值 NULL</li><li><code>ON UPDATE NO ACTION</code> 或 <code>ON UPDATE RESTRICT</code> 行动拒绝任何更新。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE DATABASE IF NOT EXISTS dbdemo;USE dbdemo;CREATE TABLE categories(   cat_id int not null auto_increment primary key,   cat_name varchar(255) not null,   cat_description text) ENGINE&#x3D;InnoDB;-- 建表增加约束CREATE TABLE products(   prd_id int not null auto_increment primary key,   prd_name varchar(355) not null,   prd_price decimal,   cat_id int not null,  --  以下为外键约束   FOREIGN KEY fk_cat(cat_id)   REFERENCES categories(cat_id)   ON UPDATE CASCADE   ON DELETE RESTRICT)ENGINE&#x3D;InnoDB;-- 改表语句增加外键约束ALTER TABLE table_nameADD CONSTRAINT constraint_nameFOREIGN KEY foreign_key_name(columns)REFERENCES parent_table(columns)ON DELETE actionON UPDATE action;-- 查看建表语句SHOW CREATE TABLE products;-- 删除外键约束ALTER TABLE table_nameDROP FOREIGN KEY constraint_name;-- 数据导入，避免外键因顺序问题存在的约束-- 要禁用外键检查，请使用以下语句：SET foreign_key_checks &#x3D; 0;-- 当然，您可以使用以下语句启用它：SET foreign_key_checks &#x3D; 1;</code></pre><h3 id="unique-唯一-（可多个、可组合）"><a href="#unique-唯一-（可多个、可组合）" class="headerlink" title="unique 唯一 （可多个、可组合）"></a>unique 唯一 （可多个、可组合）</h3><ul><li>创建时候添加（单个&#x2F;组合约束）</li><li>删除约束（单个&#x2F;组合约束）</li><li>添加约束（单个&#x2F;组合约束）</li><li>查看表中的约束<code>SHOW INDEX FROM 数据库.表名字</code></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 建表增加约束-- 单个列约束 方式1CREATE TABLE table_1(    column_name_1  data_type UNIQUE,);-- 单个列约束 方式2CREATE TABLE table_1(   ...   column_name_1 data_type,   ...   UNIQUE(column_name_1));-- 组合约束CREATE TABLE table_1(   ...   column_name_1 data_type,   column_name_2 data type,   ...   UNIQUE(column_name_1,column_name_2));-- 组合约束（指定名字）CREATE TABLE table_1(   ...   column_name_1 data_type,   column_name_2 data type,   ...   CONSTRAINT constraint_name UNIQUE(column_name_1,column_name_2));-- 查看表中的所有约束SHOW INDEX FROM 数据库.表名字-- 删除约束-- 方式1DROP INDEX index_name ON table_name;-- 方式2ALTER TABLE table_nameDROP INDEX index_name;-- 删除组合约束DROP INDEX uc_name_address ON suppliers;-- 添加约束ALTER TABLE table_nameADD CONSTRAINT constraint_name UNIQUE (column_list);-- 添加组合约束ALTER TABLE suppliersADD CONSTRAINT uc_name_address UNIQUE (name,address);</code></pre><h3 id="CHECK-约束-MySQL-不支持-CHECK-约束"><a href="#CHECK-约束-MySQL-不支持-CHECK-约束" class="headerlink" title="CHECK 约束(MySQL 不支持 CHECK 约束)"></a>CHECK 约束(MySQL 不支持 CHECK 约束)</h3><p>CHECK 约束，允许您在<code>插入</code>和<code>更新</code>之前验证列或列组的数据</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 要确保价格始终大于或等于成本，请使用以下CHECK约束：-- MySQL不支持CHECK约束CREATE TABLE IF NOT EXISTS parts (    part_no VARCHAR(18) PRIMARY KEY,    description VARCHAR(40),    cost DECIMAL(10 , 2 ) NOT NULL CHECK (cost &gt; 0),    price DECIMAL(10 , 2 ) NOT NULL CHECK (price &gt; 0),    CHECK (price &gt;&#x3D; cost));</code></pre><h4 id="使用触发器模拟"><a href="#使用触发器模拟" class="headerlink" title="使用触发器模拟"></a>使用触发器模拟</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 首先，创建一个新表parts 演示：CREATE TABLE IF NOT EXISTS parts (    part_no VARCHAR(18) PRIMARY KEY,    description VARCHAR(40),    cost DECIMAL(10 , 2 ) NOT NULL,    price DECIMAL(10,2) NOT NULL);-- 接下来，创建一个存储过程以检查cost和price列中的值。-- 存储过程的基本语法： https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_45856289&#x2F;article&#x2F;details&#x2F;116665243-- 存储过程文档： https:&#x2F;&#x2F;www.begtut.com&#x2F;mysql&#x2F;introduction-to-sql-stored-procedures.htmlDELIMITER $CREATE PROCEDURE &#96;check_parts&#96;(IN cost DECIMAL(10,2), IN price DECIMAL(10,2)) -- 两个入参BEGIN    IF cost &lt; 0 THEN        SIGNAL SQLSTATE &#39;45000&#39;           SET MESSAGE_TEXT &#x3D; &#39;check constraint on parts.cost failed&#39;;    END IF;    IF price &lt; 0 THEN      SIGNAL SQLSTATE &#39;45001&#39;    SET MESSAGE_TEXT &#x3D; &#39;check constraint on parts.price failed&#39;;    END IF;    IF price &lt; cost THEN SIGNAL SQLSTATE &#39;45002&#39;           SET MESSAGE_TEXT &#x3D; &#39;check constraint on parts.price &amp; parts.cost failed&#39;;    END IF;END$ DELIMITER ;-- 然后，创建  BEFORE INSERT 并BEFORE UPDATE触发。在触发器内部，调用check_parts()存储过程。-- before insertDELIMITER $CREATE TRIGGER &#96;parts_before_insert&#96; BEFORE INSERT ON &#96;parts&#96;FOR EACH ROWBEGIN    CALL check_parts(new.cost,new.price);END$DELIMITER ;-- before updateDELIMITER $CREATE TRIGGER &#96;parts_before_update&#96; BEFORE UPDATE ON &#96;parts&#96;FOR EACH ROWBEGIN    CALL check_parts(new.cost,new.price);END$DELIMITER ;</code></pre><h4 id="使用视图模拟"><a href="#使用视图模拟" class="headerlink" title="使用视图模拟"></a>使用视图模拟</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建一个带有基表检查选项的视图。在SELECT视图的语句中，我们只选择满足CHECK条件的有效行。如果对视图进行任何插入或更新，将导致新行不显示在视图中。-- 首先，删除parts表以删除所有关联的触发器并创建一个新的表，如parts表，但具有不同的名称parts_data：DROP TABLE IF EXISTS parts;CREATE TABLE IF NOT EXISTS parts_data (    part_no VARCHAR(18) PRIMARY KEY,    description VARCHAR(40),    cost DECIMAL(10 , 2 ) NOT NULL,    price DECIMAL(10,2) NOT NULL);-- 接下来，创建parts基于parts_data表命名的视图。通过这样做，我们可以保持使用parts表的应用程序的代码保持不变。此外，旧parts表的所有权限保持不变。CREATE VIEW parts AS    SELECT        part_no, description, cost, price    FROM        parts_data    WHERE        cost &gt; 0 AND price &gt; 0 AND price &gt;&#x3D; costWITH CHECK OPTION;-- 然后，通过parts视图在parts_data表中插入一个新行：INSERT INTO parts(part_no, description, cost, price)VALUES(&#39;A-001&#39;,&#39;Cooler&#39;,100,120);</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.begtut.com/mysql/mysql-not-null-constraint.html" target="_blank" >非空约束</a></p><p><a href="https://www.begtut.com/mysql/mysql-primary-key.html" target="_blank" >主键约束</a></p><p><a href="https://www.begtut.com/mysql/mysql-foreign-key.html" target="_blank" >外键约束</a></p><p><a href="https://www.begtut.com/mysql/mysql-unique-constraint.html" target="_blank" >唯一约束</a></p><p><a href="https://www.begtut.com/mysql/mysql-check-constraint.html" target="_blank" >CHECK 约束</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.系统学习 mysql 操作</title>
      <link href="//post/2022-11-30mysql-%E6%93%8D%E4%BD%9C.html"/>
      <url>//post/2022-11-30mysql-%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">--  创建CREATE DATABASE [IF NOT EXISTS] database_name[CHARACTER SET charset_name][COLLATE collation_name]-- 查看建库语句SHOW CREATE DATABASE testdb;--  显示SHOW DATABASES;--  选择USE database_name;--  删除-- 数据库中的所有表并永久删除数据库DROP DATABASE [IF EXISTS] database_name;</code></pre><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 建表语句CREATE TABLE [IF NOT EXISTS] table_name(    column_list) ENGINE&#x3D;storage_engine-- 为表定义列 字段设置column_name data_type(length) [NOT NULL] [DEFAULT value] [AUTO_INCREMENT]-- 查询建表语句SHOW CREATE TABLE table_name;</code></pre><p><code>ALTER TABLE</code> 语句修改现有表的结构。它允许您添加列，删除列，更改列的数据类型，添加主键，重命名表等等。</p><p>以下说明了 <code>ALTER TABLE</code> 语句语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name action1[,action2,…]</code></pre><p>要更改现有表的结构：</p><ul><li>首先，在 <code>ALTER TABLE</code> 子句后指定要更改的表名。</li><li>其次，列出要应用于表的一组操作。操作可以是任何操作，例如添加新列，添加主键或重命名表。</li><li>ALTER TABLE 语句允许您在单个 ALTER TABLE 语句中应用多个操作，操作由逗号（，）分隔。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE tasks (    task_id INT NOT NULL,    subject VARCHAR(45) NULL,    start_date DATE NULL,    end_date DATE NULL,    description VARCHAR(200) NULL,    PRIMARY KEY (task_id),    UNIQUE INDEX task_id_unique (task_id ASC));-- ALTER TABLE语句为列设置自动增量属性ALTER TABLE tasksCHANGE COLUMN task_id task_id INT(11) NOT NULL AUTO_INCREMENT;-- ALTER TABLE语句将新列添加到表示例中ALTER TABLE tasksADD COLUMN complete DECIMAL(2,1) NULLAFTER description;-- ALTER TABLE从表示例中删除列ALTER TABLE tasksDROP COLUMN description,DROP COLUMN description;-- ALTER TABLE 语句重命名表ALTER TABLE tasksRENAME TO work_items;</code></pre><h3 id="改表名-x2F-视图名"><a href="#改表名-x2F-视图名" class="headerlink" title="改表名&#x2F;视图名"></a>改表名&#x2F;视图名</h3><ul><li><span style="color: red">在执行 RENAME TABLE 语句之前，我们必须确保没有活动事务或锁定表。</span></li><li>注意：不能使用 <code>RENAME TABLE </code>语句重命名临时表，但可以使用 <code>ALTER TABLE 语句 重命名临时表</code>。</li><li>重命名表，需要同步更新：<ol><li><code>视图引用的表</code></li><li><code>存储过程引用的表</code></li><li><code>手动删除并重新创建外键</code></li></ol></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>重命名视图引用的表<br>如果要重命名的表由视图引用，则在重命名表时视图将变为无效，并且您必须手动调整视图。</div><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 要更改一个或多个表，我们使用RENAME TABLE如下语句：RENAME TABLE old_table_name TO new_table_name;-- 旧表（old_table_name）必须存在，新表（new_table_name）必须不存在。如果新表new_table_name存在，则语句将失败。</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 重命名临时表示例CREATE TEMPORARY TABLE lastnamesSELECT DISTINCT last_name from employees;-- 其次，我们使用RENAME TABLE重命名lastnames表：RENAME TABLE lastnames TO unique_lastnames;-- MySQL返回以下错误消息：-- ERROR 1017 (HY000): Can&#39;t find file: &#39;.&#x2F;hr&#x2F;lastnames.frm&#39; (errno: 2 - No such file or directory)-- 第三，我们使用ALTER TABLE 语句重命名lastnames表。ALTER TABLE lastnamesRENAME TO unique_lastnames;</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建一个v_employee_info基于employees和departments表命名的视图CREATE VIEW v_employee_info as    SELECT        id, first_name, last_name, dept_name    from        employees            inner join        departments USING (department_id);-- 可以使用CHECK TABLE语句来检查v_employee_info视图的状态CHECK TABLE v_employee_info;</code></pre><h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p>要创建临时表，只需将 <code>TEMPORARY</code> 关键字添加到 CREATE TABLE 语句中</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><code>CREATE TEMPORARY TABLE</code> 创建临时表。请注意，TEMPORARY 关键字是在 CREATE 和 TABLE 关键字之间添加的。</li><li><code>当会话结束或连接终止时，MySQL 会自动删除临时表</code>。当然，您可以使用 DROP TABLE 语句在不再使用它时显式删除临时表。</li><li><code>临时表仅可供创建它的客户端访问</code>。不同的客户端可以创建具有相同名称的临时表而不会导致错误，因为只有创建临时表的客户端才能看到它。但是，在同一会话中，两个临时表不能共享相同的名称。</li><li><code>临时表可以与数据库中的普通表具有相同的名称</code>。例如，如果创建一个名为 employees 临时表为示例数据库，现有的 employees 表变得不可访问。您针对 employees 表发出的每个查询现在都引用临时 employees 表。删除 employees 临时表时，employees 表可用并可再次访问。</li><li><code>不建议临时表与普通表重名</code>。因为这可能会导致混淆并可能导致意外的数据丢失。</li></ul><h4 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h4><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>建表 <code>CREATE TEMPORARY TABLE</code><br>删除 <code>DROP TEMPORARY TABLE table_name;</code></p><p><strong>不要丢了 TEMPORARY，防止误删普通表</strong></p></p></div><h4 id="防持久化"><a href="#防持久化" class="headerlink" title="防持久化"></a>防持久化</h4><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><strong>如果您开发使用连接池或持久连接的应用程序，则无法保证在应用程序终止时自动删除临时表。</strong></p><p>因为应用程序使用的数据库连接可能仍处于打开状态并放置在连接池中供其他客户端使用。因此，最好在不再使用临时表时始终删除它们。</p></div><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 新列添加到表ALTER TABLE tasksADD COLUMN complete DECIMAL(2,1) NULLAFTER description;-- 从表示例中删除列ALTER TABLE tasksDROP COLUMN description;-- 重命名表ALTER TABLE tasksRENAME TO work_items;-- 变更表属性 -- 更多见约束 &#x2F;post&#x2F;2022-11-30mysql-约束ALTER TABLE table_nameCHANGE old_column_name new_column_name new_column_definition;</code></pre><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3><h3 id="序列特点"><a href="#序列特点" class="headerlink" title="序列特点"></a>序列特点</h3><p>使用 AUTO_INCREMENT 属性时将应用以下规则 ：</p><ul><li>每个表只有一 <code>AUTO_INCREMENT</code> 列，其数据类型通常是整数。</li><li><code>AUTO_INCREMENT</code> 列必须编入索引，这意味着它可以是索引 <code>PRIMARY KEY </code>或 <code>UNIQUE</code> 索引。</li><li><code>AUTO_INCREMENT</code> 列必须具有 <code>NOT NULL</code> 约束。将 <code>AUTO_INCREMENT</code> 属性设置为列时，MySQL 会自动将 <code>NOT NULL</code> 约束隐式添加 到列中</li></ul><h3 id="序列工作"><a href="#序列工作" class="headerlink" title="序列工作"></a>序列工作</h3><p>AUTO_INCREMENT 列具有以下属性：</p><ul><li><code>AUTO_INCREMENT</code> 列的起始值为 1，当您 NULL 向列中插入值或在 INSERT 语句中省略其值时，它会增加 1 。</li><li>要获取最后生成的序列号，请使用 <code>LAST_INSERT_ID()</code> 函数。我们经常使用后续语句的最后一个插入 ID，例如，将数据插入表中。最后生成的序列在会话中是唯一的。换句话说，如果另一个连接生成序列号，则可以通过连接使用 <code>LAST_INSERT_ID()</code>函数获取序列号。</li><li>如果在表中插入新行并为序列列指定值，则如果列中<code>不存在序列号，则 MySQL 将插入序列号</code>，</li><li>如果已<code>存在则发出错误</code>。</li><li>如果插入一个大于下一个序列号的新值，MySQL 将<code>使用新值作为起始序列号，并生成一个大于当前序列号的唯一序列号，以供下次使用</code>。这<code>会在序列中产生间隙</code>。</li><li>如果使用 <code>UPDATE</code> 语句将 <code>AUTO_INCREMENT</code> 列中的值更新 为已存在的值，则</li><li>如果列具有唯一索引，MySQL 将发出<code>重复键错误</code>。</li><li>如果将 <code>AUTO_INCREMENT</code> 列更新为大于列中现有值的值，MySQL 将使用下一行的最后一个插入序列号的下一个数字。例如，如果最后一个插入序列号为 3，则将其更新为 10，新行的序列号为 4。</li><li>如果使用 <code>DELETE</code> 语句删除最后插入的行，MySQL 可能会也可能不会重复使用已删除的序列号，具体取决于表的存储引擎。</li><li>如果删除一行，MyISAM 表不会重复使用已删除的序列号，例如，表中的最后一个插入 ID 是 10，如果删除它，MySQL 仍会生成下一个序列号，即新行的序列号为 11。与 MyISAM 表类似，InnoDB 表在删除行时<code>不重用序列号</code>。</li><li>为列设置 <code>AUTO_INCREMENT</code> 属性后，可以通过各种方式<code>重置自动增量值</code>，例如，使用 <code>ALTER TABLE</code> 语句。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div style="display: flex;flex-direction: row;"><div style="flex: 1; text-align: center"><p><span style="color: red">库操作</span></p><p><a href="https://www.begtut.com/mysql/mysql-create-database.html" target="_blank" >创建数据库</a></p><p><a href="https://www.begtut.com/mysql/mysql-drop-database.html" target="_blank" >删除数据库</a></p></div><div style="flex: 1; text-align: center"><p><span style="color: red">表操作</span></p><p><a href="https://www.begtut.com/mysql/mysql-create-table.html" target="_blank" >创建表</a></p><p><a href="https://www.begtut.com/mysql/mysql-alter-table.html" target="_blank" >修改表</a></p><p><a href="https://www.begtut.com/mysql/mysql-drop-table.html" target="_blank" >删除表</a></p><p><a href="https://www.begtut.com/mysql/mysql-temporary-table.html" target="_blank" >临时表操作</a></p><p><a href="https://www.begtut.com/mysql/mysql-truncate-table.html" target="_blank" >清理表</a></p></div><div style="flex: 1; text-align: center"><p><span style="color: red">列操作</span></p><p><a href="https://www.begtut.com/mysql/mysql-add-column.html" target="_blank" >添加列</a></p><p><a href="https://www.begtut.com/mysql/mysql-drop-table.html" target="_blank" >删除列</a></p><p><a href="/post/2022-11-30mysql-约束" target="_blank" >更改列</a></p><p><a href="https://www.begtut.com/mysql/mysql-sequence.html" target="_blank" >序列</a></p></div></div>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useGetLastState</title>
      <link href="//post/2022-11-25useGetLastState.html"/>
      <url>//post/2022-11-25useGetLastState.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有时候，我们想要利用 useState 来更新数据，并且有时候，我们需要不断的拿到最新的值，来继续进行数据更新，频率很高～</p><p><code>简单场景</code>：同时我们晓得用<code>setState(preState=&gt; newState)</code>，来继续更新最新的值，这种用法在简单业务中使用没问题，复杂业务场景，无法应对<br><code>复杂场景：</code>比如我们需要用 <code>preState</code> 进行复杂的逻辑运算, 这时候我们可能将<code>setState</code>进行函数剥离，如果在这个函数中我们还要进行其他 state 计算，&#x3D;&#x3D;</p><h2 id="之前处理"><a href="#之前处理" class="headerlink" title="之前处理"></a>之前处理</h2><p>在组件中使用<code>useRef</code>存一份数据，计算时候使用<code>useRef</code>数据，渲染时候使用<code>useState</code>,之前没有封装，用起来存在维护多条数据的情况</p><h2 id="useGetState"><a href="#useGetState" class="headerlink" title="useGetState"></a>useGetState</h2><p>setState 使用的是 useState 的第二解构，那么 stateRef，后面也就没维护，因此：useGetState 并不满足需要，我想，这应该是此勾子设计缺陷，可能作者没考虑到上面的背景</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;import &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;type GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;function useGetState&lt;S&gt;(  initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];function useGetState&lt;S &#x3D; undefined&gt;(): [  S | undefined,  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,  GetStateAction&lt;S | undefined&gt;];function useGetState&lt;S&gt;(initialState?: S) &#123;  const [state, setState] &#x3D; useState(initialState);  const stateRef &#x3D; useRef(state);  stateRef.current &#x3D; state;  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);  &#x2F;&#x2F; setState使用的是useState的第二解构，那么stateRef，后面也就没维护  return [state, setState, getState];&#125;export default useGetState;</code></pre><h2 id="useGetLastState"><a href="#useGetLastState" class="headerlink" title="useGetLastState"></a>useGetLastState</h2><p>这里，将<code>_setState</code> 设置为私有，对外提供 setState，更新 useRef 和 useState 的值</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;import &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;type GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;function useGetLastState&lt;S&gt;(  initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];function useGetLastState&lt;S &#x3D; undefined&gt;(): [  S | undefined,  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,  GetStateAction&lt;S | undefined&gt;];function useGetLastState&lt;S&gt;(initialState?: S) &#123;  const [state, _setState] &#x3D; useState(initialState);  const stateRef &#x3D; useRef(state);  stateRef.current &#x3D; state;  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);  &#x2F;&#x2F; 这里，将_setState设置为私有，对外提供setState，更新useRef和useState的值  const setState &#x3D; useCallback((value) &#x3D;&gt; &#123;    stateRef.current &#x3D; value;    _setState(stateRef.current);  &#125;, []);  return [state, setState, getState];&#125;export default useGetLastState;</code></pre><h2 id="贡献代码？"><a href="#贡献代码？" class="headerlink" title="贡献代码？"></a>贡献代码？</h2><p>想了下，又要提 pre，又要测试…</p><p>嗯～，哈～，一个字总结：懒</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ahooks.js.org/zh-CN/hooks/use-get-state" target="_blank" >https://ahooks.js.org/zh-CN/hooks/use-get-state</a></p><p><a href="https://github.com/alibaba/hooks/blob/e78af708e2bd44affc44f195e310ac84b6e91f4c/packages/hooks/src/useGetState/index.ts#L14" target="_blank" >useGetState 源码</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件库开发 Storybook</title>
      <link href="//post/2022-11-24storybook.html"/>
      <url>//post/2022-11-24storybook.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近维护一个项目，项目中的业务组件是单独维护的，至于为什么，不是很清楚。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p><strong>优点</strong></p><ul><li>难道只是为了开发方便，项目用的公司内定的 nextjs 3.x.x 的版本？webpack 编译速度太慢？</li></ul><p><strong>缺点</strong></p><ul><li>难复用：因为接口是写到业务组件中的，其他项目要想复，有一定的难度（虽然公司应用使用网关授权的方式进行调用）</li><li>高冗余：假设其他项目用，其他业务组件会出现冗余情况</li><li>storybook：需要一定的学习成本</li><li>成本高：对于业务组件与业务项目拆分，发布时候，要先发布组件，然后项目再获取新的依赖进行发布</li><li>不确定性：中间还可能出现差异</li></ul><h2 id="storybook"><a href="#storybook" class="headerlink" title="storybook"></a>storybook</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>网络的普遍性将更多的复杂性推向了前端。它始于响应式网页设计，将每个用户界面从一个变成了 10、100、1000 个不同的用户界面。随着时间的推移，更多的需求堆积在设备、浏览器、可访问性、性能和异步状态等方面。</p><p>组件驱动的工具，如 React、Vue 和 Angular，有助于将复杂的 UI 分解为简单的组件，但它们不是灵丹妙药。随着前端的增长，组件的数量也在膨胀。成熟的项目可能包含数百个组件，这些组件会产生数千种离散的变体。</p><p>更复杂的是，这些 UI 很难调试，因为它们纠缠在业务逻辑、交互状态和应用上下文中。</p><p>现代前端的广度压倒了现有的工作流程。开发人员必须考虑无数的 UI 变体，但还没有准备好开发或组织它们。您最终会遇到这样一种情况，即 UI 更难构建、使用起来不太令人满意并且很脆弱。</p><p>用户界面多元宇宙</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>独立构建 UI<br>每一个 UI 现在都是一个零件. 组件的强大之处在于，您无需为了查看它们的呈现方式而启动整个应用程序。您可以通过传入道具、模拟数据或伪造事件来单独呈现特定的变体。</p><p>Storybook 被打包成一个小型的，仅供开发，作坊与您的应用程序一起生活。它提供了一个独立的 iframe 来呈现组件，而不受应用程序业务逻辑和上下文的干扰。这有助于您将开发重点放在组件的每个变体上，甚至是难以触及的边缘情况。</p><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/storybookjs/storybook">https://github.com/storybookjs/storybook</a><img src="https://img.shields.io/github/stars/storybookjs/storybook?style=social" /></div><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>当您为组件编写故事时，您会免费获得许多额外的好处。</p><p>📝 开发更耐用的 UI<br>隔离组件和页面并跟踪它们的用例故事. 验证难以触及的 UI 边缘情况。使用插件来模拟组件所需的一切——上下文、API 请求、设备功能等。</p><p>✅ 更轻松地测试 UI，没有问题<br>故事是一种实用的、可重现的跟踪 UI 状态的方式。在开发过程中使用它们对 UI 进行现场测试。Storybook 提供了内置的自动化工作流程辅助功能,相互作用， 和视觉的测试。或者通过将故事导入其他 JavaScript 测试工具来将故事用作测试用例。</p><p>📚 文档 UI 供您的团队重用<br>Storybook 是您 UI 的唯一真实来源。故事为您的所有组件及其各种状态编制索引，使您的团队可以轻松找到并重用现有的 UI 模式。Storybook 也会自动生成文档从那些故事中。</p><p>📤 分享 UI 的实际工作原理<br>故事展示了 UI 的实际工作方式，而不仅仅是它们应该如何工作的图片。这使每个人都了解当前正在生产的内容。出版故事书得到队友的签字。或者嵌入他们在 wikis、Markdown 和 Figma 中以简化协作。</p><p>🚦 自动化 UI 工作流程<br>Storybook 与您的持续集成工作流程兼容。将其添加为 CI 步骤以自动化用户界面测试、与团队成员一起审查实施并获得利益相关者的签署。</p><h2 id="stories"><a href="#stories" class="headerlink" title="stories"></a>stories</h2><ul><li>.stories 文件可以认为是页面，所有封装的组件都可以在.stories 文件中使用</li><li>.stories 使用 title 进行目录划分</li></ul><h2 id="storybook-中间件"><a href="#storybook-中间件" class="headerlink" title="storybook 中间件"></a>storybook 中间件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.storybook├── main.js├── middleware.js # 中间件，可以进行接口代理到日常环境├── preview-head.html└── preview.js</code></pre><h2 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h2><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><a href="https://6195b518b76f57003aa69b4c-dzkgzotbvz.chromatic.com/?path=/docs/buttons-icontextbutton-coloredicontextbutton--default" target="_blank" >https://6195b518b76f57003aa69b4c-dzkgzotbvz.chromatic.com/?path=/docs/buttons-icontextbutton-coloredicontextbutton--default</a></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p><a href="https://github.com/phork/phorkit/tree/develop/src/components/Button" target="_blank" >https://github.com/phork/phorkit/tree/develop/src/components/Button</a></p><h3 id="MDX"><a href="#MDX" class="headerlink" title="MDX"></a>MDX</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=unifiedjs.vscode-mdx" target="_blank" >vscocde MDX 插件</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://storybook.js.org/tutorials/intro-to-storybook/react/zh-CN/get-started/" target="_blank" >storybook React 教程</a></p><p><a href="https://devpress.csdn.net/vue/62f15728c6770329307f5661.html" target="_blank" >[Storybook] 使用 Vue Storybook addon-docs 创建文档</a></p><p><a href="https://www.docz.site/docs/getting-started" target="_blank" >docz</a></p>]]></content>
      
      
      <categories>
          
          <category> Npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件库开发 yalc</title>
      <link href="//post/2022-11-24yalc.html"/>
      <url>//post/2022-11-24yalc.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 npm link&#x2F;yarn link&#x2F;yalc 等工具，通过软链接的方式进行调试，影响 node_modules 中原本的包;</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>yalc 在开发和创作多个包（私有或公共）时，您通常会发现自己需要在本地环境中正在处理的其他项目中使用最新的&#x2F;WIP 版本，而无需将这些包发布到远程注册表。NPM 和 Yarn 通过一种类似的对称链接包（NPM&#x2F;纱线链接）解决了这个问题。尽管这在许多情况下可能有效，但它经常会带来严重的约束和依赖关系解决、文件系统之间的符号链接互操作性等问题。</p></blockquote><h2 id="yalc"><a href="#yalc" class="headerlink" title="yalc"></a>yalc</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>对包开发者而言，一种比 yarn&#x2F;npm link 更好的开发流程</p></blockquote><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/wclr/yalc">https://github.com/wclr/yalc</a><img src="https://img.shields.io/github/stars/wclr/yalc?style=social" /></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7033400734746066957" target="_blank" >yalc: 可能是最好的前端 link 调试方案（</a></p>]]></content>
      
      
      <categories>
          
          <category> Npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试开放题</title>
      <link href="//post/2022-11-23%E9%9D%A2%E8%AF%95.html"/>
      <url>//post/2022-11-23%E9%9D%A2%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><h3 id="1、麻烦你自我介绍一下"><a href="#1、麻烦你自我介绍一下" class="headerlink" title="1、麻烦你自我介绍一下"></a>1、麻烦你自我介绍一下</h3><img src="http://t-blog-images.aijs.top/img/202211231613681.webp" style="width:400px;max-width:100%" /><h3 id="2、你对加班怎么看"><a href="#2、你对加班怎么看" class="headerlink" title="2、你对加班怎么看"></a>2、你对加班怎么看</h3><img src="http://t-blog-images.aijs.top/img/202211231614038.webp" style="width:400px;max-width:100%" /><h3 id="3、说说你的优点"><a href="#3、说说你的优点" class="headerlink" title="3、说说你的优点"></a>3、说说你的优点</h3><img src="http://t-blog-images.aijs.top/img/202211231615883.webp" style="width:400px;max-width:100%" /><h3 id="4、说说你的缺点"><a href="#4、说说你的缺点" class="headerlink" title="4、说说你的缺点"></a>4、说说你的缺点</h3><h3 id="5、你的职业规划是什么？"><a href="#5、你的职业规划是什么？" class="headerlink" title="5、你的职业规划是什么？"></a>5、你的职业规划是什么？</h3><img src="http://t-blog-images.aijs.top/img/202211231615947.webp" style="width:400px;max-width:100%" /><h3 id="6、你的核心竞争力是什么？"><a href="#6、你的核心竞争力是什么？" class="headerlink" title="6、你的核心竞争力是什么？"></a>6、你的核心竞争力是什么？</h3><h3 id="7、你怎么处理和上级的冲突？"><a href="#7、你怎么处理和上级的冲突？" class="headerlink" title="7、你怎么处理和上级的冲突？"></a>7、你怎么处理和上级的冲突？</h3><img src="http://t-blog-images.aijs.top/img/202211231616184.webp" style="width:400px;max-width:100%" /><h3 id="8、你离职的原因是什么"><a href="#8、你离职的原因是什么" class="headerlink" title="8、你离职的原因是什么"></a>8、你离职的原因是什么</h3><img src="http://t-blog-images.aijs.top/img/202211231616289.webp" style="width:400px;max-width:100%" /><h3 id="8、你的期望薪资是多少？"><a href="#8、你的期望薪资是多少？" class="headerlink" title="8、你的期望薪资是多少？"></a>8、你的期望薪资是多少？</h3><img src="http://t-blog-images.aijs.top/img/202211231618101.webp" style="width:400px;max-width:100%" /><h3 id="9、你有什么要反问我的吗？"><a href="#9、你有什么要反问我的吗？" class="headerlink" title="9、你有什么要反问我的吗？"></a>9、你有什么要反问我的吗？</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.xiaohongshu.com/discovery/item/637a0ffb000000000e00e51c" target="_blank" >迄今为止，最靠谱的面试问题（附答案）合集</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.系统学习 mysql刷课</title>
      <link href="//post/2022-11-23mysql.html"/>
      <url>//post/2022-11-23mysql.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h2><p><a href="https://www.begtut.com/mysql/mysql-boolean.html" target="_blank" >BEGTUT.COM Mysql 教程</a></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h2 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h2><p><a href="https://www.bilibili.com/video/BV1Vy4y1z7EX" target="_blank" >MySQL 入门基础,mysql 基础视频+数据库实战,老杜带你学（829 万播放量）</a></p><p><a href="https://www.cnblogs.com/doremi429/category/2097017.html" target="_blank" >视频对应的文档</a></p><h2 id="爬取-B-站视频导航"><a href="#爬取-B-站视频导航" class="headerlink" title="爬取 B 站视频导航"></a>爬取 B 站视频导航</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function getTitles() &#123;  var datas &#x3D; &quot;&quot;;  var list &#x3D; Array.from(    document.getElementsByClassName(&quot;list-box&quot;)[0].children  );  &#x2F;&#x2F; 去重  var lset &#x3D; new Set();  list.forEach((li, index) &#x3D;&gt; &#123;    var item &#x3D; li.getElementsByTagName(&quot;a&quot;)[0].innerText;    var arr &#x3D; item.split(&quot;-&quot;);    var titles &#x3D; arr[1].split(&quot;\n&quot;);    lset.add(titles[0]);  &#125;);  Array.from(lset).forEach((item, index) &#x3D;&gt; &#123;    datas +&#x3D; &#96;## $&#123;index + 1&#125;. $&#123;item&#125;\n&#96;;  &#125;);  &#x2F;&#x2F; 拷贝  copy(datas);&#125;getTitles();</code></pre><h2 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1. 数据库概述"></a>1. 数据库概述</h2><h2 id="2-什么是-SQL"><a href="#2-什么是-SQL" class="headerlink" title="2. 什么是 SQL"></a>2. 什么是 SQL</h2><h2 id="3-安装-MySQL"><a href="#3-安装-MySQL" class="headerlink" title="3. 安装 MySQL"></a>3. 安装 MySQL</h2><h2 id="4-卸载-MySQL"><a href="#4-卸载-MySQL" class="headerlink" title="4. 卸载 MySQL"></a>4. 卸载 MySQL</h2><h2 id="5-查看-MySQL-服务"><a href="#5-查看-MySQL-服务" class="headerlink" title="5. 查看 MySQL 服务"></a>5. 查看 MySQL 服务</h2><h2 id="6-MySQL-服务启停"><a href="#6-MySQL-服务启停" class="headerlink" title="6. MySQL 服务启停"></a>6. MySQL 服务启停</h2><h2 id="7-登录-MySQL"><a href="#7-登录-MySQL" class="headerlink" title="7. 登录 MySQL"></a>7. 登录 MySQL</h2><h2 id="8-MySQL-常用命令"><a href="#8-MySQL-常用命令" class="headerlink" title="8. MySQL 常用命令"></a>8. MySQL 常用命令</h2><h2 id="9-表的理解"><a href="#9-表的理解" class="headerlink" title="9. 表的理解"></a>9. 表的理解</h2><h2 id="10-SQL-分类"><a href="#10-SQL-分类" class="headerlink" title="10. SQL 分类"></a>10. SQL 分类</h2><h2 id="11-导入演示数据"><a href="#11-导入演示数据" class="headerlink" title="11. 导入演示数据"></a>11. 导入演示数据</h2><h2 id="12-查看表结构"><a href="#12-查看表结构" class="headerlink" title="12. 查看表结构"></a>12. 查看表结构</h2><h2 id="13-简单查询"><a href="#13-简单查询" class="headerlink" title="13. 简单查询"></a>13. 简单查询</h2><h2 id="14-查询多个字段"><a href="#14-查询多个字段" class="headerlink" title="14. 查询多个字段"></a>14. 查询多个字段</h2><h2 id="15-查询所有字段"><a href="#15-查询所有字段" class="headerlink" title="15. 查询所有字段"></a>15. 查询所有字段</h2><h2 id="16-列起别名"><a href="#16-列起别名" class="headerlink" title="16. 列起别名"></a>16. 列起别名</h2><h2 id="17-列参与数学运算"><a href="#17-列参与数学运算" class="headerlink" title="17. 列参与数学运算"></a>17. 列参与数学运算</h2><h2 id="18-条件查询"><a href="#18-条件查询" class="headerlink" title="18. 条件查询"></a>18. 条件查询</h2><h2 id="19-模糊查询"><a href="#19-模糊查询" class="headerlink" title="19. 模糊查询"></a>19. 模糊查询</h2><h2 id="20-排序"><a href="#20-排序" class="headerlink" title="20. 排序"></a>20. 排序</h2><h2 id="21-多个字段排序"><a href="#21-多个字段排序" class="headerlink" title="21. 多个字段排序"></a>21. 多个字段排序</h2><h2 id="22-根据字段位置排序"><a href="#22-根据字段位置排序" class="headerlink" title="22. 根据字段位置排序"></a>22. 根据字段位置排序</h2><h2 id="23-综合案例"><a href="#23-综合案例" class="headerlink" title="23. 综合案例"></a>23. 综合案例</h2><h2 id="24-单行处理函数"><a href="#24-单行处理函数" class="headerlink" title="24. 单行处理函数"></a>24. 单行处理函数</h2><h2 id="25-分组函数"><a href="#25-分组函数" class="headerlink" title="25. 分组函数"></a>25. 分组函数</h2><h2 id="26-分组查询"><a href="#26-分组查询" class="headerlink" title="26. 分组查询"></a>26. 分组查询</h2><h2 id="27-单表查询总结"><a href="#27-单表查询总结" class="headerlink" title="27. 单表查询总结"></a>27. 单表查询总结</h2><h2 id="28-大概总结今日内容"><a href="#28-大概总结今日内容" class="headerlink" title="28. 大概总结今日内容"></a>28. 大概总结今日内容</h2><h2 id="29-回顾昨天内容"><a href="#29-回顾昨天内容" class="headerlink" title="29. 回顾昨天内容"></a>29. 回顾昨天内容</h2><h2 id="30-distinct-关键字"><a href="#30-distinct-关键字" class="headerlink" title="30. distinct 关键字"></a>30. distinct 关键字</h2><h2 id="31-连接查询概述"><a href="#31-连接查询概述" class="headerlink" title="31. 连接查询概述"></a>31. 连接查询概述</h2><h2 id="32-笛卡尔积现象"><a href="#32-笛卡尔积现象" class="headerlink" title="32. 笛卡尔积现象"></a>32. 笛卡尔积现象</h2><h2 id="33-尽量降低表连接的次数"><a href="#33-尽量降低表连接的次数" class="headerlink" title="33. 尽量降低表连接的次数"></a>33. 尽量降低表连接的次数</h2><h2 id="34-内连接之等值连接"><a href="#34-内连接之等值连接" class="headerlink" title="34. 内连接之等值连接"></a>34. 内连接之等值连接</h2><h2 id="35-内连接之非等值连接"><a href="#35-内连接之非等值连接" class="headerlink" title="35. 内连接之非等值连接"></a>35. 内连接之非等值连接</h2><h2 id="36-内连接之自连接"><a href="#36-内连接之自连接" class="headerlink" title="36. 内连接之自连接"></a>36. 内连接之自连接</h2><h2 id="37-外连接"><a href="#37-外连接" class="headerlink" title="37. 外连接"></a>37. 外连接</h2><h2 id="38-三张表连接"><a href="#38-三张表连接" class="headerlink" title="38. 三张表连接"></a>38. 三张表连接</h2><h2 id="39-子查询概述"><a href="#39-子查询概述" class="headerlink" title="39. 子查询概述"></a>39. 子查询概述</h2><h2 id="40-where-中的子查询"><a href="#40-where-中的子查询" class="headerlink" title="40. where 中的子查询"></a>40. where 中的子查询</h2><h2 id="41-from-中的子查询"><a href="#41-from-中的子查询" class="headerlink" title="41. from 中的子查询"></a>41. from 中的子查询</h2><h2 id="42-select-后的子查询"><a href="#42-select-后的子查询" class="headerlink" title="42. select 后的子查询"></a>42. select 后的子查询</h2><h2 id="43-union-的用法"><a href="#43-union-的用法" class="headerlink" title="43. union 的用法"></a>43. union 的用法</h2><h2 id="44-limit-概述"><a href="#44-limit-概述" class="headerlink" title="44. limit 概述"></a>44. limit 概述</h2><h2 id="45-limit-的使用"><a href="#45-limit-的使用" class="headerlink" title="45. limit 的使用"></a>45. limit 的使用</h2><h2 id="46-通用分页"><a href="#46-通用分页" class="headerlink" title="46. 通用分页"></a>46. 通用分页</h2><h2 id="47-表的创建及数据类型"><a href="#47-表的创建及数据类型" class="headerlink" title="47. 表的创建及数据类型"></a>47. 表的创建及数据类型</h2><h2 id="48-mysql-数据类型"><a href="#48-mysql-数据类型" class="headerlink" title="48. mysql 数据类型"></a>48. mysql 数据类型</h2><h2 id="49-模拟选用数据类型"><a href="#49-模拟选用数据类型" class="headerlink" title="49. 模拟选用数据类型"></a>49. 模拟选用数据类型</h2><h2 id="50-删除表"><a href="#50-删除表" class="headerlink" title="50. 删除表"></a>50. 删除表</h2><h2 id="51-insert-语句"><a href="#51-insert-语句" class="headerlink" title="51. insert 语句"></a>51. insert 语句</h2><h2 id="52-insert-插入日期"><a href="#52-insert-插入日期" class="headerlink" title="52. insert 插入日期"></a>52. insert 插入日期</h2><h2 id="53-date-format-日期格式化"><a href="#53-date-format-日期格式化" class="headerlink" title="53. date_format 日期格式化"></a>53. date_format 日期格式化</h2><h2 id="54-date-和-datetime-的区别"><a href="#54-date-和-datetime-的区别" class="headerlink" title="54. date 和 datetime 的区别"></a>54. date 和 datetime 的区别</h2><h2 id="55-update-语句"><a href="#55-update-语句" class="headerlink" title="55. update 语句"></a>55. update 语句</h2><h2 id="56-delete-语句"><a href="#56-delete-语句" class="headerlink" title="56. delete 语句"></a>56. delete 语句</h2><h2 id="57-表是怎么进行连接的"><a href="#57-表是怎么进行连接的" class="headerlink" title="57. 表是怎么进行连接的"></a>57. 表是怎么进行连接的</h2><h2 id="58-insert-插入多条记录"><a href="#58-insert-插入多条记录" class="headerlink" title="58. insert 插入多条记录"></a>58. insert 插入多条记录</h2><h2 id="59-快速复制表"><a href="#59-快速复制表" class="headerlink" title="59. 快速复制表"></a>59. 快速复制表</h2><h2 id="60-将查询结果插入一张表"><a href="#60-将查询结果插入一张表" class="headerlink" title="60. 将查询结果插入一张表"></a>60. 将查询结果插入一张表</h2><h2 id="61-删除大表"><a href="#61-删除大表" class="headerlink" title="61. 删除大表"></a>61. 删除大表</h2><h2 id="62-对表结构的增删改"><a href="#62-对表结构的增删改" class="headerlink" title="62. 对表结构的增删改"></a>62. 对表结构的增删改</h2><h2 id="63-约束概述"><a href="#63-约束概述" class="headerlink" title="63. 约束概述"></a>63. 约束概述</h2><h2 id="64-约束包括哪些"><a href="#64-约束包括哪些" class="headerlink" title="64. 约束包括哪些"></a>64. 约束包括哪些</h2><h2 id="65-非空约束"><a href="#65-非空约束" class="headerlink" title="65. 非空约束"></a>65. 非空约束</h2><h2 id="66-非空约束测试"><a href="#66-非空约束测试" class="headerlink" title="66. 非空约束测试"></a>66. 非空约束测试</h2><h2 id="67-唯一性约束"><a href="#67-唯一性约束" class="headerlink" title="67. 唯一性约束"></a>67. 唯一性约束</h2><h2 id="68-两个字段联合唯一"><a href="#68-两个字段联合唯一" class="headerlink" title="68. 两个字段联合唯一"></a>68. 两个字段联合唯一</h2><h2 id="69-not-null-和-unique-联合"><a href="#69-not-null-和-unique-联合" class="headerlink" title="69. not null 和 unique 联合"></a>69. not null 和 unique 联合</h2><h2 id="70-主键概述"><a href="#70-主键概述" class="headerlink" title="70. 主键概述"></a>70. 主键概述</h2><h2 id="71-添加主键约束"><a href="#71-添加主键约束" class="headerlink" title="71. 添加主键约束"></a>71. 添加主键约束</h2><h2 id="72-主键数量"><a href="#72-主键数量" class="headerlink" title="72. 主键数量"></a>72. 主键数量</h2><h2 id="73-主键值建议类型"><a href="#73-主键值建议类型" class="headerlink" title="73. 主键值建议类型"></a>73. 主键值建议类型</h2><h2 id="74-自然主键和业务主键"><a href="#74-自然主键和业务主键" class="headerlink" title="74. 自然主键和业务主键"></a>74. 自然主键和业务主键</h2><h2 id="75-外键约束"><a href="#75-外键约束" class="headerlink" title="75. 外键约束"></a>75. 外键约束</h2><img src="http://t-blog-images.aijs.top/img/202211261808198.webp" style="width:500px;max-width:100%" /><h2 id="76-存储引擎"><a href="#76-存储引擎" class="headerlink" title="76. 存储引擎"></a>76. 存储引擎</h2><h3 id="什么是存储引擎，用处？"><a href="#什么是存储引擎，用处？" class="headerlink" title="什么是存储引擎，用处？"></a>什么是存储引擎，用处？</h3><p>存储引擎是 mysql 中特有的术语，其它数据库中一般没有。（oracle 有，但不是这个名字）</p><p>存储引擎实际上是一个表存储&#x2F;组织数据的方式</p><h3 id="怎么给表添加-x2F-指定“存储引擎”"><a href="#怎么给表添加-x2F-指定“存储引擎”" class="headerlink" title="怎么给表添加&#x2F;指定“存储引擎”"></a>怎么给表添加&#x2F;指定“存储引擎”</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show create table t_student;</code></pre><p>可以在建表的时候被表指定存储引擎,建表的时候可以在最后小括号的“)”的右边使用：</p><ul><li><p><code>ENGINE</code> 来指定存储引擎。</p></li><li><p><code>CHARSET</code> 来指定这张表的字符编码方式</p></li></ul><p><strong>结论：</strong></p><ul><li><p>mysql 默认的存储引擎是：<code>InnoDB</code></p></li><li><p>mysql 默认的字符编码方式：<code>utf8</code></p></li></ul><p>建表时指定存储引擎和字符编码方式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table t_product(id int primary key,name varchar(255))engine&#x3D;InnoDB default charset &#x3D; gbk</code></pre><h2 id="77-mysql-支持哪些存储引擎"><a href="#77-mysql-支持哪些存储引擎" class="headerlink" title="77. mysql 支持哪些存储引擎"></a>77. mysql 支持哪些存储引擎</h2><p>命令：　 <code>show engines \G</code></p><h2 id="78-mysql-常用存储引擎"><a href="#78-mysql-常用存储引擎" class="headerlink" title="78. mysql 常用存储引擎"></a>78. mysql 常用存储引擎</h2><h2 id="79-InnoDB-存储引擎"><a href="#79-InnoDB-存储引擎" class="headerlink" title="79. InnoDB 存储引擎"></a>79. InnoDB 存储引擎</h2><h2 id="80-MEMORY-存储引擎"><a href="#80-MEMORY-存储引擎" class="headerlink" title="80. MEMORY 存储引擎"></a>80. MEMORY 存储引擎</h2><h2 id="81-事务概述"><a href="#81-事务概述" class="headerlink" title="81. 事务概述"></a>81. 事务概述</h2><h2 id="82-和事务有关的是-DML-语句"><a href="#82-和事务有关的是-DML-语句" class="headerlink" title="82. 和事务有关的是 DML 语句"></a>82. 和事务有关的是 DML 语句</h2><h2 id="83-对事务的理解"><a href="#83-对事务的理解" class="headerlink" title="83. 对事务的理解"></a>83. 对事务的理解</h2><h2 id="84-事务是如何实现的"><a href="#84-事务是如何实现的" class="headerlink" title="84. 事务是如何实现的"></a>84. 事务是如何实现的</h2><h2 id="85-怎么提交和回滚事务"><a href="#85-怎么提交和回滚事务" class="headerlink" title="85. 怎么提交和回滚事务"></a>85. 怎么提交和回滚事务</h2><h2 id="86-事务特性"><a href="#86-事务特性" class="headerlink" title="86. 事务特性"></a>86. 事务特性</h2><h2 id="87-事务隔离级别"><a href="#87-事务隔离级别" class="headerlink" title="87. 事务隔离级别"></a>87. 事务隔离级别</h2><h2 id="88-事务隔离级别演示"><a href="#88-事务隔离级别演示" class="headerlink" title="88. 事务隔离级别演示"></a>88. 事务隔离级别演示</h2><h2 id="89-回顾一下"><a href="#89-回顾一下" class="headerlink" title="89. 回顾一下"></a>89. 回顾一下</h2><h2 id="90-索引概述"><a href="#90-索引概述" class="headerlink" title="90. 索引概述"></a>90. 索引概述</h2><h2 id="91-索引实现原理"><a href="#91-索引实现原理" class="headerlink" title="91. 索引实现原理"></a>91. 索引实现原理</h2><h2 id="92-索引的创建和删除"><a href="#92-索引的创建和删除" class="headerlink" title="92. 索引的创建和删除"></a>92. 索引的创建和删除</h2><h2 id="93-索引的失效"><a href="#93-索引的失效" class="headerlink" title="93. 索引的失效"></a>93. 索引的失效</h2><h2 id="94-索引的分类"><a href="#94-索引的分类" class="headerlink" title="94. 索引的分类"></a>94. 索引的分类</h2><h2 id="95-视图的概述"><a href="#95-视图的概述" class="headerlink" title="95. 视图的概述"></a>95. 视图的概述</h2><h2 id="96-视图的作用"><a href="#96-视图的作用" class="headerlink" title="96. 视图的作用"></a>96. 视图的作用</h2><h2 id="97-DBA-的命令"><a href="#97-DBA-的命令" class="headerlink" title="97. DBA 的命令"></a>97. DBA 的命令</h2><h2 id="98-数据库设计三范式"><a href="#98-数据库设计三范式" class="headerlink" title="98. 数据库设计三范式"></a>98. 数据库设计三范式</h2><h2 id="99-数据库设计第一范式"><a href="#99-数据库设计第一范式" class="headerlink" title="99. 数据库设计第一范式"></a>99. 数据库设计第一范式</h2><h2 id="100-数据库设计第二范式"><a href="#100-数据库设计第二范式" class="headerlink" title="100. 数据库设计第二范式"></a>100. 数据库设计第二范式</h2><h2 id="101-数据库设计第三范式"><a href="#101-数据库设计第三范式" class="headerlink" title="101. 数据库设计第三范式"></a>101. 数据库设计第三范式</h2><h2 id="102-总结数据库表的设计"><a href="#102-总结数据库表的设计" class="headerlink" title="102. 总结数据库表的设计"></a>102. 总结数据库表的设计</h2><h2 id="103-以满足客户需求为准"><a href="#103-以满足客户需求为准" class="headerlink" title="103. 以满足客户需求为准"></a>103. 以满足客户需求为准</h2><h2 id="104-34-道作业题"><a href="#104-34-道作业题" class="headerlink" title="104. 34 道作业题"></a>104. 34 道作业题</h2><h2 id="is-的用法"><a href="#is-的用法" class="headerlink" title="is 的用法"></a>is 的用法</h2><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- MySQL BOOLEAN 运算符-- 要获取tasks表中的所有已完成任务，您可能会提出以下查询：SELECT    id, title, completedFROM    tasksWHERE    completed &#x3D; TRUE;-- +----+---------------------------+-----------+-- | id | title                     | completed |-- +----+---------------------------+-----------+-- |  1 | Master MySQL Boolean type |         1 |-- +----+---------------------------+-----------+-- 1 row in set (0.00 sec)-- 如您所见，它只返回completed值为1 的任务。要修复它，您必须使用IS运算符：SELECT    id, title, completedFROM    tasksWHERE    completed IS TRUE;-- +----+----------------------------+-----------+-- | id | title                      | completed |-- +----+----------------------------+-----------+-- |  1 | Master MySQL Boolean type  |         1 |-- |  3 | Test Boolean with a number |         2 |-- +----+----------------------------+-----------+-- 2 rows in set (0.00 sec)-- 在此示例中，我们使用IS运算符针对布尔值测试值。-- 要获取待处理的任务，请使用IS FALSE或IS NOT TRUE如下：SELECT    id, title, completedFROM    tasksWHERE    completed IS NOT TRUE;-- +----+-----------------------+-----------+-- | id | title                 | completed |-- +----+-----------------------+-----------+-- |  2 | Design database table |         0 |-- +----+-----------------------+-----------+-- 1 row in set (0.00 sec)</code></pre><h2 id="ORDER-BY-使用自定义排序顺序"><a href="#ORDER-BY-使用自定义排序顺序" class="headerlink" title="ORDER BY 使用自定义排序顺序"></a>ORDER BY 使用自定义排序顺序</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- MySQL ORDER BY 使用自定义排序顺序-- ORDER BY 子句可以使用FIELD()  函数为列中的值定义自己的自定义排序顺序。-- 请参orders见下表。-- +----------------+-- | orders         |-- +----------------+-- | orderNumber    |-- | orderDate      |-- | requiredDate   |-- | shippedDate    |-- | status         |-- | comments       |-- | customerNumber |-- +----------------+-- 7 rows in set (0.03 sec)-- 例如，如果要按以下顺序基于以下状态对订单进行排序：---- In Process-- On Hold-- Canceled-- Resolved-- Disputed-- Shipped-- 您可以使用 FIELD 函数将这些值映射到数值列表，并使用这些数字进行排序;---- 请参阅以下查询：SELECTorderNumber, statusFROMordersORDER BY FIELD(status,&#39;In Process&#39;,&#39;On Hold&#39;,&#39;Cancelled&#39;,&#39;Resolved&#39;,&#39;Disputed&#39;,&#39;Shipped&#39;);-- 运行结果：---- +-------------+------------+-- | orderNumber | status     |-- +-------------+------------+-- |       10420 | In Process |-- |       10421 | In Process |-- |       10422 | In Process |-- |       10423 | In Process |-- |       10424 | In Process |-- |       10425 | In Process |-- |       10334 | On Hold    |-- |       10401 | On Hold    |-- ...</code></pre><h2 id="Boolean-遇到-null"><a href="#Boolean-遇到-null" class="headerlink" title="Boolean 遇到 null"></a>Boolean 遇到 null</h2><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><table><thead><tr><th align="left"></th><th align="left">TRUE</th><th align="left">FALSE</th><th align="left">NULL</th></tr></thead><tbody><tr><td align="left">TRUE</td><td align="left">TRUE</td><td align="left">FALSE</td><td align="left">NULL</td></tr><tr><td align="left">FALSE</td><td align="left">FALSE</td><td align="left">FALSE</td><td align="left">FALSE</td></tr><tr><td align="left">NULL</td><td align="left">NULL</td><td align="left">FALSE</td><td align="left">NULL</td></tr></tbody></table><p><strong>短路结果：</strong></p><ul><li><code>true AND null</code> 结果为 null</li><li><code>null AND null</code> 结果为 null</li></ul><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><table><thead><tr><th align="left"></th><th align="left">TRUE</th><th align="left">FALSE</th><th align="left">NULL</th></tr></thead><tbody><tr><td align="left">TRUE</td><td align="left">TRUE</td><td align="left">TRUE</td><td align="left">TRUE</td></tr><tr><td align="left">FALSE</td><td align="left">TRUE</td><td align="left">FALSE</td><td align="left">NULL</td></tr><tr><td align="left">NULL</td><td align="left">TRUE</td><td align="left">NULL</td><td align="left">NULL</td></tr></tbody></table><p><strong>短路结果：</strong></p><ul><li><code>false or null</code> 结果为 null</li><li><code>null or null</code> 结果为 null</li></ul><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>当您在表达式中使用多个逻辑运算符时，<code>MySQL 始终会在 AND 运算符之后计算 OR 运算符</code>。<br>这称为运算符优先级，它确定运算符的执行顺序。MySQL 首先评估具有更高优先级的运算符。</p><p>请参阅以下示例。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT true OR false AND false;-- 运行结果：---- | true OR false AND false |-- +-------------------------+-- |                       1 |-- +-------------------------+-- 1 row in set (0.00 sec)</code></pre><p>这个怎么运作</p><ul><li>首先，MySQL 评估 AND 运算符，因此表达式 false AND false 返回 false。</li><li>其次，MySQL 评估 OR 运算符，因此表达式 true OR false 返回 true。</li><li>要更改评估顺序，请使用括号，例如：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT (true OR false) AND false;-- 运行结果：-- +---------------------------+-- | (true OR false) AND false |-- +---------------------------+-- | 0 |-- +---------------------------+-- 1 row in set (0.00 sec)</code></pre><p>这个怎么运作</p><ul><li>首先，MySQL 评估括号中的表达式<code>(true OR false)</code>返回 true</li><li>其次，MySQL 评估语句的剩余部分，<code>true AND false</code> 返回 false。</li></ul><h2 id="日期转化"><a href="#日期转化" class="headerlink" title="日期转化"></a>日期转化</h2><p>CAST 运算符将文字字符串’2013-01-01’和’2013-12-31’转换为 DATE 值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT   orderNumber,   requiredDate,   statusFROM   ordersWHERE   requireddate BETWEEN     CAST(&#39;2013-01-01&#39; AS DATE) AND     CAST(&#39;2013-01-31&#39; AS DATE);</code></pre><h2 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h2><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>MySQL 提供了两个通配符供 LIKE 使用：百分号%和下划线<code>_</code>。</p><ul><li><code>百分号（%）</code>通配符匹配任何<code>零个或多个字符</code>的字符串。</li><li><code>下划线（_）</code>通配符匹配任何<code>单个字符</code>。</li></ul><h3 id="包含-x2F-以什么开始-x2F-以什么结束"><a href="#包含-x2F-以什么开始-x2F-以什么结束" class="headerlink" title="包含&#x2F;以什么开始&#x2F;以什么结束"></a>包含&#x2F;以什么开始&#x2F;以什么结束</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">--  &#39;%s%&#39;--  &#39;s%&#39;--  &#39;%s&#39;--  &#39;_s%&#39;--  &#39;%s_&#39;</code></pre><h3 id="LIKE-与-ESCAPE-子句"><a href="#LIKE-与-ESCAPE-子句" class="headerlink" title="LIKE 与 ESCAPE 子句"></a>LIKE 与 ESCAPE 子句</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 例如，如果要查找产品代码包含字符串的产品_20，可以使用%\_20%以下查询中显示的模式：SELECT    productCode,    productNameFROM    productsWHERE    productCode LIKE &#39;%\_20%&#39;;-- 或者我们可以指定不同的转义字符，例如，以下ESCAPE子句使用$：SELECT    productCode,    productNameFROM    productsWHERE    productCode LIKE &#39;%$_20%&#39; ESCAPE &#39;$&#39;;</code></pre><h2 id="limit-能做什么"><a href="#limit-能做什么" class="headerlink" title="limit 能做什么"></a>limit 能做什么</h2><ul><li>分页</li><li>最大&#x2F;小值</li><li>第几个最值</li></ul><h2 id="CONCAT-WS"><a href="#CONCAT-WS" class="headerlink" title="CONCAT_WS"></a>CONCAT_WS</h2><p>以下查询选择员工的名字和姓氏，并将它们组合在一起以生成全名。<code>CONCAT_WS 函数用于连接名字和姓氏</code>。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT    CONCAT_WS(&#39;, &#39;, lastName, firstname)FROM    employees;</code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+--------------------------------------+| CONCAT_WS(&#39;, &#39;, lastName, firstname) |+--------------------------------------+| Murphy, Diane                        || Patterson, Mary                      || Firrelli, Jeff                       || Patterson, William                   || Bondur, Gerard                       |...</code></pre><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><ul><li>MySQL 支持两种别名，称为列别名和表别名</li><li><em>注意：</em>不能在 WHERE 子句中使用列别名。原因是当 MySQL 评估 WHERE 子句时，SELECT 子句中指定的列的值可能尚未确定。</li><li><code>AS 关键字是可选的</code>，因此您可以省略它。</li><li>经常在 <code>INNER JOIN</code>，<code>LEFT JOIN</code>，<code>self JOIN</code> 子句和<code>子查询</code>的语句中使用表别名</li></ul><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><h3 id="1-NOW"><a href="#1-NOW" class="headerlink" title="1. NOW()"></a>1. NOW()</h3><p>1、NOW()，用于获取当前日期和时间函数</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select now() as &#39;当前日期和时间&#39; from dual;-- 返回：2020-05-26 20:27:21</code></pre><h3 id="2-CURDATE"><a href="#2-CURDATE" class="headerlink" title="2. CURDATE()"></a>2. CURDATE()</h3><p>2、CURDATE()，用于获取当前日期，同 CURRENT_DATE()</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select curdate() as &#39;当前日期&#39; from dual;-- 返回：2020-05-26</code></pre><h3 id="3-CURTIME"><a href="#3-CURTIME" class="headerlink" title="3. CURTIME()"></a>3. CURTIME()</h3><p>3、CURTIME()，用于获取当前时间，同 CURRENT_TIME()</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select curtime() as &#39;当前时间&#39; from dual;-- 返回：20:27:57</code></pre><h3 id="4-CURRENT-TIMESTAMP"><a href="#4-CURRENT-TIMESTAMP" class="headerlink" title="4. CURRENT_TIMESTAMP()"></a>4. CURRENT_TIMESTAMP()</h3><p>4、CURRENT_TIMESTAMP()，用于获取当前日期和时间函数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select CURRENT_TIMESTAMP() from dual;-- 返回：2020-05-26 20:29:21-- 另外，在创建表时，可以为时间字段指定创建时间和更新时间-- 例如：CREATE TABLE &#96;t01&#96; (&#96;name&#96; varchar(64) DEFAULT &#39;&#39; COMMENT &#39;名字&#39;,&#96;ctime&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,-- ON UPDATE CURRENT_TIMESTAMP, 在更新时候用什么时间&#96;utime&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;-- 如果使用 Navicat，在设置时间字段时，要勾选&quot;根据当前时间戳更新&quot;，还要在默认栏中填上&quot;CURRENT_TIMESTAMP&quot;</code></pre><h3 id="5-DATE"><a href="#5-DATE" class="headerlink" title="5. DATE()"></a>5. DATE()</h3><p>5、DATE()函数，用于提取时间字段的日期，</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;YYYY-mm-dd&quot;select date(tdate) from t01;-- 返回：2020-05-26</code></pre><h3 id="6-YEAR"><a href="#6-YEAR" class="headerlink" title="6. YEAR()"></a>6. YEAR()</h3><p>6、YEAR()函数，用于提取时间字段的年，</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;YYYY&quot;select year(tdate) from t01;-- 返回：2020</code></pre><h3 id="7-MONTH"><a href="#7-MONTH" class="headerlink" title="7. MONTH()"></a>7. MONTH()</h3><p>7、MONTH()函数，用于提取时间字段的月，</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;mm&quot;，若月份前有 0 会忽略select month(tdate) from t01;-- 返回：5</code></pre><h3 id="8-DAY"><a href="#8-DAY" class="headerlink" title="8. DAY()"></a>8. DAY()</h3><p>8、DAY()函数，用于提取时间字段的日期，</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;dd&quot;，若日期前有 0 会忽略select day(tdate) from t01;-- 返回：26</code></pre><h3 id="9-TIME"><a href="#9-TIME" class="headerlink" title="9. TIME()"></a>9. TIME()</h3><p>9、TIME()函数，用于提取时间字段的时间，例如 t01 的 tdate 为’2020-05-26 11:11:11’，返回的格式为”HH:ii:ss”</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select time(tdate) from t01;-- 返回：11:11:11</code></pre><h3 id="10-HOUR"><a href="#10-HOUR" class="headerlink" title="10. HOUR()"></a>10. HOUR()</h3><p>10、HOUR()函数，用于提取时间字段的小时，</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 例如 t01 的 tdate 为&#39;2020-05-26 11:11:11&#39;，返回的格式为&quot;HH&quot;，若小时前有 0 会忽略，如 08 则返回 8select hour(tdate) from t01;-- 返回：11</code></pre><h3 id="11-MINUTE"><a href="#11-MINUTE" class="headerlink" title="11. MINUTE()"></a>11. MINUTE()</h3><p>11、MINUTE()函数，用于提取时间字段的分钟，例如 t01 的 tdate 为’2020-05-26 11:11:11’，返回的格式为”ii”，若分钟前有 0 会忽略，如 08 则返回 8</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select minute(tdate) from t01;-- 返回：11</code></pre><h3 id="12-SECOND"><a href="#12-SECOND" class="headerlink" title="12. SECOND()"></a>12. SECOND()</h3><p>12、SECOND()函数，用于提取时间字段的秒，例如 t01 的 tdate 为’2020-05-26 11:11:11’，返回的格式为”ss”，若秒前有 0 会忽略，如 08 则返回 8</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">select HOUR(tdate) from t01;</code></pre><p>返回：11</p><h3 id="13-UNIX-TIMESTAMP"><a href="#13-UNIX-TIMESTAMP" class="headerlink" title="13. UNIX_TIMESTAMP()"></a>13. UNIX_TIMESTAMP()</h3><p>13、UNIX_TIMESTAMP()函数，获取当前时间戳，还可以将时间字段转换成时间戳</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select unix_timestamp()</code></pre><p>返回：当前时间的时间戳</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select unix_timestamp(tdate) from t01;-- 返回：1590462671</code></pre><h3 id="14-时间格式化函数"><a href="#14-时间格式化函数" class="headerlink" title="14. 时间格式化函数"></a>14. 时间格式化函数</h3><p><code>DATE_FORMAT()</code>和 <code>TIME_FORMAT()</code>功能相同</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select date_format(tdate,&#39;%Y-%m-%d %H:%i:%s&#39;) from t01;-- 返回：2020-05-26 11:11:11</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select date_format(tdate,&#39;%Y-%m-%d&#39;) from t01;-- 返回：2020-05-26</code></pre><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><ul><li><p>字段级约束</p></li><li><p>表级约束</p></li></ul><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>结论：<br>一张表，主键约束只能添加 1 个。（主键只能有 1 个。）<br>主键值建议使用：int、bigint、char、等类型。<br>不建议使用：varchar 来做主键。主键值一般都是数字，一般都是定长的！</p><p>主键除了：单一主键和符合主键之外，还可以分类成：</p><p>自然主键：主键值是一个自然数，和业务没关系</p><p>业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。</p><p>实际开发业务自然主键使用比较多，因为主键一旦和业务挂钩，当业务发生变动的时候，可能会影响到主键值，</p><p>所以业务主键不建议使用</p><p>在 myslq 当中，有一种机制，可以帮助我们自动维护一个主键值？</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">drop table if exists t_vip;create table t_vip(　　id int primary key auto_increment,&#x2F;&#x2F;aotu_increment 表示自增，从1开始　　name varchar(255));insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);select * from t_vip;</code></pre><p><a href="https://www.cnblogs.com/doremi429/p/15836557.html" target="_blank" >自然主键和业务主键</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/doremi429/p/15836557.html" target="_blank" >自然主键和业务主键</a></p><p><a href="https://www.begtut.com/mysql/mysql-boolean.html" target="_blank" >BEGTUT.COM Mysql 教程(注意部分内容直译过来的，有误)</a></p><p><a href="https://blog.csdn.net/xyy1028/article/details/106165503" target="_blank" >Mysql 事务</a></p><p>here</p><p><a href="https://www.begtut.com/mysql/mysql-self-join.html" target="_blank" >见</a></p><p><a href="https://www.begtut.com/mysql/mysql-exists.html" target="_blank" >见</a></p><p><a href="https://www.begtut.com/mysql/mysql-create-table.html" target="_blank" >MySQL CREATE TABLE</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git commit --amend</title>
      <link href="//post/2022-11-18git--amend.html"/>
      <url>//post/2022-11-18git--amend.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ git status位于分支 feature&#x2F;2023-1您的分支与上游分支 &#39;origin&#x2F;feature&#x2F;2023-1&#39; 一致。无文件要提交，干净的工作区$ git pushEverything up-to-date$ git status位于分支 feature&#x2F;2023-1您的分支与上游分支 &#39;origin&#x2F;feature&#x2F;2023-1&#39; 一致。# 无文件要提交，干净的工作区$ git commit --amend[feature&#x2F;2023-1 ec3665e8] fix transI18nK2Value Date: Fri Nov 18 16:12:02 2022 +0800 1 file changed, 1 insertion(+), 2 deletions(-)#  遇到冲突了，😓，这能遇到冲突，之前从来没有过，并且这个仓库只有我在维护$ git pushTo ssh:&#x2F;&#x2F;registry.code.tt.top:10023&#x2F;fe-efficacy&#x2F;performance.git ! [rejected]          feature&#x2F;2023-1 -&gt; feature&#x2F;2023-1 (non-fast-forward)错误：无法推送一些引用到 &#39;ssh:&#x2F;&#x2F;registry.code.tt.top:10023&#x2F;fe-efficacy&#x2F;performance.git&#39;提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。提示：再次推送前，先与远程变更合并（如 &#39;git pull ...&#39;）。详见提示：&#39;git push --help&#39; 中的 &#39;Note about fast-forwards&#39; 小节。$ git pull提示：您有偏离的分支，需要指定如何调和它们。您可以在执行下一次提示：pull 操作之前执行下面一条命令来抑制本消息：提示：提示：  git config pull.rebase false  # 合并提示：  git config pull.rebase true   # 变基提示：  git config pull.ff only       # 仅快进提示：提示：您可以将 &quot;git config&quot; 替换为 &quot;git config --global&quot; 以便为所有仓库设置提示：缺省的配置项。您也可以在每次执行 pull 命令时添加 --rebase、--no-rebase，提示：或者 --ff-only 参数覆盖缺省设置。致命错误：需要指定如何调和偏离的分支。$  git config pull.ff only$ git pull致命错误：无法快进，终止。$ git merge origin&#x2F;feature&#x2F;2023-1Merge made by the &#39;ort&#39; strategy.</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 热更新 Fair</title>
      <link href="//post/2022-11-17fair.html"/>
      <url>//post/2022-11-17fair.html</url>
      
        <content type="html"><![CDATA[<h2 id="Fair-全称"><a href="#Fair-全称" class="headerlink" title="Fair 全称"></a>Fair 全称</h2><p>Flutter Over the Air</p><h2 id="58-热更新"><a href="#58-热更新" class="headerlink" title="58 热更新"></a>58 热更新</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/wuba/fair">https://github.com/wuba/fair</a><img src="https://img.shields.io/github/stars/wuba/fair?style=social" /></div><p><a href="https://fair.58.com/zh/guide/" target="_blank" >官方文档</a></p><p>Fair 是为 Flutter 设计的动态化框架，通过 Fair Compiler 工具对原生 Dart 源文件的自动转化，使项目获得动态更新 Widget 的能力。</p><img src="http://t-blog-images.aijs.top/img/202211171351832.webp" /><!-- <img src="https://github.com/wuba/fair/blob/main/fair_tools.gif" style="width:500px;max-width:100%" /> --><h2 id="58-热更新服务器"><a href="#58-热更新服务器" class="headerlink" title="58 热更新服务器"></a>58 热更新服务器</h2><p><a href="https://github.com/wuba/FairPushy" target="_blank" >FairPushy</a></p><h2 id="58-react-native-分包"><a href="#58-react-native-分包" class="headerlink" title="58 react-native 分包"></a>58 react-native 分包</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/wuba/metro-code-split">https://github.com/wuba/metro-code-split</a><img src="https://img.shields.io/github/stars/wuba/metro-code-split?style=social" /></div>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生 系统学习shell脚本</title>
      <link href="//post/2022-11-14shell%E8%AF%AD%E6%B3%95.html"/>
      <url>//post/2022-11-14shell%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title="#!"></a><code>#!</code></h2><p><code>#!</code> 它告诉系统这个脚本需要什么解释器来执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;sh，它同样也可以改为 #!&#x2F;bin&#x2F;bash</code></pre><p>之前因为不晓得啥意思，一直记不住这个东西。为此还写个 vscode sippets 来自动生成 😓</p><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><ul><li><code>bash</code> 文件</li><li><code>sh</code> 文件</li><li><code>chmod +x</code> 文件路径（相对&#x2F;绝对&#x2F;文件执行运行）,现将文件改为可执行文件</li><li><code>source</code> 文件</li><li><code>.</code> 文件</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>命名：命名只能使用英文字母，数字和下划线，首个字符不能以数字开头（通用标准：非关键字、非标点符号、非空格）</li><li>使用：$variable_name 或 ${variable_name}</li><li>只读：<code>readonly</code> variable_name</li><li>删除：<code>unset</code> variable_name</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><ul><li>单引号里的任何字符都会<code>原样输出</code></li><li>单引号字符串中的变量是<code>无效的</code></li><li>单引号字串中<code>不能出现单独一个的单引号</code>（对单引号使用转义符后也不行）</li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><ul><li>双引号里可以有变量</li><li>双引号里可以有转义字符</li></ul><h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;!-- $&#123; 导致 hexo 无法编译,用md承载 --&gt;- &#96;获取长度&#96; 变量为数组时，&#96;$&#123;#string&#125;&#96; 等价于 &#96;$&#123;#string[0]&#125;&#96;- &#96;提取子串&#96; 从字符串第 2 个字符开始截取 4 个字符 &#96;$&#123;string:1:4&#125;&#96;- &#96;查找子串&#96; 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： &#96;expr index &quot;$string&quot; io&#96;</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">- &#96;初始化语法&#96;： 1. 数组名&#x3D;(值 1 值 2 ... 值 n) 数组元素用&quot;空格&#x2F;回车&quot;符号分割开 2.元素单独赋值- &#96;读取单个元素&#96;：&#96;valuen&#x3D;$&#123;array_name[n]&#125;&#96; 下标- &#96;读取全部元素&#96;：&#96;valuen&#x3D;$&#123;array_name[@]&#125;&#96; @符号- &#96;获取数组的长度&#96;：&#96;$&#123;#array_name[@]&#125;&#96; &#96;$&#123;#array_name[*]&#125;&#96;,单元素长度&#96;$&#123;#array_name[n]&#125;&#96;- &#96;关联数组&#96; 使用任意的字符串、或者整数作为下标&#96;declare -A array_name&#96;</code></pre><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li><code>$#</code> 传递到脚本的参数个数</li><li><code>$*</code> 以<code>一个</code>单字符串显示所有向脚本传递的参数。如”<code>$*</code>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</li><li><code>$@</code> 多个参数，与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</li></ul><hr/><ul><li><code>$$</code> 脚本运行的当前进程 ID 号</li><li><code>$!</code> 后台运行的最后一个进程的 ID 号</li><li><code>$-</code> 显示 Shell 使用的当前选项，与 set 命令功能相同。</li><li><code>$?</code> 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</li></ul><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><p><strong>原生 bash 不支持简单的数学运算，借助<code>expr</code>工具实现</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashval&#x3D;&#96;expr 2 + 2&#96;echo &quot;两数之和为 : $val&quot;</code></pre><ul><li><code>+</code> 加法 <code>expr $a + $b</code> 结果为 30。</li><li><code>-</code> 减法 <code>expr $a - $b</code> 结果为 -10。</li><li><code>*</code> 乘法 <code>expr $a \* $b</code> 结果为 200。 <strong>乘号(<code>*</code>)前边必须加反斜杠(<code>\</code>)才能实现乘法运算；</strong></li><li><code>/</code> 除法 <code>expr $b / $a</code> 结果为 2。</li><li><code>%</code> 取余 <code>expr $b % $a</code> 结果为 0。</li><li><code>=</code> 赋值 a&#x3D;$b 把变量 b 的值赋给 a。</li><li><code>==</code> 相等。用于比较两个数字，相同则返回 true。 [ $a &#x3D;&#x3D; $b ] 返回 false。</li><li><code>!=</code> 不相等。用于比较两个数字，不相同则返回 true。 [ $a !&#x3D; $b ] 返回 true。</li></ul><p>注意：<strong>条件表达式要放在方括号之间，并且要有空格</strong>，例如: [$a&#x3D;&#x3D;$b] 是错误的，必须写成 [ $a &#x3D;&#x3D; $b ]。</p><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</strong></p><ul><li><code>-eq</code> 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。</li><li><code>-ne</code> 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。</li><li><code>-gt</code> 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。</li><li><code>-lt</code> 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。</li><li><code>-ge</code> 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。</li><li><code>-le</code> 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。</li></ul><h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><ul><li><code>!</code> 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。</li><li><code>-o</code> 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。</li><li><code>-a</code> 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。</li></ul><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p><strong>这里效果上同布尔运算 ， 用了两层括号</strong></p><ul><li><code>&amp;&amp;</code> 逻辑的 AND [[$a -lt 100 &amp;&amp; $b -gt 100]] 返回 false</li><li><code>||</code> 逻辑的 OR [[$a -lt 100 || $b -gt 100]] 返回 true</li></ul><h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><ul><li><code>=</code> 检测两个字符串是否相等，相等返回 true。 [ $a &#x3D; $b ] 返回 false。</li><li><code>!=</code> 检测两个字符串是否不相等，不相等返回 true。 [ $a !&#x3D; $b ] 返回 true。</li><li><code>-z</code> 检测字符串长度是否为 0，为 0 返回 true。 [ -z $a ] 返回 false。</li><li><code>-n</code> 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n “$a” ] 返回 true。</li><li><code>$</code> 检测字符串是否不为空，不为空返回 true。 [ $a ] 返回 true。</li></ul><h3 id="文件测试运算"><a href="#文件测试运算" class="headerlink" title="文件测试运算"></a>文件测试运算</h3><ul><li><code>-d file</code> 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。</li><li><code>-f file</code> 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。</li><li><code>-r file</code> 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。</li><li><code>-w file</code> 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。</li><li><code>-x file</code> 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。</li><li><code>-s file</code> 检测文件是否为空（文件大小是否大于 0），不为空返回 true。 [ -s $file ] 返回 true。</li><li><code>-e file</code> 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。</li></ul><hr/><p>以下不晓得啥东西</p><ul><li><code>-b file</code> 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。</li><li><code>-c file</code> 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。</li><li><code>-g file</code> 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。</li><li><code>-k file</code> 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。</li><li><code>-u file</code> 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。</li><li><code>-p file</code> 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。</li></ul><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ul><li><code>％s</code> 输出一个字符串</li><li><code>％d</code> 整型输出</li><li><code>％c</code> 输出一个字符</li><li><code>％f</code> 输出实数，以小数形式输出</li><li><code>%-10s</code> 指一个宽度为 10 个字符（<code>-</code> 表示左对齐，<code>默认</code>：右对齐）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kgprintf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</code></pre><h3 id="转译"><a href="#转译" class="headerlink" title="转译"></a>转译</h3><ul><li><code>\a</code> 不换行</li><li><code>\b</code> 后退</li><li><code>\c</code> 抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</li><li><code>\f</code> 换页（formfeed）</li><li><code>\n</code> 换行</li><li><code>\r</code> 回车（Carriage return）</li><li><code>\t</code> 水平制表符</li><li><code>\v</code> 垂直制表符</li><li><code>\\</code> 一个字面上的反斜杠字符</li></ul><hr/><p>不晓得什么意思</p><ul><li><code>\ddd</code> 表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</li><li><code>\0ddd</code> 表示 1 到 3 位的八进制值字符</li></ul><h2 id="test-是命令"><a href="#test-是命令" class="headerlink" title="test 是命令"></a>test 是命令</h2><ul><li>命令也能直接当脚本用 🤔</li><li>这个 命令好像等价上文操作符中的<code>[]</code></li></ul><img src="http://t-blog-images.aijs.top/img/202211141816204.webp" style="width:500px;max-width:100%" /><h3 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;shnum1&#x3D;100num2&#x3D;100if test $[num1] -eq $[num2]then    echo &#39;两个数相等！&#39;else    echo &#39;两个数不相等！&#39;fi</code></pre><ul><li><code>-eq</code> 等于则为真</li><li><code>-ne</code> 不等于则为真</li><li><code>-gt</code> 大于则为真</li><li><code>-ge</code> 大于等于则为真</li><li><code>-lt</code> 小于则为真</li><li><code>-le</code> 小于等于则为真</li></ul><h3 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h3><p><code>=</code> 等于则为真<br><code>!=</code> 不相等则为真<br><code>-z</code> 字符串 字符串的长度为零则为真<br><code>-n</code> 字符串 字符串的长度不为零则为真</p><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><p><code>-e 文件名</code> 如果文件存在则为真<br><code>-r 文件名</code> 如果文件存在且可读则为真<br><code>-w 文件名</code> 如果文件存在且可写则为真<br><code>-x 文件名</code> 如果文件存在且可执行则为真<br><code>-s 文件名</code> 如果文件存在且至少有一个字符则为真<br><code>-d 文件名</code> 如果文件存在且为目录则为真<br><code>-f 文件名</code> 如果文件存在且为普通文件则为真<br><code>-c 文件名</code> 如果文件存在且为字符型特殊文件则为真<br><code>-b 文件名</code> 如果文件存在且为块特殊文件则为真</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if-…-then-else-if"><a href="#if-…-then-else-if" class="headerlink" title="if ((…)) then else if"></a>if ((…)) then else if</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># if else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt。if [ &quot;$a&quot; -gt &quot;$b&quot; ]; then    ...fi# 如果使用 ((...)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。if (( a &gt; b )); then    ...fi</code></pre><h3 id="if-test"><a href="#if-test" class="headerlink" title="if test"></a>if test</h3><h3 id="for-in-do-done"><a href="#for-in-do-done" class="headerlink" title="for in do done"></a>for in do done</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashfor str in This is a stringdo    echo $strdone</code></pre><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashint&#x3D;1while(( $int&lt;&#x3D;5 ))do    echo $int    let &quot;int++&quot;    # let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，    # 变量计算中不需要加上 $ 来表示变量。    # 如果表达式中包含了空格或其他特殊字符，则必须引起来。done</code></pre><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 无限循环语法格式：while :do    commanddone# 或者while truedo    commanddone# TODO: 上面这两句有点奇怪，：代表 true吗？# 或者for (( ; ; ))</code></pre><h3 id="util"><a href="#util" class="headerlink" title="util"></a>util</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。# 执行循环语句，直到满足条件停下来until conditiondo    commanddone</code></pre><h3 id="case-…esac"><a href="#case-…esac" class="headerlink" title="case …esac"></a>case …esac</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># case ... esac 为多选择语句，与其他语言中的 switch ... case 语句类似，是一种多分支选择结构，# 每个 case 分支用右圆括号开始# 用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。# 可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。# case ... esac 语法格式如下：# *) 可以理解为default语句# 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。case 值 in模式1)    command1    command2    ...    commandN    ;;模式2)    command1    command2    ...    commandN    ;;esac</code></pre><h3 id="break-x2F-continue"><a href="#break-x2F-continue" class="headerlink" title="break&#x2F;continue"></a>break&#x2F;continue</h3><p>continue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[ function ] funname ()&#123;    action;    [return int;]&#125;# 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。# 2、参数返回#   可以显示加：return 返回，#   如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255# 1. 函数返回值: 在调用该函数后通过 $? 来获得# 2. 先定义后使用，注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。# 3. 调用函数仅使用其函数名即可</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li><code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>$&#123;10&#125;</code>。<em>当 n&gt;&#x3D;10 时，需要使用${n}来获取参数</em></li></ol><ul><li><code>$#</code> 传递到脚本或函数的参数个数</li><li><code>$*</code> 以一个单字符串显示所有向脚本传递的参数</li><li><code>$@</code> 与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。</li><li><code>$$</code> 脚本运行的当前进程 ID 号</li><li><code>$!</code> 后台运行的最后一个进程的 ID 号</li><li><code>$-</code> 显示 Shell 使用的当前选项，与 set 命令功能相同。</li><li><code>$?</code> 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</li></ul><h2 id="输入-x2F-输出重定向"><a href="#输入-x2F-输出重定向" class="headerlink" title="输入&#x2F;输出重定向"></a>输入&#x2F;输出重定向</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><ul><li><code>command &gt; file</code> 将输出重定向到 file。</li><li><code>command &gt;&gt; file</code> 将输出以追加的方式重定向到 file。</li></ul><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><ul><li><code>command &lt; file</code> 将输入重定向到 file。</li><li><code>&lt;&lt; tag</code> 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</li></ul><h3 id="测试无效的几个"><a href="#测试无效的几个" class="headerlink" title="测试无效的几个"></a>测试无效的几个</h3><ul><li><code>n &gt; file</code> 将文件描述符为 n 的文件重定向到 file。</li><li><code>n &gt;&gt; file</code> 将文件描述符为 n 的文件以追加的方式重定向到 file。</li><li><code>n &gt;&amp; m</code> 将输出文件 m 和 n 合并。</li><li><code>n &lt;&amp; m</code> 将输入文件 m 和 n 合并。</li></ul><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件级连执行</p><p><strong>var.sh</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashw1&#x3D;&quot;world&quot;</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash#使用 . 号来引用var.sh文件. .&#x2F;var.sh# 或者使用以下包含文件代码# source .&#x2F;var.shecho $w1echo &quot;hello $w1&quot;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.runoob.com/linux/linux-shell-variable.html" target="_blank" >见</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生 系统学习vim</title>
      <link href="//post/2022-11-14vim%E8%AF%AD%E6%B3%95.html"/>
      <url>//post/2022-11-14vim%E8%AF%AD%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h2 id="vim-键盘图"><a href="#vim-键盘图" class="headerlink" title="vim 键盘图"></a>vim 键盘图</h2><p><a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html" target="_blank" >见</a></p><img src="http://t-blog-images.aijs.top/img/202211122058918.webp" style="width:1000px;max-width:100%" /><h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">u undo # 撤销f follow # 向下b back # 向上i insert # 插入c copy # 拷贝n next # 下一p paste # 粘贴j join # 合并r repeat # 重复h hight # 顶部m middle # 中间l low # 底部g goto # 跳转d down # 向下u upper # 向上c confirm # 确认</code></pre><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="vim-x2F-vi"><a href="#vim-x2F-vi" class="headerlink" title="vim&#x2F;vi"></a>vim&#x2F;vi</h3><p>三种模式及切换</p><img src="http://t-blog-images.aijs.top/img/202211121714559.webp" /><h3 id="一般模式-复制-x2F-粘贴-x2F-删除-x2F-撤销"><a href="#一般模式-复制-x2F-粘贴-x2F-删除-x2F-撤销" class="headerlink" title="一般模式 复制&#x2F;粘贴&#x2F;删除&#x2F;撤销"></a>一般模式 复制&#x2F;粘贴&#x2F;删除&#x2F;撤销</h3><table><thead><tr><th align="left">语法</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left">yy</td><td align="left">复制光标当前一行!</td></tr><tr><td align="left">y 数字 y</td><td align="left">复制一段（从光标当前行到后 n 行)!</td></tr><tr><td align="left">p</td><td align="left">箭头移动到目的行粘贴</td></tr><tr><td align="left">u</td><td align="left">撤销上一步</td></tr><tr><td align="left">dd</td><td align="left">删除光标当前行</td></tr><tr><td align="left">d 数字 d</td><td align="left">删除光标（含）后多少行!</td></tr><tr><td align="left">x</td><td align="left">剪切一个字符(当前光标)，相当于 dek</td></tr><tr><td align="left">X</td><td align="left">剪切一个字符(当前光标的前一个)，相当于 Backspace</td></tr><tr><td align="left">yw</td><td align="left">复制一个词。</td></tr><tr><td align="left">dw</td><td align="left">删除一个词~</td></tr><tr><td align="left">shift+6(^)</td><td align="left">移动到行头口</td></tr><tr><td align="left">shift+4($)</td><td align="left">移动到行尾</td></tr><tr><td align="left">w</td><td align="left">移动到下一个词（词头位置）</td></tr><tr><td align="left">en</td><td align="left">移动到当前词尾</td></tr><tr><td align="left">1+G</td><td align="left">移动到页头，数字</td></tr><tr><td align="left">G</td><td align="left">移动到页尾</td></tr><tr><td align="left">数字 N+G</td><td align="left">移动到目标行</td></tr></tbody></table><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>进入编辑模式</p><table><thead><tr><th align="left">按键</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">当前光标后</td></tr><tr><td align="left">i</td><td align="left">当前光标前</td></tr><tr><td align="left">0</td><td align="left">当前光标行的下一行</td></tr><tr><td align="left">I</td><td align="left">光标所在行最前</td></tr><tr><td align="left">A</td><td align="left">光标所在行最后</td></tr><tr><td align="left">O</td><td align="left">当前光标行的上一行</td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><table><thead><tr><th align="left">命令</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">:w</td><td align="left">保存</td></tr><tr><td align="left">:qu</td><td align="left">退出</td></tr><tr><td align="left">:wq</td><td align="left">保存并退出</td></tr><tr><td align="left">:q!</td><td align="left">不保存强制退出 e</td></tr><tr><td align="left">&#x2F;要查找的词</td><td align="left">n 查找下一个，N 往上查找</td></tr><tr><td align="left">:noh</td><td align="left">取消高亮显示</td></tr><tr><td align="left">:set nu</td><td align="left">显示行号</td></tr><tr><td align="left">:set nonu</td><td align="left">关闭行号</td></tr><tr><td align="left">:s&#x2F;old&#x2F;new</td><td align="left">替换当前行匹配到的第一个 old 为 new</td></tr><tr><td align="left">:s&#x2F;old&#x2F;new&#x2F;g</td><td align="left">替换当前行配到的所有 old 为 new</td></tr><tr><td align="left">:%s&#x2F;old&#x2F;new</td><td align="left">替换文档中每一行,配到的第一个 old 为 new</td></tr></tbody></table><hr /><h2 id="vim-一般模式"><a href="#vim-一般模式" class="headerlink" title="vim 一般模式"></a>vim 一般模式</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><h4 id="上下左右"><a href="#上下左右" class="headerlink" title="上下左右"></a>上下左右</h4><ul><li><code>上 / h</code></li><li><code>下 / j</code></li><li><code>左 / k</code></li><li><code>右 / l</code></li></ul><h4 id="首尾跳转"><a href="#首尾跳转" class="headerlink" title="首尾跳转"></a>首尾跳转</h4><ul><li><code>0</code> 或功能键[Home] 移动到这一行的最前面字符处 (常用)</li><li><code>$</code> 或功能键[End] 移动到这一行的最后面字符处(常用)</li><li><code>n + space</code> 行中某处</li></ul><h4 id="行号跳转"><a href="#行号跳转" class="headerlink" title="行号跳转"></a>行号跳转</h4><ul><li><code>nG</code> n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</li><li><code>gg</code> 移动到这个档案的第一行，相当于 1G 啊！ (常用) <em>gg 是什么的缩写？</em></li><li><code>n + 回车</code> n 为数字。光标向下移动 n 行(常用)</li></ul><h4 id="屏幕跳转"><a href="#屏幕跳转" class="headerlink" title="屏幕跳转"></a>屏幕跳转</h4><ul><li><code>H</code> 光标移动到这个屏幕的<code>最上方</code> 那一行的第一个字符</li><li><code>M</code> 光标移动到这个屏幕的<code>中央处</code> 那一行的第一个字符</li><li><code>L</code> 光标移动到这个屏幕的<code>最下方</code> 那一行的第一个字符</li></ul><h4 id="分页跳转"><a href="#分页跳转" class="headerlink" title="分页跳转"></a>分页跳转</h4><ul><li><code>ctrl + f</code> 向<code>下一</code>页</li><li><code>ctrl + b</code> 向<code>上一</code>页</li><li><code>ctrl + d</code> 向<code>下半</code>页</li><li><code>ctrl + u</code> 向<code>上半</code>页</li></ul><h3 id="搜索-x2F-替换"><a href="#搜索-x2F-替换" class="headerlink" title="搜索&#x2F;替换"></a>搜索&#x2F;替换</h3><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li><code>/word</code> 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</li><li><code>?word</code> 向光标之上寻找一个字符串名称为 word 的字符串。</li><li><code>n</code> 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</li><li><code>N</code> 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</li></ul><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li><code>:n1,n2s/word1/word2/g</code>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</li><li><code>:1,$s/word1/word2/g 或 :%s/word1/word2/g</code> 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li><li><code>:1,$s/word1/word2/gc 或 :%s/word1/word2/gc</code> 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</li></ul><p>上面第一个比第二个的多了 s，好像没什么区别</p><h3 id="删除-x2F-复制-x2F-粘贴"><a href="#删除-x2F-复制-x2F-粘贴" class="headerlink" title="删除&#x2F;复制&#x2F;粘贴"></a>删除&#x2F;复制&#x2F;粘贴</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><code>nx</code> n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</li><li><code>x</code> 为向后删除一个字符 (相当于 [del] 按键)，</li><li><code>X</code> 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</li><li><code>d$</code> 删除游标所在处，到该行的最后一个字符</li><li><code>d0</code> 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</li><li><code>dG</code> 删除光标所在到最后一行的所有数据</li><li><code>d1G</code> 删除光标所在到第一行的所有数据</li></ul><h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><ul><li><code>dd</code> 剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</li><li><code>ndd</code> n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</li></ul><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li><code>yy</code> 复制游标所在的那一行(常用)</li><li><code>nyy</code> 向下复制 n 行，例如 20yy 则是复制 20 行(常用)</li><li><code>y$</code> 复制光标所在的那个字符到该行行尾的所有数据</li><li><code>y0</code> 复制光标所在的那个字符到该行行首的所有数据</li><li><code>yG</code> 复制游标所在行到最后一行的所有数据</li><li><code>y1G</code> 复制游标所在行到第一行的所有数据</li></ul><h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><ul><li><code>p</code> p 为将已复制的数据在光标下一行贴上，</li><li><code>P</code> 则为贴在游标上一行！</li></ul><p>举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</p><h3 id="行合并"><a href="#行合并" class="headerlink" title="行合并"></a>行合并</h3><ul><li><code>J</code> 将光标所在行与下一行的数据结合成同一行</li></ul><h3 id="重复上一个动作"><a href="#重复上一个动作" class="headerlink" title="重复上一个动作"></a>重复上一个动作</h3><ul><li>ctrl + r 与 u 操作相反</li><li>. 继续刚才的操作,即使被 undo 了之后，还会进行 undo…undo 之前的操作</li></ul><h2 id="vim-一般模式-x2F-编辑模式"><a href="#vim-一般模式-x2F-编辑模式" class="headerlink" title="vim 一般模式&#x2F;编辑模式"></a>vim 一般模式&#x2F;编辑模式</h2><ul><li><code>i</code> 为『从目前光标所在处输入』，</li><li><code>I</code> 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</li><li><code>a</code> 为『从目前光标所在的下一个字符处开始输入』，</li><li><code>A</code> 为『从光标所在行的最后一个字符处开始输入』。(常用)</li><li><code>o</code> 为在目前光标所在的下一行处输入新的一行；</li><li><code>O</code> 为在目前光标所在的上一行处输入新的一行！(常用)</li><li><code>r</code> 只会取代光标所在的那一个字符一次；</li><li><code>R</code> 会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</li></ul><p>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</p><ul><li><code>Esc</code> 退出编辑模式，回到一般模式中(常用)</li></ul><h2 id="vim-一般模式-x2F-指令行模式"><a href="#vim-一般模式-x2F-指令行模式" class="headerlink" title="vim 一般模式&#x2F;指令行模式"></a>vim 一般模式&#x2F;指令行模式</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p><strong>惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</strong></p><ul><li><code>:w</code> 将编辑的数据写入硬盘档案中(常用)</li><li><code>:w!</code>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</li><li><code>:q</code> 离开 vi (常用)</li><li><code>:q!</code>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</li><li><code>:wq</code> 储存后离开，若为 :wq! 则为强制储存后离开 (常用)</li></ul><h3 id="存文件"><a href="#存文件" class="headerlink" title="存文件"></a>存文件</h3><ul><li><code>:w [filename]</code> 将编辑的数据储存成另一个档案（类似另存新档）</li><li><code>:n1,n2 w [filename]</code> 将 n1 到 n2 的内容储存成 filename 这个档案。(这个操作咋没效果呢)</li></ul><h3 id="读取其他文件"><a href="#读取其他文件" class="headerlink" title="读取其他文件"></a>读取其他文件</h3><ul><li><code>:r [filename]</code> 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</li></ul><h3 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h3><ul><li><code>:set nu</code> 显示行号，设定之后，会在每一行的前缀显示该行的行号</li><li><code>:set nonu</code> 与 set nu 相反，为取消行号！</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><code>:n1,n2 w [filename]</code> 将 n1 到 n2 的内容储存成 filename 这个档案。**(这个操作咋没效果呢)**</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" >Linux vi&#x2F;vim</a></p><p><a href="https://www.cnblogs.com/hurryup/articles/12360129.html" target="_blank" >yum:command not found 解决办法</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manage</title>
      <link href="//post/2022-11-10manage.html"/>
      <url>//post/2022-11-10manage.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>2022-11-09</p><p>…</p><p>媳妇说：领导要她主导一个项目，不晓得怎么搞，让我给她罗列下</p><p>聊天记录我看了，确实是<code>主导</code>，而不是你 “先对接下，先把前端页面能开发的部分，先开发下”</p><p>…</p><p>2022-11-11，弯弯绕，整完，最后来句：后端没资源前端先开发 😂</p><p>…</p><p><code>Are you kidding with me?</code></p><p>…</p><p>胡闹归胡闹，既然都整理出来，就加到文章中</p><h2 id="项目负责流程"><a href="#项目负责流程" class="headerlink" title="项目负责流程"></a>项目负责流程</h2><ul><li><p>需求背景</p></li><li><p>需求对接</p></li><li><p>需求评审（会）</p><ul><li>可能要需求方跟（前端、后端、测试、也可能涉及到领导啥的）来讲这次需求</li></ul></li><li><p>技术评审（会）</p></li><li><p>研发排期（会）</p><ul><li>不是说，一批需求直接定一个月，两个月的排期要一点一点排</li><li>比如 两周一个迭代，这期需求要 2&#x2F;n 个迭代做完，之后倒推出来大概要到什么时候可以提测，验收、上线</li></ul></li><li><p>研发集成自测（会）交叉测试等</p></li><li><p>提测（如果有测试的情况）</p></li><li><p>bug 修改</p></li><li><p>产品验收</p></li><li><p>发布上线</p></li></ul><h2 id="画个简图辅助理解"><a href="#画个简图辅助理解" class="headerlink" title="画个简图辅助理解"></a>画个简图辅助理解</h2><img src="http://t-blog-images.aijs.top/img/202211111651376.webp" style="width:500px;max-width:100%" /><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol><li>自己平时有没有表达不当，让人误解</li><li>之前自己就有想过总结下，结果“忙其他的，给忘了”（<code>偷懒，不要找借口！</code>）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Manage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生 Shell 命令（持续补充）</title>
      <link href="//post/2022-11-07shell%E5%91%BD%E4%BB%A4.html"/>
      <url>//post/2022-11-07shell%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h2 id="echo-内容到文件"><a href="#echo-内容到文件" class="headerlink" title="echo 内容到文件"></a>echo 内容到文件</h2><h3 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ echo &quot;hello&quot; &gt; hw.md # 写入hello$ cat hw.md # 查看hello$ echo &quot;world&quot; &gt; hw.md  # 插写入world$ cat hw.md # 查看world</code></pre><h3 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ echo &quot;hello&quot; &gt; hw.md  # 写入hello$ cat hw.md # 查看hello$ echo &quot;world&quot; &gt;&gt; hw.md  # 追加world$ cat hw.md # 查看helloworld</code></pre><h2 id="cat-内容到文件"><a href="#cat-内容到文件" class="headerlink" title="cat 内容到文件"></a>cat 内容到文件</h2><ul><li>将 file1 文件里的内容追加到 file2：<code>cat file1 &gt;&gt; file2</code></li><li>将 file1 文件里的内容写入到 file2，写入前清空 file2（即覆盖）：<code>cat file1 &gt; file2</code></li><li>将多个文件的内容追加到另一个文件（合并 file1 和 file2 的内容写入到 file3）：<code>cat file1 file2 &gt;&gt; file3</code></li></ul><h3 id="重定向输出内容-gt"><a href="#重定向输出内容-gt" class="headerlink" title="重定向输出内容 &gt;"></a>重定向输出内容 <code>&gt;</code></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ rm -f hw.md$ cat &gt; .&#x2F;hw.md &lt;&lt; EOFheredoc&gt; helloheredoc&gt; EOF$ lshw.md$ cat hw.mdhello</code></pre><h3 id="重定向追加内容-gt-gt"><a href="#重定向追加内容-gt-gt" class="headerlink" title="重定向追加内容 &gt;&gt;"></a>重定向追加内容 <code>&gt;&gt;</code></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat &gt;&gt; .&#x2F;hw.md &lt;&lt; EOFhelloEOF$ cat hw.mdhellohello</code></pre><h3 id="文件内容合并到一个"><a href="#文件内容合并到一个" class="headerlink" title="文件内容合并到一个"></a>文件内容合并到一个</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看文件内容$ cat hw.mdhellohello# 再整一个文件$ cat &gt;&gt; .&#x2F;hw1.md &lt;&lt; EOFwordEOF# 查看文件列表$ lshw.md  hw1.md# 文件内容合并到  .&#x2F;hw3.md$ cat .&#x2F;hw1.md .&#x2F;hw.md &gt;&gt; .&#x2F;hw3.md$ lshw.md  hw1.md hw3.md# 查看合并后的内容$ cat hw3.mdwordhellohello</code></pre><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>用法：mkdir [选项]… 目录…<br>若指定目录不存在则创建目录。</p><p>长选项必须使用的参数对于短选项时也是必需使用的。</p><ul><li>-m, –mode&#x3D;模式 设置权限模式(类似 chmod)，而不是 rwxrwxrwx 减 umask</li><li>-p, –parents 需要时创建目标目录的上层目录，但即使这些目录已存在也不当作错误处理</li><li>-v, –verbose 每次创建新目录都显示信息</li><li>-Z, –context&#x3D;CTX 将每个创建的目录的 SELinux 安全环境设置为 CTX</li><li>–help 显示此帮助信息并退出</li><li>–version 显示版本信息并退出</li></ul><p><a href="http://linux.51yip.com/search/mkdir" target="_blank" >http://linux.51yip.com/search/mkdir</a></p><h3 id="批量创建文件夹"><a href="#批量创建文件夹" class="headerlink" title="批量创建文件夹"></a>批量创建文件夹</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;ms&#x2F;&#123;sales,hr,web&#125;    #创建一个名为&#x2F;ms的目录，其中有sales、hr、web的子目录</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#批量创建文件夹$ mkdir -pv &#x2F;tmp&#x2F;test&#x2F;&#123;a1,b1&#125;&#x2F;&#123;c1,d1&#125;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#39;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;a1&#39;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;a1&#x2F;c1&#39;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;a1&#x2F;d1&#39;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;b1&#39;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;b1&#x2F;c1&#39;mkdir: created directory &#39;&#x2F;tmp&#x2F;test&#x2F;b1&#x2F;d1&#39;$ tree &#x2F;tmp&#x2F;test&#x2F;&#x2F;tmp&#x2F;test&#x2F;├── a1│   ├── c1│   └── d1└── b1    ├── c1    └── d16 directories, 0 files</code></pre><h2 id="显示目录命令-ls"><a href="#显示目录命令-ls" class="headerlink" title="显示目录命令 ls"></a>显示目录命令 ls</h2><p>参数:</p><p>-a :显示包括隐藏文件和目录在内的所有目录和文件</p><p>-l :显示文件的详细信息</p><p>-h :配合-l 以人性化的方式显示文件大小</p><p>-t :按文件最后修改时间排序文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -lhat</code></pre><h2 id="权限组合"><a href="#权限组合" class="headerlink" title="权限组合"></a>权限组合</h2><ul><li>r 可读</li><li>w 可写</li><li>x 可执行</li><li><ul><li>不可</li></ul></li></ul><table><thead><tr><th align="left">组合</th><th align="left">释义</th><th align="left">权限值</th></tr></thead><tbody><tr><td align="left">rwx</td><td align="left">可读、可写、可执行</td><td align="left">4+2+1&#x3D;7</td></tr><tr><td align="left">r-x</td><td align="left">可读、不可写、可执行</td><td align="left">4+1&#x3D;5</td></tr><tr><td align="left">rw-</td><td align="left">可读、可写、不可执行</td><td align="left">4+2&#x3D;6</td></tr><tr><td align="left">-wx</td><td align="left">不可读、可写、可执行</td><td align="left">2+1&#x3D;3</td></tr></tbody></table><h2 id="文件权限修改-chmod"><a href="#文件权限修改-chmod" class="headerlink" title="文件权限修改 chmod"></a>文件权限修改 chmod</h2><ul><li>-u user 用户</li><li>-g grop 用户组</li><li>-o others 其他人</li><li>-a all 所有人</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 字符chmod u+x a.txt 用户增加执行权限# 用数值chmod 777 a.txt 所有人增加所有权限</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><ul><li>前|后：前面处理完，后面直接处理</li></ul><p>例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 造点数据$ echo &#123;1..15&#125; &gt; 1.txt$ echo &#123;a..z&#125; &gt;&gt; 1.txt$ echo 它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来. &gt;&gt; 1.txt$ echo 它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:. &gt;&gt; 1.txt# 找1.text倒数3行内容，之后grep 查找日志关键字并高亮及显示所在行上下文$ tail -n 3 1.txt | grep -1 -n official# 输出1-a b c d e f g h i j k l m n o p q r s t u v w x y z2:它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.3:它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.## 清场rm -f 1.txt</code></pre><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><h3 id="更新文档时间"><a href="#更新文档时间" class="headerlink" title="更新文档时间"></a>更新文档时间</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls -lh  1.txt# 时间 10:41-rw-r--r--  1 haotian  staff   377B 11 11 10:41 1.txt$ touch 1.txt$ ls -lh  1.txt# 时间 11:00-rw-r--r--  1 haotian  staff   377B 11 11 11:00 1.txt</code></pre><h3 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h3><h2 id="zip-x2F-unzip"><a href="#zip-x2F-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 压缩所有.txt文件$ zip  txt.zip *.txt  adding: 1.txt (deflated 35%)  adding: 2.txt (stored 0%)$ ls1.txt   2.txt   txt.zip# 解压缩所有$ unzip txt.zipArchive:  txt.zip# 提示相同文件怎么处理replace 1.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: rnew name: hello  inflating: hello# 提示相同文件怎么处理replace 2.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: rnew name: world extracting: world$ ls1.txt   2.txt   hello   txt.zip world# 查看解压后的内容$ cat hello1 2 3 4 5 6 7 8 9 10 11 12 13 14 15a b c d e f g h i j k l m n o p q r s t u v w x y z它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.# 查看解压后的内容$ cat world123$</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 不解压，仅看看$ unzip -v txt.zipArchive:  txt.zip Length   Method    Size  Cmpr    Date    Time   CRC-32   Name--------  ------  ------- ---- ---------- ----- --------  ----     377  Defl:N      244  35% 11-11-2022 11:00 8d413fc0  1.txt       4  Stored        4   0% 11-11-2022 11:10 5a82fd08  2.txt--------          -------  ---                            -------     381              248  35%                            2 files</code></pre><h2 id="tail-x2F-head"><a href="#tail-x2F-head" class="headerlink" title="tail&#x2F;head"></a>tail&#x2F;head</h2><p>查文档日志</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat 1.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 15a b c d e f g h i j k l m n o p q r s t u v w x y z它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.$ head 1.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 15a b c d e f g h i j k l m n o p q r s t u v w x y z它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.# 头部 2行$ head -2 1.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 15a b c d e f g h i j k l m n o p q r s t u v w x y z# 头部 3行$ head -3 1.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 15a b c d e f g h i j k l m n o p q r s t u v w x y z它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.# 头部 1行$ head -1 1.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 15# 头部 2行$ head -n 2  1.txt1 2 3 4 5 6 7 8 9 10 11 12 13 14 15a b c d e f g h i j k l m n o p q r s t u v w x y z# 等效 tail -n 2 1.txt 简写 tail -2  1.txt$ tail -2  1.txt它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来.它表示, 不但要找出 official 关键字所在行, 还要把所在行前后的 5 行都显示出来为了更清晰地呈现, 还可以选择显示行号, 用 -n 参数, 如下:.$</code></pre><p>注意 <code>-f</code>是循环获取，不存在<code>-w</code></p><p><a href="https://m.runoob.com/linux/linux-comm-tail.html" target="_blank" >见</a></p><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><h3 id="本地到远程"><a href="#本地到远程" class="headerlink" title="本地到远程"></a>本地到远程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">scp local_file remote_username@remote_ip:remote_folder# 或者scp local_file remote_username@remote_ip:remote_file# 或者scp local_file remote_ip:remote_folder# 或者scp local_file remote_ip:remote_file# 第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；# 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</code></pre><h3 id="远程到本地"><a href="#远程到本地" class="headerlink" title="远程到本地"></a>远程到本地</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例scp root@www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F;music &#x2F;home&#x2F;space&#x2F;music&#x2F;1.mp3scp -r www.runoob.com:&#x2F;home&#x2F;root&#x2F;others&#x2F; &#x2F;home&#x2F;space&#x2F;music&#x2F;</code></pre><h2 id="command-not-found-ip"><a href="#command-not-found-ip" class="headerlink" title="command not found: ip"></a>command not found: ip</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install iproute2mac</code></pre><h2 id="删除某个目录下所有子目录的-node-modules"><a href="#删除某个目录下所有子目录的-node-modules" class="headerlink" title="删除某个目录下所有子目录的 node_modules"></a>删除某个目录下所有子目录的 node_modules</h2><ul><li>查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 modu 执行删除</li></ul><pre class="line-numbers language-none"><code class="language-none">find &#x2F;tmp&#x2F;test&#x2F; -type d -name modu |xargs rm -rf</code></pre><ul><li>查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 node_modules 执行删除</li></ul><pre class="line-numbers language-none"><code class="language-none">find &#x2F;tmp&#x2F;test&#x2F; -type d -name node_modules |xargs rm -rf</code></pre><ul><li>查找 当前目录下 子目录下所有 node_modules 执行删除</li></ul><pre class="line-numbers language-none"><code class="language-none">find .&#x2F; -type d -name node_modules |xargs rm -rf</code></pre><p><a href="https://www.cnblogs.com/w-j-q/p/14863810.html" target="_blank" >见 find 命令</a></p><h2 id="按照文件大小查询"><a href="#按照文件大小查询" class="headerlink" title="按照文件大小查询"></a>按照文件大小查询</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查找path路径下，大雨10m的文件find path -size +10m</code></pre><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 先更新updatedblocate name</code></pre><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><p>主机名命名与业务相关 如： master work-node1 work-node2</p><p>方案 1: <code>vim /etc/hostname</code> + 重启服务器<br>方案 2:<code>hostnamectl set- hostname 你要的名字</code></p><h2 id="主机名单"><a href="#主机名单" class="headerlink" title="主机名单"></a>主机名单</h2><p><code>vim /etc/hosts</code></p><h2 id="修改-linux-ip"><a href="#修改-linux-ip" class="headerlink" title="修改 linux ip"></a>修改 linux ip</h2><h3 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h3><p>vim letclsysconfig&#x2F;network-scripts&#x2F;ifcfg-ens334</p><p>以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。</p><img src="http://t-blog-images.aijs.top/img/202211122333156.webp" style="width:500px;max-width:100%" /><h3 id="为什么要修改-ip"><a href="#为什么要修改-ip" class="headerlink" title="为什么要修改 ip"></a>为什么要修改 ip</h3><p>ip 动态分配，登录时候，不易发现（连接）服务器</p><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><ol><li><p>物理机能 ping 通虚拟机，但是虚拟机 ping 不通物理机，一般都是因为物理机的防火墙问题，把防火墙关闭就行</p></li><li><p>虚拟机能 Ping 通物理机，但是虛拟机 Ping 不通外网，一般都是因为 DNS 的设置有问题</p></li><li><p>虛拟机 Ping <a href="http://www.baidu/">www.baidu</a>. com 品示域名未知等信息，一般查看 GATEWAY 和 DNS 设置是否正确</p></li><li><p>如果以上全部设置完还是不行，需要关闭 NetworkManager 服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop NetworkManager 关闭systemct1 disable NetworkManager 禁用</code></pre></li><li><p>如果检查发现 systemct1 status network 有问题 需要检查 ifcfg-ens33</p></li></ol><h3 id="service-服务管理-（Centos6）。"><a href="#service-服务管理-（Centos6）。" class="headerlink" title="service 服务管理 （Centos6）。"></a>service 服务管理 （Centos6）。</h3><p><strong>基本语法</strong><br>service 服务名 start &#x2F; stop &#x2F; restart &#x2F; status<br><strong>经验技巧</strong><br>杳看服务的方法：letclinit.d&#x2F;服务名发现只有两个服务保留在 service<br>[root@test init.d]# pwd<br>&#x2F;etc&#x2F;init.d<br>[root@test init.d]# ls</p><h3 id="systemctl-Centos-7）"><a href="#systemctl-Centos-7）" class="headerlink" title="systemctl(Centos 7）"></a>systemctl(Centos 7）</h3><p><strong>基本语法</strong><br>systemctl start| stop | restart | status 服务名<br><strong>经验技巧</strong></p><p>查看服务的方法：usr&#x2F;lib&#x2F;systemd&#x2F;system</p><p>[root@test system]# pwo<br>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system<br>[root@test init.d]# ls-al</p><h2 id="linux-进程运行级别"><a href="#linux-进程运行级别" class="headerlink" title="linux 进程运行级别"></a>linux 进程运行级别</h2><img src="http://t-blog-images.aijs.top/img/202211130948454.webp" style="width:500px;max-width:100%" /><h2 id="配置服务开机自启动-x2F-关闭服务器防火墙"><a href="#配置服务开机自启动-x2F-关闭服务器防火墙" class="headerlink" title="配置服务开机自启动&#x2F;关闭服务器防火墙"></a>配置服务开机自启动&#x2F;关闭服务器防火墙</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Centos6chkconfig --listchkconfig --level 3 network off # 3级别的network关闭chkconfig --level 3 network on # 3级别的network开启</code></pre><img src="http://t-blog-images.aijs.top/img/202211131000418.webp" style="width:500px;max-width:100%" /><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Centos7</code></pre><h2 id="iptables-x2F-firewalld"><a href="#iptables-x2F-firewalld" class="headerlink" title="iptables&#x2F;firewalld"></a>iptables&#x2F;firewalld</h2><pre class="line-numbers language-none"><code class="language-none">systemctl stop firewalld.servicesystemctl start firewalld.servicesystemctl disable firewalld.servicesystemctl enable firewalld.servicesystemctl status firewalld</code></pre><h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>永无止境的，除非特殊情况下，不得已才会关机。<br>1）基本语法<br>(1) sync (功能描述：将数据由内存同先到硬盘中）<br>(2) halt (功能描述：停机，关闭系统，但不断电）<br>(3) poweroff (功能描述：关机，断电）<br>(3) reboot (功能描述：就是重启，等同于 shutdown -r now)<br>(4） shutdown【选项】 1 时间</p><p><strong>选项</strong></p><ul><li>-H 相当于 –halt 停机</li><li>-r 等于 reboot 重启</li></ul><p><strong>参数</strong></p><ul><li>now 立刻关机</li><li>时间 等待多久之后关机</li></ul><h2 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h2><ul><li>clear</li><li>ctrl + l</li><li>reset</li></ul><p>这三个命令只是将屏幕滚动，并不是真的清理</p><h3 id="当前工作目录的绝对路径"><a href="#当前工作目录的绝对路径" class="headerlink" title="当前工作目录的绝对路径"></a>当前工作目录的绝对路径</h3><ul><li>pwd: print working directory 打印工作目录</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查询 filename 文件中  something 的行号grep -n something filename</code></pre><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p><code>\cp 强制覆盖不提示</code></p><h2 id="more-命令-比-cat-更好"><a href="#more-命令-比-cat-更好" class="headerlink" title="more 命令 比 cat 更好"></a>more 命令 比 cat 更好</h2><p><a href="https://m.runoob.com/linux/linux-comm-more.html" target="_blank" >Linux more 命令</a></p><h2 id="less-命令-比-more-更好"><a href="#less-命令-比-more-更好" class="headerlink" title="less 命令 比 more 更好"></a>less 命令 比 more 更好</h2><p><a href="https://m.runoob.com/linux/linux-comm-less.html" target="_blank" >Linux less 命令</a></p><h2 id="ln-软连接"><a href="#ln-软连接" class="headerlink" title="ln 软连接"></a>ln 软连接</h2><p>删除方式同文件&#x2F;文件夹删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf foldername # 删除软连接文件夹# 区别是尾部&#x2F;rm -rf foldername&#x2F; #删除真实文件夹</code></pre><p><a href="https://m.runoob.com/linux/linux-comm-ln.html" target="_blank" >见</a></p><h2 id="date-x2F-ntpdate-x2F-cal"><a href="#date-x2F-ntpdate-x2F-cal" class="headerlink" title="date&#x2F;ntpdate&#x2F;cal"></a>date&#x2F;ntpdate&#x2F;cal</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ntpdate # 联网更新时间，可能需要安装工具</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">♠ &#x2F;Users&#x2F;chenhailong $ cal -y                            2022         一月                    二月                    三月日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六                   1         1  2  3  4  5         1  2  3  4  5 2  3  4  5  6  7  8   6  7  8  9 10 11 12   6  7  8  9 10 11 12 9 10 11 12 13 14 15  13 14 15 16 17 18 19  13 14 15 16 17 18 1916 17 18 19 20 21 22  20 21 22 23 24 25 26  20 21 22 23 24 25 2623 24 25 26 27 28 29  27 28                 27 28 29 30 3130 31         四月                    五月                    六月日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六                1  2   1  2  3  4  5  6  7            1  2  3  4 3  4  5  6  7  8  9   8  9 10 11 12 13 14   5  6  7  8  9 10 1110 11 12 13 14 15 16  15 16 17 18 19 20 21  12 13 14 15 16 17 1817 18 19 20 21 22 23  22 23 24 25 26 27 28  19 20 21 22 23 24 2524 25 26 27 28 29 30  29 30 31              26 27 28 29 30         七月                    八月                    九月日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六                1  2      1  2  3  4  5  6               1  2  3 3  4  5  6  7  8  9   7  8  9 10 11 12 13   4  5  6  7  8  9 1010 11 12 13 14 15 16  14 15 16 17 18 19 20  11 12 13 14 15 16 1717 18 19 20 21 22 23  21 22 23 24 25 26 27  18 19 20 21 22 23 2424 25 26 27 28 29 30  28 29 30 31           25 26 27 28 29 3031         十月                   十一月                   十二月日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六                   1         1  2  3  4  5               1  2  3 2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10 9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 1716 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 2423 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 3130 31♠ &#x2F;Users&#x2F;chenhailong $ cal      十一月 2022日 一 二 三 四 五 六       1  2  3  4  5 6  7  8  9 10 11 1213 14 15 16 17 18 1920 21 22 23 24 25 2627 28 29 30♠ &#x2F;Users&#x2F;chenhailong $ cal -3                            2022         十月                   十一月                   十二月日 一 二 三 四 五 六  日 一 二 三 四 五 六  日 一 二 三 四 五 六                   1         1  2  3  4  5               1  2  3 2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10 9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 1716 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 2423 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 3130 31</code></pre><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><img src="http://t-blog-images.aijs.top/img/202211131713117.webp" style="width:500px;max-width:100%" /><img src="http://t-blog-images.aijs.top/img/202211131714177.webp" style="width:500px;max-width:100%" /><h2 id="压缩-x2F-解压缩"><a href="#压缩-x2F-解压缩" class="headerlink" title="压缩&#x2F;解压缩"></a>压缩&#x2F;解压缩</h2><h3 id="gzip-x2F-guuzip"><a href="#gzip-x2F-guuzip" class="headerlink" title="gzip&#x2F;guuzip"></a>gzip&#x2F;guuzip</h3><p>gzip&#x2F;gunzip 压缩</p><ul><li>1）基本语法<br>gzip 文件 (功能描述：压缩文件，只能将文件压缩为*.gz 文件）<br>gunzip 文件.gz （功能描述：解压缩文件命令）</li><li>2）经验技巧<br>(1）<strong>只能压缩文件不能压缩目录</strong><br>(2）<strong>不保留原来的文件</strong><br>(3）<strong>同时名个文件会产生名个压缩包</strong></li><li>3）案例实操<br>(1 gzip 压缩</li></ul><h3 id="zip-x2F-unzip-1"><a href="#zip-x2F-unzip-1" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h3><p><strong>1）基本语法</strong><br>zip 选项 1XXX.zip 将要压缩的内容 (功能描述：压缩文件和目录的命令）<br>unzip[选项]xxx.zip (功能描述：解压缩文件）</p><p><strong>2）选项说明</strong></p><table><thead><tr><th align="left">zip 选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-r</td><td align="left">压缩目录</td></tr></tbody></table><table><thead><tr><th align="left">unzip 选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-d &lt;目录&gt;</td><td align="left">指定解压后文件的存放目录</td></tr></tbody></table><p><strong>3）经验技巧</strong><br>zip 压缩命令在 window&#x2F;inux 都通用，可以压缩目录且保留源文件</p><p><strong>4） 案例实操</strong><br>(1）压缩 houge.txt 和 bailongma.txt，压缩后的名称为 mypackage.zip</p><h3 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar 打包"></a>tar 打包</h3><p>1）基本语法</p><p>tar[选项]XXX.tar.gz 将要打包进去的内容 （功能描述：打包目录，压缩后的文件格式.tar.gz）</p><p>2）选项说明</p><table><thead><tr><th align="left">选项</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">-c</td><td align="left">产生.tar 打包文件</td></tr><tr><td align="left">-v</td><td align="left">显示详细信息</td></tr><tr><td align="left">-f</td><td align="left">指定压缩后的文件名</td></tr><tr><td align="left">-z</td><td align="left">打向同时压缩</td></tr><tr><td align="left">-X</td><td align="left">解包.tar 文件</td></tr><tr><td align="left">-C</td><td align="left">解压到指定目录</td></tr></tbody></table><p>3）案例实操~<br>(1）压缩多个文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 压缩tar -zcvf name.tar.gz houge.txt bailonama.txt# 解压缩tar -zxvf temp.tar.gz -C &#x2F; tmp</code></pre><h2 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h2><img src="http://t-blog-images.aijs.top/img/202211131716428.webp" style="width:500px;max-width:100%" /><img src="http://t-blog-images.aijs.top/img/202211131717509.webp" style="width:500px;max-width:100%" /><h3 id="更改-ip"><a href="#更改-ip" class="headerlink" title="更改 ip"></a>更改 ip</h3><img src="http://t-blog-images.aijs.top/img/202211131719448.webp" style="width:500px;max-width:100%" /><h3 id="更改-hostname"><a href="#更改-hostname" class="headerlink" title="更改 hostname"></a>更改 hostname</h3><img src="http://t-blog-images.aijs.top/img/202211131720641.webp" style="width:500px;max-width:100%" /><h2 id="磁盘查看和分区类"><a href="#磁盘查看和分区类" class="headerlink" title="磁盘查看和分区类"></a>磁盘查看和分区类</h2><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p><a href="https://m.runoob.com/linux/linux-comm-du.html" target="_blank" >Linux du 命令</a></p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看内存free -h</code></pre><h3 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h3><p>查看设备（硬盘&#x2F;光盘）挂载情况</p><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><img src="http://t-blog-images.aijs.top/img/202211132033930.webp" style="width:500px;max-width:100%" /><h2 id="如何进行磁盘分区"><a href="#如何进行磁盘分区" class="headerlink" title="如何进行磁盘分区"></a>如何进行磁盘分区</h2><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="ps-x2F-pstree"><a href="#ps-x2F-pstree" class="headerlink" title="ps&#x2F;pstree"></a>ps&#x2F;pstree</h3><img src="http://t-blog-images.aijs.top/img/202211132052202.webp" style="width:500px;max-width:100%" /><p><a href="https://blog.csdn.net/haibo0668/article/details/124502204" target="_blank" >见</a></p><h2 id="linux-各目录含义？"><a href="#linux-各目录含义？" class="headerlink" title="linux 各目录含义？"></a>linux 各目录含义？</h2><p><a href="https://blog.csdn.net/Persistence___/article/details/125328727" target="_blank" >见</a></p><h2 id="shell-脚本"><a href="#shell-脚本" class="headerlink" title="shell 脚本"></a>shell 脚本</h2><h3 id="查看支持的脚本"><a href="#查看支持的脚本" class="headerlink" title="查看支持的脚本"></a>查看支持的脚本</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;shells</code></pre><h3 id="脚本执行方式"><a href="#脚本执行方式" class="headerlink" title="脚本执行方式"></a>脚本执行方式</h3><ul><li>bash 文件</li><li>sh 文件</li><li>chmod +x 文件路径（相对&#x2F;绝对&#x2F;文件执行运行）</li><li>source 文件</li><li>. 文件</li></ul><h3 id="rm-rf"><a href="#rm-rf" class="headerlink" title="rm -rf *"></a><code>rm -rf *</code></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ rm -rf *zsh: sure you want to delete all 3 files in &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;log [yn]?# 虽然是强制，但是还是有提示的</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/q1104460935/p/shell.html#shell%E6%9F%A5%E7%9C%8B" target="_blank" >shell 常见命令</a></p><p><a href="https://www.bilibili.com/video/BV1WY4y1H7d3" target="_blank" >3 天搞定 Linux，1 天搞定 Shell</a></p><p><a href="https://wangchujiang.com/linux-command/c/yum.html" target="_blank" >yum 软件包管理</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生 给自己科普 k8s</title>
      <link href="//post/2022-11-05k8s.html"/>
      <url>//post/2022-11-05k8s.html</url>
      
        <content type="html"><![CDATA[<h2 id="满脑子问题"><a href="#满脑子问题" class="headerlink" title="满脑子问题"></a>满脑子问题</h2><h2 id="k8s-是什么"><a href="#k8s-是什么" class="headerlink" title="k8s 是什么"></a>k8s 是什么</h2><h2 id="k8s-如何安装"><a href="#k8s-如何安装" class="headerlink" title="k8s 如何安装"></a>k8s 如何安装</h2><h2 id="k8s-为什么最少-3-个-master"><a href="#k8s-为什么最少-3-个-master" class="headerlink" title="k8s 为什么最少 3 个 master"></a>k8s 为什么最少 3 个 master</h2><h2 id="k8s-如何控制-node"><a href="#k8s-如何控制-node" class="headerlink" title="k8s 如何控制 node"></a>k8s 如何控制 node</h2><h2 id="如何进行-iterm-多服务器操作"><a href="#如何进行-iterm-多服务器操作" class="headerlink" title="如何进行 iterm 多服务器操作"></a>如何进行 iterm 多服务器操作</h2><h2 id="scp-命令如何使用？有教程吗？"><a href="#scp-命令如何使用？有教程吗？" class="headerlink" title="scp 命令如何使用？有教程吗？"></a>scp 命令如何使用？有教程吗？</h2><h2 id="sz-命令"><a href="#sz-命令" class="headerlink" title="sz 命令"></a>sz 命令</h2><h2 id="如何安装环境"><a href="#如何安装环境" class="headerlink" title="如何安装环境"></a>如何安装环境</h2><h2 id="为什么要配置-host"><a href="#为什么要配置-host" class="headerlink" title="为什么要配置 host"></a>为什么要配置 host</h2><h2 id="如何安装-yuml"><a href="#如何安装-yuml" class="headerlink" title="如何安装 yuml"></a>如何安装 yuml</h2><h2 id="kind-种类有几个？应该用哪个？"><a href="#kind-种类有几个？应该用哪个？" class="headerlink" title="kind 种类有几个？应该用哪个？"></a>kind 种类有几个？应该用哪个？</h2><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><h3 id="爬取博客园标签脚本"><a href="#爬取博客园标签脚本" class="headerlink" title="爬取博客园标签脚本"></a>爬取博客园标签脚本</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var data &#x3D; &quot;&quot;;Array.from(document.getElementsByClassName(&quot;PostList&quot;))  .sort(() &#x3D;&gt; -1)  .forEach((li) &#x3D;&gt; &#123;    let linkdom &#x3D; li.children[0].children[0];    let text &#x3D; linkdom.children[0].innerText;    const lk &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;linkdom.href&#125;&quot; target&#x3D;&quot;_blank&quot; &gt;$&#123;text&#125;&lt;&#x2F;a&gt;\n&#96;;    data +&#x3D; lk;  &#125;);console.log(data);copy(data);</code></pre><img src="http://t-blog-images.aijs.top/img/202211081640635.webp" /><p><a href="https://www.cnblogs.com/jichuang/p/14160829.html" target="_blank" >（一）Kubernetes 概述</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14161119.html" target="_blank" >（二）Kubernetes 组件说明</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14170101.html" target="_blank" >（三）Kubernetes-Pod 概念</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14175528.html" target="_blank" >（四）Kubernetes 网络通讯方式</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14193972.html" target="_blank" >（五）Kubernetes 集群安装</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14349617.html" target="_blank" >（六）Kubernetes 集群安装-配置私有仓库</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14399877.html" target="_blank" >（七）Kubernetes 资源清单</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14519050.html" target="_blank" >（八）Kubernetes 资源清单-探针</a></p><p><a href="https://www.cnblogs.com/jichuang/p/14673748.html" target="_blank" >（九）Kubernetes 资源清单-start、stop、相位</a></p><p><a href="https://www.cnblogs.com/jichuang/p/15843533.html" target="_blank" >（十）Kubernetes-资源控制器-控制器说明</a></p><p><a href="https://www.cnblogs.com/jichuang/p/15880102.html" target="_blank" >（十一）Kubernetes-Service</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><a href="http://t.zoukankan.com/lexiaofei-p-7778360.html" target="_blank" >kubernetes 的主从架构</a></p><h2 id="K8S-文章收录"><a href="#K8S-文章收录" class="headerlink" title="K8S 文章收录"></a>K8S 文章收录</h2><p><strong>此系列文章，是我最近三天看到的最好的文章</strong></p><p><a href=https://juejin.cn/post/6950166816182239246 target="_blank" >1. 《k8s 集群搭建》不要让贫穷扼杀了你学 k8s 的兴趣！</a><br><a href=https://juejin.cn/post/6954904347125743624 target="_blank" >2. 万字警告 - k8s 入门，理应 Pod 先行！</a><br><a href=https://juejin.cn/post/6961209578755194916 target="_blank" >3. 《Kubernetes》- 认识下 Pod 的管理者？</a><br><a href=https://juejin.cn/post/6966031669773991944 target="_blank" >4. 后端学运维- k8s 之数据存储</a><br><a href=https://juejin.cn/post/6970622834317983775 target="_blank" >5. 《Kubernetes》，你需要掌握的 Service 和 Ingress</a></p><p><a href="https://blog.csdn.net/bearstarx/category_9759043.html" target="_blank" >https://blog.csdn.net/bearstarx/category_9759043.html</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104559510" target="_blank">Kubernetes 入门篇(一)：Kubernetes 概述</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104569680" target="_blank">Kubernetes 入门篇(二)：Kubernetes 资源对象</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104845277" target="_blank">Kubernetes 虚拟机搭建 (一) : Master 节点与 Node 节点整体配置</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104849991" target="_blank">Kubenetes 虚拟机搭建 (二) : Master 节点专属配置</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104853610" target="_blank">Kubenetes 虚拟机搭建 (三) : Node 节点注册配置</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104853698" target="_blank">Kubenetes 虚拟机搭建 (四) : Kubernetes-Dashboard 平台部署</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104861228" target="_blank">Kubernetes 入门篇 (三) : kubectl 常用运维命令应用</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104863301" target="_blank">Kubernetes 入门篇 (四) : 通过 yaml 创建资源对象</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104873617" target="_blank">Kubernetes 入门篇 (五) : Pod 生命周期与创建过程</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104874476" target="_blank">Kubernetes 入门篇 (六) : Kubernetes 设计理念</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104876327" target="_blank">Kubernetes 入门篇 (七) : Kubernetes 核心组件与通信端口</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104915170" target="_blank">Kubernetes 核心组件篇 (一) : Kubernetes 核心组件组成</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104917276" target="_blank">Kubernetes 核心组件篇 (二) : 核心组件 Kube-ApiServer</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104922232" target="_blank">Kubernetes 核心组件篇 (三) : 核心组件 Kube-Scheduler</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104927950" target="_blank">Kubernetes 核心组件篇 (四) : 核心组件 Controller Manager</a></p><p><a href="https://blog.csdn.net/BearStarX/article/details/104961245" target="_blank">Kubernetes 核心组件篇 (五) : 核心组件 Kubelet</a></p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Pod 会因为伸缩、更新、故障等情况发生变化，而 Service 会对这些变化进行跟踪。同时 Service 的名字、IP 和端口都不会发生变化。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h2 id="什么是服务发现"><a href="#什么是服务发现" class="headerlink" title="什么是服务发现"></a>什么是服务发现</h2><p>服务发现是指使用一个注册中心来记录分布式系统中的全部服务的信息，以便其他服务能够快速的找到这些已注册的服务。<br><a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/23734240?fr=aladdin" target="_blank" >服务发现</a></p><h2 id="什么是集群选举"><a href="#什么是集群选举" class="headerlink" title="什么是集群选举"></a>什么是集群选举</h2><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>不好理解，单独拎出来</p><p>通常情况下，service 和 pod 的 ip 仅可以在集群内部访问；集群外部的请求需要通过负载均衡转发到 service 在 Node 上暴露的 NodePort 上，然后再由 kube-proxy 通过边缘路由器(edge router)将其转发给相关的 Pod 或者丢弃，而 Ingress 就是为进入集群的请求提供路由规则的集合</p><p>ingress 可以给 service 提供集群外部访问的 url、负载均衡、ssl 终止、http 路由等。为了配置这些 ingress 规则，集群管理员需要部署一个 ingress controller，它监听 ingress 和 service 的变化，根据规则配置负载均衡并提供访问入口<br>————————————————<br>版权声明：本文为 CSDN 博主「devops_sre」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42715225/article/details/109775528">https://blog.csdn.net/weixin_42715225/article/details/109775528</a></p><p><a href="https://www.kubernetes.org.cn/1885.html" target="_blank" >Kubernetes Ingress 解析</a></p><p><a href="https://www.cnblogs.com/xiangxiaolin/p/14872801.html" target="_blank" >k8s——Service 和 Ingress</a></p><p><a href="http://t.zoukankan.com/DjanFey-p-11933665.html" target="_blank" >k8s 学习（六）– 服务发现</a></p><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/jaegertracing/jaeger-ui">https://github.com/jaegertracing/jaeger-ui</a><img src="https://img.shields.io/github/stars/jaegertracing/jaeger-ui?style=social" /></div><h2 id="prometheus-Grafana"><a href="#prometheus-Grafana" class="headerlink" title="prometheus+Grafana"></a>prometheus+Grafana</h2><ul><li>prometheus 以 HTTP 协议周期性抓取被监控组件状态</li><li>Grafana 数据分析和可视化工具</li></ul><p><a href="https://blog.csdn.net/weixin_47415962/article/details/116063342" target="_blank" >k8s 监控 prometheus+Grafana</a></p><p><a href="https://www.cnblogs.com/weihanli/p/14020090.html" target="_blank" >在 k8s 中部署 Prometheus 和 Grafana</a></p><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/prometheus/prometheus">https://github.com/prometheus/prometheus</a><img src="https://img.shields.io/github/stars/prometheus/prometheus?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/grafana/grafana">https://github.com/grafana/grafana</a><img src="https://img.shields.io/github/stars/grafana/grafana?style=social" /></div><h2 id="网课视频"><a href="#网课视频" class="headerlink" title="网课视频"></a>网课视频</h2><h3 id="网课避坑"><a href="#网课避坑" class="headerlink" title="网课避坑"></a>网课避坑</h3><p>有些视频，从头到尾，安装这个，安装那个，从头到尾一直在安装～，真的很“劝退”</p><p>周末两天除了刷视频、文章、吃饭、睡觉，啥事没做，也没搞个明白 😓</p><p>不过也难怪在安装，因为除了 docker 镜像+ yaml 是自定义的，yml 还很模版化（套路一样），其他的主要在整 k8s 集群、权限、日志、监控、数据卷。还有吗？</p><p>好像没了(哈～，跟你没完，还有多呢)。再有估计像 golang 调用 api 实现用户可视化操作，就像公司那套自己定制的一套发布系统</p><h3 id="尚硅谷-k8s"><a href="#尚硅谷-k8s" class="headerlink" title="尚硅谷 k8s"></a>尚硅谷 k8s</h3><p>视频文档有人整理了，爬它</p><p><a href="https://blog.csdn.net/aa18855953229/article/details/108988411" target="_blank">第一课 2020 尚硅谷 K8s 学习-k8s kubeadm 安装</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/106416668" target="_blank">第一课:k8s 介绍安装</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/107345117" target="_blank">第二课:尚硅谷 K8s 学习-k8s 资源清单和 Pod 生命周期</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/107433412" target="_blank">第三课:尚硅谷 K8s 学习-k8s 资源控制器学习</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/108046488" target="_blank">第四课:尚硅谷 K8s 学习-Service 网络学习</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/108046554" target="_blank">第五课:尚硅谷 K8s 学习-存储机制</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/108046590" target="_blank">第六课:尚硅谷 K8s 学习-k8s 资源调度器和安全认证</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/108046619" target="_blank">第七课:尚硅谷 K8s 学习- Prometheus、Grafana 和 EFK、证书年限</a></p><p><a href="https://blog.csdn.net/aa18855953229/article/details/108046650" target="_blank">第八课:尚硅谷 K8s 学习-k8s 集群的高可用</a></p><h2 id="以下为视频内容摘要"><a href="#以下为视频内容摘要" class="headerlink" title="以下为视频内容摘要"></a>以下为视频内容摘要</h2><img src="http://t-blog-images.aijs.top/img/202211051500924.png" style="width: 500px;max-width: 100%;margin-bottom:10px" /><img src="http://t-blog-images.aijs.top/img/202211051501475.png" style="width: 500px;max-width: 100%" /><!-- http://t-blog-images.aijs.top/img/202211061102460.png 删除 --><h2 id="K8S-的内置资源"><a href="#K8S-的内置资源" class="headerlink" title="K8S 的内置资源"></a>K8S 的内置资源</h2><ul><li><p><code>Pod</code>:K8S 最小的调度单元，可以将一组密切关联的容器组成一个逻辑单元，在这个单元里容器之间可以更好的共享资源。</p></li><li><p><code>Deployment</code>:主要用于无状态应用，用来部署多个副本的 Pod,并且在 Pod 出现异常时帮助应用及时恢复正常。</p></li><li><p><code>Statefulset</code>:主要用于有状态应用，可以控制 Pod 的启动顺序，为 Pod 绑定不同的存储等。</p></li><li><p><code>Job/CronJob</code>:用于一次性和周期性的任务。</p></li><li><p><code>Daemonset</code>：通常用来部署后台常驻任务，会在每台 Vorker 节点启</p></li><li><p><code>Service</code>:应用的访问入口，通过 selector 选择具有指定 labelf 的 Pod,为其提供服务发现和负载均衡的功能，每个 Service 都可以通过 CoreDNS 获取到其对应的 IP。</p></li><li><p><code>Ingress</code>:提供 K8S 集群外部访问应用。</p></li><li><p><code>Configmap</code>、Secret:描述应用的配置和密钥等数据。</p></li><li><p><code>PV、PVC、HostPath、EmptyDir</code>:描述应用的各类存储。</p></li></ul><p>控制器逻辑</p><ul><li><code>观察</code>：通过监控 kubernetes 资源对象变化的事件来获取当前对象状态，我们只需要注入 EventHandler 让 client-go 将变化的事件对象信息放入 WorkQueue 中。</li><li><code>分析</code>：确定当前状态和期望状态的不同，由 Vorker 完成。</li><li><code>执行</code>：执行能够驱动对象当前状态变化的操作，由 Worker 完成。</li><li><code>更新</code>：更新对象的当前状态，由 Vorker 完成。</li></ul><p>Client 类型</p><ul><li><code>RESTClient</code>：最基础的客户端，提供最基本的封装</li><li><code>Clientset</code>:是一个 Client 的集合，在 Clientset 中包含了所有 K8S 内置资源的 Client,通过 Clientset 便可以很方便的操作如 Pod、Service 这些资源</li><li><code>dynamicclient</code> 动态客户端，可以操作任意 K8S 的资源，包括 CRD 定义的资源</li><li><code>DiscoveryClient</code>：用于发现 K8S 提供的资源组、资源版本和资源信息，比如：kubectl api-resources</li></ul><p><a href="https://github.com/BackendDoc/kubernetes" target="_blank" >使用一条命令创建 k8s 单机集群，低配置的电脑也可以运行 k8s 集群</a></p><p>基础概念: 什么是 Pod 控制器类型 K8S 网络通迅模式<br>k8s: 构建 K8S 集群<br>资源清单：资源 资源清单的语法 编写 Pod Pod 的生命周期<br>Pod 控制器：各种控制器的特点以及使用定义方式<br>服务发现：SVC 原理及其构建方式</p><p>存储：黨握多种存储类型的特点 并且能够在不同环境中选择合适的存储方案（有自己的简众）<br>调度器：黨握调度器原理 能够根据要求把 Pod 定义到想要的范点运行</p><p>安全：集群的认证 鉴权 访问控制原理及其流程<br>HELM: linux yum 黨握 HELM 原理 HELM 模板自定义 HELM 部署一些常用插件</p><p>运维：修改 Kubeadm 达到证书可用期限为 10 年 能够构建高可用的 Kubernet 集群</p><p>高可用集群副节点数据最好是&gt;&#x3D;3 奇数个</p><ul><li><code>APISERVER</code>:所有服务访问统一入口</li><li><code>CrontrollerManager</code>:维待副本期望数目</li><li><code>Scheduler</code>:负责介绍任务选择合适的节点进行分配任务</li><li><code>ETCD</code>:键值对数据库储存 K8S 集群所有重要信息（持久化）</li><li><code>kubelet</code>:直接跟容器引擎交互实现容器的生命周期管理</li><li><code>Kube-proxy</code>:负责写入规则至 IPTABLES、IPVS 实现服务映射访问的</li><li><code>COREDNS</code>:可以为集群中的 SVC 创建一个域名 IP 的对应关系解析</li><li><code>DASHBOARD</code>:给 K8S 集群提供个 B&#x2F;S 结构访间体系</li><li><code>INGRESS CONTROLLER</code>:官方只能实现四层代理，INGRESS 可以实现七层代理</li><li><code>FEDERATION</code>:提供一个可以跨集群中心多 K8S 统一管理功能</li><li><code>PROMETHEUS</code>:提供 K8S 集群的监控能力</li><li><code>ELK</code>:提供 K8S 集群只志统一分析介入平台</li></ul><h3 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h3><p><code>ReplicationController</code> 用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收。</p><p>在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationControlle</p><p><code>ReplicaSet</code> 跟 ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector。虽然 ReplicaSet 可以独立使用，但一般还是建议使用 Deployment 来自动管理 ReplicaSet,这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持 rolling-update 但 Deployment 支持)</p><p><code>Horizontal Pod Autoscaling</code> 仅适用于 Deployment 和 ReplicaSet,在 V1 版本中仅支持根据 Pod 的 CPU 利用率扩所容，在 vlalpha 版本中，支持根据内存和用户自定义的 metric 扩缩容</p><p><code>StatefulSet</code> 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计)，其应用场景包括：</p><ul><li>稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现</li><li>稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service(即没有 Cluster IP 的 Service)来实现</li><li>有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从 0 到 N-l,在下一个 Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现</li><li>有序收缩，有序删除（即从 N-1 到 0）</li></ul><p><code>DaemonSet</code> 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod<br>使用 DaemonSet 的一些典型用法：</p><ul><li>运行集群存储 daemon,例如在每个 Node 上运行 glusterd、ceph。</li><li>在每个 Node 上运行日志收集 daemon,例如 fluentd、logstash。</li><li>在每个 Node 上运行监控 daemon,例如 Prometheus Node Exporter</li></ul><p><code>Job</code> 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束<br><code>Cron Job</code> 管理基于时间的 Job,即：</p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p>网络通信</p><p>Kubernetes 的网络模型假定了所有 Pod 都在一个可以直接连通的扁平的网络空间中，这在 GCE(Google Compute Engine)里面是现成的网络模型，Kubernetes 假定这个网络己经存在。而在私有云里搭建 Kubernetes 集群，就不能假定这个网络已经存在了。我们需要自己实现这个网络假设，将不同节点上的 Docker 容器之间的互相访问先打通，然后运行 Kubernetes</p><ul><li>同一个 Pod 内的多个容器之间：IO</li><li>各 Pod 之间的通讯：Overlay Network</li><li>Pod 与 Service 之间的通讯：各节点的 Iptables 规则</li></ul><img src="http://t-blog-images.aijs.top/img/202211061313394.png" style="width: 800px;max-width: 100%;margin-bottom:10px" /><img src="http://t-blog-images.aijs.top/img/202211061315365.png" style="width: 800px;max-width: 100%;margin-bottom:10px"/><h2 id="什么是-4-层负载"><a href="#什么是-4-层负载" class="headerlink" title="什么是 4 层负载"></a>什么是 4 层负载</h2><img src="http://t-blog-images.aijs.top/img/202211081135414.webp" style="width: 500px;max-width: 100%;" /><ul><li>四层负载均衡工作在 OSI 模型的传输层，由于在传输层，只有 TCP&#x2F;UDP 协议，这两种协议中除了包含源 IP、目标 IP 以外，还包含源端口号及目的端口号。</li><li>四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器</li></ul><h2 id="什么是-7-层负载"><a href="#什么是-7-层负载" class="headerlink" title="什么是 7 层负载"></a>什么是 7 层负载</h2><ul><li>七层负载均衡工作在 OSI 模型的应用层，应用层协议较多，常用 http、radius、dns 等。</li><li>七层负载就可以基于这些协议来负载。</li><li>这些应用层协议中会包含很多有意义的内容。比如同一个 Web 服务器的负载均衡，除了根据 IP 加端口进行负载外，还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。</li></ul><h2 id="4-层-x2F-7-层负载关系"><a href="#4-层-x2F-7-层负载关系" class="headerlink" title="4 层&#x2F;7 层负载关系"></a>4 层&#x2F;7 层负载关系</h2><ul><li><code>四层即传输层</code>，就是基于 IP + 端口的负载均衡；</li><li><code>七层即应用层</code>，就是基于 URL 等应用层信息的负载均衡；</li></ul><p><a href="https://www.cnblogs.com/psy-sdudio/p/15872083.html" target="_blank" >四层、七层负载均衡的区别 </a></p><h2 id="蓝绿发布、金丝雀发布、灰度发布、滚动发布、A-x2F-B-测试"><a href="#蓝绿发布、金丝雀发布、灰度发布、滚动发布、A-x2F-B-测试" class="headerlink" title="蓝绿发布、金丝雀发布、灰度发布、滚动发布、A&#x2F;B 测试"></a>蓝绿发布、金丝雀发布、灰度发布、滚动发布、A&#x2F;B 测试</h2><ul><li><code>蓝绿发布</code>： 绿的为线上，蓝的为线上测试版本</li><li><code>金丝雀发布(灰度发布)</code>：灰度，对部分用户可见，使用 7 层代理的内容进行流量控制</li><li><code>滚动发布</code>：单个 pod 逐步替换的过程，保证了可用性</li><li><code>A/B 测试</code>：多个版本放到线上，观察哪了用户体验更好</li></ul><p><a href="https://passport.csdn.net/account/autologin?from=https://blog.csdn.net/QiuHaoqian/article/details/121733254" target="_blank" >蓝绿发布、滚动发布、灰度发布，有什么区别？</a></p><p><a href="https://blog.csdn.net/agonie201218/article/details/122218450" target="_blank" >k8s 使用 Nginx Ingress 实现灰度发布和蓝绿发布</a></p><h2 id="以下为微服务相关东西"><a href="#以下为微服务相关东西" class="headerlink" title="以下为微服务相关东西"></a>以下为微服务相关东西</h2><h2 id="sidecar-是什么"><a href="#sidecar-是什么" class="headerlink" title="sidecar 是什么"></a>sidecar 是什么</h2><h2 id="什么是服务治理"><a href="#什么是服务治理" class="headerlink" title="什么是服务治理"></a>什么是服务治理</h2><h2 id="istio-与服务治理有什么关系"><a href="#istio-与服务治理有什么关系" class="headerlink" title="istio 与服务治理有什么关系"></a>istio 与服务治理有什么关系</h2><ul><li>service mesh 服务网格</li><li>istio 就是我们上述提到的 service mesh 架构的一种实现</li><li>istio 就是为了解决微服务的这些问题才出现的</li></ul><p><strong>istio 解决的问题</strong></p><table><thead><tr><th align="left">微服务存在的问题</th><th align="left">istio 处理措施</th></tr></thead><tbody><tr><td align="left">故障排查</td><td align="left">Traffic Management</td></tr><tr><td align="left">应用容错</td><td align="left">Observability</td></tr><tr><td align="left">发布升级</td><td align="left">Policy Enforcement</td></tr><tr><td align="left">系统安全</td><td align="left">Service Identity an Security</td></tr></tbody></table><!-- <img src="http://t-blog-images.aijs.top/img/202211081402963.webp" /> --><p>服务之间的通信（比如这里的 Service A 访问 Service B）会通过代理（默认是 <code>envoy</code>）来进行，而且中间的网络协议支持 HTTP&#x2F;1.1，HTTP&#x2F;2，gRPC 或者 TCP，可以说覆盖了主流的通信协议。控制中心做了进一步的细分，分成了 Pilot、Mixer、和 Citadel，它们的各自功能如下：</p><ul><li><p><code>Pilot</code>：为 <code>envoy</code> 提供了服务发现，流量管理和智能路由（AB 测试、金丝雀发布等），以及错误处理（超时、重试、熔断）功能。用户通过 pilot 的 API 管理网络相关的资源对象，pilot 会根据用户的配置和服务的信息把网络流量管理变成 envoy 能识别的格式分发到各个 sidecar 代理中。</p></li><li><p><code>Mixer</code>：为整个集群执行访问控制（哪些用户可以访问哪些服务）和 policy 管理（rate limit，quota 等），并且收集代理观察到的服务之间的流量统计数据</p></li><li><p><code>Citadel</code>：为服务之间提供认证和证书管理，可以让服务自动升级成 TLS 协议</p></li></ul><p>————————————————<br>版权声明：本文为 CSDN 博主「Dark<em>Ice</em>」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_40274679/article/details/106232119">https://blog.csdn.net/weixin_40274679/article/details/106232119</a></p><p><a href="https://blog.csdn.net/weixin_40274679/article/details/106232119" target="_blank" >Istio 是啥？一文带你彻底了解</a></p><p><a href="https://blog.csdn.net/qq_42046105/article/details/112791356" target="_blank" >Istio 架构原理</a></p><h2 id="Ingress-与-istio-有很多重合的功能-两者有什么区别"><a href="#Ingress-与-istio-有很多重合的功能-两者有什么区别" class="headerlink" title="Ingress 与 istio 有很多重合的功能,两者有什么区别"></a>Ingress 与 istio 有很多重合的功能,两者有什么区别</h2><p>Service Mesh 的出现，弥补了 Kubernetes 在微服务的连接、管理和监控方面的短板，为 Kubernetes 提供更好的应用和服务管理。因此，Service Mesh 的代表 Istio 一经推出，就被认为是可以和 Kubernetes 形成双剑合璧效果的微服务管理的利器，受到了业界的推崇。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Istio 与 Kubernetes 极为互补。“K8S 实际上只是负责基本的调度和编排，负责主机上容器的运行，Istio 做的是互补，因为它主要做的是服务发现。当用容器来实现不同的服务时，需要发现服务、动态连接服务、进行服务升级，甚至还会产生一些安全性、可靠性、性能方面的功能需求，实际上这些功能都是 K8S 原生没有或者要用手动的方法才能实现的。Istio 就是一个可以在 K8S 上，把这些应用、服务进行较好管理的框架。</p></blockquote><p>这篇文章之后的内容，看上去像是在打广告～，不看也罢<br>————————————————<br>版权声明：本文为 CSDN 博主「科技峰行者」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sunhf_csdn/article/details/84257923">https://blog.csdn.net/sunhf_csdn/article/details/84257923</a></p><h2 id="什么是流量控制，什么是熔断"><a href="#什么是流量控制，什么是熔断" class="headerlink" title="什么是流量控制，什么是熔断"></a>什么是流量控制，什么是熔断</h2><h2 id="可能的需求"><a href="#可能的需求" class="headerlink" title="可能的需求"></a>可能的需求</h2><ul><li>部署软件</li><li>扩缩容</li><li>可视化监控</li><li>灰度</li><li>回滚</li><li>高并发</li><li>高可用</li></ul><h2 id="Configmap"><a href="#Configmap" class="headerlink" title="Configmap"></a>Configmap</h2><p>configMap 描述信息<br>ConfigMap 功能在 Kubernetes1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取<br>配置信息。ConfigMap API 给我们提供了向容器中注入配置信息的机制，ConfigMap 可以被用来保存单个属<br>性，也可以用来保存整个配置文件或者 JSON 二进制大对象</p><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p><strong>Secret 解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod<br>Spec 中。Secret 可以以 Volume 或者环境变量的方式使用</strong></p><h2 id="k8s-API-调用"><a href="#k8s-API-调用" class="headerlink" title="k8s API 调用"></a>k8s API 调用</h2><p>哈～，顿悟了，用这些 API 就能实现 devops 平台开发了</p><p><a href="https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#get-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84-pod" target="_blank" >Pod</a></p><h2 id="CNCF-毕业项目"><a href="#CNCF-毕业项目" class="headerlink" title="CNCF 毕业项目"></a>CNCF 毕业项目</h2><p>项目毕业意味着，这项技术已经展现出强劲的采用率势头，开放的治理流程，以及对社区，可持续性和包容性的承诺</p><p><a href="https://copyfuture.com/blogs-details/20190911225926796t02nyyadtqaou0v" target="_blank" >见</a></p><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>开源容器编排系统，主要应用与自动化容器化应用程序的部署、扩展和管理。它已经是事实上的容器编排标准。</p><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>一套开源系统监控&amp;报警&amp;时间序列数据库工具包</p><h3 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h3><p>被广泛采用的开源网络代理，被设计为云原生应用程序的第 7 层边缘和服务代理</p><h3 id="CoreDNS"><a href="#CoreDNS" class="headerlink" title="CoreDNS"></a>CoreDNS</h3><p>CoreDNS 是 DNS 服务器解决方案，它既能作为独立的 DNS 服务器，也作为 Kubernetes 的默认向前的 DNS 服务器</p><h3 id="Containerd"><a href="#Containerd" class="headerlink" title="Containerd"></a>Containerd</h3><p>Docker 引擎的底层运行时（runtime）管理器。目前，Containerd 作为业界标准的容器运行时被广泛采用。</p><h3 id="Fluentd"><a href="#Fluentd" class="headerlink" title="Fluentd"></a>Fluentd</h3><p>用于统一日志记录层的数据收集器，它会将数据源与后端系统分离</p><h3 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h3><p>Jaeger 作为端到端的分布式跟踪平台，帮助企业监控云原生架构并进行故障排除</p><h3 id="Vitess"><a href="#Vitess" class="headerlink" title="Vitess"></a>Vitess</h3><p>Vitess 是用于 MySQL 水平扩展的数据库集群系统</p><h3 id="Helm（中文）"><a href="#Helm（中文）" class="headerlink" title="Helm（中文）"></a>Helm（中文）</h3><p><strong>掌舵</strong></p><p><a href="https://helm.sh/zh/" target="_blank" >https://helm.sh/zh/</a></p><p>Helm 帮助您管理 Kubernetes 应用—— Helm Chart，即使是最复杂的 Kubernetes 应用程序，都可以帮助您定义，安装和升级。</p><p>Helm Chart 易于创建、发版、分享和发布，所以停止复制粘贴，开始使用 Helm 吧。</p><p>Helm 是 CNCF 的毕业项目，由 Helm 社区维护。</p><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><p>Harbor 是个开源制品（artifact）仓库，是首个原创于中国、并且成为 CNCF 毕业级的开源项目。用户可通过策略和基于角色的访问控制来保护制品（如容器镜像、Helm Chart 等），扫描镜像并避免受安全漏洞的危害。Harbor 扩展了开源项目 Docker Distribution，添加了用户所需的功能（例如安全性，身份，漏洞扫描和管理）。在环境中部署 Harbor 可以提高镜像传输效率，便于就近构建和运行容器应用。Harbor 支持在制品仓库之间复制镜像、Chart 等制品，并提供高级安全功能，例如用户管理、访问控制和操作审计等。</p><p><a href="https://www.sohu.com/na/403995544_609552" target="_blank" >首个中国原创项目 Harbor 毕业 </a></p><p><a href="https://goharbor.io/" target="_blank" >https://goharbor.io/</a></p><h3 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h3><p>一款可靠的分布式配置管理中心，诞生于携程框架研发部，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景<br><a href="https://www.apolloconfig.com/#/zh/README?id=screenshots" target="_blank" >见</a></p><h2 id="Helm-可以使用-Harbor-仓库？"><a href="#Helm-可以使用-Harbor-仓库？" class="headerlink" title="Helm 可以使用 Harbor 仓库？"></a>Helm 可以使用 Harbor 仓库？</h2><h2 id="什么是-EFK"><a href="#什么是-EFK" class="headerlink" title="什么是 EFK"></a>什么是 EFK</h2><p>EFK 组件： Elasticsearch (分布式集群搜索) Fluentd (日志收集转发) Kibana (面板操作查询)</p><p><strong>日志收集：</strong>Elasticsearch 是分析引擎，Kibana 是可视化面板，前面这两个是一伙的，Fluentd 是收集日志的</p><p><strong>监控：</strong> Prometheus 和 Grafana</p><p><a href="https://www.cnblogs.com/wenyang321/p/14111483.html" target="_blank" >第四篇 kubernetes 部署 EFK 日志平台</a></p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="http://docs.kubernetes.org.cn/" target="_blank" >Kubernetes 中文社区 | 中文文档</a></p><p><a href="https://kubernetes.io/zh-cn/docs/concepts/" target="_blank" >官网</a></p><p><strong>选择性消化官方文档，从自己感兴趣的部分开始</strong></p><p><a href="https://github.com/guangzhengli/k8s-tutorials" target="_blank" >https://github.com/guangzhengli/k8s-tutorials</a></p><h2 id="在线-k8s-集群"><a href="#在线-k8s-集群" class="headerlink" title="在线 k8s 集群"></a>在线 k8s 集群</h2><p>no 马内，也可以玩</p><p>Play with Kubernetes<br>A simple, interactive and fun playground to learn Kubernetes</p><p><a href="https://labs.play-with-k8s.com/" target="_blank" >https://labs.play-with-k8s.com</a></p><p><strong>有效时间 4 小时</strong><br><img src="http://t-blog-images.aijs.top/img/202211091738969.webp" style="width:500px;max-width:100%" /></p><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p><a href="https://www.zhaowenyu.com/etcd-doc/" target="_blank" >https://www.zhaowenyu.com/etcd-doc/</a></p><h2 id="etcd-在-k8s-中存储哪些信息"><a href="#etcd-在-k8s-中存储哪些信息" class="headerlink" title="etcd 在 k8s 中存储哪些信息"></a>etcd 在 k8s 中存储哪些信息</h2><h2 id="k8s-术语"><a href="#k8s-术语" class="headerlink" title="k8s 术语"></a>k8s 术语</h2><p><a href="https://www.zhaowenyu.com/etcd-doc/" target="_blank" >https://www.zhaowenyu.com/etcd-doc/</a></p><h2 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h2><p><a href="https://kubernetes.github.io/ingress-nginx/" target="_blank" >https://kubernetes.github.io/ingress-nginx/</a></p><h2 id="linux-系统根目录各文件夹的作用"><a href="#linux-系统根目录各文件夹的作用" class="headerlink" title="linux 系统根目录各文件夹的作用"></a>linux 系统根目录各文件夹的作用</h2><h2 id="tgz-格式解压"><a href="#tgz-格式解压" class="headerlink" title="tgz 格式解压"></a>tgz 格式解压</h2><h2 id="docker-load-i-xx-tar"><a href="#docker-load-i-xx-tar" class="headerlink" title="docker load i xx.tar"></a>docker load i xx.tar</h2><h2 id="k8s-探针"><a href="#k8s-探针" class="headerlink" title="k8s 探针"></a>k8s 探针</h2><ul><li>存活探针 希望容器在探测失败时被杀死并重新启动</li><li>就绪探针 区分已经失败的应用和仍在处理其启动数据的应用</li><li>启动探针 容器需要在启动期间加载大型数据、配置文件或执行迁移</li></ul><h2 id="认证-x2F-鉴权-x2F-准入控制"><a href="#认证-x2F-鉴权-x2F-准入控制" class="headerlink" title="认证&#x2F;鉴权&#x2F;准入控制"></a>认证&#x2F;鉴权&#x2F;准入控制</h2><ul><li>Authentication 认证</li><li>Authorization 鉴权</li><li>Admission Control 准入控制</li></ul><h2 id="drone"><a href="#drone" class="headerlink" title="drone"></a>drone</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/jenkinsci/jenkins">https://github.com/jenkinsci/jenkins</a><img src="https://img.shields.io/github/stars/jenkinsci/jenkins?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/harness/drone">https://github.com/harness/drone</a><img src="https://img.shields.io/github/stars/harness/drone?style=social" /></div><p>drone 官网底部 github 链接 跳转 Drone by Harness。找到了 drone-ui 和 drone-go 仓库，star 数 200 多，我怀疑整个世界了。 在 github 上搜 drone 找到了，star 数超过 jenkins，这就正常，此项目在 Harness 下</p><p>嗯 我们公司用 drone</p><p>Drone makes advanced customization easy. <code>Implement custom access controls</code>,<code>approval workflows</code>, secret management, yaml syntax extensions and more.</p><p>没找到中文文档</p><p><a href="https://www.drone.io/" target="_blank" >https://www.drone.io/</a></p><p><a href="https://docs.drone.io/pipeline/docker/examples/languages/node/" target="_blank" >官方文档</a></p><p><a href="http://t.zoukankan.com/rongfengliang-p-8982143.html" target="_blank" >drone 学习一 几个核心组件</a></p><h2 id="drone-插件开发"><a href="#drone-插件开发" class="headerlink" title="drone 插件开发"></a>drone 插件开发</h2><p><a href="https://www.jianshu.com/p/478c4524a1ce" target="_blank" >https://www.jianshu.com/p/478c4524a1ce</a></p><h2 id="jsonnet"><a href="#jsonnet" class="headerlink" title="jsonnet"></a>jsonnet</h2><ul><li>Jsonnet - json 数据模板语言</li></ul><p><a href="https://juejin.cn/post/6988819621956550669" target="_blank" >https://juejin.cn/post/6988819621956550669</a></p><p><strong>注：这篇文章里有个 Shuttle 工具，看上去很酷</strong></p><h2 id="k8s-drone"><a href="#k8s-drone" class="headerlink" title="k8s drone"></a>k8s drone</h2><h2 id="node-x2F-clone-日志"><a href="#node-x2F-clone-日志" class="headerlink" title="node&#x2F;clone 日志"></a>node&#x2F;clone 日志</h2><pre class="line-numbers language-none"><code class="language-none">Cloning with 5 retriesInitialized empty Git repository in &#x2F;code&#x2F;.git&#x2F;+ git fetch origin +refs&#x2F;heads&#x2F;hotfix&#x2F;1.4-part-solve:From https:&#x2F;&#x2F;registry.code.yy.top&#x2F;fe-efficacy&#x2F;socrates-admin* branch            hotfix&#x2F;1.4-part-solve -&gt; FETCH_HEAD* [new branch]      hotfix&#x2F;1.4-part-solve -&gt; origin&#x2F;hotfix&#x2F;1.4-part-solve+ git checkout 67deb4c0d6a8217f86f4564f33ed1545ddac1a6a -b hotfix&#x2F;1.4-part-solveSwitched to a new branch &#39;hotfix&#x2F;1.4-part-solve&#39;+ git submodule update --init --recursive</code></pre><h2 id="drone-自定义插件注入流水线中"><a href="#drone-自定义插件注入流水线中" class="headerlink" title="drone 自定义插件注入流水线中"></a>drone 自定义插件注入流水线中</h2><h2 id="服务器之间免登"><a href="#服务器之间免登" class="headerlink" title="服务器之间免登"></a>服务器之间免登</h2><p><a href="https://www.jianshu.com/p/92925df93626" target="_blank" >Linux——配置服务器间的免密登录</a></p><p><a href="https://zhuanlan.zhihu.com/p/36981600" target="_blank" >SSH 配置—Linux 下实现免密码登录</a></p><h2 id="Node-节点注册配置"><a href="#Node-节点注册配置" class="headerlink" title="Node 节点注册配置"></a>Node 节点注册配置</h2><p><a href="https://blog.csdn.net/BearStarX/article/details/104853610/" target="_blank" >Node 节点注册配置</a></p><h2 id="k8s-集群准备"><a href="#k8s-集群准备" class="headerlink" title="k8s 集群准备"></a>k8s 集群准备</h2><ol><li>看了下，阿里云按小时算，一个月也要点钱</li><li>自己电脑 16G 的内存 i5 配置，搞个 1+2 集群应该也还行吧</li></ol><p><a href="https://blog.csdn.net/tiny_du/article/details/123823093" target="_blank" >部署 k8s 集群（k8s 集群搭建详细实践版）</a></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p><a href="https://blog.csdn.net/bearstarx/category_9701585.html" target="_blank" >见</a></p><h2 id="云服务器是如何将内网暴露到外网的？"><a href="#云服务器是如何将内网暴露到外网的？" class="headerlink" title="云服务器是如何将内网暴露到外网的？"></a>云服务器是如何将内网暴露到外网的？</h2><p>如果我有一组台式机，是不是可以实现云服务器的效果</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 命令及分区</title>
      <link href="//post/2022-11-04redis.html"/>
      <url>//post/2022-11-04redis.html</url>
      
        <content type="html"><![CDATA[<h2 id="爬取脚本"><a href="#爬取脚本" class="headerlink" title="爬取脚本"></a>爬取脚本</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var data &#x3D; &quot;&quot;;Array.from(  document.getElementsByClassName(&quot;left&quot;)[0].children[1].children).forEach((li) &#x3D;&gt; &#123;  var a &#x3D; li.children[0];  data +&#x3D; &#96;\&#96;$&#123;a.innerText&#125;\&#96;: \n&#96;.replace(&quot;Redis &quot;, &quot;&quot;).replace(&quot; 命令&quot;, &quot;&quot;);&#125;);copy(data);</code></pre><h2 id="最最基本"><a href="#最最基本" class="headerlink" title="最最基本"></a>最最基本</h2><ul><li>redis 是数据库，具备增删改查</li><li>redis 数据“分类型储存”，命令进行类型操作</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>懒得安装了，直接用在线的吧 <a href="https://try.redis.io/" target="_blank" >https://try.redis.io/</a></p><h2 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h2><h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><ul><li><code>Incr</code>:</li><li><code>Incrby</code>:</li><li><code>Incrbyfloat</code>:</li></ul><h3 id="减"><a href="#减" class="headerlink" title="减"></a>减</h3><ul><li><code>Decr</code>:</li><li><code>Decrby</code>:</li></ul><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul><li><code>SET</code>: 设置指定 key 的值 <code>SET KEY_NAME VALUE</code></li><li><code>Mset</code>: 同时设置一个或多个 key-value 对 <code>MSET key1 value1 key2 value2 .. keyN valueN</code></li><li><code>Setnx</code>: 只有在 key 不存在时设置 key 的值 <code>SETNX KEY_NAME VALUE</code></li><li><code>Msetnx</code>: 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在 <code>MSETNX key1 value1 key2 value2 .. keyN valueN</code></li><li><code>Setex</code>: 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) <code>SETEX KEY_NAME TIMEOUT VALUE</code></li><li><code>Setbit</code>: 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit) <code>Setbit KEY_NAME OFFSET</code> <a href="https://blog.csdn.net/qq_18433441/article/details/79650406" target="_blank" >对 redis 中 setbit 命令的理解</a></li><li><code>Setrange</code>: 从偏移量 offset 开始,用 value 参数覆写给定 key 所储存的字符串值 <code>SETRANGE KEY_NAME OFFSET VALUE</code></li><li><code>Psetex</code>: 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位<code>PSETEX key1 EXPIRY_IN_MILLISECONDS value1 </code></li></ul><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul><li><code>Getrange</code>: 返回 key 中字符串值的子字符 <code>GETRANGE KEY_NAME start end</code></li><li><code>Get</code>: 获取指定 key 的值 <code>GET KEY_NAME</code></li><li><code>Getbit</code>: 对 key 所储存的字符串值，获取指定偏移量上的位(bit) <code>GETBIT KEY_NAME OFFSET</code></li><li><code>Getset</code>: 将给定 key 的值设为 value ，并返回 key 的旧值(old value) <code>GETSET KEY_NAME VALUE</code></li><li><code>Mget</code>: 获取所有(一个或多个)给定 key 的值 <code>MGET KEY1 KEY2 .. KEYN</code></li><li><code>Strlen</code>: 返回 key 所储存的字符串值的长度 <code>STRLEN KEY_NAME</code></li><li><code>Append</code>: 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾,不存在新增 <code>APPEND KEY_NAME NEW_VALUE</code></li></ul><h2 id="Hash-对象存储"><a href="#Hash-对象存储" class="headerlink" title="Hash 对象存储"></a>Hash 对象存储</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>对象存储，对象的 k-v 编辑</p><h3 id="Hash-增"><a href="#Hash-增" class="headerlink" title="Hash 增"></a>Hash 增</h3><ul><li><code>Hmset</code>: 同时将多个 field-value (域-值)对设置到哈希表 key 中 <code>HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN</code></li><li><code>Hmget</code>: 获取所有给定字段的值 <code>HMGET KEY_NAME FIELD1...FIELDN</code></li><li><code>Hset</code>: 将哈希表 key 中的字段 field 的值设为 value <code>HSET KEY_NAME FIELD VALUE </code></li><li><code>Hsetnx</code>: 只有在字段 field 不存在时，设置哈希表字段的值。<code>HSETNX KEY_NAME FIELD VALUE</code></li></ul><h3 id="Hash-删"><a href="#Hash-删" class="headerlink" title="Hash 删"></a>Hash 删</h3><ul><li><code>Hdel</code>: 删除一个或多个哈希表字段 <code>HDEL KEY_NAME FIELD1.. FIELDN </code></li></ul><h3 id="Hash-改"><a href="#Hash-改" class="headerlink" title="Hash 改"></a>Hash 改</h3><ul><li><code>Hincrbyfloat</code>: Redis Hincrbyfloat 命令 - 为哈希表 key 中的指定字段的浮点数值加上增量 increment <code>HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER </code></li><li><code>Hincrby</code>: 为哈希表 key 中的指定字段的整数值加上增量 increment <code>HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER</code></li></ul><h3 id="Hash-查"><a href="#Hash-查" class="headerlink" title="Hash 查"></a>Hash 查</h3><ul><li><code>Hget</code>: 获取存储在哈希表中指定字段的值 <code>HGET KEY_NAME FIELD_NAME</code></li><li><code>Hgetall</code>: 获取在哈希表中指定 key 的所有字段和值 <code>HGETALL KEY_NAME </code></li><li><code>Hkeys</code>: 获取所有哈希表中的字段 <code>HKEYS KEY_NAME</code></li><li><code>Hvals</code>: 获取哈希表中所有值 <code>HVALS KEY_NAME FIELD VALUE </code></li><li><code>Hexists</code>: 查看哈希表 key 中，指定的字段是否存在 <code>HEXISTS KEY_NAME FIELD_NAME</code></li><li><code>Hlen</code>: 获取哈希表中字段的数量 <code>HLEN KEY_NAME</code></li></ul><h2 id="LIST-列表存储"><a href="#LIST-列表存储" class="headerlink" title="LIST 列表存储"></a>LIST 列表存储</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>有点像数组的增删“改”查，没看到有改的方法</p><h3 id="LIST-增"><a href="#LIST-增" class="headerlink" title="LIST 增"></a>LIST 增</h3><ul><li><code>Lset</code>: 通过索引设置列表元素的值 <code>LSET KEY_NAME INDEX VALUE</code></li><li><code>Linsert</code>: 在列表的元素前或者后插入元素 <code>LINSERT KEY_NAME BEFORE EXISTING_VALUE NEW_VALUE </code></li><li><code>Lpushx</code>: 将一个或多个值插入到已存在的列表头部 <code>LPUSHX KEY_NAME VALUE1.. VALUEN</code></li><li><code>Rpushx</code>: 为已存在的列表添加值 <code>RPUSHX KEY_NAME VALUE1..VALUEN</code></li><li><code>Lpush</code>:在列表头部添加一个或多个值 <code>LPUSH KEY_NAME VALUE1.. VALUEN</code></li><li><code>Rpush</code>: 在列表尾部添加一个或多个值 <code>RPUSH KEY_NAME VALUE1..VALUEN</code></li></ul><h3 id="LIST-删"><a href="#LIST-删" class="headerlink" title="LIST 删"></a>LIST 删</h3><ul><li><code>Lrem</code>: 移除列表元素 <code>LREM KEY_NAME COUNT VALUE</code></li><li><code>Ltrim</code>: 只保留指定区间内的元素 <code>LTRIM KEY_NAME START STOP</code></li><li><code>Rpoplpush</code>: 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 <code>RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME</code></li><li><code>Brpoplpush</code>: 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；</li><li><code>BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT </code></li><li><code>Blpop</code>: 移出并获取列表的第一个元素 <code>BLPOP LIST1 LIST2 .. LISTN TIMEOUT</code></li><li><code>Brpop</code>: 移出并获取列表的最后一个元素 <code>BRPOP LIST1 LIST2 .. LISTN TIMEOUT </code></li><li><code>Lpop</code>: 移出并获取列表的第一个元素 <code>LPOP KEY_NAME</code></li><li><code>Rpop</code>: 移除并获取列表最后一个元素 <code>RPOP KEY_NAME</code></li></ul><p><strong>注意：带有 <code>TIMEOUT</code> 的命令。如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li>清空列表 <code>ltrim key start end</code> 中的 start 要比 end 大即可，数值且都为正数。如：<code>ltrim key 1 0</code></li></ul><h3 id="LIST-改"><a href="#LIST-改" class="headerlink" title="LIST 改"></a>LIST 改</h3><h3 id="LIST-查"><a href="#LIST-查" class="headerlink" title="LIST 查"></a>LIST 查</h3><p>Lindex 命令 通过索引获取列表中的元素 <code>LINDEX KEY_NAME INDEX_POSITION</code><br>Lrange 命令 获取列表指定范围内的元素 <code>LRANGE KEY_NAME START END</code><br>Llen 命令 获取列表长度 <code>LLEN KEY_NAME </code></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><ul><li><code>Sadd</code>: 向集合添加一个或多个成员 <code>SADD KEY_NAME VALUE1..VALUEN</code></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul><li><code>Srem</code>: 移除集合中一个或多个成员 <code>SREM KEY MEMBER1..MEMBERN</code></li><li><code>Spop</code>: 移除并返回集合中的一个随机元素 <code>SPOP KEY</code></li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul><li><code>Smove</code>: 将 member 元素从 source 集合移动到 destination 集合 <code>SMOVE SOURCE DESTINATION MEMBER</code></li></ul><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><ul><li><code>Smembers</code>: 返回集合中的所有成员 <code>SMEMBERS KEY VALUE </code></li><li><code>Scard</code>: 获取集合的成员数 <code>SCARD KEY_NAME</code> <span style="color: red">你用个 scount 也比 scard 好啊</span></li><li><code>Sscan</code>: 迭代集合中的元素 <code>SSCAN KEY [MATCH pattern] [COUNT count]</code> <strong>没看懂</strong></li><li><code>Srandmember</code>: 返回集合中一个或多个随机数 <code>SRANDMEMBER KEY [count]</code></li><li><code>Sismember</code>: 判断 member 元素是否是集合 key 的成员 <code>SISMEMBER KEY VALUE</code></li></ul><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><ul><li><code>Sinter</code>: 返回给定所有集合的交集 <code>SINTER KEY KEY1..KEYN </code></li><li><code>Sinterstore</code>: 返回给定所有集合的交集并存储在 destination <code>SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN</code></li></ul><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><ul><li><code>Sunion</code>: 返回所有给定集合的并集 <code>SUNION KEY KEY1..KEYN</code></li><li><code>Sunionstore</code>: 所有给定集合的并集存储在 destination <code>SUNIONSTORE DESTINATION KEY KEY1..KEYN</code></li></ul><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><ul><li><code>Sdiff</code>: 返回给定所有集合的差集 <code>SDIFF KEY KEY1..KEYN</code></li><li><code>Sdiffstore</code>: 返回给定所有集合的差集并存储在 destination <code>SDIFFSTORE DESTINATION_KEY KEY1..KEYN</code></li></ul><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><ul><li><code>每个元素都会关联一个 double 类型的分数</code>。redis 正是通过分数来为集合中的成员进行<code>从小到大</code>的排序。</li><li>有序集合的成员是唯一的,但<code>分数(score)却可以重复</code></li></ul><h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><ul><li><code>Zadd</code>: 向有序集合添加一个或多个成员，或者更新已存在成员的分数 <code>ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</code></li></ul><h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><ul><li><code>Zrem</code>: 移除有序集合中的一个或多个成员 <code>ZRANK key member</code></li><li><code>Zremrangebyrank</code>: 移除有序集合中给定的分数区间的所有成员 <code>ZREMRANGEBYSCORE key min max</code></li><li><code>Zremrangebylex</code>: 移除有序集合中给定的字典区间的所有成员 <code>ZREMRANGEBYLEX key min max</code> <code>这里原文档书写有误</code></li></ul><img src="http://t-blog-images.aijs.top/img/202211042109618.png" /><h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><ul><li><code>Zincrby</code>: 有序集合中对指定成员的分数加上增量 increment <code>ZINCRBY key increment member</code></li></ul><h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><ul><li><code>Zcard</code>: 获取有序集合的成员数 <code>ZCARD KEY_NAME</code></li><li><code>Zrange</code>: 通过索引区间返回有序集合成指定区间内的成员 <code>ZRANGE key start stop [WITHSCORES]</code> # 显示有序集下标区间 start 至 stop 的成员</li><li><code>Zrangebylex</code>: 移除有序集合中给定的字典区间的所有成员 <code>ZREMRANGEBYLEX key min max</code></li><li><code>Zrangebyscore</code>: 通过分数返回有序集合指定区间内的成员 <code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code> # -inf +inf 正负无穷大</li><li><code>Zcount</code>: 计算在有序集合中指定区间分数的成员数 <code>ZCOUNT key min max</code></li><li><code>Zlexcount</code>:在有序集合中计算指定字典区间内成员数量 <code>ZLEXCOUNT KEY MIN MAX</code></li><li><code>Zrank</code>: 获得成员按分数值递增(从小到大)排列的排名 <code>ZRANK key member</code></li><li><code>Zrevrank</code>: 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 <code>ZREVRANK key member</code></li></ul><h3 id="交集-1"><a href="#交集-1" class="headerlink" title="交集"></a>交集</h3><ul><li><code>Zinterstore</code>: 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 <code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></li></ul><h3 id="并集-1"><a href="#并集-1" class="headerlink" title="并集"></a>并集</h3><ul><li><code>Zunionstore</code>: 计算给定的一个或多个有序集的并集，并存储在新的 key 中 <code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code></li></ul><h3 id="差集-1"><a href="#差集-1" class="headerlink" title="差集"></a>差集</h3><ul><li><code>Zscore</code>: 返回有序集中，成员的分数值 <code>ZSCORE key member</code></li><li><code>Zscan</code>: 迭代有序集合中的元素（包括元素成员和元素分值） <code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code> ???</li><li><code>Zremrangebylex</code>: 移除有序集合中给定的字典区间的所有成员 <code>ZREMRANGEBYLEX key min max</code></li><li><code>Zrevrangebyscore</code>: 移除有序集合中给定的分数区间的所有成员 <code>ZREMRANGEBYSCORE key min max</code></li><li><code>Zrevrange</code>: 返回有序集中指定区间内的成员，通过索引，分数从高到底 <code>ZREVRANGE key start stop [WITHSCORES]</code></li></ul><h2 id="Redis-发布订阅-有啥用"><a href="#Redis-发布订阅-有啥用" class="headerlink" title="Redis 发布订阅? 有啥用"></a>Redis 发布订阅? 有啥用</h2><h2 id="Redis-事务【一损俱损】"><a href="#Redis-事务【一损俱损】" class="headerlink" title="Redis 事务【一损俱损】"></a>Redis 事务【一损俱损】</h2><h3 id="Redis-事务三个阶段"><a href="#Redis-事务三个阶段" class="headerlink" title="Redis 事务三个阶段"></a>Redis 事务三个阶段</h3><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h3 id="Redis-事务命令"><a href="#Redis-事务命令" class="headerlink" title="Redis 事务命令"></a>Redis 事务命令</h3><ol><li><code>MULTI</code> 标记一个事务块的开始。</li><li><code>EXEC</code> 执行所有事务块内的命令。</li><li><code>DISCARD</code> 取消事务，放弃执行事务块内的所有命令。</li><li><code>UNWATCH</code> 取消 WATCH 命令对所有 key 的监视。</li><li><code>WATCH key [key ...]</code> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li></ol><h2 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h2><h3 id="eval-呃怎么和-js-eval-那么像"><a href="#eval-呃怎么和-js-eval-那么像" class="headerlink" title="eval 呃怎么和 js eval 那么像"></a>eval 呃怎么和 js eval 那么像</h3><p>Redis 脚本使用 Lua 解释器来执行脚本 Redis 脚本使用 Lua 解释器来执行脚本</p><p>【暂时跳过】没时间整这个</p><h3 id="连接命令"><a href="#连接命令" class="headerlink" title="连接命令"></a>连接命令</h3><ol><li>AUTH password 验证密码是否正确</li><li>ECHO message 打印字符串</li><li>PING 查看服务是否运行</li><li>QUIT 关闭当前连接</li><li>SELECT index 切换到指定的数据库</li></ol><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="分区的优势【容量大，速度快】"><a href="#分区的优势【容量大，速度快】" class="headerlink" title="分区的优势【容量大，速度快】"></a>分区的优势【容量大，速度快】</h3><ul><li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li><li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li></ul><h3 id="分区的不足【复杂度高，操作、事务受限】"><a href="#分区的不足【复杂度高，操作、事务受限】" class="headerlink" title="分区的不足【复杂度高，操作、事务受限】"></a>分区的不足【复杂度高，操作、事务受限】</h3><p>redis 的一些特性在分区方面表现的不是很好：</p><ul><li>涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 redis 实例上时，你就不能对这两个 set 执行交集操作。</li><li>涉及多个 key 的 redis 事务不能使用。</li><li>当使用分区时，数据处理较为复杂</li></ul><h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>Redis 有两种类型分区。 假设有 4 个 Redis 实例 R0，R1，R2，R3，和类似 user:1，user:2 这样的表示用户的多个 key，对既定的 key 有多种不同方式来选择这个 key 存放在哪个实例中。也就是说，有不同的系统来映射某个 key 到某个 Redis 服务。</p><h4 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h4><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。</p><p>比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。</p><p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各种对象的映射表，通常对 Redis 来说并非是好的方法。</p><h4 id="哈希分区【这个更优】"><a href="#哈希分区【这个更优】" class="headerlink" title="哈希分区【这个更优】"></a>哈希分区【这个更优】</h4><p>另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是 object_name:这种形式，像下面描述的一样简单：</p><p>用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar)会输出类似 93024922 的整数。<br>对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 &#x3D; 2，就是说 key foobar 应该被存到 R2 实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.redis.net.cn/order/3573.html" target="_blank" >https://www.redis.net.cn/order/3573.html</a></p><p><a href="https://try.redis.io/" target="_blank" >https://try.redis.io/</a></p><p>吐槽：某些云厂家卖人家的东西，也不给社区捐钱，啊呸</p>]]></content>
      
      
      <categories>
          
          <category> Db </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Db </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphql</title>
      <link href="//post/2022-11-03graphql.html"/>
      <url>//post/2022-11-03graphql.html</url>
      
        <content type="html"><![CDATA[<h1 id="文章背景"><a href="#文章背景" class="headerlink" title="文章背景"></a>文章背景</h1><p>中文官网废话太多，语句也有些不通顺的地方</p><h1 id="Graphql-是什么"><a href="#Graphql-是什么" class="headerlink" title="Graphql 是什么"></a>Graphql 是什么</h1><p>GraphQL 全称叫 Graph Query Language，官方宣传语是“为你的 API 量身定制的查询语言”。</p><p>用传统的方式来解释就是：相当于将你所有后端 API 组成的集合看成一个数据库，用户终端发送一个查询语句，你的 GraphQL 服务解析这条语句并通过一系列规则从你的“ API 数据库”里面将查询的数据结果返回给终端，而 GraphQL 就相当于这个系统的一个查询语言。</p><p>作者：倩倩_a570<br>链接：<a href="https://www.jianshu.com/p/05e405eef8fa">https://www.jianshu.com/p/05e405eef8fa</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>注意：GraphQL 不是数据库</strong></p><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时</p><p>简单来说：提供了 schema 结构的数据，按照规则，填写相应的字段就可以获取到对应的字段内容，不多不少，刚刚好</p><h2 id="在什么背景下提出的"><a href="#在什么背景下提出的" class="headerlink" title="在什么背景下提出的"></a>在什么背景下提出的</h2><p>GraphQL 在 rest 背景下提出</p><p>REST API ：服务端决定有哪些数据返回，客户端只能挑选使用，如果数据过于冗余也只能默默接收再对数据进行处理；而数据不能满足需求则需要请求更多的接口。以上就是我们常说的“过渡获取”和“欠缺获取”</p><p>由于”过度”和”欠缺”的获取问题及其对客户端应用程序性能的影响，促进有效获取的 API 技术才有机会在市场上引起轰动 —— GraphQL 大胆地介入并填补了这一空白。</p><p>作者：倩倩_a570<br>链接：<a href="https://www.jianshu.com/p/05e405eef8fa">https://www.jianshu.com/p/05e405eef8fa</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>简单来说：相比较 Rest 风格来讲，GraphQL，相当于在 Rest 返回时候有选择的进行聚合字段进行返回</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>请求你所要的数据不多不少</li><li>获取多个资源只用一个请求</li><li>描述所有的可能类型系统</li><li>更倾向于查询</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="GitHub-GraphQL-API"><a href="#GitHub-GraphQL-API" class="headerlink" title="GitHub GraphQL API"></a>GitHub GraphQL API</h3><p><a href="https://docs.github.com/cn/graphql/overview/explorer" target="_blank" >https://docs.github.com/cn/graphql/overview/explorer</a></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"># 涉及到知识点如下：# 查询# 字段（Fields）# 参数（Arguments）# 别名（Aliases）# 操作名称（Operation Name）# 变量（Variables）# 指令（Directives）# 元字段（Meta fields）query myquery(  $if: Boolean &#x3D; false  $withUpdateAt: Boolean!  $withUser: Boolean!) &#123;  viewer &#123;    __typename # 元字段 ，查看类型    uuid: id # 给id更改别名为uuid    status &#123;      __typename      createdAt @skip(if: $if) # $if变量为true的时候，不返回 createdAt      updatedAt @include(if: $withUpdateAt) # $withUpdateAt变量为false的时候，不返回 updatedAt      user @include(if: $withUser) &#123;        __typename        id        email      &#125;    &#125;  &#125;&#125;</code></pre><h3 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;skipCreatedAt&quot;: false,  &quot;withUpdateAt&quot;: true,  &quot;withUser&quot;: true&#125;</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;viewer&quot;: &#123;      &quot;__typename&quot;: &quot;User&quot;,      &quot;uuid&quot;: &quot;MDQ6VXNlcjE4MzA1MzYx&quot;,      &quot;status&quot;: &#123;        &quot;__typename&quot;: &quot;UserStatus&quot;,        &quot;createdAt&quot;: &quot;2019-01-11T14:57:43Z&quot;,        &quot;updatedAt&quot;: &quot;2019-09-24T08:56:23Z&quot;,        &quot;user&quot;: &#123;          &quot;__typename&quot;: &quot;User&quot;,          &quot;id&quot;: &quot;MDQ6VXNlcjE4MzA1MzYx&quot;,          &quot;email&quot;: &quot;&quot;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><p>GraphQL 查询语言基本上就是关于选择对象上的字段</p><p>GraphQL 查询的结构和结果非常相似，因此即便不知道服务器的情况，你也能预测查询会返回什么结果</p><h3 id="为什么引入-schema"><a href="#为什么引入-schema" class="headerlink" title="为什么引入 schema?"></a>为什么引入 schema?</h3><p>需要的数据的确切描述依然很有意义，我们能选择什么字段？服务器会返回哪种对象？这些对象下有哪些字段可用？</p><p>GraphQL 服务都会定义一套类型，用以描述从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询</p><h3 id="对象类型和字段"><a href="#对象类型和字段" class="headerlink" title="对象类型和字段"></a>对象类型和字段</h3><p>GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段例如：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"># 嗯， 看上去有点像 golang 的结构体type Character &#123;  name: String!  appearsIn: [Episode!]!&#125;</code></pre><ul><li><code>对象类型</code> 拥有一些字段的类型</li><li><code>字段</code> 对象类型的次级选项</li><li><code>标量</code> 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择</li><li><code>非空</code> String!</li><li><code>数组</code> [Episode!]</li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">type Starship &#123;  id: ID!  name: String!  length(unit: LengthUnit &#x3D; METER): Float&#125;</code></pre><p>在 GraphQL 中，所有参数必须具名传递</p><p>参数可能是必选或者可选的，当一个参数是可选的，我们可以定义一个默认值 —— 如果 unit 参数没有传递，那么它将会被默认设置为 METER</p><p><strong>要么可选，要么必选，可选的必须有默认值！</strong></p><h3 id="查询和变更类型"><a href="#查询和变更类型" class="headerlink" title="查询和变更类型"></a>查询和变更类型</h3><p>schema 中大部分是普通对象类型，schema 内有两个特殊类型：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">schema &#123;  query: Query  mutation: Mutation&#125;</code></pre><p>例如：</p><p>服务端：schema</p><pre class="line-numbers language-schema" data-language="schema"><code class="language-schema">type Query &#123;  hero(episode: Episode): Character  droid(id: ID!): Droid&#125;</code></pre><p>客户端</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">query &#123;  hero &#123;    name  &#125;  droid(id: &quot;2000&quot;) &#123;    name  &#125;&#125;</code></pre><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>标量类型的来源：表示 GraphQL 查询的叶子节点</p><h4 id="默认标量类型"><a href="#默认标量类型" class="headerlink" title="默认标量类型"></a>默认标量类型</h4><p>GraphQL 默认标量类型：</p><ul><li><code>Int</code>：有符号 32 位整数。</li><li><code>Float</code>：有符号双精度浮点值。</li><li><code>String</code>：UTF‐8 字符序列。</li><li><code>Boolean</code>：true 或者 false。</li><li><code>ID</code>：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li></ul><h4 id="自定义标量类型"><a href="#自定义标量类型" class="headerlink" title="自定义标量类型"></a>自定义标量类型</h4><p>例如，我们可以定义一个 Date 类型：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">scalar Date</code></pre><p>然后就取决于我们的实现中如何定义将其序列化、反序列化和验证</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">enum Episode &#123;  NEWHOPE  EMPIRE  JEDI&#125;</code></pre><p>无论在 schema 的哪处 使用了 Episode，都可以肯定它返回的是 NEWHOPE、EMPIRE 和 JEDI 之一。</p><h3 id="列表和非空"><a href="#列表和非空" class="headerlink" title="列表和非空"></a>列表和非空</h3><p>类型修饰符</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">type Character &#123;  name: String! # 英文!表示非空  appearsIn: [Episode]! # 在 GraphQL schema 语言中，我们通过将类型包在方括号中来标记列表&#125;</code></pre><p>非空和列表修饰符可以组合使用。例如你可以要求一个非空字符串的数组：<br>这表示数组本身可以为空，但是其不能有任何空值成员。用 JSON 举例如下：</p><pre class="line-numbers language-none"><code class="language-none">myField: null &#x2F;&#x2F; 有效myField: [] &#x2F;&#x2F; 有效myField: [&#39;a&#39;, &#39;b&#39;] &#x2F;&#x2F; 有效myField: [&#39;a&#39;, null, &#39;b&#39;] &#x2F;&#x2F; 错误</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一个<code>抽象类型</code>，它包含某些字段，<code>对象类型</code>必须包含这些字段，才能算实现了这个接口</p><p>与 typescript 不同的是这里的<code>implements</code>关键字来实现接口，把接口字段<code>又</code>罗列了一遍</p><p><strong>接口</strong></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">interface Character &#123; # 接口interface定义  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!&#125;</code></pre><p><strong>实现了 Character 的类型：</strong></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"># 实现接口type Human implements Character &#123;  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!  starships: [Starship]  totalCredits: Int&#125;# 实现接口type Droid implements Character &#123;  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!  primaryFunction: String&#125;# 引入了其他的字段 totalCredits、starships 和 primaryFunction，这都属于特定的类型的角色</code></pre><p><strong>如果要查询一个只存在于特定对象类型上的字段，你需要使用内联片段：</strong></p><p><strong>查询语句</strong></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">query HeroForEpisode($ep: Episode!) &#123;  hero(episode: $ep) &#123;    name    ... on Droid &#123;      primaryFunction    &#125;  &#125;&#125;</code></pre><p><strong>参数：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;ep&quot;: &quot;JEDI&quot;&#125;</code></pre><p><strong>返回：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;primaryFunction&quot;: &quot;Astromech&quot;    &#125;  &#125;&#125;</code></pre><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"># 与typescript 的联合类型相似union SearchResult &#x3D; Human | Droid | Starship</code></pre><p><strong>注意</strong>，联合类型的成员需要是具体对象类型；<code>不能使用接口</code>或者<code>其他联合类型</code>来创造一个联合类型。</p><p>由于 Human 和 Droid 共享一个公共接口（Character），你可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段：</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  search(text: &quot;an&quot;) &#123;    __typename    ... on Character &#123;      # 使用了接口      name    &#125;    ... on Human &#123;      height    &#125;    ... on Droid &#123;      primaryFunction    &#125;    ... on Starship &#123;      name #Starship不是接口，要获取类型，还是要作为对象属性来写      length    &#125;  &#125;&#125;# 这里的Starship 是上文的对象类型# type Starship &#123;#   id: ID!#   name: String!#   length(unit: LengthUnit &#x3D; METER): Float# &#125;</code></pre><h3 id="输入类型"><a href="#输入类型" class="headerlink" title="输入类型"></a>输入类型</h3><p>枚举和字符串等标量值作为参数传递给字段，也能很容易地传递复杂对象。这在变更（mutation）中特别有用，因为有时候你需要传递一整个对象作为新建对象。</p><p>输入对象看上去和常规对象一模一样，除了关键字是 <code>input</code> 而不是 <code>type</code>:</p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">input ReviewInput &#123;  stars: Int!  commentary: String&#125;</code></pre><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql"># $review为参数对象mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;  createReview(episode: $ep, review: $review) &#123;    stars    commentary  &#125;&#125;</code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;ep&quot;: &quot;JEDI&quot;,  &quot;review&quot;: &#123;    &quot;stars&quot;: 5,    &quot;commentary&quot;: &quot;This is a great movie!&quot;  &#125;&#125;</code></pre><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;createReview&quot;: &#123;      &quot;stars&quot;: 5,      &quot;commentary&quot;: &quot;This is a great movie!&quot;    &#125;  &#125;&#125;</code></pre><h2 id="验证（规则限制）"><a href="#验证（规则限制）" class="headerlink" title="验证（规则限制）"></a>验证（规则限制）</h2><p>什么是验证？谁来验证？</p><p>通过使用类型系统，你可以预判一个查询是否有效。这让服务器和客户端可以在无效查询创建时就有效地通知开发者，而不用依赖运行时检查。</p><p><strong>助解：</strong></p><ol><li>有问题，提示，不执行查询，有点像浏览器 Option 预检的味道；好像不是 typescript 那种静态校验</li><li>类型系统来校验</li><li>这部分内容，更像是使用限制，你不能这么干，你要那么干</li></ol><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p><strong>有个问题：如果是树状结构的组织架构，咋整了？组织架构是递归结构</strong></p><img src="http://t-blog-images.aijs.top/img/202211041022372.webp" /><h3 id="对象类型不存在的字段"><a href="#对象类型不存在的字段" class="headerlink" title="对象类型不存在的字段"></a>对象类型不存在的字段</h3><img src="http://t-blog-images.aijs.top/img/202211041023087.webp" /><h3 id="返回的不是标量-x2F-枚举类型"><a href="#返回的不是标量-x2F-枚举类型" class="headerlink" title="返回的不是标量&#x2F;枚举类型"></a>返回的不是标量&#x2F;枚举类型</h3><img src="http://t-blog-images.aijs.top/img/202211041026559.webp" /><h3 id="特定类型的特定字段"><a href="#特定类型的特定字段" class="headerlink" title="特定类型的特定字段"></a>特定类型的特定字段</h3><p>如果对应的 Character 是 Droid，我们希望获取 primaryFunction 字段，而在其他情况下，则忽略此字段。我们可以使用之前引入的“片段”来解决这个问题。先在 Droid 上定义一个片段，然后在查询中引入它，这样我们就能在定义了 primaryFunction 的地方查询它</p><h4 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h4><img src="http://t-blog-images.aijs.top/img/202211041029172.webp" /><h4 id="具名片段"><a href="#具名片段" class="headerlink" title="具名片段"></a>具名片段</h4><img src="http://t-blog-images.aijs.top/img/202211041029675.webp" /><h4 id="匿名片段"><a href="#匿名片段" class="headerlink" title="匿名片段"></a>匿名片段</h4><img src="http://t-blog-images.aijs.top/img/202211041030465.webp" /><h3 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h3><p><a href="https://github.com/graphql/graphql-js/blob/master/src/validation" target="_blank" >GraphQL.js 的 validation 目录包含了规范兼容的 GraphQL 验证器实现代码。</a></p><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>一个 GraphQL 查询在被验证后，GraphQL 服务器会将之执行，并返回与请求的结构相对应的结果，该结果通常会是 JSON 的格式。</p><h3 id="一个查询请求被执行的全过程"><a href="#一个查询请求被执行的全过程" class="headerlink" title="一个查询请求被执行的全过程"></a>一个查询请求被执行的全过程</h3><p>GraphQL 查询中的每个字段视为返回子类型的父类型函数或方法。<br>事实上，这正是 GraphQL 的工作原理。</p><ul><li><p>每个类型的每个字段都由一个 resolver 函数支持，该函数由 GraphQL 服务器开发人员提供。</p></li><li><p>当一个字段被执行时，相应的 resolver 被调用以产生下一个值。</p></li><li><p>如果字段产生标量值，例如字符串或数字，则执行完成。</p></li><li><p>如果一个字段产生一个对象，则该查询将继续执行该对象对应字段的解析器，直到生成标量值。</p></li><li><p>GraphQL 查询始终以标量值结束。</p></li></ul><h3 id="根字段-amp-解析器"><a href="#根字段-amp-解析器" class="headerlink" title="根字段 &amp; 解析器#"></a>根字段 &amp; 解析器#</h3><ul><li>Root 类型或 Query 类型 代表着所有进入 GraphQL API 可能的入口点</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Query: &#123;  human(obj, args, context, info) &#123;    return context.db.loadHumanByID(args.id).then(      userData &#x3D;&gt; new Human(userData)    )  &#125;&#125;</code></pre><ul><li><code>obj</code> 上一级对象，如果字段属于根节点查询类型通常不会被使用。</li><li><code>args</code> 可以提供在 GraphQL 查询中传入的参数。</li><li><code>context</code> 会被提供给所有解析器，并且持有重要的上下文信息比如当前登入的用户或者数据库访问对象。</li><li><code>info</code> 一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值</li></ul><h3 id="异步解析器"><a href="#异步解析器" class="headerlink" title="异步解析器"></a>异步解析器</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">human(obj, args, context, info) &#123;  return context.db.loadHumanByID(args.id).then(    userData &#x3D;&gt; new Human(userData)  )&#125;</code></pre><ul><li><code>context</code> 提供了一个数据库访问对象，用来通过查询中传递的参数 id 来查询数据，因为从数据库拉取数据的过程是一个异步操作，该方法返回了一个 Promise 对象，在 JavaScript 语言中 Promise 对象用来处理异步操作，但在许多语言中存在相同的概念，通常称作 Futures、Tasks 或者 Defferred。</li><li>当数据库返回查询结果，我们就能构造并返回一个新的 Human 对象。</li><li>等返回：这里要注意的是，只有解析器能感知到 Promise 的进度，GraphQL 查询只关注一个包含着 name 属性的 human 字段是否返回，在执行期间如果异步操作没有完成，则 GraphQL 会一直等待下去，因此在这个环节需要关注异步处理上的优化。</li></ul><h3 id="不重要的解析器"><a href="#不重要的解析器" class="headerlink" title="不重要的解析器"></a>不重要的解析器</h3><h3 id="标量强制"><a href="#标量强制" class="headerlink" title="标量强制"></a>标量强制</h3><pre class="line-numbers language-none"><code class="language-none">&#123;  human(id: 1002) &#123;    name      # 先处理name    appearsIn # appearsIn,starships同步执行， appearsIn 是枚举类型    starships &#123;      name    &#125;  &#125;&#125;</code></pre><p>appearsIn 字段，因为类型系统已经被设定，所以解析器函数的返回值必须符合与类型系统对应的 API 规则的约束</p><h3 id="列表解析器"><a href="#列表解析器" class="headerlink" title="列表解析器"></a>列表解析器</h3><p>返回一个 Promises 列表，并发执行这些 Promise，当执行结束返回一个对象列表后，它将继续并发加载列表中每个对象的 name 字段。</p><h3 id="产生结果"><a href="#产生结果" class="headerlink" title="产生结果"></a>产生结果</h3><p>当每个字段被解析时，结果被放置到键值映射中，字段名称（或别名）作为键值映射的键，解析器的值作为键值映射的值。<br>这个过程从查询字段的底部叶子节点开始返回，直到根 Query 类型的起始节点。（为什么这么设计？）<br>最后合并成为能够镜像到原始查询结构的结果，然后可以将其发送（通常为 JSON 格式）到请求的客户端。</p><h2 id="自省"><a href="#自省" class="headerlink" title="自省"></a>自省</h2><p>有时候会需要去问 <code>GraphQL Schema</code> 它支持哪些查询。GraphQL 通过内省系统让我们可以做到这点！</p><p>助解：这个与 <code>elastic</code> 有点类似了，我们在不晓得有哪些东西的时候，自省<code>关键字</code>语句，就会给提示，这个对象有哪些东西</p><h3 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h3><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __schema &#123;    types &#123;      name    &#125;  &#125;&#125;</code></pre><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__schema&quot;: &#123;      &quot;types&quot;: [        &#123;          &quot;name&quot;: &quot;Query&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;String&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;ID&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Mutation&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Episode&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Character&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Int&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;LengthUnit&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Human&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Float&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Droid&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;FriendsConnection&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;FriendsEdge&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;PageInfo&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Boolean&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Review&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;ReviewInput&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Starship&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;SearchResult&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__Schema&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__Type&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__TypeKind&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__Field&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__InputValue&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__EnumValue&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__Directive&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;__DirectiveLocation&quot;        &#125;      ]    &#125;  &#125;&#125;</code></pre><p>有好多类型！它们都是什么？我们来总结一下：</p><ul><li><code>Query</code>, <code>Character</code>, <code>Human</code>, <code>Episode</code>, <code>Droid</code> - 这些是我们在类型系统中定义的类型。<code>对象类型</code></li><li><code>String</code>, <code>Boolean</code> - 这些是内建的标量，由类型系统提供。</li><li><code>__Schema</code>, <code>__Type</code>, <code>__TypeKind</code>, <code>__Field</code>, <code>__InputValue</code>, <code>__EnumValue</code>, <code>__Directive</code> - 这些有着两个下划线的类型是内省系统的一部分。</li></ul><p>这里有点要注意的是：<code>__TypeKind</code>, <code>__Field</code>, <code>__InputValue</code>, <code>__EnumValue</code>, <code>__Directive</code> ,这些是 <code>__Type</code> 与 kind、field 等的组合</p><p>现在，来试试找到一个可以探索出有哪些可用查询的地方。</p><p>当我们设计类型系统的时候，我们<code>确定了一个所有查询开始的地方，来问问内省系统它是什么！</code></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __schema &#123;    queryType &#123;      name    &#125;  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__schema&quot;: &#123;      &quot;queryType&quot;: &#123;        &quot;name&quot;: &quot;Query&quot;      &#125;    &#125;  &#125;&#125;</code></pre><h4 id="类型-type"><a href="#类型-type" class="headerlink" title="类型 __type"></a>类型 <code>__type</code></h4><pre class="line-numbers language-none"><code class="language-none">&#123;  __type(name: &quot;Droid&quot;) &#123;    name  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__type&quot;: &#123;      &quot;name&quot;: &quot;Droid&quot;    &#125;  &#125;&#125;</code></pre><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p><strong>例 1</strong></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __type(name: &quot;Droid&quot;) &#123;    name    kind # 是一个接口还是一个对象？  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__type&quot;: &#123;      &quot;name&quot;: &quot;Droid&quot;,      &quot;kind&quot;: &quot;OBJECT&quot;    &#125;  &#125;&#125;</code></pre><p><strong>例 2</strong></p><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __type(name: &quot;Character&quot;) &#123;    name    kind # 这里  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__type&quot;: &#123;      &quot;name&quot;: &quot;Character&quot;,      &quot;kind&quot;: &quot;INTERFACE&quot; # 它是一个接口    &#125;  &#125;&#125;</code></pre><h4 id="对象的字段"><a href="#对象的字段" class="headerlink" title="对象的字段"></a>对象的字段</h4><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __type(name: &quot;Droid&quot;) &#123;    name    # 这里    fields &#123;      name      type &#123;        name        kind      &#125;    &#125;  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__type&quot;: &#123;      &quot;name&quot;: &quot;Droid&quot;,      &quot;fields&quot;: [        &#123;          &quot;name&quot;: &quot;id&quot;,          &quot;type&quot;: &#123;            &quot;name&quot;: null,            &quot;kind&quot;: &quot;NON_NULL&quot;          &#125;        &#125;,        &#123;          &quot;name&quot;: &quot;name&quot;,          &quot;type&quot;: &#123;            &quot;name&quot;: null,            &quot;kind&quot;: &quot;NON_NULL&quot;          &#125;        &#125;,        &#123;          &quot;name&quot;: &quot;friends&quot;,          &quot;type&quot;: &#123;            &quot;name&quot;: null,            &quot;kind&quot;: &quot;LIST&quot;          &#125;        &#125;,        &#123;          &quot;name&quot;: &quot;friendsConnection&quot;,          &quot;type&quot;: &#123;            &quot;name&quot;: null,            &quot;kind&quot;: &quot;NON_NULL&quot;          &#125;        &#125;,        &#123;          &quot;name&quot;: &quot;appearsIn&quot;,          &quot;type&quot;: &#123;            &quot;name&quot;: null,            &quot;kind&quot;: &quot;NON_NULL&quot;          &#125;        &#125;,        &#123;          &quot;name&quot;: &quot;primaryFunction&quot;,          &quot;type&quot;: &#123;            &quot;name&quot;: &quot;String&quot;,            &quot;kind&quot;: &quot;SCALAR&quot;          &#125;        &#125;      ]    &#125;  &#125;&#125;</code></pre><h4 id="查看包装类型-ofType"><a href="#查看包装类型-ofType" class="headerlink" title="查看包装类型 ofType"></a>查看包装类型 ofType</h4><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __type(name: &quot;Droid&quot;) &#123;    name    fields &#123;      name      type &#123;        name        kind        # 这里        ofType &#123;          name          kind        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h4 id="文档描述-description"><a href="#文档描述-description" class="headerlink" title="文档描述 description"></a>文档描述 description</h4><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  __type(name: &quot;Droid&quot;) &#123;    name    description #这里  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;__type&quot;: &#123;      &quot;name&quot;: &quot;Droid&quot;,      &quot;description&quot;: &quot;An autonomous mechanical character in the Star Wars universe&quot;    &#125;  &#125;&#125;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h3><p>复数类型字段对应的数据</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  hero &#123;    name    friends(first: 2) &#123;      # 前两个      name    &#125;  &#125;&#125;</code></pre><h3 id="分页和边"><a href="#分页和边" class="headerlink" title="分页和边"></a>分页和边</h3><p>我们可以像这样 friends(first:2 offset:2) 来请求列表中接下来的两个结果。 &#x2F;&#x2F; 跳过 2 个，取 2 个<br>我们可以像这样 friends(first:2 after:$friendId), 来请求我们上一次获取到的最后一个朋友之后的两个结果。&#x2F;&#x2F; 在某个id对应的数据之后取2个<br>我们可以像这样 friends(first:2 after:$friendCursor), 从最后一项中获取一个游标并使用它来分页。 &#x2F;&#x2F; 在某个游标之后取 2 个</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="完整链接模式"><a href="#完整链接模式" class="headerlink" title="完整链接模式"></a>完整链接模式</h3><pre class="line-numbers language-graphql" data-language="graphql"><code class="language-graphql">&#123;  hero &#123;    name    friendsConnection(first: 2, after: &quot;Y3Vyc29yMQ&#x3D;&#x3D;&quot;) &#123;      totalCount      edges &#123;        node &#123;          name        &#125;        cursor      &#125;      pageInfo &#123;        # 列表的结尾、计数及连接，晓得什么时候结束        endCursor        hasNextPage      &#125;    &#125;  &#125;&#125;</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;friendsConnection&quot;: &#123;        &quot;totalCount&quot;: 3,        &quot;edges&quot;: [          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Han Solo&quot;            &#125;,            &quot;cursor&quot;: &quot;Y3Vyc29yMg&#x3D;&#x3D;&quot;          &#125;,          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Leia Organa&quot;            &#125;,            &quot;cursor&quot;: &quot;Y3Vyc29yMw&#x3D;&#x3D;&quot;          &#125;        ],        &quot;pageInfo&quot;: &#123;          &quot;endCursor&quot;: &quot;Y3Vyc29yMw&#x3D;&#x3D;&quot;,          &quot;hasNextPage&quot;: false        &#125;      &#125;    &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Graphql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pdf 添加水印并下载</title>
      <link href="//post/2022-11-02pdf-watermark.html"/>
      <url>//post/2022-11-02pdf-watermark.html</url>
      
        <content type="html"><![CDATA[<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>React-PDF + Canvas 实现预览水印效果</p><h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p>用户下载 pdf 也要加载水印</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>方案 1. 后端 在 pdf 上传时候水印</li><li>方案 2. 后端 pdf 增加水印</li><li>方案 3. 前端在文件上传时候增加水印</li><li>方案 4. 前端在文件下载的时候增加水印</li></ul><p>现在场景是：文件直接存储到 COS 上面，没有经过后端</p><p>那么只能采用前端实现方案，<code>或者</code>是前端把链接给后端，后端对文件下载，加完水印再给前端，肯定是前者更优</p><h2 id="前端实现方式"><a href="#前端实现方式" class="headerlink" title="前端实现方式"></a>前端实现方式</h2><p>用到两个库 pdf-lib + @pdf-lib&#x2F;fontkit</p><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/Hopding/pdf-lib">https://github.com/Hopding/pdf-lib</a><img src="https://img.shields.io/github/stars/Hopding/pdf-lib?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/foliojs/fontkit">https://github.com/foliojs/fontkit</a><img src="https://img.shields.io/github/stars/foliojs/fontkit?style=social" /></div><p><strong>不支持中文是 fontkit 使用问题，不是 pdf-lib 问题</strong></p><p><a href="https://github.com/Hopding/pdf-lib/issues/494" target="_blank" >https://github.com/Hopding/pdf-lib/issues/494</a></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;html&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;pdf-lib&#x2F;1.14.1&#x2F;pdf-lib.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;@pdf-lib&#x2F;fontkit&#x2F;dist&#x2F;fontkit.umd.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;downloadjs@1.4.7&quot;&gt;&lt;&#x2F;script&gt;  &lt;&#x2F;head&gt;  &lt;style&gt;    body &#123;      width: 100vw;      height: 100vh;      display: flex;      justify-content: center;      align-items: center;      flex-direction: column;    &#125;    p &#123;      font-family: helvetica;      font-size: 24px;      text-align: center;      margin: 25px;    &#125;    .small &#123;      font-family: helvetica;      font-size: 18px;      text-align: center;      margin: 25px;    &#125;    button &#123;      background-color: #315efb;      border: none;      color: white;      padding: 14px 32px;      border-radius: 10px;      text-align: center;      font-size: 16px;      cursor: pointer;    &#125;  &lt;&#x2F;style&gt;  &lt;body&gt;    &lt;p&gt;点击这个按钮通过&lt;code&gt;pdf-lib&lt;&#x2F;code&gt;给原来的pdf文件添加水印&lt;&#x2F;p&gt;    &lt;button onclick&#x3D;&quot;modify()&quot;&gt;Modify PDF&lt;&#x2F;button&gt;    &lt;p class&#x3D;&quot;small&quot;&gt;(点击后自动下载修改完成后的pdf文件)&lt;&#x2F;p&gt;  &lt;&#x2F;body&gt;  &lt;script&gt;    &#x2F;&#x2F;1. 引入相关对象和方法    const &#123; degrees, PDFDocument, rgb, StandardFonts &#125; &#x3D; PDFLib; &#x2F;&#x2F;引入PDFLib相关方法    const fontkit &#x3D; window.fontkit; &#x2F;&#x2F;引入自定义字体工具包    &#x2F;&#x2F; pdf浏览    async function modify() &#123;      &#x2F;*2. 获取pdf文件的arrarybuffer文件流         可请求后台接口返回的base64文件流，然后转成arrayBuffer类型         可访问前端项目中的本地文件         不能直接访问服务器链接文件，会有跨域问题*&#x2F;      const url &#x3D; &quot;.&#x2F;1.pdf&quot;;      const existingPdfBytes &#x3D; await fetch(url).then((res) &#x3D;&gt;        res.arrayBuffer()      );      &#x2F;&#x2F; 将arraybuffer数据转成pdf文档      const pdfDoc &#x3D; await PDFDocument.load(existingPdfBytes);      &#x2F;&#x2F;3. 自定义字体，如不需要使用自定义字体可以将这一段全部注释掉，也不用下载自定义字体文件和自定义字体工具fontkit      &#x2F;&#x2F;将自己下载好的.ttf文件放置项目中，然后访问文件路径      const fonturl &#x3D; &quot;.&#x2F;fangzhengkaiti.ttf&quot;;      const fontBytes &#x3D; await fetch(fonturl).then((res) &#x3D;&gt; res.arrayBuffer());      &#x2F;&#x2F; 自定义字体挂载、fontkit为自定义字体注册工具      pdfDoc.registerFontkit(fontkit);      const customFont &#x3D; await pdfDoc.embedFont(fontBytes);      &#x2F;&#x2F; 内置字体（不支持中文）, 如果水印中不包含中文可直接用内置字体，本次这里没用到内置字体      const helveticaFont &#x3D; await pdfDoc.embedFont(StandardFonts.Helvetica);      &#x2F;&#x2F;4. 添加水印      &#x2F;&#x2F;为每页pdf添加文字水印      const pages &#x3D; pdfDoc.getPages();      for (let i &#x3D; 0; i &lt; pages.length; i++) &#123;        const noPage &#x3D; pages[i];        const &#123; width, height &#125; &#x3D; noPage.getSize();        for (let i &#x3D; 0; i &lt; 10; i++) &#123;          for (let j &#x3D; 0; j &lt; 3; j++) &#123;            noPage.drawText(&quot;版权所有，侵权不究！&quot;, &#123;              x: 230 * j,              y: (height &#x2F; 5) * i,              size: 16,              font: customFont, &#x2F;&#x2F;这里使用的是自定义字体              &#x2F;&#x2F;使用上面定义好的内置字体              &#x2F;&#x2F; font: helveticaFont,              color: rgb(0.46, 0.53, 0.6),              rotate: degrees(30),              opacity: 0.3,            &#125;);          &#125;        &#125;      &#125;      &#x2F;&#x2F;5. 保存pdf文件的unit64Arrary文件流      const pdfBytes &#x3D; await pdfDoc.save();      download(pdfBytes, &quot;test.pdf&quot;, &quot;application&#x2F;pdf&quot;); &#x2F;&#x2F;下载带水印的pdf      &#x2F;&#x2F;6. 新标签页预览、打印      let blobData &#x3D; new Blob([pdfBytes], &#123; type: &quot;application&#x2F;pdf;Base64&quot; &#125;);      let a &#x3D; document.createElement(&quot;a&quot;);      a.target &#x3D; &quot;_blank&quot;;      a.href &#x3D; window.URL.createObjectURL(blobData);      document.body.appendChild(a);      a.click();      document.body.removeChild(a);    &#125;  &lt;&#x2F;script&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><img src="http://t-blog-images.aijs.top/img/202211021338629.webp" style="width: 500px;max-width: 100%"/><h2 id="字体选用"><a href="#字体选用" class="headerlink" title="字体选用"></a>字体选用</h2><img src="http://t-blog-images.aijs.top/img/202211021342143.webp"  style="width: 500px;max-width: 100%"/><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px;margin-bottom:20px"><a target="_blank" href="https://github.com/Hopding/pdf-lib">https://github.com/Hopding/pdf-lib</a><img src="https://img.shields.io/github/stars/Hopding/pdf-lib?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/foliojs/fontkit">https://github.com/foliojs/fontkit</a><img src="https://img.shields.io/github/stars/foliojs/fontkit?style=social" /></div><p><a href="https://github.com/Hopding/pdf-lib/issues/494" target="_blank" >https://github.com/Hopding/pdf-lib/issues/494</a></p><p><a href="https://blog.csdn.net/weixin_54177757/article/details/125458375" target="_blank" >pdf-lib 给 pdf 添加水印并预览、下载、打印</a></p><p><a href="https://www.fonts.net.cn/font-search-result.html?q=%E6%A5%B7%E4%BD%93" target="_blank" >字体天下</a></p>]]></content>
      
      
      <categories>
          
          <category> PDF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生 了解elastic</title>
      <link href="//post/2022-11-02elastic.html"/>
      <url>//post/2022-11-02elastic.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景很有意思"><a href="#背景很有意思" class="headerlink" title="背景很有意思"></a>背景很有意思</h2><p><a href="https://blog.csdn.net/qq_45065241/article/details/120942716" target="_blank" >ElasticSearch 的由来</a></p><h2 id="elastic"><a href="#elastic" class="headerlink" title="elastic"></a>elastic</h2><p>ElasticSearch 实时搜索、分析引擎</p><p><a href="https://zhuanlan.zhihu.com/p/467431106" target="_blank" >ElasticSearch 基础入门篇</a></p><p><a href="https://learnku.com/docs/elasticsearch73/7.3" target="_blank" >Elasticsearch 中文文档 7.3 </a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html#highlighting" target="_blank" >Elasticsearch Guide: 8.5</a></p><p>在做 wiki 全文检索的时候，用到了这个<code>/globalsearch/es/query</code>,这是前端页面调用的接口，注意里面的<code>es</code>是 <code>Elasticsearch</code>的简写，后端对数据进行转化处理，调用 restful 风格的 elastic 进行查询，然后返回给前端</p><h2 id="Kibana-用户手册（中文的，很友好）"><a href="#Kibana-用户手册（中文的，很友好）" class="headerlink" title="Kibana 用户手册（中文的，很友好）"></a>Kibana 用户手册（中文的，很友好）</h2><p><a href="https://www.elastic.co/guide/cn/kibana/current/breaking-changes-6.0.html" target="_blank" >Kibana 用户手册</a></p><p>在做 RN 移动端时候，公司用的这套东西，查看 ATOP 接口日志。当时不会用，现在嘛-还不会用，之后就会了 😂</p><h2 id="elastic-与-mysql-对比"><a href="#elastic-与-mysql-对比" class="headerlink" title="elastic 与 mysql 对比"></a>elastic 与 mysql 对比</h2><table><thead><tr><th align="left">释义</th><th align="left">mysql</th><th align="left">ElasticSearch</th></tr></thead><tbody><tr><td align="left">数据库</td><td align="left">Database</td><td align="left">Index</td></tr><tr><td align="left">表</td><td align="left">Table</td><td align="left">Type</td></tr><tr><td align="left">行</td><td align="left">Row</td><td align="left">Document</td></tr><tr><td align="left">列&#x2F;字段</td><td align="left">column</td><td align="left">Field</td></tr><tr><td align="left">关系</td><td align="left">schema</td><td align="left">Mapping</td></tr><tr><td align="left">索引</td><td align="left">index</td><td align="left">Everythis is indexed</td></tr><tr><td align="left">sql 语句</td><td align="left">sql</td><td align="left">Query DSL</td></tr><tr><td align="left">查询</td><td align="left">select * from table</td><td align="left">GET http:&#x2F;&#x2F;…</td></tr><tr><td align="left">更新</td><td align="left">update table set</td><td align="left">GET http:&#x2F;&#x2F;…</td></tr></tbody></table><ul><li>MySQL 中的数据库（DataBase），等价于 ES 中的索引（Index）。</li><li>MySQL 中一个数据库下面有 N 张表（Table），等价于 1 个索引 Index 下面有 N 多类型（Type）。</li><li>MySQL 中一个数据库表（Table）下的数据由多行（Row）多列（column，属性）组成，等价于 1 个 Type 由多个文档（Document）和多 Field 组成。</li><li>MySQL 中定义表结构、设定字段类型等价于 ES 中的 Mapping。举例说明，在一个关系型数据库里面，Schema 定义了表、每个表的字段，还有表和字段之间的关系。与之对应的，在 ES 中，Mapping 定义索引下的 Type 的字段处理规则，即索引如何建立、索引类型、是否保存原始索引 JSON 文档、是否压缩原始 JSON 文档、是否需要分词处理、如何进行分词处理等。</li><li>MySQL 中的增 insert、删 delete、改 update、查 search 操作等价于 ES 中的增 PUT&#x2F;POST、删 Delete、改 _update、查 GET。其中的修改指定条件的更新 update 等价于 ES 中的 update_by_query，指定条件的删除等价于 ES 中的 delete_by_query。</li><li>MySQL 中的 group by、avg、sum 等函数类似于 ES 中的 Aggregations 的部分特性。</li><li>MySQL 中的去重 distinct 类似 ES 中的 cardinality 操作。</li><li>MySQL 中的数据迁移等价于 ES 中的 reindex 操作。</li></ul><p>作者：<em>PhoenixWong</em><br>链接：<a href="https://juejin.cn/post/6844903938550939661">https://juejin.cn/post/6844903938550939661</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-your-data.html" target="_blank" >Search your data</a></p><h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html" target="_blank" >Query DSL</a></p><!-- ## 操作分类### 健康检测### 建立数据库### 建立表### 新增数据- 单条数据- 批量数据### 查询### 更新### 删除### 聚合 --><h2 id="go-elasticsearch"><a href="#go-elasticsearch" class="headerlink" title="go-elasticsearch"></a>go-elasticsearch</h2><p><a href="https://www.cnblogs.com/leimu/p/14699697.html" target="_blank" >go-elasticsearch</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://blog.csdn.net/qq330983778/category_9396656.html" target="_blank" >Elasticsearch 专栏</a></p><p><a href="https://learnku.com/docs/elasticsearch73/7.3" target="_blank" >Elasticsearch 中文文档 7.3 </a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/highlighting.html#highlighting" target="_blank" >Elasticsearch Guide: 8.5</a></p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 - 抽象相等比较</title>
      <link href="//post/2022-11-01%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83.html"/>
      <url>//post/2022-11-01%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本来是当一个很小的知识点来写的，发现越写越多，所以拆出来，单独做一篇文章，文章标题看上去很抽象</p><h2 id="js-关于-valueOf-和-toString"><a href="#js-关于-valueOf-和-toString" class="headerlink" title="js 关于 valueOf()和 toString()"></a>js 关于 valueOf()和 toString()</h2><p><a href="https://blog.csdn.net/qq_42960676/article/details/88975442" target="_blank" >js 关于 valueOf()和 toString()</a></p><p>链接内部有错误，</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; [];console.log(![]); &#x2F;&#x2F;false&#x2F;&#x2F; 注意[] &#x3D;&#x3D; false; &#x2F;&#x2F; true![]; &#x2F;&#x2F; false&#x2F;&#x2F; 上面不能推出：[] &#x3D;&#x3D; ![]; &#x2F;&#x2F; true[] !&#x3D; []; &#x2F;&#x2F; true&#x2F;&#x2F; 费脑子</code></pre><p>把下面的看完来分析下：</p><p><code>[] == false;</code>:</p><ol><li>对象与 boolean 比较，会将[]执行 ToPrimitive,</li><li>ToPrimitive 第一参数非 Date 第二参数默认是 number 类型，执行 [].valueOf,返回[]非基本数据类型，执行.toString 返回 <code>&#39;&#39;</code>，</li><li>转化成了：<code>字符串与false比较</code>,</li><li>都要转化成 number， 0 &#x3D;&#x3D; 0， 返回 true</li></ol><p><code>![]</code> 这个怎么理解了按照之前那种理解 !’’,就变成 true 了， 错了错了，，</p><ol><li>根据 Falsy 的规则, []是 true, ![]就是 false</li></ol><p><code>[] == ![];</code>,</p><ol><li>! 优先级高于比较运算符， ![] 转化成 boolean 是 false ,</li><li>对象和 false 比较，[].valueOf().toString() &#x3D;&#x3D; false, 也就是 ‘’ &#x3D;&#x3D;&#x3D; false,</li><li>都要转化成 number 类型 ToNumber(‘’) &#x3D;&#x3D;&#x3D; ToNumber(false),</li><li>0&#x3D;&#x3D;0 最终是 true</li></ol><p><code>[] != [];</code></p><p>满足抽象相等表格对角线比较，转化成 <code>[] !== []</code>,所以是 true</p><h2 id="严格等-x3D-x3D-x3D"><a href="#严格等-x3D-x3D-x3D" class="headerlink" title="严格等 &#x3D;&#x3D;&#x3D;"></a>严格等 &#x3D;&#x3D;&#x3D;</h2><ul><li>对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。</li><li>对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：<ul><li>第一个情况是，浮点数 0 是不分正负的。区分 +0 和 -0 在解决一些特定的数学问题时是必要的，但是大部分情况下我们并不用关心。全等操作符认为这两个值是全等的。</li><li>第二个情况是，浮点数包含了 NaN 值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为 NaN 与其他任何值都不全等，包括它自己</li></ul></li></ul><p><code>（等式 (x !== x) 成立的唯一情况是 x 的值为 NaN）</code> 我想说 MDN 写错了，</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 数值类型比较的才是值，单有NaN这个奇葩存在NaN !&#x3D;&#x3D; NaN &#x2F;&#x2F; true&#x2F;&#x2F; 引用数据类型比较的不是值，而是其引用[] !&#x3D;&#x3D; [] &#x2F;&#x2F; true&#123;&#125; !&#x3D;&#x3D; &#123;&#125; &#x2F;&#x2F; true</code></pre><h3 id="x3D-x3D-false-为什么是-true"><a href="#x3D-x3D-false-为什么是-true" class="headerlink" title="[]&#x3D;&#x3D;false 为什么是 true?"></a>[]&#x3D;&#x3D;false 为什么是 true?</h3><ol><li>首先因为 &#x3D;&#x3D; 号有强制转换功能，右边 false 先变为 0，而接下来左边先会执行[].valueOf()返回本身还是[]</li><li>因为执行 valueOf()不返回原始值（Number,String,Boolean,Underfined,Null),[]是个 Object，是引用类型，所以还会执行[].toString()方法返回” “，一个空字符串，最终空字符串在转换为 0，所以[]&#x3D;&#x3D;false，返回的是 true。</li></ol><h3 id="为什么会执行-valueOf-和-toString-他们又是什么东西？"><a href="#为什么会执行-valueOf-和-toString-他们又是什么东西？" class="headerlink" title="为什么会执行 valueOf()和 toString(),他们又是什么东西？"></a>为什么会执行 valueOf()和 toString(),他们又是什么东西？</h3><p>打印 Object 的 prototype 可以发现对象原型里有 valueOf()和 toString()这两个方法，数组也是对象所以说它也能调用这个方法</p><h3 id="那为什么会调用这个方法呢？"><a href="#那为什么会调用这个方法呢？" class="headerlink" title="那为什么会调用这个方法呢？"></a>那为什么会调用这个方法呢？</h3><p>涉及到：抽象相等比较算法</p><h2 id="抽象相等比较-x3D-x3D"><a href="#抽象相等比较-x3D-x3D" class="headerlink" title="抽象相等比较 &#x3D;&#x3D;"></a>抽象相等比较 &#x3D;&#x3D;</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E7%90%86%E8%A7%A3%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E7%9A%84%E6%A8%A1%E5%9E%8B" target="_blank" >表格内容出自 MDN,因为 MDN 有滚动，看着不方便，然后调整了下样式，这个截下来了</a></p><img src="http://t-blog-images.aijs.top/img/202211011432143.webp" /><p>在上面的表格中，</p><ul><li><code>ToNumber</code>(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符 +）的效果相同。</li><li><code>ToPrimitive</code>(A)通过尝试调用 A 的 A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。</li><li><code>IsFalsy</code>,充当效仿 undefined 的角色的对象会 <code>等于 undefined/null</code> 对应上文 <code>javascript Falsy</code></li></ul><h2 id="表格数据怎么看"><a href="#表格数据怎么看" class="headerlink" title="表格数据怎么看"></a>表格数据怎么看</h2><ol><li>横着看 图 1，看 undefined,null 两横行</li><li>看对角线 图 2，同类型比较，看严格等 &#x3D;&#x3D;&#x3D;</li><li>看对角线以下，<ul><li>number 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较,转化成 <code>number</code>,引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li><li>string 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较,转化成 <code>number</code>,引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li><li>boolean 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较转化成 <code>number</code>,引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li><li>引用 类型与其他类型（非 1,2）的 <code>es5 基本类型</code>比较，boolean 类型会转化成 <code>number</code>，引用类型使用 ToPrimitive 转化后比较 <strong>（here1）</strong></li><li><em>总结：对角线以下的比较，基本上都要转化成 number 进行比较，引用类型会使用 ToPrimitive 转化成基本数据类型， 中间过程中如果可以转化成对角线比较，直接进行 &#x3D;&#x3D;&#x3D;比较</em></li></ul></li><li><strong>（here1）</strong>位置，根据 ToPrimitive 在进行比较 ，ToPrimitive 是 number&#x2F;string 的，按照 number&#x2F;string 进行比较</li></ol><p>注意点:</p><ul><li>number 和 string，在与对象进行比较时候，并不是立即就转化的，要看 ToPrimitive 的执行结果，如果 ToPrimitive 转化结果刚好是同类型不用转化了，如果不是同类型，非 string,boolean 要转化成 number</li><li>这里排除了 Symbol 和 Bigint, 排除的原因 Symbol 在一些转化中，会报错，所以上文限制了 es5 基本数据类型</li></ul><p><strong>图 1 横着看</strong><br><img src="http://t-blog-images.aijs.top/img/202211011501993.webp" /></p><p><strong>图 2 看对角线</strong><br><img src="http://t-blog-images.aijs.top/img/202211011502410.webp" /></p><p><strong>一般而言，根据 ECMAScript 规范，</strong></p><ul><li>所有的对象都与 undefined 和 null 不相等。</li><li>但是大部分浏览器允许非常窄的一类对象（即，所有页面中的 <code>document.all</code> 对象），在某些情况下，<code>充当效仿 undefined 的角色</code>。</li><li>相等操作符就是在这样的一个背景下。因此，<code>IsFalsy(A) 方法的值为 true，当且仅当 A 效仿 undefined。</code></li><li>在其他所有情况下，一个对象都不会等于 undefined 或 null。</li></ul><p><strong>这幅图看上去很多，其实吧，背后的东西更多</strong></p><ol><li>Falsy</li><li>ToNumber</li><li>ToString</li><li>ToPrimitive</li></ol><h2 id="Falsy"><a href="#Falsy" class="headerlink" title="Falsy"></a>Falsy</h2><p>当 JavaScript 期望一个布尔值，并被给与下面值中的一个时，它总是会被当做 false。</p><table><thead><tr><th align="left">序号</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">undefined</td><td align="left">undefined - 原始值</td></tr><tr><td align="left">2</td><td align="left">null</td><td align="left">null - 缺少值</td></tr><tr><td align="left">3</td><td align="left">0 ,+0,-0, 0n, NaN</td><td align="left">数值 ,Bigint 0</td></tr><tr><td align="left">4</td><td align="left">“”,’’,&#96;&#96;</td><td align="left">空字符串</td></tr><tr><td align="left">5</td><td align="left">false</td><td align="left">false 关键字</td></tr></tbody></table><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><table><thead><tr><th align="left">input</th><th align="left">result</th></tr></thead><tbody><tr><td align="left">undefined</td><td align="left">NaN</td></tr><tr><td align="left">null</td><td align="left">+0</td></tr><tr><td align="left">boolean</td><td align="left">+0 或 1</td></tr><tr><td align="left">number</td><td align="left">不转换</td></tr><tr><td align="left">string</td><td align="left"><a href="https://tc39.es/ecma262/#sec-stringtonumber" target="_blank" >参照§7.1.3.1 </a></td></tr><tr><td align="left">symbol</td><td align="left">TypeError</td></tr><tr><td align="left">Bigint</td><td align="left">TypeError</td></tr><tr><td align="left">object</td><td align="left">ToNumber(ToPrimitive(input,Number))</td></tr></tbody></table><ol><li>把字符串转换成数字，不是简单地“去掉引号”，具体规则参照§7.1.3.1。</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Number(&quot;123&quot;); &#x2F;&#x2F;123Number(&quot;&quot;); &#x2F;&#x2F;0Number(&quot; 123 &quot;); &#x2F;&#x2F;123Number(&quot;a123&quot;); &#x2F;&#x2F;NaN</code></pre><ol start="2"><li>把 symbol 转换成数字，会直接抛出类型错误。</li><li>把对象转换成数字，会先进行 ToPrimitive(input,Number)，然后把得到的值进行转换</li></ol><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>注意：要和对象的.toString 方法区分开，这两个完全没关系</p><p><a href="https://tc39.es/ecma262/#sec-tostring" target="_blank" >https://tc39.es/ecma262/#sec-tostring</a></p><table><thead><tr><th align="left">input</th><th align="left">result</th></tr></thead><tbody><tr><td align="left">null</td><td align="left">‘null’</td></tr><tr><td align="left">undefined</td><td align="left">‘undefined’</td></tr><tr><td align="left">number</td><td align="left">Return Number::toString(argument, 10) 链接就不放了，打击人</td></tr><tr><td align="left">boolean</td><td align="left">‘true’或’false’</td></tr><tr><td align="left">string</td><td align="left">不转换</td></tr><tr><td align="left">symbol</td><td align="left">TypeError</td></tr><tr><td align="left">symbol</td><td align="left">Return BigInt::toString(argument, 10) 链接就不放了，打击人</td></tr><tr><td align="left">object</td><td align="left">ToString(ToPrimitive(input,String))</td></tr></tbody></table><h2 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ToPrimitive apiToPrimitive(input [, PreferredType])</code></pre><table><thead><tr><th align="left">inputTpye</th><th align="left">result</th></tr></thead><tbody><tr><td align="left">Null</td><td align="left">不转换，直接返回</td></tr><tr><td align="left">Undefined</td><td align="left">不转换，直接返回</td></tr><tr><td align="left">Number</td><td align="left">不转换，直接返回</td></tr><tr><td align="left">Boolean</td><td align="left">不转换，直接返回</td></tr><tr><td align="left">String</td><td align="left">不转换，直接返回</td></tr><tr><td align="left">Symbol</td><td align="left">不转换，直接返回</td></tr><tr><td align="left">Object</td><td align="left">按照下列步骤进行转换</td></tr></tbody></table><p>在没有改写或自定义@@toPrimitive 方法的条件下，</p><ul><li>如果是 Date 求原值，则 PreferredType 是 String，其他均为 Number。</li><li>PreferredType 是 <code>String</code>，则<code>先调用 toString()</code>，<code>结果不是原始值的话再调用 valueOf()</code>，还不是原始值的话则抛出错误；</li><li>PreferredType 是 <code>Number</code>，则<code> 先调用 valueOf()</code>,<code>结果不是原始值的话再调用 toString() </code>，还不是原始值的话则抛出错误；</li></ul><h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符+"></a>一元运算符+</h2><p>一元运算符“+”是用来把目标转化成数字类型的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; UnaryExpression: +UnaryExpression;</code></pre><ol><li>把 UnaryExpression 的 result 赋值给 expr</li><li>返回 ToNumber(GetValue(expr)).</li></ol><p>在一元“+”运算过程中，把目标直接转化成数字类型。一共涉及了一个方法：ToNumber()。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">+[]; &#x2F;&#x2F; 0&#x2F;&#x2F; 转化过程&#x2F;&#x2F; 1. [] 执行ToPrimitive([], &#39;number&#39;)&#x2F;&#x2F; 2. 首先会执行[].valueOf(),返回 []，不是基本数据类型，&#x2F;&#x2F; 执行 [].toString() 返回 &#39;&#39;， 是基本数据类型返回 &#39;&#39;&#x2F;&#x2F; +&#39;&#39; &#x3D;&gt; 0 ，所以结果为0</code></pre><h2 id="装箱-x2F-拆箱"><a href="#装箱-x2F-拆箱" class="headerlink" title="装箱&#x2F;拆箱"></a>装箱&#x2F;拆箱</h2><p><a href="https://juejin.cn/post/6844903859765133320" target="_blank" >见</a></p><h3 id="ecma-文档"><a href="#ecma-文档" class="headerlink" title="ecma 文档"></a>ecma 文档</h3><p>还是别看了吧，不建议去看</p><p><a href="https://tc39.es/ecma262/#table-toboolean-conversions" target="_blank" >抽象操作</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#%E7%90%86%E8%A7%A3%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E7%9A%84%E6%A8%A1%E5%9E%8B" target="_blank" >JavaScript 中的相等性判断</a></p><p><a href="https://sinaad.github.io/xfe/2016/04/15/ToPrimitive/" target="_blank" >js 隐式装箱-ToPrimitive</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 技巧</title>
      <link href="//post/2022-10-31js%E6%8A%80%E5%B7%A7.html"/>
      <url>//post/2022-10-31js%E6%8A%80%E5%B7%A7.html</url>
      
        <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://onelk.cn/article/5MJ6LPNR8WX78Q0O" target="_blank" >2022 年你需要了解的 13 种 JavaScript 代码技巧</a></p><p><a href="https://onelk.cn/article/59X0RGWORWL16YE3" target="_blank" >如何用一行 CSS 实现 10 种现代布局</a></p><p><a href="https://1linelayouts.glitch.me/" target="_blank" >https://1linelayouts.glitch.me/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go knife</title>
      <link href="//post/2022-10-31go-knife.html"/>
      <url>//post/2022-10-31go-knife.html</url>
      
        <content type="html"><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><img src="http://t-blog-images.aijs.top/img/202210311134749.webp" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/501477368" target="_blank" >参考</a></p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><pre class="line-numbers language-none"><code class="language-none">mkdir srctouch main.gogo mod init go-localizego mod tidymkdir config controller dao middleware model router service tmp util constant internet...</code></pre><h2 id="air"><a href="#air" class="headerlink" title="air"></a>air</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/cosmtrek/air/issues/135" target="_blank" >参考 issues 135</a></p><pre class="line-numbers language-none"><code class="language-none">$ curl -sSfL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;cosmtrek&#x2F;air&#x2F;master&#x2F;install.sh | sh -s -- -b $(go env GOPATH)&#x2F;bin$ air -v---&#x2F; &#x2F;\ | | | |_)&#x2F;_&#x2F;--\ |_| |_| \_ 1.40.4, built with Go 1.18.3</code></pre><h3 id="配置-alias"><a href="#配置-alias" class="headerlink" title="配置 alias"></a>配置 alias</h3><pre class="line-numbers language-none"><code class="language-none">alias air&#x3D;&#39;$(go env GOPATH)&#x2F;bin&#x2F;air&#39;</code></pre><p>注意：比较奇怪的是 air -v 可输出， air 命令颜色为红色， 非绿色</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>注意：终端需要重启</p><pre class="line-numbers language-none"><code class="language-none">最简单的方法是执行# 优先在当前路径查找 &#96;.air.toml&#96; 后缀的文件，如果没有找到，则使用默认的air -c .air.toml您可以运行以下命令初始化，把默认配置添加到当前路径下的.air.toml 文件。air init在这之后，你只需执行 air 命令，无需添加额外的变量，它就能使用 .air.toml 文件中的配置了。air</code></pre><h2 id="出错了"><a href="#出错了" class="headerlink" title="出错了"></a>出错了</h2><p>写了 you.go 文件，空文件，没有写 package</p><pre class="line-numbers language-none"><code class="language-none">♠ &#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize $ air  __    _   ___ &#x2F; &#x2F;\  | | | |_)&#x2F;_&#x2F;--\ |_| |_| \_ 1.40.4, built with Go 1.18.3watching .watching configwatching controllerwatching controller&#x2F;v1watching daowatching middlewarewatching modelwatching routerwatching service!exclude tmpwatching utilbuilding...controller&#x2F;v1&#x2F;you.go:1:1: expected &#39;package&#39;, found &#39;EOF&#39;failed to build, error: exit status 1</code></pre><h3 id="起来了"><a href="#起来了" class="headerlink" title="起来了"></a>起来了</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">♠ &#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize $ air  __    _   ___ &#x2F; &#x2F;\  | | | |_)&#x2F;_&#x2F;--\ |_| |_| \_ 1.40.4, built with Go 1.18.3watching .watching configwatching controllerwatching controller&#x2F;v1watching daowatching middlewarewatching modelwatching routerwatching service!exclude tmpwatching utilbuilding...running...[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production. - using env:   export GIN_MODE&#x3D;release - using code:  gin.SetMode(gin.ReleaseMode)[GIN-debug] GET    &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.GetMe (3 handlers)[GIN-debug] POST   &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.PostMe (3 handlers)[GIN-debug] PUT    &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.PutMe (3 handlers)[GIN-debug] DELETE &#x2F;api&#x2F;me                   --&gt; go-localize&#x2F;controller&#x2F;v1.DeleteMe (3 handlers)[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.Please check https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;gin-gonic&#x2F;gin#readme-don-t-trust-all-proxies for details.[GIN-debug] Listening and serving HTTP on :8001</code></pre><h2 id="重启耗时如何查看？"><a href="#重启耗时如何查看？" class="headerlink" title="重启耗时如何查看？"></a>重启耗时如何查看？</h2><p>监听文件有点多，应该需要限制下范围</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">[GIN-debug] Listening and serving HTTP on :8001event: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: CHMODevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: WRITEevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: CHMODevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: WRITEevent: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;go&#x2F;go-localize&#x2F;README.md&quot;: CHMOD</code></pre><h3 id="文件范围缩小"><a href="#文件范围缩小" class="headerlink" title="文件范围缩小"></a>文件范围缩小</h3><p>创建文件夹，将所有代码移动到 src 目录下，监听 src 目录</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; .air.tomlroot &#x3D; &quot;.&#x2F;src&quot;</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 空文件夹上传find .&#x2F; -type d -empty -execdir touch &#123;&#125;&#x2F;.gitkeep &#123;&#125; \;git initgit add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:841660202&#x2F;go-localize.gitgit push -u origin main</code></pre><h2 id="gin"><a href="#gin" class="headerlink" title="gin"></a>gin</h2><h2 id="swag"><a href="#swag" class="headerlink" title="swag"></a>swag</h2><h3 id="安装-swag"><a href="#安装-swag" class="headerlink" title="安装 swag"></a>安装 swag</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 1. 安装 swagger&#x2F;&#x2F; go install github.com&#x2F;swaggo&#x2F;swag&#x2F;cmd&#x2F;swag@latest&#x2F;&#x2F; 2. 配置~&#x2F;.zshrc  注意：引号 github 上引号没写&#x2F;&#x2F; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;swaggo&#x2F;swag&#x2F;issues&#x2F;197&quot; target&#x3D;&quot;_blank&quot; &gt;issues197&lt;&#x2F;a&gt;&#x2F;&#x2F; export PATH&#x3D;&quot;$(go env GOPATH)&#x2F;bin:$PATH&quot;&#x2F;&#x2F; $ swag -v&#x2F;&#x2F; swag version v1.8.7&#x2F;&#x2F; swag init  &#x2F;&#x2F; 注意，一定要和main.go处于同一级目录&#x2F;&#x2F; 访问地址&#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8080&#x2F;swagger&#x2F;index.html</code></pre><h2 id="knife"><a href="#knife" class="headerlink" title="knife"></a>knife</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：必须要有@ID 注解，生成 operationId，点击菜单才能正常打开<br>id 用于标识操作的唯一字符串。在所有 API 操作中必须唯一。</p></div><p><a href="https://github.com/swaggo/swag/pull/732" target="_blank" >&#x2F;swaggo&#x2F;swag&#x2F;pull&#x2F;732</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 访问链接&#x2F;&#x2F; http:&#x2F;&#x2F;localhost:8080&#x2F;knife&#x2F;doc.html#&#x2F;home</code></pre><p><a href="https://gitee.com/youbeiwuhuan/knife4go#https://gitee.com/xiaoym/knife4j" target="_blank" >参考</a></p><h3 id="knife-优化点"><a href="#knife-优化点" class="headerlink" title="knife 优化点"></a>knife 优化点</h3><ul><li>刷新页面，菜单没默认打开对应的链接</li><li>复制接口&#x2F;文档&#x2F;地址，点击一次提示两次</li><li>后续：自动生成前端代码</li></ul><h3 id="gin-knife-例子"><a href="#gin-knife-例子" class="headerlink" title="gin knife 例子"></a>gin knife 例子</h3><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：必须要有@ID 注解，生成 operationId，点击菜单才能正常打开<br>id 用于标识操作的唯一字符串。在所有 API 操作中必须唯一。</p></div><p><a href="https://github.com/swaggo/swag/blob/master/example/celler/main.go" target="_blank" >&#x2F;swaggo&#x2F;swag</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 知识积累</title>
      <link href="//post/2022-10-29go-proj.html"/>
      <url>//post/2022-10-29go-proj.html</url>
      
        <content type="html"><![CDATA[<h2 id="strconv"><a href="#strconv" class="headerlink" title="strconv"></a>strconv</h2><p><a href="https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/strconv.html" target="_blank" >见</a></p><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p><a href="http://c.biancheng.net/view/108.html" target="_blank" >http://c.biancheng.net/view/108.html</a></p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; redisgo get github.com&#x2F;go-redis&#x2F;redis&#x2F;&#x2F; .inigo get gopkg.in&#x2F;ini.v1 v1.64.0&#x2F;&#x2F; gormgo get github.com&#x2F;jinzhu&#x2F;gorm&#x2F;&#x2F; gingo get github.com&#x2F;gin-gonic&#x2F;gin&#x2F;&#x2F; jwtgo get github.com&#x2F;dgri.jalva&#x2F;jwt-go&#x2F;&#x2F; loggo get github.com&#x2F;sirupsen&#x2F;logrus&#x2F;&#x2F; 参数绑定&#x2F;&#x2F; 验证器&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;go-playground&#x2F;validator&#x2F;&#x2F; [学会使用validator库，看这一篇就够用了](https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;194319694)&#x2F;&#x2F; favicongo get github.com&#x2F;thinkerou&#x2F;favicon&#x2F;&#x2F; knife4go&#x2F;&#x2F; https:&#x2F;&#x2F;gitee.com&#x2F;youbeiwuhuan&#x2F;knife4go#https:&#x2F;&#x2F;gitee.com&#x2F;xiaoym&#x2F;knife4j&#x2F;&#x2F; uuid&#x2F;&#x2F; github.com&#x2F;gofrs&#x2F;uuid&#x2F;&#x2F; example https:&#x2F;&#x2F;github.com&#x2F;swaggo&#x2F;swag&#x2F;blob&#x2F;master&#x2F;example&#x2F;celler&#x2F;model&#x2F;account.go&#x2F;&#x2F;gojson, 有什么用？前后端约定好字段，生成结构体？&#x2F;&#x2F; gojson generates go struct definitions from json or yaml documents.&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ChimeraCoder&#x2F;gojson&#x2F;&#x2F; 在线转化&#x2F;&#x2F; https:&#x2F;&#x2F;mholt.github.io&#x2F;json-to-go&#x2F;</code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/CocaineCong/gin-mall">https://github.com/CocaineCong/gin-mall</a><img src="https://img.shields.io/github/stars/CocaineCong/gin-mall?style=social" /></div><h2 id="刷课程"><a href="#刷课程" class="headerlink" title="刷课程"></a>刷课程</h2><p><a href="https://www.bilibili.com/video/BV1WT411w7HN" target="_blank" >go 重点语法</a></p><p><a href="https://www.bilibili.com/video/BV1t54y1v78Q" target="_blank" >Gin 框架全套实战</a></p><p><a href="https://www.bilibili.com/video/BV1Zd4y1U7D8" target="_blank" >【Go 语言 web 开发】经典项目电子商城</a></p><p><a href="https://blog.csdn.net/xiexingshishu/article/details/124540777" target="_blank" >go 包</a></p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://www.topgoer.com/%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9.html" target="_blank" >&#x2F;资料下载&#x2F;零碎知识点.html</a></p><h2 id="elastic"><a href="#elastic" class="headerlink" title="elastic"></a>elastic</h2><p>Elasticsearch 全文检索数据库</p><ul><li>分布式、高扩展、近实时的搜索引擎，主要用于海量数据快速存储，实时检索，高效分析的场景</li><li>通过简单易用的 RESTful API，隐藏 Lucene 的复杂性，让全文搜索变得简单</li><li>ES 不是什么新技术，主要是将全文检索、数据分析以及分布式技术结合在一起，形成了独一无二的 ES；</li></ul><p><a href="http://t.zoukankan.com/xiao-xue-di-p-14429881.html" target="_blank" ></a><br><a href="https://blog.csdn.net/K346K346/article/details/119223766" target="_blank" >Go Elasticsearch 快速入门</a></p><h2 id="爬取-CSDN-专栏"><a href="#爬取-CSDN-专栏" class="headerlink" title="爬取 CSDN 专栏"></a>爬取 CSDN 专栏</h2><p><a href="https://dablelv.blog.csdn.net/article/details/124263167" target="_blank">Elasticsearch 基本概念</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/123431410" target="_blank">Elasticsearch 简介</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/123213483" target="_blank">Go Elasticsearch index CRUD</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/121398229" target="_blank">Go Elasticsearch 删除快速入门</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/121396060" target="_blank">Go Elasticsearch 更新快速入门</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/120981171" target="_blank">Go Elasticsearch 增加快速入门</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/120906440" target="_blank">Go Elasticsearch 查询快速入门</a></p><p><a href="https://dablelv.blog.csdn.net/article/details/119223766" target="_blank">Go Elasticsearch 快速入门</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var data &#x3D; &quot;&quot;;Array.prototype.slice  .call(document.getElementsByClassName(&quot;column_article_list&quot;))  .forEach((ul) &#x3D;&gt; &#123;    Array.from(ul.children).forEach((li) &#x3D;&gt; &#123;      var a &#x3D; li.children[0];      console.log(a);      var href &#x3D; a.href;      var title &#x3D; a.getElementsByClassName(&quot;title&quot;)[0].innerText;      var astr &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;href&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;title&#125;&lt;&#x2F;a&gt; \n\n&#96;;      data +&#x3D; astr;    &#125;);  &#125;);copy(data); &#x2F;&#x2F;控制台直接拷贝到剪切板</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextjs13 turbopack</title>
      <link href="//post/2022-10-28nextjs13.html"/>
      <url>//post/2022-10-28nextjs13.html</url>
      
        <content type="html"><![CDATA[<h2 id="官方链接"><a href="#官方链接" class="headerlink" title="官方链接"></a>官方链接</h2><p><a href="https://turbo.build/" target="_blank" >https://turbo.build/</a></p><p><a href="https://nextjs.org/" target="_blank" >https://nextjs.org/</a></p><h2 id="比较一组数据"><a href="#比较一组数据" class="headerlink" title="比较一组数据"></a>比较一组数据</h2><div style="display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;"> <div style="flex:1 1 0;"> <p style="height: 50px"> 1000个组件量级，启动</p> <img src="http://t-blog-images.aijs.top/img/202210281455133.webp" style="width:300px" /> </div> <div style="width: 10px"></div> <div style="flex:1 1 0"> <p style="height: 50px">10000个组件量级，文件变动</p><img src="http://t-blog-images.aijs.top/img/202210281456033.webp" style="width:300px" /> </div></div><p>实际开发中，组件个数可能远超过 10000</p><p>从结果来看 vite 还强，速度快不是 next.js13 多牛叉，技术基本上早就成型，而是因为背靠 turbopack，想想 vite 诞生对 vue 的支持力度较大，react 资源较少，不过也够用的了，在<a href="/#/post/2022-09-07vite-react" target="_blank" >2022-09-07vite-react</a> 公司线上项目试了，确实快乐很多。</p><p>现在 next.js13 内置，turbopack，想想也带劲，公司一直在用 next.js 进行项目开发，在内部还整了个前端基建。那速度，使用过的同事，都能体会龟速，被喷的不要不要的，比自己搭建的还慢,有些部门直接弃用</p><p>尤其是公司内部 wiki 编辑器的集成。直接导致，整个项目间歇式工作， Mac 8G 内存， CPU 给你顶飞</p><p>现在，重拾信心，毕竟服务端渲染 SEO 的优势摆在那的</p><h2 id="体验一把"><a href="#体验一把" class="headerlink" title="体验一把"></a>体验一把</h2><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动 1"></a>启动 1</h3><pre class="line-numbers language-none"><code class="language-none">👑 ~&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app git:(main) $ pn dev&gt; my-app@0.1.0 dev &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app&gt; next devwarn  - Port 3000 is in use, trying 3001 instead.warn  - Port 3001 is in use, trying 3002 instead.ready - started server on 0.0.0.0:3002, url: http:&#x2F;&#x2F;localhost:3002event - compiled client and server successfully in 2.1s (150 modules)wait  - compiling...event - compiled client and server successfully in 161 ms (150 modules)</code></pre><p>哎呦我去～，这么久，配个端口重来</p><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动 2"></a>启动 2</h3><p>电脑启动多个项目，端口占用了，重来～</p><pre class="line-numbers language-none"><code class="language-none">👑 ~&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app git:(main) ✗ $ pn dev&gt; my-app@0.1.0 dev &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app&gt; next dev --port 3005ready - started server on 0.0.0.0:3005, url: http:&#x2F;&#x2F;localhost:3005event - compiled client and server successfully in 812 ms (150 modules)</code></pre><h3 id="总感觉怪怪的"><a href="#总感觉怪怪的" class="headerlink" title="总感觉怪怪的"></a>总感觉怪怪的</h3><p>查看了下根目录下生成的.next，在<code>.next/cache/</code>下依然是 <code>webpack</code></p><img src="http://t-blog-images.aijs.top/img/202210281836675.webp" style="width: 200px;" /><p>被骗了吗？，不应该啊</p><h3 id="这才是正确姿势"><a href="#这才是正确姿势" class="headerlink" title="这才是正确姿势"></a>这才是正确姿势</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pn turbo&gt; my-app@0.1.0 turbo &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;nextjs13&#x2F;my-app&gt; next dev --turbo --port 3005&gt;&gt;&gt; TURBOPACK (alpha)Thank you for trying Next.js v13 with Turbopack! As a reminder,Turbopack is currently in alpha and not yet ready for production.We appreciate your ongoing support as we work to make it readyfor everyone.Warning: You are using configuration that may require additionalsetup with Turbopack. If you already made these changes pleaseignore this warning.- PostCSS detected (postcss.config.js)  PostCSS is not yet supported by Next.js v13 with Turbopack.  To use with Turbopack, see: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-postcss- Tailwind detected (tailwind.config.js)  Tailwind is not yet supported by Next.js v13 with Turbopack.  To use with Turbopack, see: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-tailwindLearn more about Next.js v13 and Turbopack: https:&#x2F;&#x2F;nextjs.link&#x2F;with-turbopackPlease direct feedback to: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-feedbackready - started server on 0.0.0.0:3005, url: http:&#x2F;&#x2F;localhost:3005event - initial compilation 5.974mserror - [rendering] [root of the dev server]&#x2F;  Error during SSR Rendering  timed out waiting for the Node.js process to connectevent - updated in 2125msevent - updated in 1521ms</code></pre><h3 id="报错了跑不起来-升级-nodejs-16"><a href="#报错了跑不起来-升级-nodejs-16" class="headerlink" title="报错了跑不起来 升级 nodejs 16+"></a>报错了跑不起来 升级 nodejs 16+</h3><p><a href="https://nextjs.org/blog/next-13#introducing-turbopack-alpha:~:text=The%20minimum%20Node.js%20version%20has%20been%20bumped%20from%2012.22.0%20to%2014.6.0%2C%20since%2012.x%20has%20reached%20end%2Dof%2Dlife%20(PR)." target="_blank" >nextjs 官方 blog 只说了：The minimum Node.js version has been bumped from 12.22.0 to 14.6.0, since 12.x has reached end-of-life (PR).</a><br><a href="https://github.com/vercel/next.js/issues/41859" target="_blank" >issue 41859</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo nPassword:   installed : v16.13.1 (with npm 8.1.2)</code></pre><h3 id="next-js-图片报错"><a href="#next-js-图片报错" class="headerlink" title="next.js 图片报错"></a>next.js 图片报错</h3><p>应该是 turbo 的原因导致的，没用之前正常</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; next.config.js&#x2F;** @type &#123;import(&#39;next&#39;).NextConfig&#125; *&#x2F;const nextConfig &#x3D; &#123;  reactStrictMode: true,  swcMinify: true,  images: &#123;    remotePatterns: [      &#123;        protocol: &quot;https&quot;,        hostname: &quot;images.unsplash.com&quot;,        port: &quot;&quot;,        pathname: &quot;&#x2F;**&#x2F;*&quot;,      &#125;,    ],  &#125;,&#125;;module.exports &#x3D; nextConfig;</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><a href="https://nextjs.org/blog/next-13#breaking-changes" target="_blank" >next-13#breaking-changes</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>The next&#x2F;image import was renamed to next&#x2F;legacy&#x2F;image. The next&#x2F;future&#x2F;image import was renamed to next&#x2F;image. A codemod is available to safely and automatically rename your imports.</p></blockquote><h3 id="tailwind-css-全部失效"><a href="#tailwind-css-全部失效" class="headerlink" title="tailwind css 全部失效"></a>tailwind css 全部失效</h3><p>目前还不支持</p><pre class="line-numbers language-none"><code class="language-none">- PostCSS detected (postcss.config.js)  PostCSS is not yet supported by Next.js v13 with Turbopack.  To use with Turbopack, see: https:&#x2F;&#x2F;nextjs.link&#x2F;turbopack-postcss</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>next.js13 turbo 问题还不少，暂时不适合用到正式项目</li><li>正如开头说的，没有 turbo 的 next.js13 速度还是慢</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-移动端适配</title>
      <link href="//post/2022-10-28%E7%A7%BB%E5%8A%A8%E9%80%82%E9%85%8D.html"/>
      <url>//post/2022-10-28%E7%A7%BB%E5%8A%A8%E9%80%82%E9%85%8D.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/819c57372beb" target="_blank" >网易精品课移动端适配方案</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-设计模式</title>
      <link href="//post/2022-10-27%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>//post/2022-10-27%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="旧文章链接"><a href="#旧文章链接" class="headerlink" title="旧文章链接"></a>旧文章链接</h2><p><a href="post/2022-07-18设计模式" target="_blank" >post&#x2F;2022-07-18 设计模式</a></p><h2 id="《JavaScript-设计模式与开发实践》"><a href="#《JavaScript-设计模式与开发实践》" class="headerlink" title="《JavaScript 设计模式与开发实践》"></a>《JavaScript 设计模式与开发实践》</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用</p><p>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性</p><h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><p>学习设计模式，有助于写出<code>可复用和可维护性高</code>的程序</p><h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><p>设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构</p><h2 id="创建型模式-5"><a href="#创建型模式-5" class="headerlink" title="创建型模式 5"></a>创建型模式 5</h2><h3 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h3><ul><li><p>工厂模式：将创建对象的过程单独封装</p></li><li><p>使用场景：有构造函数的地方、写了大量构造函数、调用了大量的 new 的情况下</p><p><a href="https://zhuanlan.zhihu.com/p/93291550" target="_blank" >见</a></p></li></ul><h3 id="二、抽象工厂模式"><a href="#二、抽象工厂模式" class="headerlink" title="二、抽象工厂模式"></a>二、抽象工厂模式</h3><h4 id="工厂模式与抽象工厂模式区别"><a href="#工厂模式与抽象工厂模式区别" class="headerlink" title="工厂模式与抽象工厂模式区别"></a>工厂模式与抽象工厂模式区别</h4><p>抽象工厂（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性<br>具体工厂（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</p><p><a href="https://zhuanlan.zhihu.com/p/93416391" target="_blank" >见</a></p><h3 id="三、单例模式"><a href="#三、单例模式" class="headerlink" title="三、单例模式"></a>三、单例模式</h3><ul><li><em>定义：</em>保证一个类仅有一个实例，并提供一个访问它的全局访问点</li><li><em>核心：</em>确保只有一个实例，并提供全局访问</li><li>实现单例的方式：<code>单例函数</code>, <code>类的构造方法</code> ,<code>类的静态方法</code></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 提取出通用的单例function getSingleton(fn) &#123;  var instance &#x3D; null;  return function () &#123;    if (!instance) &#123;      instance &#x3D; fn.apply(this, arguments);    &#125;    return instance;  &#125;;&#125;&#x2F;&#x2F; 通过构造函数class Singleton &#123;  &#x2F;&#x2F; static instance; 加不加都可，类中可以直接赋值和获取静态属性  constructor() &#123;    if (!Singleton.instance) &#123;      &#x2F;&#x2F; 将 this 挂载到单例上      Singleton.instance &#x3D; this; &#x2F;&#x2F; this，是新创建的对象，new关键字原理中，this指向new出的对象    &#125;    return Singleton.instance;  &#125;&#125;const a &#x3D; new Singleton();const b &#x3D; new Singleton();console.log(a &#x3D;&#x3D;&#x3D; b);&#x2F;&#x2F;  通过静态方法class Singleton &#123;  static instance &#x3D; null;  static getInstance() &#123;    if (!Singleton.instance) &#123;      Singleton.instance &#x3D; new Singleton();    &#125;    return Singleton.instance;  &#125;&#125;const a &#x3D; Singleton.getInstance();const b &#x3D; Singleton.getInstance();console.log(a &#x3D;&#x3D;&#x3D; b);</code></pre><p><a href="/#/post/2022-09-19qa" target="_blank" >&#x2F;#&#x2F;post&#x2F;2022-09-19qa</a></p><h3 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h3><h3 id="五、原型模式"><a href="#五、原型模式" class="headerlink" title="五、原型模式"></a>五、原型模式</h3><p><a href="https://zhuanlan.zhihu.com/p/94104346" target="_blank" >见</a> <a href="https://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" >见</a></p><ul><li>为什么出现：直接创建对象代价较大，所以采用这种模式</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。 - <code>对象会记住它的原型</code>。</li><li>原型模式是用于创建对象的一种模式。我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象</li><li>注意：使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据&#x2F;方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的</li><li>JavaScript <code>本身是一门基于原型的面向对象语言</code>，<code>Object.create</code> 方法就是原型模式的天然实现—––准确地说，只要我们还在借助 Prototype 来实现对象的创建和原型的继承，那么我们就是在应用原型模式</li><li>当对象 a 需 要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的 效果，<code>Object.create</code>的原理体现</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj &#x3D; &#123; name: &quot;zyy&quot; &#125;;var A &#x3D; function () &#123;&#125;;A.prototype &#x3D; obj;var a &#x3D; new A();&#x2F;&#x2F;a.name &#x3D; zyy&#x2F;&#x2F; 执行这段代码的时候，引擎做的事：&#x2F;&#x2F; 1. 尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。&#x2F;&#x2F; 2. 查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.proto 记录着并且指向 A.prototype，而 A.prototype 被设置为对象 obj。&#x2F;&#x2F; 3. 在对象 obj 中找到了 name 属性，并返回它的值。&#x2F;&#x2F; 提问自测&#x2F;&#x2F; 1、为什么说 ES6 的 Class 只是语法糖&#x2F;&#x2F; 起源上说，JavaScript是基于原型的面向对象系统。而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来， 一个对象是通过克隆另外一个对象所得到的。&#x2F;&#x2F; ES6的 Class 语法,让 JavaScript 看起来像是一门基于类的语言，但其背后仍是通过原型机制来创建对象。&#x2F;&#x2F; 2、上面使用了new A() ，所以A属于类吗？&#x2F;&#x2F; 在这里 A 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。&#x2F;&#x2F; 3、存在没有原型的对象吗？&#x2F;&#x2F; 通过设置构造器的 prototype 来实现原型继承的时候，除了根对象 Object.prototype 本身之外，任何对象都会有一个 原型。而通过 Object.create( null )可以创建出没有原型的对象。</code></pre><h2 id="结构型模式-8"><a href="#结构型模式-8" class="headerlink" title="结构型模式 8"></a>结构型模式 8</h2><h3 id="适配器模式-“包装模式”"><a href="#适配器模式-“包装模式”" class="headerlink" title="适配器模式 “包装模式”"></a>适配器模式 “包装模式”</h3><p>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实 现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够 使它们协同作用。</p><p>个人总结场景：之前一种设计，后来想到了一种更好的设计，要让现在的兼容之前的，并且只保留一份同等功能的代码，就需要在两种设计之间增加适配器</p><p><a href="https://juejin.cn/post/6962470884527308836" target="_blank" >javascript 设计模式之适配器模式</a></p><h3 id="装饰器模式-“包装模式”"><a href="#装饰器模式-“包装模式”" class="headerlink" title="装饰器模式 “包装模式”"></a>装饰器模式 “包装模式”</h3><ul><li>解决问题：继承会破坏封装性，装饰器模式，比起继承，更具有封装型</li><li>ES7 中的 decorator 同样借鉴了这个语法糖，不过依赖于 ES5 的 Object.defineProperty 方法</li><li>装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>给对象动态地增加职责的方式称为装 饰器(decorator)模式。装饰器模式能够在不改 变对象自身的基础上，在程序运行期间给对象 动态地添加职责。</p></blockquote><p>ES7 为我们提供了语法糖可以给一个类装上装饰器，继续改造上面的代码</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 装饰器函数，它的第一个参数是目标类function Decorator(target) &#123;    target.control &#x3D; function() &#123;        console.log(&#39;我是新的逻辑&#39;)    &#125;    return target&#125;&#x2F;&#x2F; 将装饰器“安装” 到HorribleCode上@Decoratorclass HorribleCode () &#123;    &#x2F;&#x2F;老代码逻辑&#125;HorribleCode.control()</code></pre><h3 id="过滤器模式-x2F-标准模式-x2F-挑三拣四"><a href="#过滤器模式-x2F-标准模式-x2F-挑三拣四" class="headerlink" title="过滤器模式&#x2F;标准模式&#x2F;挑三拣四"></a>过滤器模式&#x2F;标准模式&#x2F;挑三拣四</h3><p>目的：使用不同标准来过滤一组对象<br>实现：制定不同的规则来实现过滤，然后对过滤结果进行分组<br><a href="https://cloud.tencent.com/developer/article/1663903" target="_blank" >见</a></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>抽象部分与实现部分的分离，使得二者可以独立的变化，而不必拘泥于形式</p><p>在封装开源库的组件时候，经常会用到这种设计模式。</p><p>例如，对外提供暴露一个 complete 函数,<br>如果用户有传入此函数, 那么就会在某一段代码逻辑中调用。</p><p>这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。</p><p>JavaScript 中桥接模式的典型应用是：Array 对象上的 forEach 函数。</p><p>使用场景：</p><ol><li>最简单模拟 forEach 方法：</li><li>桥接模式在事件监听中的应用 <code>elem.addEventListener(&#39;click&#39;, getBeerByIdBridge, false);</code></li><li>桥接模式用于组件开发</li></ol><p>作者：Sky 飞羽<br>链接：<a href="https://www.jianshu.com/p/ceb82afe828d">https://www.jianshu.com/p/ceb82afe828d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="代理模式-“包装模式”"><a href="#代理模式-“包装模式”" class="headerlink" title="代理模式 “包装模式”"></a>代理模式 “包装模式”</h3><ul><li>作用：实现访问主体的控制，简单来说就是增加了一层，进行访问控制</li><li>三种：<code>保护代理</code>,<code>虚拟代理</code>,<code>缓存代理</code></li></ul><h3 id="组合模式-x2F-部分整体模式"><a href="#组合模式-x2F-部分整体模式" class="headerlink" title="组合模式&#x2F;部分整体模式"></a>组合模式&#x2F;部分整体模式</h3><ul><li>用相同的方式处理一组相似对象 例如： 文件目录显示，多级目录呈现等树形结构数据的操作</li></ul><p><a href="https://segmentfault.com/a/1190000019773556" target="_blank" >见</a></p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><ul><li>一种用于性能优化的模式，它的目标是尽量减少共享对象的数量</li><li>内部共享，外部剥离(能够共用的封装在能不，不能够共用的封装在外部)</li></ul><p><a href="https://www.yisu.com/zixun/186653.html" target="_blank" >见</a></p><h3 id="外观模式（模块化开发）"><a href="#外观模式（模块化开发）" class="headerlink" title="外观模式（模块化开发）"></a>外观模式（模块化开发）</h3><ul><li>增加一层，让从外部看来，像是一个（一致对外）</li><li>使用：模块汇总后统一导出</li></ul><p><a href="https://segmentfault.com/a/1190000014132789" target="_blank" >见</a></p><h2 id="行为型模式-10"><a href="#行为型模式-10" class="headerlink" title="行为型模式 10"></a>行为型模式 10</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><ul><li>为请求创建了一个接收者对象的链。多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。</li><li>这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止</li><li>使用场景：不同日志输出&#x2F;记录</li><li>区别于过滤模式，过滤是满足就执行，责任链模式：满足执行并终止</li></ul><p><a href="https://www.jianshu.com/p/53b0e70f6cd2" target="_blank" >见</a></p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li>用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系</li></ul><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><ul><li>这个比较难理解</li></ul><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><ul><li>在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素</li><li>在 javascript 中，实现了<code>[Symbol.iterator]属性的类数组，返回一个函数，就可以使用迭代器</code></li></ul><p><a href="https://zhuanlan.zhihu.com/p/97025000" target="_blank" >JavaScript 设计模式（九）-迭代器模式</a><br><a href="https://es6.ruanyifeng.com/#docs/iterator" target="_blank" >Iterator 和 for…of 循环</a></p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><ul><li>保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</li><li>历史记录这玩意就是备忘录模式</li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><ul><li>发布—订阅模式的优点： 时间上的解耦，对象之间的解耦</li><li>避免了 Context 无限膨胀，状态切换的逻辑分布在状态类中，也避免了大量的 if-else 语句。</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然。</li><li>Context 中的请求动作和状态类中封装的行为相互独立切互不影响，也使得修改更加容易。</li></ul><p>实现方式：</p><ol><li>类似 java 中一个 State 抽象类，其他状态类继承并重写其方法，实现自己的状态类方法</li><li>JavaScript 可以非常方便利用委托技术， 通过 Function.prototype.call 方法直接把请求委托给某个对象字面来执行</li></ol><p><a href="https://juejin.cn/post/6844903862013280269#heading-7" target="_blank" >JavaScript 版本的状态机</a></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><ul><li>策略模式的出现是为了解决多重判断的问题</li><li>组成：组策略，组策略的实现</li><li>可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护</li></ul><p>使用场景：<code>规则校验</code>,<code>权限操作</code></p><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><ul><li>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。</li><li>简单理解为：规划好了蓝图，照着蓝图去具体实现</li></ul><h3 id="观察者模式-x2F-发布订阅模式"><a href="#观察者模式-x2F-发布订阅模式" class="headerlink" title="观察者模式&#x2F;发布订阅模式"></a>观察者模式&#x2F;发布订阅模式</h3><ul><li>也叫观察者模式</li><li>解耦：1. 时间上的解耦，2. 为对象之间的解耦</li></ul><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><ul><li>中介者模式的作用：就是解除对象与对象之间的紧耦合关系。</li><li>增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可</li><li>如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</li></ul><p><a href="https://juejin.cn/post/6844903848155283463" target="_blank" >见</a></p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><ul><li>意图：主要将数据结构与数据操作分离。</li><li>主要解决：稳定的数据结构和易变的操作耦合问题。</li><li>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中<br><a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" >菜鸟教程-设计模式-访问者模式</a><br><a href="https://juejin.cn/post/7012599751527006239" target="_blank" >见</a></li></ul><h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><p>未对该类做任何实现的空对象类</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="创建型模式-原建工抽单"><a href="#创建型模式-原建工抽单" class="headerlink" title="创建型模式 原建工抽单"></a>创建型模式 原建工抽单</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 原型模式、建造者模式、工厂模式、抽象工厂模式、单例模式、&#x2F;&#x2F; 记忆口诀：原建工抽单（原来建工立业的人要抽单【交税】）</code></pre><table><thead><tr><th align="left">简</th><th>原</th><th>建</th><th>工</th><th>抽</th><th>单</th></tr></thead><tbody><tr><td align="left">全</td><td>原型模式</td><td>建造者模式</td><td>工厂模式</td><td>抽象工厂模式</td><td>单例模式</td></tr></tbody></table><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 享元模式、桥接模式、外观模式、适配器模式、组合模式、装饰者模式、代理模式、&#x2F;&#x2F; 记忆口诀（7）：享桥外适组装代【想桥外试、租装戴】</code></pre><table><thead><tr><th align="left">简</th><th>享</th><th>桥</th><th>外</th><th>适</th><th>组</th><th>装</th><th>代</th></tr></thead><tbody><tr><td align="left">全</td><td>享元模式</td><td>桥接模式</td><td>外观模式</td><td>适配器模式</td><td>组合模式</td><td>装饰者模式</td><td>代理模式</td></tr></tbody></table><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式&#x2F;&#x2F; 记忆口诀（11）：观察者、访问者、中介者；命令、解释、模版、状态；策略、责任、迭代、备忘</code></pre><h2 id="记忆口诀"><a href="#记忆口诀" class="headerlink" title="记忆口诀"></a>记忆口诀</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>中间件是什么设计模式？（1. 中间人？不像 2. 过滤器？像又不像 3.代理模式，像又不像）</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html" target="_blank" >设计模式简介</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css theme</title>
      <link href="//post/2022-10-26theme.html"/>
      <url>//post/2022-10-26theme.html</url>
      
        <content type="html"><![CDATA[<h2 id="mdn-主题切换"><a href="#mdn-主题切换" class="headerlink" title="mdn 主题切换"></a>mdn 主题切换</h2><img src="http://t-blog-images.aijs.top/img/202210261559271.webp"  style="width: 500px;max-width: 100%"/><div style="width: 10px"></div><!-- <img src="http://t-blog-images.aijs.top/img/202210261605824.webp" /> --><img src="http://t-blog-images.aijs.top/img/202210261610477.webp" style="width: 500px;max-width: 100%" /><h2 id="light-x2F-dark-x2F-os-default"><a href="#light-x2F-dark-x2F-os-default" class="headerlink" title="light&#x2F;dark&#x2F;os-default"></a>light&#x2F;dark&#x2F;os-default</h2><h3 id="theme-scss"><a href="#theme-scss" class="headerlink" title="_theme.scss"></a>_theme.scss</h3><pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">&#x2F;&#x2F; _theme.scss@use &quot;sass:color&quot;;@use &quot;..&#x2F;vars.scss&quot; as *; &#x2F;&#x2F; 这个见下面的@use &quot;..&#x2F;color-palette&quot; as *; &#x2F;&#x2F; 这个没找到&#x2F;* 浅色主题 *&#x2F;@mixin light-theme &#123;  --text-primary: #&#123;$mdn-theme-light-text-primary&#125;;  --text-secondary: #&#123;$mdn-theme-light-text-secondary&#125;;  --text-inactive: #&#123;$mdn-theme-light-text-inactive&#125;;  --text-link: #&#123;$mdn-theme-light-text-link&#125;;  --text-invert: #&#123;$mdn-theme-light-text-invert&#125;;  --background-primary: #&#123;$mdn-theme-light-background-primary&#125;;  --background-secondary: #&#123;$mdn-theme-light-background-secondary&#125;;  --background-tertiary: #&#123;$mdn-theme-light-background-tertiary&#125;;  --background-toc-active: #&#123;$mdn-theme-light-background-toc-active&#125;;  --background-mark-yellow: #&#123;color.adjust(      $mdn-color-light-theme-yellow-30,      $alpha: -0.6    )&#125;;  --background-mark-green: #&#123;color.adjust(      $mdn-color-light-theme-green-30,      $alpha: -0.6    )&#125;;  --background-information: #&#123;color.adjust(      $mdn-theme-light-icon-information,      $alpha: -0.9    )&#125;;  --background-warning: #&#123;color.adjust(      $mdn-theme-light-icon-warning,      $alpha: -0.9    )&#125;;  --background-critical: #&#123;color.adjust(      $mdn-theme-light-icon-critical,      $alpha: -0.9    )&#125;;  --background-success: #&#123;color.adjust(      $mdn-theme-light-icon-success,      $alpha: -0.9    )&#125;;  --border-primary: #&#123;$mdn-theme-light-border-primary&#125;;  --border-secondary: #&#123;$mdn-theme-light-border-secondary&#125;;  --button-primary-default: #&#123;$mdn-theme-light-button-primary-default&#125;;  --button-primary-hover: #&#123;$mdn-theme-light-button-primary-hover&#125;;  --button-primary-active: #&#123;$mdn-theme-light-button-primary-active&#125;;  --button-primary-inactive: #&#123;$mdn-theme-light-button-primary-inactive&#125;;  --button-secondary-default: #&#123;$mdn-theme-light-button-secondary-default&#125;;  --button-secondary-hover: #&#123;$mdn-theme-light-button-secondary-hover&#125;;  --button-secondary-active: #&#123;$mdn-theme-light-button-secondary-active&#125;;  --button-secondary-inactive: #&#123;$mdn-theme-light-button-secondary-inactive&#125;;  --button-secondary-border-focus: #&#123;$mdn-theme-light-button-secondary-border-focus&#125;;  --button-secondary-border-red: #&#123;$mdn-theme-light-button-secondary-border-red&#125;;  --button-secondary-border-red-focus: #&#123;$mdn-theme-light-button-secondary-border-red-focus&#125;;  --icon-primary: #&#123;$mdn-theme-light-icon-primary&#125;;  --icon-secondary: #&#123;$mdn-theme-light-icon-secondary&#125;;  --icon-information: #&#123;$mdn-theme-light-icon-information&#125;;  --icon-warning: #&#123;$mdn-theme-light-icon-warning&#125;;  --icon-critical: #&#123;$mdn-theme-light-icon-critical&#125;;  --icon-success: #&#123;$mdn-theme-light-icon-success&#125;;  --accent-primary: #&#123;$mdn-theme-light-accent-primary&#125;;  --accent-primary-engage: #&#123;color.adjust(      $mdn-theme-light-accent-primary,      $alpha: -0.9    )&#125;;  --accent-secondary: #&#123;$mdn-theme-light-accent-secondary&#125;;  --accent-tertiary: #&#123;color.adjust(      $mdn-color-light-theme-blue-50,      $alpha: -0.9    )&#125;;  --shadow-01: #&#123;$mdn-theme-light-shadow-01&#125;;  --shadow-02: #&#123;$mdn-theme-light-shadow-02&#125;;  --focus-01: #&#123;$mdn-theme-light-focus-01&#125;;  --field-focus-border: #&#123;$mdn-theme-light-field-focus-border&#125;;  --code-token-tag: #&#123;$mdn-theme-light-code-token-tag&#125;;  --code-token-punctuation: #&#123;$mdn-theme-light-code-token-punctuation&#125;;  --code-token-attribute-name: #&#123;$mdn-theme-light-code-token-attribute-name&#125;;  --code-token-attribute-value: #&#123;$mdn-theme-light-code-token-attribute-value&#125;;  --code-token-comment: #&#123;$mdn-theme-light-code-token-comment&#125;;  --code-token-default: #&#123;$mdn-theme-light-code-token-default&#125;;  --code-token-selector: #&#123;$mdn-theme-light-code-token-selector&#125;;  --code-background-inline: #&#123;$mdn-theme-light-code-background-inline&#125;;  --code-background-block: #&#123;$mdn-theme-light-code-background-block&#125;;  --notecard-link-color: #&#123;$mdn-color-neutral-80&#125;;  --scrollbar-bg: transparent;  --scrollbar-color: rgba(0, 0, 0, 0.25);  --category-color: #&#123;$mdn-color-light-theme-blue-50&#125;;  --category-color-background: #&#123;$mdn-color-light-theme-blue-50&#125;10;  --code-color: #&#123;$mdn-color-light-theme-blue-40&#125;;  --mark-color: #&#123;$mdn-color-light-theme-blue-10&#125;;  --plus-accent-color: #&#123;$mdn-color-dark-theme-red-60&#125;;  --html-accent-color: #&#123;$mdn-color-light-theme-red-60&#125;;  --css-accent-color: #&#123;$mdn-color-light-theme-blue-60&#125;;  --js-accent-color: #&#123;$mdn-color-light-theme-yellow-40&#125;;  --http-accent-color: #&#123;$mdn-color-light-theme-green-60&#125;;  --apis-accent-color: #&#123;$mdn-color-light-theme-violet-60&#125;;  --learn-accent-color: #&#123;$mdn-color-light-theme-pink-60&#125;;  --plus-code-color: #&#123;$mdn-color-light-theme-blue-60&#125;;  --html-code-color: #&#123;$mdn-color-light-theme-red-70&#125;;  --css-code-color: #&#123;$mdn-color-light-theme-blue-60&#125;;  --js-code-color: #&#123;$mdn-color-light-theme-yellow-60&#125;;  --http-code-color: #&#123;$mdn-color-light-theme-green-60&#125;;  --apis-code-color: #&#123;$mdn-color-light-theme-violet-60&#125;;  --learn-code-color: #&#123;$mdn-color-light-theme-pink-60&#125;;  --plus-mark-color: #&#123;$mdn-color-light-theme-red-10&#125;;  --html-mark-color: #&#123;$mdn-color-light-theme-red-10&#125;;  --css-mark-color: #&#123;$mdn-color-light-theme-blue-10&#125;;  --js-mark-color: #&#123;$mdn-color-light-theme-yellow-10&#125;;  --http-mark-color: #&#123;$mdn-color-light-theme-green-10&#125;;  --apis-mark-color: #&#123;$mdn-color-light-theme-violet-10&#125;;  --learn-mark-color: #&#123;$mdn-color-light-theme-pink-10&#125;;  --plus-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;  --html-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;  --css-accent-background-color: #&#123;$mdn-color-light-theme-blue-50&#125;30;  --js-accent-background-color: #&#123;$mdn-color-light-theme-yellow-50&#125;30;  --http-accent-background-color: #&#123;$mdn-color-light-theme-green-50&#125;30;  --apis-accent-background-color: #&#123;$mdn-color-light-theme-violet-50&#125;30;  --learn-accent-background-color: #&#123;$mdn-color-light-theme-pink-50&#125;30;  --plus-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-red-50,      $alpha: -0.3    )&#125;;  --html-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-red-50,      $alpha: -0.3    )&#125;;  --css-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-blue-50,      $alpha: -0.3    )&#125;;  --js-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-yellow-50,      $alpha: -0.3    )&#125;;  --http-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-green-50,      $alpha: -0.3    )&#125;;  --apis-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-violet-50,      $alpha: -0.3    )&#125;;  --learn-accent-engage: #&#123;color.adjust(      $mdn-color-light-theme-pink-50,      $alpha: -0.3    )&#125;;  --modal-backdrop-color: #&#123;rgba($mdn-theme-dark-background-primary, 0.1)&#125;;  --blend-color: #&#123;$mdn-color-white&#125;80;  --text-primary-red: #&#123;$mdn-color-light-theme-red-60&#125;;  --text-primary-green: #&#123;$mdn-color-light-theme-green-60&#125;;  --text-primary-blue: #&#123;$mdn-color-light-theme-blue-60&#125;;  --text-primary-yellow: #&#123;$mdn-color-light-theme-yellow-60&#125;;  color-scheme: light;&#125;&#x2F;* 深色主题 *&#x2F;@mixin dark-theme &#123;  --text-primary: #&#123;$mdn-theme-dark-text-primary&#125;;  --text-secondary: #&#123;$mdn-theme-dark-text-secondary&#125;;  --text-inactive: #&#123;$mdn-theme-dark-text-inactive&#125;;  --text-link: #&#123;$mdn-theme-dark-text-link&#125;;  --text-invert: #&#123;$mdn-theme-dark-text-invert&#125;;  --background-primary: #&#123;$mdn-theme-dark-background-primary&#125;;  --background-secondary: #&#123;$mdn-theme-dark-background-secondary&#125;;  --background-tertiary: #&#123;$mdn-theme-dark-background-tertiary&#125;;  --background-toc-active: #&#123;$mdn-theme-dark-background-toc-active&#125;;  --background-mark-yellow: #&#123;color.adjust(      $mdn-color-dark-theme-yellow-30,      $alpha: -0.6    )&#125;;  --background-mark-green: #&#123;color.adjust(      $mdn-color-light-theme-green-30,      $alpha: -0.6    )&#125;;  --background-information: #&#123;color.adjust(      $mdn-theme-light-icon-information,      $alpha: -0.9    )&#125;;  --background-warning: #&#123;color.adjust(      $mdn-theme-light-icon-warning,      $alpha: -0.9    )&#125;;  --background-critical: #&#123;color.adjust(      $mdn-theme-light-icon-critical,      $alpha: -0.9    )&#125;;  --background-success: #&#123;color.adjust(      $mdn-theme-light-icon-success,      $alpha: -0.9    )&#125;;  --border-primary: #&#123;$mdn-theme-dark-border-primary&#125;;  --border-secondary: #&#123;$mdn-theme-dark-border-secondary&#125;;  --button-primary-default: #&#123;$mdn-theme-dark-button-primary-default&#125;;  --button-primary-hover: #&#123;$mdn-theme-dark-button-primary-hover&#125;;  --button-primary-active: #&#123;$mdn-theme-dark-button-primary-active&#125;;  --button-primary-inactive: #&#123;$mdn-theme-dark-button-primary-inactive&#125;;  --button-secondary-default: #&#123;$mdn-theme-dark-button-secondary-default&#125;;  --button-secondary-hover: #&#123;$mdn-theme-dark-button-secondary-hover&#125;;  --button-secondary-active: #&#123;$mdn-theme-dark-button-secondary-active&#125;;  --button-secondary-inactive: #&#123;$mdn-theme-dark-button-secondary-inactive&#125;;  --button-secondary-border-focus: #&#123;$mdn-theme-light-button-secondary-border-focus&#125;;  --button-secondary-border-red: #&#123;$mdn-theme-light-button-secondary-border-red&#125;;  --button-secondary-border-red-focus: #&#123;$mdn-theme-light-button-secondary-border-red-focus&#125;;  --icon-primary: #&#123;$mdn-theme-dark-icon-primary&#125;;  --icon-secondary: #&#123;$mdn-theme-dark-icon-secondary&#125;;  --icon-information: #&#123;$mdn-theme-dark-icon-information&#125;;  --icon-warning: #&#123;$mdn-theme-dark-icon-warning&#125;;  --icon-critical: #&#123;$mdn-theme-dark-icon-critical&#125;;  --icon-success: #&#123;$mdn-theme-dark-icon-success&#125;;  --accent-primary: #&#123;$mdn-theme-dark-accent-primary&#125;;  --accent-primary-engage: #&#123;color.adjust(      $mdn-theme-dark-accent-primary,      $alpha: -0.9    )&#125;;  --accent-secondary: #&#123;$mdn-theme-dark-accent-secondary&#125;;  --accent-tertiary: #&#123;color.adjust(      $mdn-color-light-theme-blue-50,      $alpha: -0.9    )&#125;;  --shadow-01: #&#123;$mdn-theme-dark-shadow-01&#125;;  --shadow-02: #&#123;$mdn-theme-dark-shadow-02&#125;;  --focus-01: #&#123;$mdn-theme-dark-focus-01&#125;;  --field-focus-border: #&#123;$mdn-theme-dark-field-focus-border&#125;;  --code-token-tag: #&#123;$mdn-theme-dark-code-token-tag&#125;;  --code-token-punctuation: #&#123;$mdn-theme-dark-code-token-punctuation&#125;;  --code-token-attribute-name: #&#123;$mdn-theme-dark-code-token-attribute-name&#125;;  --code-token-attribute-value: #&#123;$mdn-theme-dark-code-token-attribute-value&#125;;  --code-token-comment: #&#123;$mdn-theme-dark-code-token-comment&#125;;  --code-token-default: #&#123;$mdn-theme-dark-code-token-default&#125;;  --code-token-selector: #&#123;$mdn-theme-dark-code-token-selector&#125;;  --code-background-inline: #&#123;$mdn-theme-dark-code-background-inline&#125;;  --code-background-block: #&#123;$mdn-theme-dark-code-background-block&#125;;  --notecard-link-color: #&#123;$mdn-color-neutral-10&#125;;  --scrollbar-bg: transparent;  --scrollbar-color: rgba(255, 255, 255, 0.25);  --category-color: #&#123;$mdn-color-dark-theme-blue-30&#125;;  --category-color-background: #&#123;$mdn-color-dark-theme-blue-30&#125;70;  --code-color: #&#123;$mdn-color-dark-theme-blue-20&#125;;  --mark-color: #&#123;$mdn-color-dark-theme-blue-70&#125;;  --plus-accent-color: #&#123;$mdn-color-dark-theme-red-30&#125;;  --html-accent-color: #&#123;$mdn-color-dark-theme-red-40&#125;;  --css-accent-color: #&#123;$mdn-color-dark-theme-blue-30&#125;;  --js-accent-color: #&#123;$mdn-color-dark-theme-yellow-40&#125;;  --http-accent-color: #&#123;$mdn-color-dark-theme-green-40&#125;;  --apis-accent-color: #&#123;$mdn-color-dark-theme-violet-40&#125;;  --learn-accent-color: #&#123;$mdn-color-dark-theme-pink-40&#125;;  --plus-code-color: #&#123;$mdn-color-dark-theme-blue-20&#125;;  --html-code-color: #&#123;$mdn-color-neutral-light-70&#125;;  --css-code-color: #&#123;$mdn-color-dark-theme-blue-20&#125;;  --js-code-color: #&#123;$mdn-color-dark-theme-yellow-30&#125;;  --http-code-color: #&#123;$mdn-color-dark-theme-green-30&#125;;  --apis-code-color: #&#123;$mdn-color-dark-theme-violet-30&#125;;  --learn-code-color: #&#123;$mdn-color-dark-theme-pink-30&#125;;  --plus-mark-color: #&#123;$mdn-color-dark-theme-red-70&#125;;  --html-mark-color: #&#123;$mdn-color-dark-theme-red-70&#125;;  --css-mark-color: #&#123;$mdn-color-dark-theme-blue-70&#125;;  --js-mark-color: #&#123;$mdn-color-dark-theme-yellow-70&#125;;  --http-mark-color: #&#123;$mdn-color-dark-theme-green-70&#125;;  --apis-mark-color: #&#123;$mdn-color-dark-theme-violet-70&#125;;  --learn-mark-color: #&#123;$mdn-color-dark-theme-pink-70&#125;;  --plus-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;  --html-accent-background-color: #&#123;$mdn-color-light-theme-red-50&#125;30;  --css-accent-background-color: #&#123;$mdn-color-light-theme-blue-50&#125;30;  --js-accent-background-color: #&#123;$mdn-color-light-theme-yellow-50&#125;30;  --http-accent-background-color: #&#123;$mdn-color-light-theme-green-50&#125;30;  --apis-accent-background-color: #&#123;$mdn-color-light-theme-violet-50&#125;30;  --learn-accent-background-color: #&#123;$mdn-color-light-theme-pink-50&#125;30;  --plus-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-red-40,      $alpha: -0.3    )&#125;;  --html-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-red-40,      $alpha: -0.3    )&#125;;  --css-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-blue-30,      $alpha: -0.3    )&#125;;  --js-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-yellow-40,      $alpha: -0.3    )&#125;;  --http-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-green-40,      $alpha: -0.3    )&#125;;  --apis-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-violet-40,      $alpha: -0.3    )&#125;;  --learn-accent-engage: #&#123;color.adjust(      $mdn-color-dark-theme-pink-40,      $alpha: -0.3    )&#125;;  --modal-backdrop-color: #&#123;rgba($mdn-theme-dark-background-primary, 0.7)&#125;;  --blend-color: #&#123;$mdn-color-black&#125;80;  --text-primary-red: #&#123;$mdn-color-dark-theme-red-30&#125;;  --text-primary-green: #&#123;$mdn-color-dark-theme-green-30&#125;;  --text-primary-blue: #&#123;$mdn-color-dark-theme-blue-30&#125;;  --text-primary-yellow: #&#123;$mdn-color-dark-theme-yellow-30&#125;;  color-scheme: dark;&#125;body,:root &#123;  --mdn-color-white: #&#123;$mdn-color-white&#125;;  --mdn-color-black: #&#123;$mdn-color-black&#125;;  --mdn-color-dark-grey: #&#123;$mdn-color-neutral-70&#125;;  --mdn-background-dark: #&#123;$mdn-theme-dark-background-primary&#125;;  --mdn-background-light: #&#123;$mdn-theme-light-background-primary&#125;;  --mdn-background-light-grey: #&#123;$mdn-color-neutral-10&#125;;  --color-announcement-banner-accent: #&#123;$mdn-color-light-theme-pink-40&#125;;&#125;.light &#123;  @include light-theme;&#125;.dark &#123;  @include dark-theme;&#125;&#x2F;* 默认主题 *&#x2F;&#x2F;&#x2F; OS Default.:root:not(.light):not(.dark) &#123;  @media (prefers-color-scheme: light) &#123;    @include light-theme;  &#125;  @media (prefers-color-scheme: dark) &#123;    @include dark-theme;  &#125;&#125;</code></pre><h3 id="x2F-vars-scss"><a href="#x2F-vars-scss" class="headerlink" title="..&#x2F;vars.scss"></a>..&#x2F;vars.scss</h3><pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">@use &quot;.&#x2F;color-palette&quot; as *;$mdn-color-neutral-light-70: #f9f9fb;$mdn-color-neutral-light-80: #f2f1f1;$mdn-color-neutral-light-90: #ebeaea;$mdn-color-neutral-10: #e2e2e2;$mdn-color-neutral-20: #cdcdcd;$mdn-color-neutral-30: #b3b3b3;$mdn-color-neutral-40: #9e9e9e;$mdn-color-neutral-50: #858585;$mdn-color-neutral-60: #696969;$mdn-color-neutral-70: #4e4e4e;$mdn-color-neutral-80: #343434;$mdn-color-neutral-90: #1b1b1b;$mdn-color-light-theme-blue: #0085f2;$mdn-color-light-theme-green: #009a46;$mdn-color-light-theme-yellow: #928700;$mdn-color-light-theme-red: #d30038;$mdn-color-light-theme-violet: #9b65ff;$mdn-color-light-theme-pink: #d00058;$mdn-color-dark-theme-blue: $mdn-color-light-theme-blue;$mdn-color-dark-theme-green: $mdn-color-light-theme-green;$mdn-color-dark-theme-yellow: $mdn-color-light-theme-yellow;$mdn-color-dark-theme-red: $mdn-color-light-theme-red;$mdn-color-dark-theme-violet: $mdn-color-light-theme-violet;$mdn-color-dark-theme-pink: $mdn-color-light-theme-pink;$mdn-color-light-theme-blue-10: #dce2f2;$mdn-color-light-theme-blue-20: #c1cff1;$mdn-color-light-theme-blue-30: #8cb4ff;$mdn-color-light-theme-blue-40: #5e9eff;$mdn-color-light-theme-blue-50: #0085f2;$mdn-color-light-theme-blue-60: #0069c2;$mdn-color-light-theme-blue-70: #004d92;$mdn-color-light-theme-blue-80: #003465;$mdn-color-light-theme-blue-90: #001b3a;$mdn-color-dark-theme-blue-10: $mdn-color-light-theme-blue-10;$mdn-color-dark-theme-blue-20: $mdn-color-light-theme-blue-20;$mdn-color-dark-theme-blue-30: $mdn-color-light-theme-blue-30;$mdn-color-dark-theme-blue-40: $mdn-color-light-theme-blue-40;$mdn-color-dark-theme-blue-50: $mdn-color-light-theme-blue-50;$mdn-color-dark-theme-blue-60: $mdn-color-light-theme-blue-60;$mdn-color-dark-theme-blue-70: $mdn-color-light-theme-blue-70;$mdn-color-dark-theme-blue-80: $mdn-color-light-theme-blue-80;$mdn-color-dark-theme-blue-90: $mdn-color-light-theme-blue-90;$mdn-color-light-theme-green-10: #a9f3ba;$mdn-color-light-theme-green-20: #73e693;$mdn-color-light-theme-green-30: #00d061;$mdn-color-light-theme-green-40: #00b755;$mdn-color-light-theme-green-50: #009a46;$mdn-color-light-theme-green-60: #007936;$mdn-color-light-theme-green-70: #005a26;$mdn-color-light-theme-green-80: #003d18;$mdn-color-light-theme-green-90: #00210a;$mdn-color-dark-theme-green-10: $mdn-color-light-theme-green-10;$mdn-color-dark-theme-green-20: $mdn-color-light-theme-green-20;$mdn-color-dark-theme-green-30: $mdn-color-light-theme-green-30;$mdn-color-dark-theme-green-40: $mdn-color-light-theme-green-40;$mdn-color-dark-theme-green-50: $mdn-color-light-theme-green-50;$mdn-color-dark-theme-green-60: $mdn-color-light-theme-green-60;$mdn-color-dark-theme-green-70: $mdn-color-light-theme-green-70;$mdn-color-dark-theme-green-80: $mdn-color-light-theme-green-80;$mdn-color-dark-theme-green-90: $mdn-color-light-theme-green-90;$mdn-color-light-theme-yellow-10: #f0e498;$mdn-color-light-theme-yellow-20: #dfd172;$mdn-color-light-theme-yellow-30: #c7b700;$mdn-color-light-theme-yellow-40: #afa100;$mdn-color-light-theme-yellow-50: #938700;$mdn-color-light-theme-yellow-60: #746a00;$mdn-color-light-theme-yellow-70: #564e00;$mdn-color-light-theme-yellow-80: #3a3500;$mdn-color-light-theme-yellow-90: #1f1c00;$mdn-color-dark-theme-yellow-10: $mdn-color-light-theme-yellow-10;$mdn-color-dark-theme-yellow-20: $mdn-color-light-theme-yellow-20;$mdn-color-dark-theme-yellow-30: $mdn-color-light-theme-yellow-30;$mdn-color-dark-theme-yellow-40: $mdn-color-light-theme-yellow-40;$mdn-color-dark-theme-yellow-50: $mdn-color-light-theme-yellow-50;$mdn-color-dark-theme-yellow-60: $mdn-color-light-theme-yellow-60;$mdn-color-dark-theme-yellow-70: $mdn-color-light-theme-yellow-70;$mdn-color-dark-theme-yellow-80: $mdn-color-light-theme-yellow-80;$mdn-color-dark-theme-yellow-90: $mdn-color-light-theme-yellow-90;$mdn-color-light-theme-red-10: #ffd9dc;$mdn-color-light-theme-red-20: #ffc0c4;$mdn-color-light-theme-red-30: #ff97a0;$mdn-color-light-theme-red-40: #ff707f;$mdn-color-light-theme-red-50: #ff2a51;$mdn-color-light-theme-red-60: #d30038;$mdn-color-light-theme-red-70: #9e0027;$mdn-color-light-theme-red-80: #6f0019;$mdn-color-light-theme-red-90: #40000a;$mdn-color-dark-theme-red-10: $mdn-color-light-theme-red-10;$mdn-color-dark-theme-red-20: $mdn-color-light-theme-red-20;$mdn-color-dark-theme-red-30: $mdn-color-light-theme-red-30;$mdn-color-dark-theme-red-40: $mdn-color-light-theme-red-40;$mdn-color-dark-theme-red-50: $mdn-color-light-theme-red-50;$mdn-color-dark-theme-red-60: $mdn-color-light-theme-red-60;$mdn-color-dark-theme-red-70: $mdn-color-light-theme-red-70;$mdn-color-dark-theme-red-80: $mdn-color-light-theme-red-80;$mdn-color-dark-theme-red-90: $mdn-color-light-theme-red-90;$mdn-color-light-theme-violet-10: #e6deff;$mdn-color-light-theme-violet-20: #d4c5ff;$mdn-color-light-theme-violet-30: #bea5ff;$mdn-color-light-theme-violet-40: #ae8aff;$mdn-color-light-theme-violet-50: #9b65ff;$mdn-color-light-theme-violet-60: #872bff;$mdn-color-light-theme-violet-70: #6800cf;$mdn-color-light-theme-violet-80: #480091;$mdn-color-light-theme-violet-90: #280056;$mdn-color-dark-theme-violet-10: $mdn-color-light-theme-violet-10;$mdn-color-dark-theme-violet-20: $mdn-color-light-theme-violet-20;$mdn-color-dark-theme-violet-30: $mdn-color-light-theme-violet-30;$mdn-color-dark-theme-violet-40: $mdn-color-light-theme-violet-40;$mdn-color-dark-theme-violet-50: $mdn-color-light-theme-violet-50;$mdn-color-dark-theme-violet-60: $mdn-color-light-theme-violet-60;$mdn-color-dark-theme-violet-70: $mdn-color-light-theme-violet-70;$mdn-color-dark-theme-violet-80: $mdn-color-light-theme-violet-80;$mdn-color-dark-theme-violet-90: $mdn-color-light-theme-violet-90;$mdn-color-light-theme-pink-10: #ffd9df;$mdn-color-light-theme-pink-20: #ffbbc8;$mdn-color-light-theme-pink-30: #ff93aa;$mdn-color-light-theme-pink-40: #ff6d91;$mdn-color-light-theme-pink-50: #ff1f72;$mdn-color-light-theme-pink-60: #d00058;$mdn-color-light-theme-pink-70: #9e0041;$mdn-color-light-theme-pink-80: #6d002b;$mdn-color-light-theme-pink-90: #3f0015;$mdn-color-dark-theme-pink-10: $mdn-color-light-theme-pink-10;$mdn-color-dark-theme-pink-20: $mdn-color-light-theme-pink-20;$mdn-color-dark-theme-pink-30: $mdn-color-light-theme-pink-30;$mdn-color-dark-theme-pink-40: $mdn-color-light-theme-pink-40;$mdn-color-dark-theme-pink-50: $mdn-color-light-theme-pink-50;$mdn-color-dark-theme-pink-60: $mdn-color-light-theme-pink-60;$mdn-color-dark-theme-pink-70: $mdn-color-light-theme-pink-70;$mdn-color-dark-theme-pink-80: $mdn-color-light-theme-pink-80;$mdn-color-dark-theme-pink-90: $mdn-color-light-theme-pink-90;$mdn-color-black: #000;$mdn-color-white: #fff;$mdn-theme-light-text-primary: $mdn-color-neutral-90;$mdn-theme-light-text-secondary: $mdn-color-neutral-70;$mdn-theme-light-text-inactive: #&#123;$mdn-color-neutral-40&#125;a6;$mdn-theme-light-text-link: $mdn-color-light-theme-blue-60;$mdn-theme-light-text-invert: $mdn-color-white;$mdn-theme-light-background-primary: $mdn-color-white;$mdn-theme-light-background-secondary: $mdn-color-neutral-light-70;$mdn-theme-light-background-tertiary: $mdn-color-white;$mdn-theme-light-background-toc-active: $mdn-color-neutral-light-90;$mdn-theme-light-border-primary: $mdn-color-neutral-20;$mdn-theme-light-border-secondary: $mdn-color-neutral-20;$mdn-theme-light-button-primary-default: $mdn-color-neutral-90;$mdn-theme-light-button-primary-hover: $mdn-color-neutral-60;$mdn-theme-light-button-primary-active: $mdn-color-neutral-40;$mdn-theme-light-button-primary-inactive: $mdn-color-neutral-90;$mdn-theme-light-button-secondary-default: $mdn-color-white;$mdn-theme-light-button-secondary-hover: $mdn-color-neutral-20;$mdn-theme-light-button-secondary-active: $mdn-color-neutral-20;$mdn-theme-light-button-secondary-inactive: $mdn-color-neutral-light-70;$mdn-theme-light-button-secondary-border-focus: $mdn-color-light-theme-blue-50;$mdn-theme-light-button-secondary-border-red: $mdn-color-light-theme-red-30;$mdn-theme-light-button-secondary-border-red-focus: $mdn-color-light-theme-red-10;$mdn-theme-light-icon-primary: $mdn-color-neutral-60;$mdn-theme-light-icon-secondary: $mdn-color-neutral-30;$mdn-theme-light-icon-information: $mdn-color-light-theme-blue-50;$mdn-theme-light-icon-warning: $mdn-color-light-theme-red-50;$mdn-theme-light-icon-critical: $mdn-color-light-theme-red-60;$mdn-theme-light-icon-success: $mdn-color-light-theme-green-60;$mdn-theme-light-accent-primary: $mdn-color-light-theme-blue-50;$mdn-theme-light-accent-secondary: $mdn-color-light-theme-blue-50;$mdn-theme-light-field-focus-border: $mdn-color-light-theme-blue-50;$mdn-theme-light-focus-01: 0 0 0 3px rgba(0, 144, 237, 0.4);$mdn-theme-light-shadow-01: 0 1px 2px rgba(43, 42, 51, 0.05);$mdn-theme-light-shadow-02: 0 1px 6px rgba(43, 42, 51, 0.1);$mdn-theme-light-code-token-tag: $mdn-color-light-theme-blue-60;$mdn-theme-light-code-token-punctuation: $mdn-color-neutral-50;$mdn-theme-light-code-token-attribute-name: $mdn-color-light-theme-red-60;$mdn-theme-light-code-token-attribute-value: $mdn-color-light-theme-green-60;$mdn-theme-light-code-token-comment: $mdn-color-neutral-50;$mdn-theme-light-code-token-default: $mdn-color-neutral-90;$mdn-theme-light-code-token-selector: $mdn-color-light-theme-violet-60;$mdn-theme-light-code-background-inline: $mdn-color-neutral-light-80;$mdn-theme-light-code-background-block: $mdn-color-neutral-light-80;$mdn-theme-dark-text-primary: $mdn-color-white;$mdn-theme-dark-text-secondary: $mdn-color-neutral-20;$mdn-theme-dark-text-inactive: #&#123;$mdn-color-neutral-20&#125;a6;$mdn-theme-dark-text-link: $mdn-color-dark-theme-blue-30;$mdn-theme-dark-text-invert: $mdn-color-neutral-90;$mdn-theme-dark-background-primary: $mdn-color-neutral-90;$mdn-theme-dark-background-secondary: $mdn-color-neutral-80;$mdn-theme-dark-background-tertiary: $mdn-color-neutral-70;$mdn-theme-dark-background-toc-active: $mdn-color-neutral-80;$mdn-theme-dark-border-primary: $mdn-color-neutral-50;$mdn-theme-dark-border-secondary: $mdn-color-neutral-60;$mdn-theme-dark-button-primary-default: $mdn-color-white;$mdn-theme-dark-button-primary-hover: $mdn-color-neutral-20;$mdn-theme-dark-button-primary-active: $mdn-color-neutral-40;$mdn-theme-dark-button-primary-inactive: $mdn-color-white;$mdn-theme-dark-button-secondary-default: $mdn-color-neutral-70;$mdn-theme-dark-button-secondary-hover: $mdn-color-neutral-50;$mdn-theme-dark-button-secondary-active: $mdn-color-neutral-40;$mdn-theme-dark-button-secondary-inactive: $mdn-color-neutral-70;$mdn-theme-dark-shadow-01: 0 1px 2px rgba(251, 251, 254, 0.2);$mdn-theme-dark-shadow-02: 0 1px 6px rgba(251, 251, 254, 0.2);$mdn-theme-dark-icon-primary: $mdn-color-white;$mdn-theme-dark-icon-secondary: $mdn-color-neutral-30;$mdn-theme-dark-icon-information: $mdn-color-dark-theme-blue-40;$mdn-theme-dark-icon-warning: $mdn-color-dark-theme-yellow-40;$mdn-theme-dark-icon-critical: $mdn-color-dark-theme-red-40;$mdn-theme-dark-icon-success: $mdn-color-dark-theme-green-40;$mdn-theme-dark-accent-primary: $mdn-color-dark-theme-blue-40;$mdn-theme-dark-accent-secondary: $mdn-color-dark-theme-blue-40;$mdn-theme-dark-field-focus-border: $mdn-color-white;$mdn-theme-dark-focus-01: 0 0 0 3px rgba(251, 251, 254, 0.5);$mdn-theme-dark-code-token-tag: $mdn-color-dark-theme-blue-20;$mdn-theme-dark-code-token-punctuation: $mdn-color-neutral-30;$mdn-theme-dark-code-token-attribute-name: $mdn-color-dark-theme-red-30;$mdn-theme-dark-code-token-attribute-value: $mdn-color-dark-theme-green-30;$mdn-theme-dark-code-token-comment: $mdn-color-neutral-30;$mdn-theme-dark-code-token-default: $mdn-color-white;$mdn-theme-dark-code-token-selector: $mdn-color-dark-theme-violet-30;$mdn-theme-dark-code-background-inline: $mdn-color-neutral-80;$mdn-theme-dark-code-background-block: $mdn-color-neutral-80;$screen-sm: 426px;$screen-md: 769px;$screen-lg: 992px;$screen-xl: 1200px;$screen-xxl: 1441px;&#x2F;* * z-index scale *&#x2F;$send-to-back: -1;$bring-to-front: 9999;$bottom-layer: 100;$middle-layer: 200;$top-layer: 300;</code></pre><h2 id="知乎-theme-实现方案"><a href="#知乎-theme-实现方案" class="headerlink" title="知乎 theme 实现方案"></a>知乎 theme 实现方案</h2><p>通过</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--   data-theme&#x3D;&quot;light --&gt;&lt;html  lang&#x3D;&quot;zh&quot;  data-hairline&#x3D;&quot;true&quot;  data-theme&#x3D;&quot;light&quot;  data-rh&#x3D;&quot;data-theme&quot;  style&#x3D;&quot;&quot;&gt;&lt;&#x2F;html&gt;</code></pre><p><a href="https://lukelowrey.com/css-variable-theme-switcher/" target="_blank" >The simplest CSS variable dark mode theme</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎网站找到面试题</title>
      <link href="//post/2022-10-24zhihu.html"/>
      <url>//post/2022-10-24zhihu.html</url>
      
        <content type="html"><![CDATA[<h2 id="爬取脚本"><a href="#爬取脚本" class="headerlink" title="爬取脚本"></a>爬取脚本</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.from(document.getElementsByTagName(&quot;h3&quot;)).forEach((item) &#x3D;&gt; &#123;  document.body.append(item.innerText + &quot;\n&quot;);&#125;);</code></pre><h2 id="1-🌟-介绍-js-的基本数据类型。"><a href="#1-🌟-介绍-js-的基本数据类型。" class="headerlink" title="1.🌟 介绍 js 的基本数据类型。"></a>1.🌟 介绍 js 的基本数据类型。</h2><h2 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h2><h2 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h2><h2 id="4-🌟-内部属性-Class-是什么？"><a href="#4-🌟-内部属性-Class-是什么？" class="headerlink" title="4.🌟 内部属性 [[Class]] 是什么？"></a>4.🌟 内部属性 [[Class]] 是什么？</h2><ul><li>值等于 加上 <code>toStringTag</code> 属性</li><li><code>Null()和 Undefined()这样的原生构造函数并不存在</code>,<code>但是内部[[class]]属性值仍然是&quot;Null&quot;和&quot;Undefined&quot;</code>.</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 方式1class myClass &#123;  get [Symbol.toStringTag]() &#123;    return &quot;myClass1&quot;;  &#125;&#125;Object.prototype.toString.call(new myClass()); &#x2F;&#x2F; &quot;[object myClass1]&quot;&#x2F;&#x2F; 方式2const obj &#x3D; &#123;&#125;;Object.defineProperty(obj, Symbol.toStringTag, &#123; value: &quot;CustomObject&quot; &#125;); &#x2F;&#x2F; &quot;[object CustomObject]&quot;</code></pre><p><a href="https://juejin.cn/post/7081618269043425310" target="_blank" >见</a></p><h2 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h2><h2 id="undeclared-x2F-undefined-x2F-null"><a href="#undeclared-x2F-undefined-x2F-null" class="headerlink" title="undeclared&#x2F;undefined&#x2F;null"></a>undeclared&#x2F;undefined&#x2F;null</h2><h3 id="6-🌟-undefined-与-undeclared-的区别？"><a href="#6-🌟-undefined-与-undeclared-的区别？" class="headerlink" title="6.🌟 undefined 与 undeclared 的区别？"></a>6.🌟 undefined 与 undeclared 的区别？</h3><ul><li>已在作用域中声明但还没有赋值的变量，是 undefined 的。</li><li>还没有在作用域中声明过的变量，是 undeclared 的。</li></ul><h3 id="7-🌟-null-和-undefined-的区别？"><a href="#7-🌟-null-和-undefined-的区别？" class="headerlink" title="7.🌟 null 和 undefined 的区别？"></a>7.🌟 null 和 undefined 的区别？</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">- 基本数据类型 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 &#96;undefined&#96; 和 &#96;null&#96;- 含义不同- undefined 不是保留字- typeof null 为“object”- null 计算中被转化成 &#96;0&#96;, undefined 被转化成 &#96;NaN&#96;- undefined 是一个标识符,undefined 是全局对象的一个属性</code></pre><h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 <code>undefined 是一个标识符</code>，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</p><p><code>undefined 是全局对象的一个属性</code></p><p>表达式 <code>void ___</code> 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</p><p>按惯例我们用 void 0 来获得 undefined。</p><h2 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h2><h2 id="原型-x2F-原型链"><a href="#原型-x2F-原型链" class="headerlink" title="原型&#x2F;原型链"></a>原型&#x2F;原型链</h2><h3 id="10-🌟-JavaScript-原型，原型链？-有什么特点？"><a href="#10-🌟-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10.🌟 JavaScript 原型，原型链？ 有什么特点？"></a>10.🌟 JavaScript 原型，原型链？ 有什么特点？</h3><h3 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h3><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><h3 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h3><h3 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h3><h3 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a>14. typeof NaN 的结果是什么？</h3><h3 id="15-🌟-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-🌟-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15.🌟 isNaN 和 Number.isNaN 函数的区别？"></a>15.🌟 isNaN 和 Number.isNaN 函数的区别？</h3><ul><li><p><code>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true</code>，因此非数字值传入也<code>可能</code>会<br>返回 true ，会影响 NaN 的判断。</p></li><li><p><code>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN </code>，这种方法对于 NaN 的判断更为<br>准确</p></li></ul><h2 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h2><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; Array(); &#x2F;&#x2F; []var b &#x3D; Array(1); &#x2F;&#x2F; [empty]b &#x3D;&#x3D; a; &#x2F;&#x2F; falsea[0] &#x3D;&#x3D; b[0]; &#x2F;&#x2F; true</code></pre><h3 id="empty-是个什么东西？"><a href="#empty-是个什么东西？" class="headerlink" title="empty 是个什么东西？"></a>empty 是个什么东西？</h3><p><a href="https://segmentfault.com/q/1010000014236517" target="_blank" > empty 是个什么东西？</a></p><h2 id="数据转换规则"><a href="#数据转换规则" class="headerlink" title="数据转换规则"></a>数据转换规则</h2><h3 id="17-其他值到字符串的转换规则？-ToString"><a href="#17-其他值到字符串的转换规则？-ToString" class="headerlink" title="17. 其他值到字符串的转换规则？ ToString"></a>17. 其他值到字符串的转换规则？ ToString</h3><p><a href="/#/post/2022-11-01抽象相等比较" target="_blank" >前端基础 - 抽象相等比较</a></p><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Infinity.toString(); &#x2F;&#x2F; &quot;Infinity&quot;NaN.toString(); &#x2F;&#x2F; &quot;NaN&quot;</code></pre><h4 id="基本数据类型使用-Object-prototype-toString"><a href="#基本数据类型使用-Object-prototype-toString" class="headerlink" title="基本数据类型使用 Object.prototype.toString()"></a>基本数据类型使用 Object.prototype.toString()</h4><p>基本数据类型全部返回 <code>[object Object]</code></p><h3 id="18-其他值到数字值的转换规则？-ToNumber"><a href="#18-其他值到数字值的转换规则？-ToNumber" class="headerlink" title="18. 其他值到数字值的转换规则？ ToNumber"></a>18. 其他值到数字值的转换规则？ ToNumber</h3><p><a href="/#/post/2022-11-01抽象相等比较" target="_blank" >前端基础 - 抽象相等比较</a></p><h3 id="19-其他值到布尔类型的值的转换规则？-ToBoolean"><a href="#19-其他值到布尔类型的值的转换规则？-ToBoolean" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？ ToBoolean"></a>19. 其他值到布尔类型的值的转换规则？ ToBoolean</h3><p><a href="/#/post/2022-11-01抽象相等比较" target="_blank" >前端基础 - 抽象相等比较</a></p><h3 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><p><a href="/#/post/2022-11-01抽象相等比较" target="_blank" >前端基础 - 抽象相等比较</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</code></pre><h3 id="21-🌟-什么是假值对象？"><a href="#21-🌟-什么是假值对象？" class="headerlink" title="21.🌟 什么是假值对象？"></a>21.🌟 什么是假值对象？</h3><p><a href="/#/post/2022-11-01抽象相等比较" target="_blank" >前端基础 - 抽象相等比较</a></p><p><code>充当效仿 undefined 的角色</code></p><h3 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h3><h3 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h3><ul><li>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。</li><li>而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN</li></ul><h3 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. + 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其<br>中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以<br>数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p><a href="/#/post/2022-11-01抽象相等比较" target="_blank" >前端基础 - 抽象相等比较</a></p><h3 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h3><h3 id="26-和-amp-amp-操作符的返回值？"><a href="#26-和-amp-amp-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h3><h3 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h3><h3 id="28-x3D-x3D-操作符的强制类型转换规则？"><a href="#28-x3D-x3D-操作符的强制类型转换规则？" class="headerlink" title="28. &#x3D;&#x3D; 操作符的强制类型转换规则？"></a>28. &#x3D;&#x3D; 操作符的强制类型转换规则？</h3><h3 id="29-如何将字符串转化为数字，例如-‘12-3b’"><a href="#29-如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="29. 如何将字符串转化为数字，例如 ‘12.3b’?"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h3><p>（1）使用 <code>Number()</code> 方法，前提是所包含的字符串不包含不合法字符。</p><p>（2）使用 <code>parseInt() </code>方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p><p>（3）使用 <code>parseFloat()</code> 方法，该函数解析一个字符串参数并返回一个浮点数。</p><p>（4）使用 <code>+ 操作符的隐式转换</code>。 结果<code>NaN</code></p><h3 id="30-🌟-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-🌟-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30.🌟 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30.🌟 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h3><p><a href="https://juejin.cn/post/6844903609029623815" target="_blank" >见</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;\B(?&#x3D;(\d&#123;3&#125;)+(?!\d))&#x2F;g;&#x2F;&#x2F; \B非单词边界&#x2F;&#x2F; ?&#x3D; 先行断言   后面是  --&#x2F;&#x2F; ?! 后行断言， 后面不是 --</code></pre><h2 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h2><h2 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h2><h2 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h2><h2 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h2><h2 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h2><h2 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h2><h2 id="37-🌟-Javascript-的作用域链？"><a href="#37-🌟-Javascript-的作用域链？" class="headerlink" title="37.🌟 Javascript 的作用域链？"></a>37.🌟 Javascript 的作用域链？</h2><p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>函数。</p><ul><li>作用域链的本质：上是一个指向变量对象的指针列表。变量对象是一个<code>包含了执行环境中所有变量和函数</code>的对象。</li><li>作用域链的前端:<code>始终都是当前执行上下文的变量对象</code>。</li><li>作用域链的最后一个对象: <code>始终是全局执行上下文的变量对象（也就是全局对象)</code>。</li></ul><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p><p>作用域链的创建过程跟执行上下文的建立有关….</p><h2 id="38-🌟-谈谈-This-对象的理解。"><a href="#38-🌟-谈谈-This-对象的理解。" class="headerlink" title="38.🌟 谈谈 This 对象的理解。"></a>38.🌟 谈谈 This 对象的理解。</h2><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模<br>式来判断。</p><ul><li>构造函数调用</li><li>显示绑定调用 apply、call、bind</li><li>属性方法调用</li><li>函数调用，严格模式 undefined,非严格模式指向 window</li></ul><h2 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h2><h2 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h2><h3 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h3><h3 id="41-写一个通用的事件侦听器函数。"><a href="#41-写一个通用的事件侦听器函数。" class="headerlink" title="41. 写一个通用的事件侦听器函数。"></a>41. 写一个通用的事件侦听器函数。</h3><h3 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><h3 id="43-🌟-三种事件模型是什么？"><a href="#43-🌟-三种事件模型是什么？" class="headerlink" title="43. 🌟 三种事件模型是什么？"></a>43. 🌟 三种事件模型是什么？</h3><p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p><ul><li><p><code>第一种事件模型是最早的 DOM0 级模型</code>，<code>这种模型不会传播，所以没有事件流的概念</code>，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p></li><li><p><code>第二种事件模型是 IE 事件模型</code>，在该事件模型中，<code>一次事件共有两个过程</code>，<code>事件处理阶段和事件冒泡阶段</code>。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p></li><li><p><code>第三种是 DOM2 级事件模型</code>，在该事件模型中，<code>一次事件共有三个过程</code>，</p><ul><li>第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li><li>后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中<code>第三个参数可以指定事件是否在捕获阶段执行</code>。</li></ul></li></ul><p><strong>DOM2 级事件执行过程</strong></p><ul><li>绑定在被点击元素的事件是按照代码顺序发生。</li><li>其他元素通过冒泡或者捕获“感知”的事件。</li><li>按照 W3C 的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。</li></ul><h3 id="44-事件委托是什么？"><a href="#44-事件委托是什么？" class="headerlink" title="44. 事件委托是什么？"></a>44. 事件委托是什么？</h3><h2 id="45-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#45-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="45. [“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h2><h2 id="46-🌟-什么是闭包，为什么要用它？"><a href="#46-🌟-什么是闭包，为什么要用它？" class="headerlink" title="46. 🌟 什么是闭包，为什么要用它？"></a>46. 🌟 什么是闭包，为什么要用它？</h2><p>闭包: 是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以<br>访问到当前函数的局部变量。</p><p><strong>闭包有两个常用的用途。</strong></p><p><code>闭包的第一个用途</code>是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外<br>部访问到函数内部的变量，可以使用这种方法<code>来创建私有变量</code>。</p><p><code>函数的另一个用途</code>是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以<br>这个<code>变量对象不会被回收</code>。</p><p>其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</p><h2 id="47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h2><p>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。</p><p>设立”严格模式”的目的，主要有以下几个：</p><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫</li></ul><h2 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h2><ul><li><p><code>第一种方式</code>是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p></li><li><p><code>第二种方式</code>可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p></li><li><p><code>第三种方式</code>，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的<br>[[Class]] 属性来进行判断。</p></li></ul><h2 id="49-🌟-instanceof-的作用？"><a href="#49-🌟-instanceof-的作用？" class="headerlink" title="49.🌟 instanceof 的作用？"></a>49.🌟 instanceof 的作用？</h2><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置</p><h2 id="50-🌟-new-操作符具体干了什么呢？如何实现？"><a href="#50-🌟-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50.🌟 new 操作符具体干了什么呢？如何实现？"></a>50.🌟 new 操作符具体干了什么呢？如何实现？</h2><p>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><h2 id="51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h2><p><strong>hasOwnProperty</strong></p><p>所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。<br>这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</p><h2 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h2><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 _JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等_，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p><p>另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p><h2 id="53-forEach-call-“”-function-a-a-style-outline-x3D-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#53-forEach-call-“”-function-a-a-style-outline-x3D-”1px-solid-”-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="53. [].forEach.call($$(“”),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. [].forEach.call($$(“”),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</h2><h2 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a>54. js 延迟加载的方式有哪些？</h2><p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p><p>几种方式：</p><ul><li><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p></li><li><p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p></li><li><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p></li><li><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p></li></ul><h2 id="55-🌟-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-🌟-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55.🌟 Ajax 是什么? 如何创建一个 Ajax？"></a>55.🌟 Ajax 是什么? 如何创建一个 Ajax？</h2><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h3><h3 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h3><pre class="line-numbers language-none"><code class="language-none">1.在 XMLHttpRequest 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。2.在 XMLHttpRequest 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。3.在 URL 后面加上一个随机数： &quot;fresh&#x3D;&quot; + Math.random();。4.在 URL 后面加上时间戳：&quot;nowtime&#x3D;&quot; + new Date().getTime();。5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup(&#123;cache:false&#125;)。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</code></pre><h2 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h2><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="59-什么是浏览器的同源策略？"><a href="#59-什么是浏览器的同源策略？" class="headerlink" title="59. 什么是浏览器的同源策略？"></a>59. 什么是浏览器的同源策略？</h3><p>浏览器的同源策略的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。<br>这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。</p><p>同源政策主要限制了三个方面</p><ul><li><p>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p></li><li><p>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</p></li><li><p>第三个是当前域下 ajax 无法发送跨域请求。</p></li></ul><p>同源政策的目的: 主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，<br>对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><h3 id="60-🌟-如何解决跨域问题？"><a href="#60-🌟-如何解决跨域问题？" class="headerlink" title="60.🌟 如何解决跨域问题？"></a>60.🌟 如何解决跨域问题？</h3><p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p><p><strong>如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。</strong></p><p>（1）将 <code>document.domain</code> 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。</p><p><strong>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。</strong></p><p>（2）使用 <code>location.hash</code> 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p><p>（3）使用 <code>window.name</code> 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p><p>（4）使用 <code>postMessage</code> 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。</p><p><strong>如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</strong></p><p>（5）使用 <code>jsonp</code> 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。</p><p>（6）使用 <code>CORS</code> 的方式，CORS 是一个 W3C 标准，全称是”跨域资源共享”。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</p><p><strong>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</strong></p><p>（7）使用 <code>websocket</code> 协议，这个协议没有同源限制。</p><p>（8）使用<code>服务器来代理跨域的访问请求</code>，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p><h3 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h3><h3 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h3><ul><li><p>我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</p></li><li><p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条 cookie 包括了 5 个属性值 <code>expires、domain、path、secure、HttpOnly</code>。</p><ul><li>其中 expires 指定了 cookie 失效的时间</li><li>domain 是域名、path 是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。</li><li>secure 规定了 cookie 只能在确保安全的情况下传输，</li><li>HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</li></ul></li><li><p>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p></li></ul><h2 id="模块加载"><a href="#模块加载" class="headerlink" title="模块加载"></a>模块加载</h2><h3 id="63-模块化开发怎么做？"><a href="#63-模块化开发怎么做？" class="headerlink" title="63. 模块化开发怎么做？"></a>63. 模块化开发怎么做？</h3><h3 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h3><p>js 中现在比较成熟的有四种模块加载方案。</p><p><code>第一种是 CommonJS 方案</code>，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是<br>服务器端的解决方案，它是以同步的方式来引入模块的，<code>因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式 加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适</code></p><p><code>第二种是 AMD 方案</code>，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定<br>义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p><p><code>第三种是 CMD 方案</code>，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js<br>的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p><p><code>第四种方案是 ES6 提出的方案</code>，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</p><h3 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h3><h3 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><h3 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p><h3 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h3><h2 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h2><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。</p><p><em>在 class 中添加的方法，其实是添加在类的原型上的。</em></p><h2 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h2><p>document.write 的内容会代替整个文档内容，<code>会重写整个页面</code>。</p><p>innerHTML 的内容只是替代指定元素的内容，<code>只会重写页面中的部分内容</code>。</p><h2 id="71-🌟-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-🌟-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71.🌟 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71.🌟 DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; (1）创建新节点createDocumentFragment(node);createElement(node);createTextNode(text);&#x2F;&#x2F; （2）添加、移除、替换、插入appendChild(node)removeChild(node)replaceChild(new,old)insertBefore(new,old)&#x2F;&#x2F; （3）查找getElementById();getElementsByName();getElementsByTagName();getElementsByClassName();querySelector();querySelectorAll();&#x2F;&#x2F; （4）属性操作getAttribute(key);setAttribute(key, value);hasAttribute(key);removeAttribute(key);</code></pre><h2 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 对于这样一个 HTML 元素：&lt;div&gt;content&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;。&#x2F;&#x2F; innerHTML：内部 HTML，content&lt;br&#x2F;&gt;；&#x2F;&#x2F; outerHTML：外部 HTML，&lt;div&gt;content&lt;br&#x2F;&gt;&lt;&#x2F;div&gt;；&#x2F;&#x2F; innerText：内部文本，content ；&#x2F;&#x2F; outerText：内部文本，content ；</code></pre><h2 id="73-call-和-apply-的区别？"><a href="#73-call-和-apply-的区别？" class="headerlink" title="73. .call() 和 .apply() 的区别？"></a>73. .call() 和 .apply() 的区别？</h2><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><p><em>apply 接受两个参数</em> ,<code>第一个参数指定了函数体内 this 对象的指向</code>，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p><p><em>call 传入的参数数量不固定</em> ,跟 apply 相同的是，<code>第一个参数也是代表函数体内的 this 指向</code>，从第二个参数开始往后，每个参数被依次传入函数。</p><h2 id="74-🌟JavaScript-类数组对象的定义？"><a href="#74-🌟JavaScript-类数组对象的定义？" class="headerlink" title="74. 🌟JavaScript 类数组对象的定义？"></a>74. 🌟JavaScript 类数组对象的定义？</h2><p><em>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法</em></p><p>常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length<br>属性值，代表可接收的参数个数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 常见的类数组转换为数组的方法有这样几种：&#x2F;&#x2F; （1）通过 call 调用数组的 slice 方法来实现转换Array.prototype.slice.call(arrayLike);&#x2F;&#x2F; （2）通过 call 调用数组的 splice 方法来实现转换Array.prototype.splice.call(arrayLike, 0);&#x2F;&#x2F; （3）通过 apply 调用数组的 concat 方法来实现转换Array.prototype.concat.apply([], arrayLike);&#x2F;&#x2F; （4）通过 Array.from 方法来实现转换Array.from(arrayLike);</code></pre><h2 id="75-🌟-数组和对象有哪些原生方法，列举一下？"><a href="#75-🌟-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75.🌟 数组和对象有哪些原生方法，列举一下？"></a>75.🌟 数组和对象有哪些原生方法，列举一下？</h2><h2 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h2><h2 id="77-🌟-的长度？"><a href="#77-🌟-的长度？" class="headerlink" title="77.🌟 [,,,] 的长度？"></a>77.🌟 [,,,] 的长度？</h2><p><code>长度为 3</code></p><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p><p>JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</p><p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数<br>量。</p><h2 id="78-🌟-JavaScript-中的作用域与变量声明提升？"><a href="#78-🌟-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78.🌟 JavaScript 中的作用域与变量声明提升？"></a>78.🌟 JavaScript 中的作用域与变量声明提升？</h2><p>变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</p><p><em>造成变量声明提升的本质原因</em>:<code>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象</code>。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</p><h2 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h2><ol><li>避免使用过深的嵌套循环。</li><li>当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找</li><li>循环能提前终止，要提前终止</li><li>对象&#x2F;map 可以代替数组遍历</li></ol><h2 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h2><h2 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h2><h2 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h2><h2 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h2><h2 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h2><p>按照 HTML5 标准中的 HTML 语法规则，如果在 <code>&lt;/body&gt;</code>后再出现<code>&lt;script&gt;</code>或任何元素的开始标签，都是 parse error，浏览器会忽略之前的<code>&lt;/body&gt;</code>，即视作仍旧在 body 内。</p><p>所以实际效果和写在<code>&lt;/body&gt;</code>之前是没有区别的。总之，这种写法虽然也能 work，但是并没有带来任何额外好处，实际上出现这样的写法很可能是误解了“将 script 放在页面最末端”的教条。所以还是不要这样写为好。</p><p>作者：贺师俊<br>链接：<a href="https://www.zhihu.com/question/20027966/answer/13727164">https://www.zhihu.com/question/20027966/answer/13727164</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？</h2><h2 id="86-什么是“前端路由”？-什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？-什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？ 什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？ 什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h2><h2 id="87-如何测试前端代码么？知道-BDD-TDD-Unit-Test-么？知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？知道-BDD-TDD-Unit-Test-么？知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？知道 BDD, TDD, Unit Test 么？知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？知道 BDD, TDD, Unit Test 么？知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h2><h2 id="88-检测浏览器版本版本有哪些方式？"><a href="#88-检测浏览器版本版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本版本有哪些方式？"></a>88. 检测浏览器版本版本有哪些方式？</h2><p>检测浏览器版本一共有两种方式：</p><p>_一种是检测 window.navigator.userAgent 的值_，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p><p>_第二种方式是功能检测_，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p><h2 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h2><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p><h2 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。&#x2F;&#x2F; 对于 &#39;filename&#39; 和 &#39;.hiddenfile&#39; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。&#x2F;&#x2F; String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。function getFileExtension(filename) &#123;  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);&#125;</code></pre><h2 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h2><h2 id="92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>92. Object.is() 与原来的比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h2><p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回 false）。</p><p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.</p><p><strong>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</strong></p><h2 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h2><p><code>encodeURI</code> 是对整个 URI 进行转义，<code>将 URI 中的非法字符转换为合法字符</code>，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p><p><code>encodeURIComponent</code> 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p><p><code>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别</code>，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p><h2 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h2><h3 id="utf8"><a href="#utf8" class="headerlink" title="utf8"></a>utf8</h3><p><strong>优点</strong></p><ul><li>UTF-8 编码可以通过屏蔽位和移位操作<code>快速读写</code>。</li><li>字符串比较时 strcmp()和 wcscmp()的返回结果相同，因此使<code>排序变得更加容易</code>。</li><li>字节 FF 和 FE 在 UTF-8 编码中永远不会出现，因此他们<code>可以用来区分 UTF-16 或 UTF-32 文本</code>。</li><li>UTF-8 是<code>字节顺序无关的</code>。它的<code>字节顺序在所有系统中都是一样的</code>，因此它实际上并不需要 BOM。 [1]</li><li>同时兼容 ASCII 编码</li></ul><p><strong>缺点</strong><br>你无法从 UNICODE 字符数判断出 UTF-8 文本的字节数，因为 UTF-8 采用的是不定长的编码方式。</p><p><a href="https://baike.baidu.com/item/UTF-8/481798" target="_blank" >百度百科 UTF-8</a></p><h2 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h2><h2 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h2><p><code>浅拷贝</code>指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。</p><p><code>深拷贝</code>相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p><h2 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h2><h2 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h2><h2 id="99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-x3D-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</h2><h2 id="100-原码、反码和补码的介绍-101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#100-原码、反码和补码的介绍-101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>100. 原码、反码和补码的介绍 101. toPrecision 和 toFixed 和 Math.round 的区别？</h2><h2 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h2><h2 id="注意点-SQL-注入不属于-XSS-攻击"><a href="#注意点-SQL-注入不属于-XSS-攻击" class="headerlink" title="注意点 SQL 注入不属于 XSS 攻击"></a>注意点 SQL 注入不属于 XSS 攻击</h2><p><strong>原因：SQL 注入，执行是在服务端执行，XSS 攻击是在客户端执行</strong></p><h2 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h2><h2 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h2><h2 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h2><h2 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h2><h2 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h2><h2 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h2><h2 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h2><h2 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h2><h2 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h2><h2 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h2><h2 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h2><h2 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h2><h2 id="115-谈谈你对-webpack-的看法-116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？"><a href="#115-谈谈你对-webpack-的看法-116-offsetWidth-x2F-offsetHeight-clientWidth-x2F-clientHeight-与-scrollWidth-x2F-scrollHeight-的区别？" class="headerlink" title="115. 谈谈你对 webpack 的看法 116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？"></a>115. 谈谈你对 webpack 的看法 116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</h2><h2 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h2><h2 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h2><h2 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h2><h2 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h2><h2 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h2><h2 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h2><h2 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h2><h2 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>mouseenter: <code>当鼠标指针从它后代的物理空间移动到它自己的物理空间时，它不会冒泡，也不会发送给它的任何后代</code></li><li>mouseover: <code>可能会存在性能问题</code>。层次结构很深，发送到 mouseover 事件可能相当多，并导致严重的<code>性能问题</code>。在这种情况下，最好是监听 mouseenter 事件。</li><li>mouseleave（当鼠标退出其内容区域时向元素触发），mouseenter 事件的作用与 CSS 伪类 <code>:hover</code> 非常相似</li></ul><h3 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h3><ul><li>mouseenter&#x2F;mouseleave</li><li>mouseover&#x2F;mouseout 冒泡</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseenter_event" target="_blank" >MDN mouseenter_event</a></p><h2 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h2><h2 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，<br>但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，<br>只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。</p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p><h2 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h2><h2 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h2><h2 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>尾调用指的是函数的最后一步调用另一个函数。</p><h3 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h3><p>我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。</p><p>使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h2 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h2><ol><li>Symbol 函数前<code>不能使用 new 命令</code>，否则会报错。</li><li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>Symbol 作为属性名，该属性不会出现在 <code>for...in</code>、<code>for...of</code> 循环中，也不会被<code> Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。</li><li>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li><li>获取 Symbol 括号内的值(description)，用 Symbol.prototype.description</li></ol><h2 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h2><ul><li>WeakSet 弱引用，假设，除了 WeakSet 之外没有其他的引用，那么垃圾回收机制，可能被回收</li></ul><h2 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h2><h3 id="Map-与-Object-的区别"><a href="#Map-与-Object-的区别" class="headerlink" title="Map 与 Object 的区别"></a>Map 与 Object 的区别</h3><ul><li>Object 本质上是哈希结构的键值对的集合，它只能用字符串、数字或者 Symbol 等简单数据类型</li><li>Map 类继承了 Object，并对 Object 功能做了一些拓展，Map 的键可以是任意的数据类型。</li><li>Map 技高一筹,他的 <code>key 既可以是基本数据类型，也可以是引用数据类型</code></li><li>Map 实现了迭代器，可用 for…of 遍历，而 Object 不行。</li><li>Map 可以直接拿到长度，而 Object 不行。 填入 Map 的元素，会保持原有的顺序，而 Object</li></ul><p><a href="https://www.jianshu.com/p/94cf51649517" target="_blank" >这篇文章，“同名碰撞写的有问题”</a></p><p><strong>obj[key] &#x3D; value 实际上是</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function processingKey(key) &#123;  if (key &#x3D;&#x3D;&#x3D; undefined) &#123;    return &quot;undefined&quot;;  &#125; else if (key &#x3D;&#x3D;&#x3D; null) &#123;    return &quot;null&quot;;  &#125; else &#123;    return key.toString();  &#125;&#125;obj[processingKey(key)] &#x3D; value;</code></pre><p><a href="https://juejin.cn/post/6844904000827949064" target="_blank" >[js 行为研究] 对象作为对象的键会发生什么？</a></p><h2 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h2><p><a href="/#/post/2022-06-10js-数据劫持" target="_blank" >&#x2F;#&#x2F;post&#x2F;2022-06-10js-数据劫持</a></p><p><a href="/#/post/2022-07-04js" target="_blank" >&#x2F;#&#x2F;post&#x2F;2022-07-04js 数据劫持</a></p><h2 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h2><h3 id="问题：-ES6-Proxy-里面为什么要用-Reflect？"><a href="#问题：-ES6-Proxy-里面为什么要用-Reflect？" class="headerlink" title="问题： ES6 Proxy 里面为什么要用 Reflect？"></a>问题： <a href="https://www.zhihu.com/question/460133198" target="_blank" >ES6 Proxy 里面为什么要用 Reflect？</a></h3><p>Proxy &amp; Reflect 的话题</p><ul><li><p>Proxy 代理，它内置了一系列”陷阱“用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p></li><li><p>Reflect 反射，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy 的方法相同。</p></li><li><p>简单来说，我们可以通过 Proxy 创建对于原始对象的代理对象，从而在代理对象中使用 - Reflect 达到对于 JavaScript 原始操作的拦截。</p></li></ul><p>作者：WangHaoyu<br>链接：<a href="https://www.zhihu.com/question/460133198/answer/2416115070">https://www.zhihu.com/question/460133198/answer/2416115070</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="为什么-Proxy-amp-Reflect-联合使用"><a href="#为什么-Proxy-amp-Reflect-联合使用" class="headerlink" title="为什么 Proxy &amp; Reflect 联合使用"></a>为什么 Proxy &amp; Reflect 联合使用</h3><ul><li>是为了和 Proxy 的 API 对应上，是为触发代理对象的劫持时保证正确的 this 上下文指向</li><li>Proxy 中 receiver 存在的意义就是为了正确的在陷阱中传递上下文</li><li>Reflect.get(target, key, receiver) 可理解成为 target[key].call(receiver)</li></ul><h2 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h2><p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p><p>（1）如果 X 是内置模块（比如 require(‘http’)）<br>　　 a. 返回该模块。<br>　　 b. 不再继续执行。</p><p>（2）如果 X 以 “.&#x2F;“ 或者 “&#x2F;“ 或者 “..&#x2F;“ 开头<br>　　 a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。</p><pre><code><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; X&#x2F;&#x2F; X.js&#x2F;&#x2F; X.json&#x2F;&#x2F; X.node</code></pre>c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; X&#x2F;package.json（main 字段）&#x2F;&#x2F; X&#x2F;index.js&#x2F;&#x2F; X&#x2F;index.json&#x2F;&#x2F; X&#x2F;index.node</code></pre></code></pre><p>（3）如果 X 不带路径<br>　　 a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　 b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p><p>（4）抛出 “not found”</p><h2 id="136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-x2F-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</h2><p>Promise 对象是异步编程的一种解决方案，最早由社区提出。<br>Promises&#x2F;A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p><p><code>Promise 是一个构造函数</code>，接收一个函数作为参数，返回<code>一个 Promise 实例</code>。<br><code>一个 Promise 实例</code>有三种状态，分别是 <code>pending</code>、<code>resolved</code> 和 <code>rejected</code>，分别代表了进行中、已成功和已失败。<br>实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 <code>resolve()</code> 和 <code>reject()</code> 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><h2 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const PENDING &#x3D; &quot;pending&quot;;const RESOLVED &#x3D; &quot;resolved&quot;;const REJECTED &#x3D; &quot;rejected&quot;;function MyPromise(fn) &#123;  &#x2F;&#x2F; 保存初始化状态  var self &#x3D; this;  &#x2F;&#x2F; 初始化状态  this.state &#x3D; PENDING;  &#x2F;&#x2F; 用于保存 resolve 或者 rejected 传入的值  this.value &#x3D; null;  &#x2F;&#x2F; 用于保存 resolve 的回调函数  this.resolvedCallbacks &#x3D; [];  &#x2F;&#x2F; 用于保存 reject 的回调函数  this.rejectedCallbacks &#x3D; [];  &#x2F;&#x2F; 状态转变为 resolved 方法  function resolve(value) &#123;    &#x2F;&#x2F; 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变    if (value instanceof MyPromise) &#123;      return value.then(resolve, reject);    &#125;    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 只有状态为 pending 时才能转变，      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        self.state &#x3D; RESOLVED;        &#x2F;&#x2F; 设置传入的值        self.value &#x3D; value;        &#x2F;&#x2F; 执行回调函数        self.resolvedCallbacks.forEach((callback) &#x3D;&gt; &#123;          callback(value);        &#125;);      &#125;    &#125;, 0);  &#125;  &#x2F;&#x2F; 状态转变为 rejected 方法  function reject(value) &#123;    &#x2F;&#x2F; 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 只有状态为 pending 时才能转变      if (self.state &#x3D;&#x3D;&#x3D; PENDING) &#123;        &#x2F;&#x2F; 修改状态        self.state &#x3D; REJECTED;        &#x2F;&#x2F; 设置传入的值        self.value &#x3D; value;        &#x2F;&#x2F; 执行回调函数        self.rejectedCallbacks.forEach((callback) &#x3D;&gt; &#123;          callback(value);        &#125;);      &#125;    &#125;, 0);  &#125;  &#x2F;&#x2F; 将两个方法传入函数执行  try &#123;    fn(resolve, reject);  &#125; catch (e) &#123;    &#x2F;&#x2F; 遇到错误时，捕获错误，执行 reject 函数    reject(e);  &#125;&#125;MyPromise.prototype.then &#x3D; function (onResolved, onRejected) &#123;  &#x2F;&#x2F; 首先判断两个参数是否为函数类型，因为这两个参数是可选参数  onResolved &#x3D;    typeof onResolved &#x3D;&#x3D;&#x3D; &quot;function&quot;      ? onResolved      : function (value) &#123;          return value;        &#125;;  onRejected &#x3D;    typeof onRejected &#x3D;&#x3D;&#x3D; &quot;function&quot;      ? onRejected      : function (error) &#123;          throw error;        &#125;;  &#x2F;&#x2F; 如果是等待状态，则将函数加入对应列表中  if (this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;    this.resolvedCallbacks.push(onResolved);    this.rejectedCallbacks.push(onRejected);  &#125;  &#x2F;&#x2F; 如果状态已经凝固，则直接执行对应状态的函数  if (this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;    onResolved(this.value);  &#125;  if (this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;    onRejected(this.value);  &#125;&#125;;</code></pre><h2 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function isSupportFontSize(size) &#123;  &#x2F;&#x2F; 创建dom，设置字体大小，挂在dom,获取字体  let pdom &#x3D; document.createElement(&quot;p&quot;);  pdom.style.fontSize &#x3D; size + &quot;px&quot;;  document.body.append(pdom);  function getstyle(obj, key) &#123;    if (obj.currentStyle) &#123;      return obj.currentStyle[key];    &#125; else &#123;      return getComputedStyle(obj, false)[key];    &#125;  &#125;  &#x2F;&#x2F; 验证是否一致  return parseFloat(getstyle(pdom, &quot;fontSize&quot;)) &#x3D;&#x3D; size;&#125;isSupportFontSize(10);</code></pre><h2 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h2><p>error 统计使用浏览器的 window.error 事件。</p><h2 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h2><p><code>单例模式保证了全局只有一个实例来被访问</code>。比如说常用的如弹框组件的实现和全局状态的实现。</p><h2 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h2><p><code>策略模式主要是用来将方法的实现和方法的调用分离开</code>，外部通过不同的参数可以调用不同的策略。主要在 MVP 模式解耦的时候<br>用来将视图层的方法定义和方法调用分离。</p><h2 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h2><p>代理模式是为<code>一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理</code>。</p><h2 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h2><p>中介者模式指的是，<code>多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦</code></p><h2 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h2><p><code>适配器用来解决两个接口不兼容的情况</code>，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种<br>新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种<br>自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p><h2 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h2><p><code>发布订阅模式其实属于广义上的观察者模式</code></p><ul><li><p><code>在观察者模式中</code>，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p></li><li><p><code>而在发布订阅模式中</code>，<code>发布者和订阅者之间多了一个调度中心</code>。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p></li></ul><h2 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h2><h2 id="147-Vue-的各个生命阶段是什么？"><a href="#147-Vue-的各个生命阶段是什么？" class="headerlink" title="147. Vue 的各个生命阶段是什么？"></a>147. Vue 的各个生命阶段是什么？</h2><h2 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h2><h2 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h2><h2 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h2><h2 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h2><h2 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h2><h2 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h2><h2 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h2><h2 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h2><h2 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h2><h2 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h2><h2 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h2><h2 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h2><h2 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h2><h2 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h2><h2 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h2><h2 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h2><h2 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h2><h2 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h2><h2 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h2><h2 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h2><h2 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h2><h2 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h2><h2 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h2><h2 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h2><h2 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h2><h2 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h2><h2 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="JS-为什么不能直接赋值-undefined-？"><a href="#JS-为什么不能直接赋值-undefined-？" class="headerlink" title="JS 为什么不能直接赋值 undefined ？"></a>JS 为什么不能直接赋值 undefined ？</h2><p><a href="https://juejin.cn/post/7113217396801798151" target="_blank" >JS 为什么不能直接赋值 undefined ？</a></p><p>低级浏览器可以被改写，不安全</p><h2 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h2><ul><li>十六进制 hexadecimal <code>0x</code></li><li>八进制 octal <code>0O</code></li><li>二进制 binary <code>0b</code></li><li>十进制 decimal</li></ul><p><a href="https://www.zhihu.com/question/66324454" target="_blank" >见</a></p><h2 id="CommonJS-AMD-CMD-全称"><a href="#CommonJS-AMD-CMD-全称" class="headerlink" title="CommonJS,AMD,CMD 全称"></a>CommonJS,AMD,CMD 全称</h2><h3 id="全称"><a href="#全称" class="headerlink" title="全称"></a>全称</h3><ul><li><p>AMD 规范:全称<code>Asynchronous Module Definition</code>，称为 异步模块加载规范 。一般应用在浏览器端。流行的浏览器端异步加载库 RequireJS 实现的就是 AMD 规范。</p></li><li><p>CMD 规范，全称<code>Common Module Definition</code>，称为 通用模块加载规范。一般也是用在浏览器端。浏览器端异步加载库 Sea.js 实现的就是 CMD 规范。</p></li><li><p>CommonJS: 称为同步模块加载规范，也就是说，只有加载完成，才能执行后面的操作。</p></li></ul><p>AMD 特点: 依赖前置，提前执行!<br>CMD 特点: 依赖就近，延迟执行!</p><h3 id="CMD-与-AMD-区别"><a href="#CMD-与-AMD-区别" class="headerlink" title="CMD 与 AMD 区别"></a>CMD 与 AMD 区别</h3><p>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。<br>CMD 推崇依赖就近，AMD 推崇依赖前置。</p><h3 id="nodejs-为什么使用-commonjs-规范"><a href="#nodejs-为什么使用-commonjs-规范" class="headerlink" title="nodejs 为什么使用 commonjs 规范"></a>nodejs 为什么使用 commonjs 规范</h3><p>因为 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式。但如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范</p><p>作者：一点代码<br>链接：<a href="https://www.jianshu.com/p/65ab05d3cdeb">https://www.jianshu.com/p/65ab05d3cdeb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="class-是-prototype-的语法糖？"><a href="#class-是-prototype-的语法糖？" class="headerlink" title="class 是 prototype 的语法糖？"></a>class 是 prototype 的语法糖？</h2><ul><li>两者如何增加属性？</li><li>两者如何实现继承？</li><li>既然是语法糖，那么父类是 class，子类是 prototype 能否继承？</li><li>既然是语法糖，这个糖如何实现的？</li><li>prototype 如何实现 class 的 static</li></ul><h3 id="是不是属于自身属性"><a href="#是不是属于自身属性" class="headerlink" title="是不是属于自身属性"></a>是不是属于自身属性</h3><ul><li><code>实例.hasOwnProperty(属性)</code> 查看该属性是否来自本身。</li><li><code>Object.getOwnPropertyNames(obj)</code> 返回所有对象本身属性名数组，无论是否能枚举</li><li><code>属性 in 对象 判断能否通过该对象访问该属性</code>，无论是在本身还是原型上</li></ul><h3 id="获取一个对象的-prototype"><a href="#获取一个对象的-prototype" class="headerlink" title="获取一个对象的 prototype"></a>获取一个对象的 prototype</h3><ul><li><code>Object.getPrototypeOf(obj) 方法</code>，他返回对象的 prototype</li><li><code>Object.setPrototypeOf(object, prototype) 方法</code>，设置对象的 prototype</li><li>还可以使用对象的<code>__proto__</code>属性获取和修改对象的 prototype（不推荐）</li></ul><p>作者：羽月<br>链接：<a href="https://juejin.cn/post/6844903788642484237">https://juejin.cn/post/6844903788642484237</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><a href="https://juejin.cn/post/6844903788642484237#heading-4" target="_blank" >见</a></p><h2 id="为什么-JavaScript-最大安全整数是-2-53-1"><a href="#为什么-JavaScript-最大安全整数是-2-53-1" class="headerlink" title="为什么 JavaScript 最大安全整数是 2^53-1"></a>为什么 JavaScript 最大安全整数是 2^53-1</h2><p><strong>这个 53 是怎么得到的？</strong></p><p>IEEE 754 规定了四种表示浮点数值的方式：</p><p>单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）。</p><p><code>Number</code> 类型使用的便是其中的<code>双精确度（64 位）</code>。</p><img src="http://t-blog-images.aijs.top/img/202211011218126.webp" /><table><thead><tr><th align="left">位置</th><th align="left">位数</th><th align="left">作用</th><th align="left">表示</th></tr></thead><tbody><tr><td align="left">0-51</td><td align="left">52</td><td align="left">尾数位</td><td align="left">原码表示</td></tr><tr><td align="left">52-62</td><td align="left">11</td><td align="left">指数位</td><td align="left">移码表示</td></tr><tr><td align="left">63</td><td align="left">1</td><td align="left">符号位</td><td align="left">0,1</td></tr></tbody></table><p><strong>因为： 此时就不安全了;</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">2 ** 53 &#x3D;&#x3D;&#x3D; 2 ** 53 + 1; &#x2F;&#x2F;true</code></pre><p><strong>在 2^53-1 之后的数中，只要指数相同，并且尾数前 52 位相同，则这个两个数数值相同。</strong></p><p><a href="https://juejin.cn/post/6880143057930190855" target="_blank" >为什么 JavaScript 最大安全整数是 2^53-1</a></p><h2 id="没你想象的那么简单"><a href="#没你想象的那么简单" class="headerlink" title=", 没你想象的那么简单"></a>, 没你想象的那么简单</h2><p>对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let x &#x3D; 1;x &#x3D; (x++, x);console.log(x);&#x2F;&#x2F; expected output: 2x &#x3D; (2, 3);console.log(x);&#x2F;&#x2F; expected output: 3</code></pre><p>这也太难了吧</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/142745906" target="_blank" >170 道 JavaScript 面试题及知识点总结（上）</a><br><a href="https://zhuanlan.zhihu.com/p/142749891" target="_blank" >170 道 JavaScript 面试题及知识点总结（下）</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可视化埋点</title>
      <link href="//post/2022-10-24%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%8B%E7%82%B9.html"/>
      <url>//post/2022-10-24%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%8B%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/560974740" target="_blank" >从 0 到 1 搭建可视化埋点平台</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-css q&amp;a</title>
      <link href="//post/2022-10-23css-qa.html"/>
      <url>//post/2022-10-23css-qa.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-获取-CDNS-的-文章标题"><a href="#1-获取-CDNS-的-文章标题" class="headerlink" title="1. 获取 CDNS 的 文章标题"></a>1. 获取 CDNS 的 文章标题</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var list &#x3D; document.getElementsByClassName(&quot;column_article_list&quot;)[0].children;Array.from(list).forEach((item) &#x3D;&gt; &#123;  var text &#x3D; item.children[0].children[0].children[0].innerText;  document.body.append(text + &quot;\n&quot;);&#125;);</code></pre><h2 id="1-css-的-root、var-以及-root、html、-选择器优先级"><a href="#1-css-的-root、var-以及-root、html、-选择器优先级" class="headerlink" title="1. css 的:root、var()以及:root、html、* 选择器优先级"></a>1. css 的:root、var()以及:root、html、<code>*</code> 选择器优先级</h2><p><a href="https://blog.csdn.net/qq_39706777/article/details/120025610" target="_blank" >见</a></p><h3 id="1-1-root"><a href="#1-1-root" class="headerlink" title="1.1. :root"></a>1.1. :root</h3><p>代表文档的根元素，在:root 中声明的属性是全局属性，都可以通过 var()引用</p><h3 id="1-2-var"><a href="#1-2-var" class="headerlink" title="1.2. var( )"></a>1.2. var( )</h3><p>var(属性名) 可以代替元素任何属性中的任何值</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">:root&#123;    --normal-color: pink;&#125;.bg&#123;    background-color: var(--normal-color);&#125;————————————————版权声明：本文为CSDN博主「liun_n」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39706777&#x2F;article&#x2F;details&#x2F;120025610</code></pre><h3 id="1-3-var-回退值"><a href="#1-3-var-回退值" class="headerlink" title="1.3. var( )回退值"></a>1.3. var( )回退值</h3><p>没有声明–active-color，则回退到 blue</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">:root &#123;  --normal-color: pink;&#125;.bg &#123;  background-color: var(—active-color, blue);&#125;</code></pre><h3 id="1-4-优先级"><a href="#1-4-优先级" class="headerlink" title="1.4. 优先级"></a>1.4. 优先级</h3><p>:root &gt; html &gt; <code>*</code> 选择器优先级</p><h2 id="2-移动端总结"><a href="#2-移动端总结" class="headerlink" title="2. 移动端总结"></a>2. 移动端总结</h2><h3 id="缩放适配"><a href="#缩放适配" class="headerlink" title="缩放适配"></a>缩放适配</h3><h3 id="rem-适配"><a href="#rem-适配" class="headerlink" title="rem 适配"></a>rem 适配</h3><h3 id="vw-适配"><a href="#vw-适配" class="headerlink" title="vw 适配"></a>vw 适配</h3><h3 id="移动端点击-300ms"><a href="#移动端点击-300ms" class="headerlink" title="移动端点击 300ms"></a>移动端点击 300ms</h3><p>高版本 chrome 和 iOS 已经修复<br>是否引入 faskclick.js</p><p>Chrome 32 对移动端进行了优化，可以不禁用缩放，也能解决延迟的问题。<br>接着 Firefox 和 IE&#x2F;Edge 紧随其后也修复了这个 BUG，<br>最后，就是 iOS 9.3 也同样修复这个 BUG</p><p>是否仍然有必要使用呢，回到开始，我说过，适合自己的才是最好的，因此，如果你的业务需求，是只需要对 iOS 9.3 以上的 WKWebView 做适配，那么强烈建议你不去使用，毕竟减少了文件请求大小，引入风险的概率</p><p><a href="https://juejin.cn/post/6844903850160160782" target="_blank" >移动端 300ms 延迟及 fastClick 原理解析</a></p><p><strong>原理：</strong></p><p>移动端，当用户点击屏幕时，会依次触发 touchstart，touchmove(0 次或多次)，touchend，mousemove，mousedown，mouseup，click。<br>touchmove: 只有当手指在屏幕发生移动的时候才会触发 touchmove 事件。</p><p>在 touchstart, touchmove 或者 touchend 事件中的任意一个调用 event.preventDefault，mouse 事件 以及 click 事件将不会触发。</p><p>fastClick 在 touchend 阶段 调用 event.preventDefault，然后通过 document.createEvent 创建一个 MouseEvents，然后 通过 event​Target​.dispatch​Event 触发对应目标元素上绑定的 click 事件。</p><h3 id="点击穿透"><a href="#点击穿透" class="headerlink" title="点击穿透"></a>点击穿透</h3><p><a href="https://www.cnblogs.com/shytong/p/5463673.html" target="_blank" >点击穿透原理及解决</a></p><p>原理：在这 300ms 以内，因为上层元素隐藏或消失了，由于 click 事件的滞后性，同样位置的 DOM 元素触发了 click 事件（如果是 input 则触发了 focus 事件）。在代码中，给我们的感觉就是 target 发生了飘移。</p><p>1、禁止页面缩放 部分浏览器不再需要等待 300ms<br>2、300+ms<br>3、阻止默认事件。<br>4、引入 faskclick.js： 原理：touch 事件先于 mouse 事件先于 click 执行，因此可以在 document.body 上绑定事件用于监听点触行为，根据需要模拟 click 触发真正需要响应的元素</p><h2 id="3-学习-css-文本溢出显示省略号？"><a href="#3-学习-css-文本溢出显示省略号？" class="headerlink" title="3. 学习 css 文本溢出显示省略号？"></a>3. 学习 css 文本溢出显示省略号？</h2><h3 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h3><h3 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* 单行 *&#x2F;display: inline-block;width: 100px;&#x2F;* 设置文本不进行换行 *&#x2F;white-space: nowrap;&#x2F;* 让超出部分省略 *&#x2F;overflow: hidden;&#x2F;* 超出部分使用省略号 *&#x2F;text-overflow: ellipsis;&#x2F;* 多行 *&#x2F;width: 100px;overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical;&#x2F;* 注意：必要时候，需要设置 *&#x2F;</code></pre><p>两栏布局？</p><h2 id="4-translate-x2F-position？"><a href="#4-translate-x2F-position？" class="headerlink" title="4. translate &#x2F; position？"></a>4. translate &#x2F; position？</h2><ol><li><p><strong>是什么</strong> translate 是 transform 的一个值。</p></li><li><p><strong>回流&#x2F;重绘</strong> 改变 transform 或者 opacity 不会触发浏览器重新布局，或者重绘，只会触发复合。<br>而改变绝对定位会触发回流，进而触发重绘，所以说在使用绝对定位时会触发重绘和回流操作。</p></li><li><p><strong>CPU&#x2F;GPU</strong> transform 使浏览器为元素创建一个 GPU 图层，但是改变绝对定位会使用到 CPU，因此 translate 更加高效，可以缩短平滑动画的绘制时间。</p></li><li><p><strong>原位置</strong> translate 改变元素时，元素依然会占据原始位置，但是绝对定位的元素不会占据之前的位置</p></li></ol><h2 id="5-你对媒体查询的理解？"><a href="#5-你对媒体查询的理解？" class="headerlink" title="5. 你对媒体查询的理解？"></a>5. 你对媒体查询的理解？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><ul><li>媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定 CSS 样式，</li><li>媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。</li><li>媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。</li><li>使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。</li></ul><!-- 作者：洞听链接：https://www.jianshu.com/p/eb1123d5b20b来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 --><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 这个不属于css级别的 --&gt;&lt;meta  name&#x3D;&quot;viewport&quot;  content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot;&#x2F;&gt;</code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;link  rel&#x3D;&quot;stylesheet&quot;  type&#x3D;&quot;text&#x2F;css&quot;  href&#x3D;&quot;m320.css&quot;  media&#x3D;&quot;only screen and (max-width:320px)&quot;&#x2F;&gt;&lt;link  rel&#x3D;&quot;stylesheet&quot;  type&#x3D;&quot;text&#x2F;css&quot;  href&#x3D;&quot;m480.css&quot;  media&#x3D;&quot;only screen and (min-width:321px) and (max-width:375px)&quot;&#x2F;&gt;</code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;*媒体查询*&#x2F;&#x2F;*当页面大于1200px 时，大屏幕，主要是PC 端*&#x2F;@media (min-width: 1200px) &#123;&#125;&#x2F;*在992 和1199 像素之间的屏幕里，中等屏幕，分辨率低的PC*&#x2F;@media (min-width: 992px) and (max-width: 1199px) &#123;&#125;&#x2F;*在768 和991 像素之间的屏幕里，小屏幕，主要是PAD*&#x2F;@media (min-width: 768px) and (max-width: 991px) &#123;&#125;&#x2F;*在480 和767 像素之间的屏幕里，超小屏幕，主要是手机*&#x2F;@media (min-width: 480px) and (max-width: 767px) &#123;&#125;&#x2F;*在小于480 像素的屏幕，微小屏幕，更低分辨率的手机*&#x2F;@media (max-width: 479px) &#123;&#125;</code></pre><h2 id="6-你对-css-sprites-的理解，好处是什么"><a href="#6-你对-css-sprites-的理解，好处是什么" class="headerlink" title="6. 你对 css sprites 的理解，好处是什么"></a>6. 你对 css sprites 的理解，好处是什么</h2><p>使用工具(ps 之类的)将多张图片打包成一张雪碧图，并为其生成何时的 css。每张图<br>片都有相应的 css 类，该类定义了</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">background-image,background-position,background-size 属性。</code></pre><p>使用图片时，将相应的类添加到你的元素中去即可。</p><h2 id="7-有哪些⽅式（CSS）可以隐藏⻚⾯元素？"><a href="#7-有哪些⽅式（CSS）可以隐藏⻚⾯元素？" class="headerlink" title="7. 有哪些⽅式（CSS）可以隐藏⻚⾯元素？"></a>7. 有哪些⽅式（CSS）可以隐藏⻚⾯元素？</h2><ul><li>占据空间，可以操作的 <code>opacity:0</code></li><li>占据空间，不可操作的 <code>visibility: hidden</code>, <code>transform: scale(0,0)</code></li><li>不占据空间 <code>overflow:hidden</code>, <code>display: none</code>, <code>z-index: -999</code></li></ul><h2 id="8-link-和-import-的区别？"><a href="#8-link-和-import-的区别？" class="headerlink" title="8. link 和@import 的区别？"></a>8. link 和@import 的区别？</h2><p>一、link 和@import 的区别？<br>1.1、<em>所属不同</em> link 属于 html 标签，而@import 是 css 提供的。<br>1.2、<em>加载</em> 页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面被加载完再加载的。<br>1.3、<em>兼容性问题：</em>@import 只在 IE5 以上才能识别，而 link 是 html 标签，无兼容性问题。<br>1.4、<em>权重问题:</em> link。的权重要高于 @import<br>1.5、<em>DOM 操作:</em> DOM 可以操作 link 中的样式，而不可以操作@import 中的样式。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/124225973">https://blog.csdn.net/weixin_47450807/article/details/124225973</a></p><p>简单了解 CSS3 的 all 属性</p><h2 id="9-margin-和-padding-分别适合什么场景使用？"><a href="#9-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="9. margin 和 padding 分别适合什么场景使用？"></a>9. margin 和 padding 分别适合什么场景使用？</h2><p><em>margin</em> 是用来隔开元素与元素之间的间距，padding 是用来隔开元素和内容的间距。margin 用来布局分开元素使得元素互不相干。<br><em>padding</em> 用于元素和内容之间的间隔，让内容与包裹元素之间存在一段距离。</p><h3 id="何时使用-margin"><a href="#何时使用-margin" class="headerlink" title="何时使用 margin"></a>何时使用 margin</h3><p>2.1、需要在 border 外侧田间空白时。<br>2.2、空白处不需要背景色时。<br>2.3、上下相连的两个盒子之间的空白，需要相互抵消时。如 15px+20px 的 margin，将得到 20px 的空白。</p><h3 id="何时使用-padding"><a href="#何时使用-padding" class="headerlink" title="何时使用 padding"></a>何时使用 padding</h3><p>3.1、需要在 border 内测添加空白时。<br>3.2、空白处需要背景（色）时。<br>3.3、上下相连的两个盒子之间的空白，希望等于两者之和时。如 15px+20px 的 padding，将得到 35px 的空白。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/124192349">https://blog.csdn.net/weixin_47450807/article/details/124192349</a></p><h2 id="10-浏览器是怎样解析-CSS-选择器的？"><a href="#10-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="10. 浏览器是怎样解析 CSS 选择器的？"></a>10. 浏览器是怎样解析 CSS 选择器的？</h2><p>1、<em>样式系统</em>从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只<br>要选择器的子树一直在工作，样式系统就会持续左移，知道和规则匹配，或者是<br>因为不匹配而放弃该规则。</p><p>2、如果<em>正向解析</em>，例如「div div p em」，我们首先就要检查当前元素到<br>html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到<br>最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹<br>配与否，效率很低。</p><p>3、<em>逆向匹配则</em>不同，如果当前的 DOM 元素是 div，而不是 selector 最后的<br>em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。</p><p>CSS 优化、提高性能的方法有哪些？</p><h2 id="11-请解释一下为什么需要清除浮动？"><a href="#11-请解释一下为什么需要清除浮动？" class="headerlink" title="11. 请解释一下为什么需要清除浮动？"></a>11. 请解释一下为什么需要清除浮动？</h2><p>来阻止盒子坍塌</p><h2 id="12-清除浮动的方式"><a href="#12-清除浮动的方式" class="headerlink" title="12. 清除浮动的方式"></a>12. 清除浮动的方式</h2><ul><li>使用 BFC</li><li>使用 clear 来清除浮动</li><li>使用伪元素选择器</li><li>固定高度</li></ul><h2 id="13-css-块级元素，行内元素和行内块级元素-css-三栏布局总结"><a href="#13-css-块级元素，行内元素和行内块级元素-css-三栏布局总结" class="headerlink" title="13. css 块级元素，行内元素和行内块级元素 css 三栏布局总结"></a>13. css 块级元素，行内元素和行内块级元素 css 三栏布局总结</h2><p><em>块级元素</em></p><p>1、它独占一行。<br>2、它的宽高可以设置。<br>3、默认时，宽度是 100%</p><p><code>&lt;div&gt;</code>，<code>&lt;h1-h6&gt;</code>,<code>&lt;ul&gt;</code>,<code>&lt;ol&gt;</code>,<code>li</code>等</p><p><em>行内元素</em></p><p>1、它的宽度有内容决定，高度有内容字体大小决定。<br>2、它不可以设置宽高。<br>3、它可以和其他行内元素位于同一行。</p><p><code>&lt;span&gt;</code>,<code>&lt;label&gt;</code>,<code>&lt;i&gt;</code>,<code>&lt;e&gt;</code></p><p><em>行内跨级元素</em></p><p>1、它既可以和其他的行内元素位于同一行。<br>2、元素的高度及与边的间距都可以设置。</p><p><code>&lt;input&gt;</code>，<code>&lt;img&gt;</code>,<code>&lt;select&gt;</code>等。</p><h2 id="14-如何理解-margin-重叠问题？？？？"><a href="#14-如何理解-margin-重叠问题？？？？" class="headerlink" title="14. 如何理解 margin 重叠问题？？？？"></a>14. 如何理解 margin 重叠问题？？？？</h2><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。<br>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><p>产生折叠的必备条件：margin 必须是邻接的</p><p>而根据 w3c 规范，两个 margin 是邻接的必须满足以下条件：</p><ul><li>必须是处于常规文档流（非 float 和绝对定位）的块级盒子,并且处于同一个 BFC 当中。</li><li>没有线盒，没有空隙（clearance，下面会讲到），没有 padding 和 border 将他们分隔开</li><li>都属于垂直方向上相邻的外边距，可以是下面任意一种情况</li><li>元素的 margin-top 与其第一个常规文档流的子元素的 margin-top</li><li>元素的 margin-bottom 与其下一个常规文档流的兄弟元素的 margin-top</li><li>height 为 auto 的元素的 margin-bottom 与其最后一个常规文档流的子元素的 margin-bottom</li><li>高度为 0 并且最小高度也为 0，不包含常规文档流的子元素，并且自身没有建立新的 BFC 的元素的 margin-top 和 margin-bottom</li><li>这里出现了两个新的概念 BFC 与 clearance。</li></ul><p>作者：LOVE 小狼<br>链接：<a href="https://www.jianshu.com/p/9c22ff05b9dd">https://www.jianshu.com/p/9c22ff05b9dd</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>Block formatting contexts，译为块级格式化上下文，它是指块级元素所在的一个环境</p><h3 id="clearance"><a href="#clearance" class="headerlink" title="clearance"></a>clearance</h3><p>闭合浮动的元素会在其 margin-top 以上产生一定的空隙，该空隙会阻止元素 margin-top 的折叠，并作为间距存在于元素的 margin-top 的上方。</p><p>‘display‘、‘position‘和‘float‘的相互关系？</p><h2 id="15-简单介绍使用图片-base64-编码的优点和缺点？"><a href="#15-简单介绍使用图片-base64-编码的优点和缺点？" class="headerlink" title="15. 简单介绍使用图片 base64 编码的优点和缺点？"></a>15. 简单介绍使用图片 base64 编码的优点和缺点？</h2><p><em>一、写在前面</em><br>base64 编码是一种图片处理格式，通过特定的算法将图片编码成一个长串字符串，在页面上显示的时候，可以用该字符串来代替图片的 url 属性。</p><p><em>二、使用 base64 的优点是：</em></p><p>1、减少一个图片的 http 请求。</p><p><em>三、使用 base64 的缺点是：</em></p><p>1、<em>体积问题</em> 根据 base64 的编码原理，编码后的大小会比原文件大小大 1&#x2F;3,如果把大图片编码到 html&#x2F;css 中，不仅会造<br>成文件体积增加，影响文件的加载速度，还会增加浏览器对 html 或 css 文件解析渲染的时间。<br>2、<em>缓存问题</em> 使用 base64 无法直接缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比于直接缓存图片<br>的效果要差很多。<br>3、<em>兼容性的问题</em> ，ie8 以前的浏览器不支持。<br>一般一些网站的小图标可以使用 base64 图片来引入。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/124042418">https://blog.csdn.net/weixin_47450807/article/details/124042418</a></p><h2 id="16-绝对定位元素与非绝对定位元素的百分比计算的区别？"><a href="#16-绝对定位元素与非绝对定位元素的百分比计算的区别？" class="headerlink" title="16. 绝对定位元素与非绝对定位元素的百分比计算的区别？"></a>16. 绝对定位元素与非绝对定位元素的百分比计算的区别？</h2><p><em>绝对定位元素的宽高百分比</em>是相对于临近的 position 不为 static 的祖先元素的<br>padding box 来计算的。</p><p><em>非绝对定位元素的宽高百分比</em>则是相对于父元素的 content box 来计算的。</p><h2 id="17-width-100-和-width-auto-有什么区别"><a href="#17-width-100-和-width-auto-有什么区别" class="headerlink" title="17. width: 100%和 width: auto 有什么区别"></a>17. width: 100%和 width: auto 有什么区别</h2><p><em>设置 children 元素 margin: 0</em> , 此时设置 width：100%和 width: auto 是没有什么区别的。</p><p><em>如果设置 children 元素 margin: 0 30px 时</em></p><p>width: 100%的元素宽度不变， 位置向左偏移 30px；<br>width: auto 的元素宽度变化，宽度 &#x3D; 父元素宽度 - 左边 margin - 右边 margin， 并且向左偏移 30px。</p><p><em>如果设置 children 元素 margin: 0 -30px 时</em></p><p>width: 100%的元素宽度不变，位置向左偏移-30px；<br>width: auto 的元素宽度变化，宽度 &#x3D; 父元素宽度 - 左边 margin - 右边 margin，并且向左偏移 30px ，并且向左偏移-30px;</p><p><a href="https://blog.csdn.net/weixin_47450807/article/details/124038254" target="_blank" >见</a></p><h2 id="18-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？"><a href="#18-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？" class="headerlink" title="18. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？"></a>18. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？</h2><h3 id="visibility-属性三种值，"><a href="#visibility-属性三种值，" class="headerlink" title="visibility 属性三种值，"></a>visibility 属性三种值，</h3><ul><li>visible，没有任何变化。</li><li>hidden：相当于 opacity: 0</li><li>collapse：有时候是 <code>visibility：hidden</code>， 有时候是 <code>display:none</code><ul><li>对于一般元素来说 visibility：collapse 表现的样式和 hidden 一样，</li><li>但是对于 table 相关的元素，比如 table group，table 列，table column group,他的表现却跟 display:none 一样，也就是说，他们占用的空间都会被释放掉。</li></ul></li></ul><h3 id="存在兼容性问题："><a href="#存在兼容性问题：" class="headerlink" title="存在兼容性问题："></a>存在兼容性问题：</h3><p>在谷歌浏览器里，使用 collapse 值和使用 hidden 值没有什么区别。<br>在火狐浏览器、Opera 和 IE11 里，使用 collapse 值的效果就如它的字面意思：table 的行会消失，它的下面一行<br>会补充它的位置。</p><p>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/124037787">https://blog.csdn.net/weixin_47450807/article/details/124037787</a></p><h2 id="19-什么是包含块，对于包含块的理解？"><a href="#19-什么是包含块，对于包含块的理解？" class="headerlink" title="19. 什么是包含块，对于包含块的理解？"></a>19. 什么是包含块，对于包含块的理解？</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>元素用来计算和定位的一个框</p><h3 id="分情况"><a href="#分情况" class="headerlink" title="分情况"></a>分情况</h3><p><em>默认情况下包含块</em> 就是离当前元素最近的块级祖先元素。<br><em>对于开启绝对定位的元素来说</em> 包含块是离它最近的开启了定位(且 position 不为 static)的祖先元素。<br><em>如果所有的祖先元素都没有开启定位</em> 则其包含块就是初始包含块（根元素）。</p><h2 id="20-为什么要初始化-CSS-的样式"><a href="#20-为什么要初始化-CSS-的样式" class="headerlink" title="20. 为什么要初始化 CSS 的样式"></a>20. 为什么要初始化 CSS 的样式</h2><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 css 初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><p>初始化的目的，并不是去除边框，只是为了统一所有的浏览器，正常化</p><h3 id="淘宝初始化"><a href="#淘宝初始化" class="headerlink" title="淘宝初始化"></a>淘宝初始化</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;body,button,input,select,textarea&#123;font:12px&#x2F;1.5tahoma,arial,\5b8b\4f53;&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;address,cite,dfn,em,var&#123;font-style:normal;&#125;code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;small&#123;font-size:12px;&#125;ul,ol&#123;list-style:none;&#125; &#x2F;&#x2F;常见a&#123;text-decoration:none;&#125; &#x2F;&#x2F;常见a:hover&#123;text-decoration:underline;&#125; &#x2F;&#x2F;常见sup&#123;vertical-align:text-top;&#125; &#x2F;&#x2F;常见sub&#123;vertical-align:text-bottom;&#125; &#x2F;&#x2F;常见legend&#123;color:#000;&#125;fieldset,img&#123;border:0;&#125;button,input,select,textarea&#123;font-size:100%;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125; *&#x2F;</code></pre><h2 id="20-li-与-li-之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#20-li-与-li-之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="20. li 与 li 之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>20. li 与 li 之间存在看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>浏览器默认会把 display 属性为 inline 或者 inline-block <code>元素间的空白字符（空格换行 tab）渲染成一个空格</code>。也就是我们上面 li 元素换行产生的换行符，而它会变成一个空格，当然空格就占用一个字符的宽度</p><h3 id="有什么解决办法？"><a href="#有什么解决办法？" class="headerlink" title="有什么解决办法？"></a>有什么解决办法？</h3><ul><li><code>不使用换行</code>，也就是将所有的 li 都在一行展示</li><li>将 ul 的字符尺寸设置为 0，文字大小为 0,则空格就不会被展示，但是如果在 ul 中设置的字体，需要重新设置(<code>将li父级标签字符设置为0在Safari浏览器依然出现间隔空白</code>)</li><li>给 ul 设置 <code>letter-space</code>:-5px,并且给 li 的<code> letter-space</code> 设置为 normal</li></ul><h2 id="21-浏览器兼容性及其解决方案整理"><a href="#21-浏览器兼容性及其解决方案整理" class="headerlink" title="21. 浏览器兼容性及其解决方案整理"></a>21. 浏览器兼容性及其解决方案整理</h2><h2 id="22-CSS-多列等高如何实现"><a href="#22-CSS-多列等高如何实现" class="headerlink" title="22. CSS 多列等高如何实现"></a>22. CSS 多列等高如何实现</h2><ul><li>table 布局实现等高</li><li>使用 flex 布局</li><li>grid 布局</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css">.box &#123;  width: 300px;  display: grid;  grid-auto-flow: column;&#125;.left &#123;  background-color: red;&#125;.right &#123;  background-color: gainsboro;&#125;&#x2F;* ———————————————— 版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47450807&#x2F;article&#x2F;details&#x2F;124012215 *&#x2F;</code></pre><h2 id="23-前端-css-高频面试题——em-x2F-px-x2F-rem-x2F-vw-x2F-vh-的区别？"><a href="#23-前端-css-高频面试题——em-x2F-px-x2F-rem-x2F-vw-x2F-vh-的区别？" class="headerlink" title="23. 前端 css 高频面试题——em&#x2F;px&#x2F;rem&#x2F;vw&#x2F;vh 的区别？"></a>23. 前端 css 高频面试题——em&#x2F;px&#x2F;rem&#x2F;vw&#x2F;vh 的区别？</h2><h2 id="24-一个品字布局如何设计？"><a href="#24-一个品字布局如何设计？" class="headerlink" title="24. 一个品字布局如何设计？"></a>24. 一个品字布局如何设计？</h2><h2 id="25-用纯-CSS-创建一个三角形的原理是什么？"><a href="#25-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="25. 用纯 CSS 创建一个三角形的原理是什么？"></a>25. 用纯 CSS 创建一个三角形的原理是什么？</h2><div style="display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;"><img src="http://t-blog-images.aijs.top/img/202210232319912.png" style="width: 100px" /><img src="http://t-blog-images.aijs.top/img/202210232319463.png" style="width: 100px" /></div><pre class="line-numbers language-css" data-language="css"><code class="language-css">div &#123;  &#x2F;* 宽高都设置为0 *&#x2F;  width: 0px;  height: 0px;  &#x2F;* border的宽度设置为30px *&#x2F;  border-width: 30px;  &#x2F;* border-style设置为实线 *&#x2F;  border-style: solid;  &#x2F;* border的上左右的颜色都设置为透明 *&#x2F;  border-color: red transparent transparent transparent;  &#x2F;* border-color: transparent red transparent transparent; *&#x2F;  &#x2F;* border-color: transparent transparent red transparent; *&#x2F;  &#x2F;* border-color: transparent transparent transparent red; *&#x2F;  &#x2F;* 加上这一行可以让三角形顶格， 不加三角形会下移20px *&#x2F;  &#x2F;* border-top: none; *&#x2F; &#x2F;* 因为border有顶部宽度 *&#x2F;&#125;</code></pre><p><a href="https://www.cnblogs.com/lidaying5/p/12605809.html" target="_blank" >见</a></p><h2 id="26-CSS3-的-flex-布局总结？"><a href="#26-CSS3-的-flex-布局总结？" class="headerlink" title="26. CSS3 的 flex 布局总结？"></a>26. CSS3 的 flex 布局总结？</h2><p>一、简单介绍<br>flex 是 flexibleBox 的缩写，意为弹性布局，用来为盒模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 flex 布局。</p><p><em>注意，设为 flex 布局以后，子元素的 float，clear,vertical-align 属性将失效。</em></p><p>采用 flex 布局的元素，称为 flex 容器，简称容器。他的所以子元素自动称为容器成员，称为 flex 元素，简称元素。<br>容器默认存在两根轴：<code>水平的主轴（main axis）</code>和<code>垂直的辅轴（cross axis）</code>，<code>元素默认沿主轴排列</code>。</p><p>二、6 个属性<br>1、<em>flex-direction</em>:属性决定主轴的方向（即元素的排列方向），默认是横轴方向。属性值为 <code>row-reverse</code>,<code>row</code>,<code>col</code>,<code>col-reverse</code>。<br>2、<em>flex-wrap</em>:属性定义，如果一条轴线排列不下，如何换行。<code>wrap:换行</code>，<code>no-wrap:不换行</code>,<code>wrap-reverse:翻转换行</code>。<br>3、<em>flex-flow</em>:属性是 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性的简写形式，默认值为 <code>row nowrap</code>。<br>4、<em>justify-content</em>: 6 个值，属性定义了元素在主轴的对齐方式。可选值为 flex-start,flex-end,center,space-around,space-between，stretch。<br>5、<em>align-items</em>:4 个值，属性在辅线上如何对齐。存在的属性有：flex-end,flex-start,center,strech。<br>6、<em>align-content</em>:属性定义多根轴线的对其方式，如果只存在一根轴线，则不起作用。存在的属性有：center，flex-end,flex-start,space-around,space-between,stretch。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/123988959">https://blog.csdn.net/weixin_47450807/article/details/123988959</a></p><h2 id="25-CSS-中的-position-的值及其作用？display-有哪些值？"><a href="#25-CSS-中的-position-的值及其作用？display-有哪些值？" class="headerlink" title="25. CSS 中的 position 的值及其作用？display 有哪些值？"></a>25. CSS 中的 position 的值及其作用？display 有哪些值？</h2><p>1、<code>relative</code>: 生成固定定位的元素，相对于元素本身正常的文档流进行定位。<br>2、<code>absolute</code> :生成绝对定位的元素，相对于值不为 static 的第一个父元素的 padding box 进行定位<br>3、<code>fixed</code>（老 IE 不支持）:生成固定定位的元素，相对于浏览器窗口进行定位。<br>4、<code>static</code>: 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom,left,right,z-index 声明）。<br>5、<code>inherit</code>: 表示从父元素中继承 position 中的值。</p><h2 id="26-如何居中-div"><a href="#26-如何居中-div" class="headerlink" title="26. 如何居中 div"></a>26. 如何居中 div</h2><ul><li>使用 margin: 0 auto</li><li>flex 布局</li><li>绝对定位 + 定位值都设置为 0 + margin: auto</li><li>绝对定位 + margin</li><li>绝对定位 + transform</li></ul><h2 id="27-CSS3-新增伪类有哪些"><a href="#27-CSS3-新增伪类有哪些" class="headerlink" title="27. CSS3 新增伪类有哪些"></a>27. CSS3 新增伪类有哪些</h2><h2 id="28-CSS-优先级算法如何计算"><a href="#28-CSS-优先级算法如何计算" class="headerlink" title="28. CSS 优先级算法如何计算"></a>28. CSS 优先级算法如何计算</h2><p>注意: <em>这里针对的是一条属性 (理解这个 “一条属性” )，当某一个属性，本身就比另一属性优先级低，再怎么配置，也不会展示此属性如（max-width 和 width， media 媒体查询等)</em></p><ul><li>判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。<br>一条声明如果加上权重，那么他的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</li><li>一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。</li></ul><p><em>选择器的特殊性可以分为四个等级，</em></p><ul><li><p>第一个等级是<code>行内样式</code>，为 1 0 0 0,</p></li><li><p>第二个等级是 <code>id 选择器</code>，为 0 1 0 0 ，</p></li><li><p>第三个等级是<code>类选择器，伪类选择器，属性选择器</code>为：0 0 1 0，</p></li><li><p>第四个等级是<code>元素选择器和伪元素选择器</code>：0 0 0 1。</p></li><li><p>规则中每出现一个选择器，就将他的特殊性进行累加，<em>这个累加只限于对应等级的累加，不会产生进位</em> 。选择器特殊性值的比较是从左向右排序的，也就是说以 1 开头的特殊性比所有 0 开头的特殊性值要大。比如说特殊性值为 1000 的规则优先级就要比特殊性值为 0999 的规则高。如果两个规则的特殊性值相等的时候，那么就会根据他们引用的顺序，后出现的规则的优先级最高。</p></li></ul><h2 id="29-CSS-中的那些属性是可以继承的？"><a href="#29-CSS-中的那些属性是可以继承的？" class="headerlink" title="29. CSS 中的那些属性是可以继承的？"></a>29. CSS 中的那些属性是可以继承的？</h2><p>1、字体系列的属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">font, font-family, font-weight, font-size, font-style, font-variant, font-stretch, font-size-adjust</code></pre><p>2、字体系列的属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">text-indent, text-align, text-shadow, line-height, word-spacing, letter-spacing, text-transform, direction, color</code></pre><p>3、表格布局属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">caption-side, border-collapse, empty-cells.</code></pre><p>4、列表属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">list-style-type, list-style-image, list-style-position, list-style</code></pre><p>5、光标属性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">cursor</code></pre><p>2.6、元素可见性</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">visibility</code></pre><h3 id="inhert"><a href="#inhert" class="headerlink" title="inhert"></a>inhert</h3><p>当一个属性不是继承属性的时候，此时可以使用 inhert 关键字来指定一个属性应该从父元素继承他的值，inhert 关键字用于显示的指定继承性，可以用于任何继承性和非继承性。</p><h2 id="28-伪类和伪元素的区别？"><a href="#28-伪类和伪元素的区别？" class="headerlink" title="28. 伪类和伪元素的区别？"></a>28. 伪类和伪元素的区别？</h2><h3 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h3><p><em>伪类</em>用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。也就是说，当用户悬停指定的元素时，我们可以通过:hover 来描述这个元素的状态。<br><em>伪元素</em>用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。</p><h3 id="常见伪类"><a href="#常见伪类" class="headerlink" title="常见伪类"></a>常见伪类</h3><p><a href="https://blog.csdn.net/weixin_43012215/article/details/113488202" target="_blank" >a 链接 love hate 原则有顺序</a></p><p><em>a 链接相关</em></p><ul><li><p><code>:link</code>: 选取未访问过的超链接元素。如果我们注意过搜索引擎的结果的话，它里面的链接只要点过的就会变色，从而标记哪个链接是访问过的。:link 这个属性就是用来标识没访问过的链接。</p></li><li><p><code>:visited</code>: 选取访问过的超链接元素。和第一条相反，:visited 是用来标记哪个链接是已经访问过的，防止重复点击。</p></li><li><p><code>:hover</code>: 选取鼠标悬停的元素。，这个伪类经常用在 PC 端，当鼠标放在一个元素上时，可以用 :hover 来控制鼠标悬停的样式。因为在移动端里没有鼠标的概念，所以移动端里很少用这个伪类。</p></li><li><p><code>:active</code>: 选取点中的元素。这个伪类的作用在刚才提到过了，当我们希望按钮有操作反馈的时候，可以用它来标记操作反馈的样式。当然这个伪类也是可以通用的，并不是只能用在按钮上。</p></li><li><p><code>:empty</code>: 选取没有子元素的元素。比如选择空的 span，就可以用 span:empty 选择器来选择。这里要注意元素内有空格的话也不能算空，不会被这个伪类选中。</p></li><li><p><code>:focus</code>: 选取获得焦点的元素。这个伪类用来标识获得焦点的元素，比如搜索框在聚焦的时候有个比较明显的边框，方便用户知道当前在可输入的状态。</p></li><li><p><code>:checked</code>: 选取勾选状态的 input 元素， 只对 radio 和 checkbox 生效。</p></li><li><p><code>:disabled</code>: 选取禁用的表单元素。</p></li></ul><p><em>选元素的</em></p><ul><li><code>:first-child</code>: 选取当前选择器下第一个元素。</li><li><code>:last-child</code>: 和 first-child 相反，选取当前选择器下最后一个元素。</li><li><code>:nth-child(an+b)</code>: 选取指定位置的元素。这个伪类是有参数的，参数可以支持 an+b 的形式，这里 a 和 b 都是可变的，n 从 0 起。使用这个伪类可以做到选择第几个，或者选择序号符合 an+b 的所有元素。比如使用 li:nth-child(2n+1)，就可以选中 li 元素中序号是 2 的整数倍加 1 的所有元素，也就是第 1、3、5、7、9、2n+1 个 li 元素。</li><li><code>:nth-last-child(an+b)</code>: 这个伪类和 nth-child 相似，只不过在计数的时候，这个伪类是从后往前计数。</li><li><code>:only-child</code>: 选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效。</li><li><code>:only-of-type</code>: 选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以。</li></ul><h3 id="常见伪元素"><a href="#常见伪元素" class="headerlink" title="常见伪元素"></a>常见伪元素</h3><ul><li><code>::first-line:</code>为某个元素的第一行文字使用样式。</li><li><code>::first-letter:</code>为某个元素中的文字的首字母或第一个字使用样式。</li><li><code>::before:</code>在某个元素之前插入一些内容。</li><li><code>::after:</code>在某个元素之后插入一些内容。</li><li><code>::selection:</code>对光标选中的元素添加样式。</li></ul><h2 id="30-css-选择器有哪些？"><a href="#30-css-选择器有哪些？" class="headerlink" title="30. css 选择器有哪些？"></a>30. css 选择器有哪些？</h2><ul><li>id 选择器 <code>#myId &#123;&#125;</code></li><li>类选择器 <code>.myClass &#123;&#125;</code></li><li>标签选择器 <code>p,h1 &#123;&#125;</code><div style="height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px"></div></li><li>后代选择器 <code>div h1 &#123;&#125;</code></li><li>子选择器 <code>div&gt;h1 &#123;&#125;</code></li><li>兄弟选择器 <code>ul~h1 &#123;&#125;</code></li><li>相邻兄弟选择器 <code>ul+h1 &#123;&#125;</code><div style="height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px"></div></li><li>属性选择器 <code>li[name=&#39;sss&#39;] &#123;&#125;</code></li><li>伪类选择器 <code>h1:hover &#123;&#125;</code></li><li>伪元素选择器 <code>h1::before&#123;&#125;</code></li><li>通配符选择器 <code>* &#123;&#125;</code></li></ul><h2 id="31-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#31-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="31. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>31. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h2><p>1、盒模型都是由四部分组成的，分别是 <code>margin，border， padding, content</code>。<br>2、标准和模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。</p><p><em>标准盒模型的范围只有 content，</em><br><em>IE 盒模型的 width 和 height 属性的范围包含 border，padding 和 content。</em></p><p>3、一般来说我们可以通过 box-sizing 属性来改变元素的盒模型，存在两个值，</p><ul><li><code>border-box</code> 表示 IE 盒模型，</li><li><code>content-box</code> 表示标准盒模型。</li></ul><h2 id="32-未知大小的父元素，子元素水平垂直居中？"><a href="#32-未知大小的父元素，子元素水平垂直居中？" class="headerlink" title="32. 未知大小的父元素，子元素水平垂直居中？"></a>32. 未知大小的父元素，子元素水平垂直居中？</h2><ul><li>flex</li><li>table</li><li>transform</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* table *&#x2F;.parent &#123;  width: 200px;  height: 200px;  display: table;  background-color: red;&#125;.child &#123;  display: table-cell;  vertical-align: middle;  text-align: center;&#125;&#x2F;* ———————————————— *&#x2F;&#x2F;* 版权声明：本文为CSDN博主「卖菜的小白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 *&#x2F;&#x2F;* 原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_47450807&#x2F;article&#x2F;details&#x2F;123666444 *&#x2F;</code></pre><h2 id="32-BFC"><a href="#32-BFC" class="headerlink" title="32. BFC"></a>32. BFC</h2><h3 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h3><p>BFC(Block Formatting Context)格式化上下文，是 web 页面中盒子模型布局的 CSS 渲染模式，指的是一个独立的渲染区域或者是一个隔离的独立容器。</p><h3 id="如何创建-BFC"><a href="#如何创建-BFC" class="headerlink" title="如何创建 BFC"></a>如何创建 BFC</h3><p>1、<code>浮动元素</code>，float 除 none 以外。<br>2、<code>定位元素</code>，position(absolute, fixed)<br>3、<code>display</code> 为以下其中之一的值：inline-block,table-cell,table-caption.<br>4、<code>overflow</code> 除了 visible 以外的值(hidden,auto, scroll)</p><h3 id="BFC-特点，能解决什么问题"><a href="#BFC-特点，能解决什么问题" class="headerlink" title="BFC 特点，能解决什么问题"></a>BFC 特点，能解决什么问题</h3><ul><li><code>BFC中的盒子对齐</code>: 内部的 Box 会在垂直方向上一个接着一个的放置。</li><li><code>外边距重叠</code>: 在正常的文档流中，两个兄弟盒子之间的具有由其外边距决定的，不是他们的外边距之和决定的，而是以较大的为准。</li><li><code>不被浮动元素覆盖</code>: 两栏布局， 三栏布局</li><li><code>可以防止字体环绕</code></li><li><code>BFC 包含浮动的块</code>： 如果我们使用浮动，则该元素就会脱离正常的文档流，则会造成父元素高度的坍塌</li></ul><p><strong>总结（由外到内）：父元素塌陷问题、文字环绕问题、外边距重叠问题、不被浮动元素覆盖、BFC 内盒子对齐问题</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_47450807/category_11702913.html" target="_blank" >weixin_47450807 的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js class</title>
      <link href="//post/2022-10-21js-class.html"/>
      <url>//post/2022-10-21js-class.html</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="什么是类，-有什么作用"><a href="#什么是类，-有什么作用" class="headerlink" title="什么是类， 有什么作用"></a>什么是类， 有什么作用</h2><p>类是: <code>用于创建对象的模板</code>。用代码封装数据以处理该数据。</p><p>JS 中的类建立在原型上，但与 ES5 类的语法和语义不同</p><p>类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。</p><h2 id="与函数区别"><a href="#与函数区别" class="headerlink" title="与函数区别"></a>与函数区别</h2><p>class 关键字声明一个类。<span style="color: red">函数声明会提升，类声明不会</span></p><p>类表达式是定义类的另一种方法。类表达式可以命名或不命名。命名类表达式的名称是该类体的局部名称。</p><h2 id="类体和方法定义"><a href="#类体和方法定义" class="headerlink" title="类体和方法定义"></a>类体和方法定义</h2><p>一个类的类体: <code>是一对花括号/大括号 &#123;&#125; 中的部分</code>。这是你定义类成员的位置，如方法或构造函数。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter 和 setter 都在严格模式下执行。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;  speak() &#123;    return this;  &#125;  static eat() &#123;    return this;  &#125;&#125;let obj &#x3D; new Animal();obj.speak(); &#x2F;&#x2F; Animal &#123;&#125; &#x2F;&#x2F; 实例化后，指向的是类的实例let speak &#x3D; obj.speak;speak(); &#x2F;&#x2F; undefined &#x2F;&#x2F;严格执行Animal.eat(); &#x2F;&#x2F; class Animal &#x2F;&#x2F; 类的静态方法中指向类let eat &#x3D; Animal.eat;eat(); &#x2F;&#x2F; undefined</code></pre><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>constructor 是一种用于创建和初始化 class 创建的对象的特殊方法</p><p>哪里特殊了？</p><p><strong>构造函数中的 this 指向实例，其他类体中的 this 指向 undefined</strong></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">constructor([arguments]) &#123; ... &#125;</code></pre><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>只能出现一次 constructor，出现多次报错</li><li>constructor 内部可以使用 super 调用父类构造方法</li><li>不指定构造方法，会有一个默认构造方法（有两种：非派生、派生类的构造函数）</li><li>setPrototypeOf 只一个类的原型，不改变这个基类的构造函数</li></ul><p><strong>默认构造方法</strong></p><p>如前所述，如果不指定构造方法，则使用默认构造函数。对于基类，默认构造函数是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">constructor() &#123;&#125;</code></pre><p>对于派生类，默认构造函数是：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">constructor(...args) &#123;  super(...args);&#125;</code></pre><h1 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h1><p><strong>extends</strong>关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class ChildClass extends ParentClass &#123; ... &#125;</code></pre><p>extends 关键字用来创建一个普通类或者内建对象的子类。</p><ul><li>什么是普通类：没有父类，非内置对象的类</li><li>什么是派生类：父类也叫超类、基类，子类也叫派生类。 <a href="https://www.jianshu.com/p/5bae725b9902" target="_blank" >见</a></li><li>什么是内置对象： Date</li><li>扩展 null</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 扩展 null 这是什么骚操作，有什么用？&#x2F;&#x2F; 新对象的原型将不会继承 Object.prototypeclass nullExtends extends null &#123;  constructor() &#123;&#125;&#125;Object.getPrototypeOf(nullExtends); &#x2F;&#x2F; Function.prototypeObject.getPrototypeOf(nullExtends.prototype); &#x2F;&#x2F; nullnew nullExtends(); &#x2F;&#x2F;ReferenceError: this is not defined</code></pre><h1 id="类私有域"><a href="#类私有域" class="headerlink" title="类私有域"></a>类私有域</h1><ul><li>类属性在默认情况下是<code>公有的</code></li><li>前缀 # 的方法来定义<code>私有类字段</code>，这一隐秘封装的类特性由 JavaScript 自身强制执行。</li></ul><h2 id="私有字段"><a href="#私有字段" class="headerlink" title="私有字段"></a>私有字段</h2><p>私有字段包括私有实例字段和私有静态字段。</p><h3 id="私有实例字段"><a href="#私有实例字段" class="headerlink" title="私有实例字段"></a>私有实例字段</h3><ul><li>私有字段在类声明的构造方法中就可被访问。</li><li>类似于公有字段，私有字段在构造（construction）基类或调用子类的 super() 方法时被添加到类实例中</li><li>作用域之外引用、未声明引用、删除都会报错</li></ul><h3 id="私有静态字段"><a href="#私有静态字段" class="headerlink" title="私有静态字段"></a>私有静态字段</h3><ul><li>私有静态字段： 在解析类结构时被添加到类的构造方法（constructor）中。</li><li>静态变量：只能被静态方法调用的限制仍然成立。</li></ul><h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><h3 id="私有实例方法"><a href="#私有实例方法" class="headerlink" title="私有实例方法"></a>私有实例方法</h3><ul><li>私有实例方法是类实例上可用的方法，它们的访问方式与私有实例字段相同。</li><li>私有实例方法可以是生成器方法、异步方法或异步生成器方法，也可以是私有的 getter 和 setter。</li></ul><h3 id="私有静态方法"><a href="#私有静态方法" class="headerlink" title="私有静态方法"></a>私有静态方法</h3><p>私有静态方法可以是生成器方法，异步方法或异步生成器方法。</p><p>前面提到的私有静态字段的限制同样适用于私有静态方法。</p><p>同样地，使用 this 可能会出现意想不到的行为。<br>在下方的例子中，<code>this 是 Derived 类（而不是 Base 类）的引用</code>，<br>所以尝试调用 Derived.publicStaticMethod2() 会抛出 TypeError。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Base &#123;  static #privateStaticMethod() &#123;    return 42;  &#125;  static publicStaticMethod1() &#123;    return Base.#privateStaticMethod();  &#125;  static publicStaticMethod2() &#123;    return this.#privateStaticMethod();  &#125;&#125;class Derived extends Base &#123;&#125;console.log(Derived.publicStaticMethod1());&#x2F;&#x2F; 42console.log(Derived.publicStaticMethod2());&#x2F;&#x2F; TypeError: Cannot read private member #privateStaticMethod&#x2F;&#x2F; from an object whose class did not declare it</code></pre><h1 id="公有类字段"><a href="#公有类字段" class="headerlink" title="公有类字段"></a>公有类字段</h1><p>公有静态字段和公有实例字段都是<code>可编辑</code>、<code>可枚举</code>和<code>可配置</code>的属性。因此，不同于私有对应值（private counterpart）的是，它们参与原型的继承。</p><h2 id="公有静态字段"><a href="#公有静态字段" class="headerlink" title="公有静态字段"></a>公有静态字段</h2><p>在类里面存分数据，只有一份，其他实例不存，可被其他实例共享</p><ol><li>公有静态字段是使用关键字 static 声明的。</li><li>我们在声明一个类的时候，使用 Object.defineProperty() 方法将公有静态字段添加到类的构造函数中。</li><li>在类被声明之后，可以从类的构造函数访问公有静态字段。</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class ClassWithStaticField &#123;  static staticField &#x3D; &quot;static field&quot;; &#x2F;&#x2F; 如果没有初始化，默认是undefined&#125;console.log(ClassWithStaticField.staticField);&#x2F;&#x2F; 预期输出值：&quot;static field&quot;​</code></pre><p>公有静态字段不会在子类中重复初始化，可以通过原型链访问它们。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class ClassWithStaticField &#123;  static baseStaticField &#x3D; &quot;base field&quot;;&#125;class SubClassWithStaticField extends ClassWithStaticField &#123;  static subStaticField &#x3D; &quot;sub class field&quot;;&#125;console.log(SubClassWithStaticField.subStaticField);&#x2F;&#x2F; 预期输出值：&quot;sub class field&quot;console.log(SubClassWithStaticField.baseStaticField);&#x2F;&#x2F; 预期输出值：&quot;base field&quot;</code></pre><p>在初始化字段时，this 指向的是类。_(原文这里写错了)_ <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields#:~:text=%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E6%AE%B5%E6%97%B6%EF%BC%8Cthis%20%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" target="_blank" >见</a><br>你也可以通过名字引用构造函数，并使用 super 获取到存在的父类的构造函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class ClassWithStaticField &#123;  static baseStaticField &#x3D; &quot;base static field&quot;;  &#x2F;&#x2F; 这里可以论证 在初始化字段时，this 指向的是类  static anotherBaseStaticField &#x3D; this.baseStaticField;  static baseStaticMethod() &#123;    return &quot;base static method output&quot;;  &#125;&#125;class SubClassWithStaticField extends ClassWithStaticField &#123;  static subStaticField &#x3D; super.baseStaticMethod();&#125;console.log(ClassWithStaticField.anotherBaseStaticField);&#x2F;&#x2F; 预期输出值：&quot;base static field&quot;console.log(SubClassWithStaticField.subStaticField);&#x2F;&#x2F; 预期输出值：&quot;base static method output&quot;</code></pre><h2 id="公有实例字段"><a href="#公有实例字段" class="headerlink" title="公有实例字段"></a>公有实例字段</h2><p>公有实例字段存在于类的每一个实例中。是对类模型的描述（这个类模型产出的实例对象的特点）</p><p>公有实例字段可以在基类的构造过程中（构造函数主体运行前）使用 Object.defineProperty() 添加，<br>也可以在子类构造函数中的 super() 函数结束后添加。</p><ul><li>公有实例字段默认 undefined。</li><li>公有实例字段名可以由计算得出。</li><li>在初始化字段时，this 指向的是类正在构造中的实例。和公有实例方法相同的是：你可以在子类中使用 super 来访问父类的原型。</li><li>因为类的实例字段是在对应的构造函数运行之前添加的，所以你可以在构造函数中访问字段的值。（现有字段，而后有构造函数）</li><li>因为派生类的实例字段是在 super() 返回之后定义的，所以基类的构造函数无法访问派生类的字段。</li><li>因为类字段是通过 [[Define]] 语义（本质上是 Object.defineProperty()）添加的，所以派生类中的字段声明并不会调用基类中的 setter。此行为不同于在构造函数中使用 this.field &#x3D; …</li></ul><h2 id="公有静态方法"><a href="#公有静态方法" class="headerlink" title="公有静态方法"></a>公有静态方法</h2><p>关键字 static 将为一个类定义一个静态方法。静态方法不是在一个实例之上被调用，而是在类自身之上被调用</p><p>静态方法是在类的声明阶段用 Object.defineProperty() 方法添加到类的构造函数中的。静态方法是可编辑、<strong>不可枚举</strong>和可配置的。</p><h2 id="公有实例方法"><a href="#公有实例方法" class="headerlink" title="公有实例方法"></a>公有实例方法</h2><p>正如其名，公有实例方法是可以在类的实例中使用的。<br>公有实例方法是在类的声明阶段用 Object.defineProperty() 方法添加到类中的。静态方法是可编辑、<strong>不可枚举</strong>和可配置的。<br>实例的方法中，this 指向的是实例本身，你可以使用 super 访问到父类的原型，由此你可以调用父类的方法。<br>getter 和 setter 是和类的属性绑定的特殊方法，分别会在其绑定的属性被取值、赋值时调用。使用 get 和 set 语法定义实例的公有 getter 和 setter。</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>静态方法调用直接在类上进行，不能在类的实例上调用。静态方法通常用于创建实用程序函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">static methodName() &#123; ... &#125;</code></pre><h2 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h2><p>从另一个静态方法: 静态方法调用同一个类中的其他静态方法，可使用 this 关键字。<br>从类的构造函数和其他方法: 非静态方法中，不能直接使用 this 关键字来访问静态方法。而是要用类名来调用：CLASSNAME.STATIC_METHOD_NAME() ，或者用构造函数的属性来调用该方法： this.constructor.STATIC_METHOD_NAME().</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class StaticMethodCall &#123;  constructor() &#123;    console.log(StaticMethodCall.staticMethod());    &#x2F;&#x2F; &#39;static method has been called.&#39;    console.log(this.constructor.staticMethod());    &#x2F;&#x2F; &#39;static method has been called.&#39;  &#125;  static staticMethod() &#123;    return &quot;static method has been called.&quot;;  &#125;&#125;</code></pre><h1 id="类中的-this"><a href="#类中的-this" class="headerlink" title="类中的 this"></a>类中的 this</h1><p>类声明和类表达式的主体都执行在严格模式下 <strong>同样遵循谁调用指向谁：</strong></p><ol><li>实例调用实例方法，指向实例</li><li>类调用静态方法，指向类</li><li><em>实例方法、类的静态在全局调用，由于是严格模式，所以 this 是 undefined</em></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm migrate 注意点</title>
      <link href="//post/2022-10-21gorm-migrate.html"/>
      <url>//post/2022-10-21gorm-migrate.html</url>
      
        <content type="html"><![CDATA[<h2 id="等效语句"><a href="#等效语句" class="headerlink" title="等效语句"></a>等效语句</h2><p>添加、删除会报错</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; ...type User struct &#123;gorm.ModelName string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96;&#125;&#x2F;&#x2F; ....&#x2F;&#x2F; 方式1db.Debug().AutoMigrate(&amp;User&#123;&#125;)&#x2F;&#x2F; 方式2db.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;Name&quot;) &#x2F;&#x2F; 重复操作&#x2F;&#x2F; 2022&#x2F;10&#x2F;21 09:52:36 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;migrator.go:18 Error 1061: Duplicate key name &#39;idx_name&#39;&#x2F;&#x2F; [2.300ms] [rows:0] CREATE UNIQUE INDEX &#96;idx_name&#96; ON &#96;users&#96;(&#96;name&#96;)&#x2F;&#x2F; 方式3db.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;) &#x2F;&#x2F; 重复操作&#x2F;&#x2F; 2022&#x2F;10&#x2F;21 09:52:59 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;migrator.go:19 Error 1061: Duplicate key name &#39;idx_name&#39;&#x2F;&#x2F; [1.194ms] [rows:0] CREATE UNIQUE INDEX &#96;idx_name&#96; ON &#96;users&#96;(&#96;name&#96;)</code></pre><h2 id="AutoMigrate"><a href="#AutoMigrate" class="headerlink" title="AutoMigrate"></a>AutoMigrate</h2><p>AutoMigrate 用于自动迁移您的 schema，保持您的 schema 是最新的。</p><p>注意： AutoMigrate 会创建表、缺失的外键、约束、列和索引。 如果大小、精度、是否为空可以更改，则 AutoMigrate 会改变列的类型。 出于保护您数据的目的，它 不会 删除未使用的列</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.AutoMigrate(&amp;User&#123;&#125;)db.AutoMigrate(&amp;User&#123;&#125;, &amp;Product&#123;&#125;, &amp;Order&#123;&#125;)&#x2F;&#x2F; 创建表时添加后缀, 注意：文档上没说，操作mysql时候，即使你不添加 ENGINE&#x3D;InnoDB ,默认自动添加db.Set(&quot;gorm:table_options&quot;, &quot;ENGINE&#x3D;InnoDB&quot;).AutoMigrate(&amp;User&#123;&#125;)&#x2F;&#x2F; 注意 AutoMigrate 会自动创建数据库外键约束，您可以在初始化时禁用此功能，例如：db, err :&#x3D; gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config&#123;  DisableForeignKeyConstraintWhenMigrating: true,&#125;)</code></pre><h2 id="Migrator-接口"><a href="#Migrator-接口" class="headerlink" title="Migrator 接口"></a>Migrator 接口</h2><p>GORM 提供了 Migrator 接口，该接口为每个数据库提供了统一的 API 接口，可用来为您的数据库构建独立迁移，例如：</p><p>SQLite 不支持 ALTER COLUMN、DROP COLUMN，当你试图修改表结构，GORM 将创建一个新表、复制所有数据、删除旧表、重命名新表。</p><p>一些版本的 MySQL 不支持 rename 列，索引。GORM 将基于您使用 MySQL 的版本执行不同 SQL</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type Migrator interface &#123;  &#x2F;&#x2F; AutoMigrate 自动迁移  AutoMigrate(dst ...interface&#123;&#125;) error  &#x2F;&#x2F; Database 数据哭  CurrentDatabase() string  FullDataTypeOf(\*schema.Field) clause.Expr  &#x2F;&#x2F; Tables 表  CreateTable(dst ...interface&#123;&#125;) error  DropTable(dst ...interface&#123;&#125;) error  HasTable(dst interface&#123;&#125;) bool  RenameTable(oldName, newName interface&#123;&#125;) error  GetTables() (tableList []string, err error)  &#x2F;&#x2F; Columns 列  AddColumn(dst interface&#123;&#125;, field string) error  DropColumn(dst interface&#123;&#125;, field string) error  AlterColumn(dst interface&#123;&#125;, field string) error  MigrateColumn(dst interface&#123;&#125;, field \*schema.Field, columnType ColumnType) error  HasColumn(dst interface&#123;&#125;, field string) bool  RenameColumn(dst interface&#123;&#125;, oldName, field string) error  ColumnTypes(dst interface&#123;&#125;) ([]ColumnType, error)  &#x2F;&#x2F; Constraints 外键约束  CreateConstraint(dst interface&#123;&#125;, name string) error  DropConstraint(dst interface&#123;&#125;, name string) error  HasConstraint(dst interface&#123;&#125;, name string) bool  &#x2F;&#x2F; Indexes 索引  CreateIndex(dst interface&#123;&#125;, name string) error  DropIndex(dst interface&#123;&#125;, name string) error  HasIndex(dst interface&#123;&#125;, name string) bool  RenameIndex(dst interface&#123;&#125;, oldName, newName string) error&#125;</code></pre><h2 id="当前数据库"><a href="#当前数据库" class="headerlink" title="当前数据库"></a>当前数据库</h2><p>返回当前使用的数据库名</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Migrator().CurrentDatabase()</code></pre><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 为 &#96;User&#96; 创建表db.Migrator().CreateTable(&amp;User&#123;&#125;)&#x2F;&#x2F; 将 &quot;ENGINE&#x3D;InnoDB&quot; 添加到创建 &#96;User&#96; 的 SQL 里去db.Set(&quot;gorm:table_options&quot;, &quot;ENGINE&#x3D;InnoDB&quot;).Migrator().CreateTable(&amp;User&#123;&#125;)&#x2F;&#x2F; 检查 &#96;User&#96; 对应的表是否存在db.Migrator().HasTable(&amp;User&#123;&#125;)db.Migrator().HasTable(&quot;users&quot;)&#x2F;&#x2F; 如果存在表则删除（删除时会忽略、删除外键约束)&#x2F;&#x2F; 下面两个等效，同时操作报错db.Migrator().DropTable(&amp;User&#123;&#125;)db.Migrator().DropTable(&quot;users&quot;)&#x2F;&#x2F; 重命名表db.Migrator().RenameTable(&amp;User&#123;&#125;, &amp;UserInfo&#123;&#125;)db.Migrator().RenameTable(&quot;users&quot;, &quot;user_infos&quot;)</code></pre><h2 id="列"><a href="#列" class="headerlink" title="列"></a>列</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">type User struct &#123;  Name string&#125;&#x2F;&#x2F; 添加 name 字段db.Migrator().AddColumn(&amp;User&#123;&#125;, &quot;Name&quot;)&#x2F;&#x2F; 删除 name 字段db.Migrator().DropColumn(&amp;User&#123;&#125;, &quot;Name&quot;)&#x2F;&#x2F; 修改 name 字段db.Migrator().AlterColumn(&amp;User&#123;&#125;, &quot;Name&quot;)&#x2F;&#x2F; 检查 name 字段是否存在db.Migrator().HasColumn(&amp;User&#123;&#125;, &quot;Name&quot;)type User struct &#123;  Name    string  NewName string&#125;&#x2F;&#x2F; 字段重命名  注意： 下面两个等效，同时使用报错db.Migrator().RenameColumn(&amp;User&#123;&#125;, &quot;Name&quot;, &quot;NewName&quot;)db.Migrator().RenameColumn(&amp;User&#123;&#125;, &quot;name&quot;, &quot;new_name&quot;)&#x2F;&#x2F; 字段类型db.Migrator().ColumnTypes(&amp;User&#123;&#125;) ([]gorm.ColumnType, error)type ColumnType interface &#123;    Name() string    DatabaseTypeName() string                 &#x2F;&#x2F; varchar    ColumnType() (columnType string, ok bool) &#x2F;&#x2F; varchar(64)    PrimaryKey() (isPrimaryKey bool, ok bool)    AutoIncrement() (isAutoIncrement bool, ok bool)    Length() (length int64, ok bool)    DecimalSize() (precision int64, scale int64, ok bool)    Nullable() (nullable bool, ok bool)    Unique() (unique bool, ok bool)    ScanType() reflect.Type    Comment() (value string, ok bool)    DefaultValue() (value string, ok bool)&#125;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F;  表自带约束，之后重复创建约束报错type UserIndex struct &#123;  Name  string &#96;gorm:&quot;check:name_checker,name &lt;&gt; &#39;jinzhu&#39;&quot;&#96;&#125;&#x2F;&#x2F; 创建约束db.Migrator().CreateConstraint(&amp;User&#123;&#125;, &quot;name_checker&quot;)&#x2F;&#x2F; 删除约束db.Migrator().DropConstraint(&amp;User&#123;&#125;, &quot;name_checker&quot;)&#x2F;&#x2F; 检查约束是否存在db.Migrator().HasConstraint(&amp;User&#123;&#125;, &quot;name_checker&quot;)&#x2F;&#x2F; 为 relation 创建外键type User struct &#123;  gorm.Model  CreditCards []CreditCard&#125;type CreditCard struct &#123;  gorm.Model  Number string  UserID uint&#125;&#x2F;&#x2F; 为 user &amp; credit_cards 创建 db 外键&#x2F;&#x2F; 以下两行代码等效，同时使用，报错db.Migrator().CreateConstraint(&amp;User&#123;&#125;, &quot;CreditCards&quot;)db.Migrator().CreateConstraint(&amp;User&#123;&#125;, &quot;fk_users_credit_cards&quot;)&#x2F;&#x2F; ALTER TABLE &#96;credit_cards&#96; ADD CONSTRAINT &#96;fk_users_credit_cards&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;users&#96;(&#96;id&#96;)&#x2F;&#x2F; 检查 user &amp; credit_cards 的外键是否存在&#x2F;&#x2F; 以下两行代码等效，db.Migrator().HasConstraint(&amp;User&#123;&#125;, &quot;CreditCards&quot;)db.Migrator().HasConstraint(&amp;User&#123;&#125;, &quot;fk_users_credit_cards&quot;)&#x2F;&#x2F; 删除 user &amp; credit_cards 的 db 外键&#x2F;&#x2F; 以下两行代码等效，同时使用，报错db.Migrator().DropConstraint(&amp;User&#123;&#125;, &quot;CreditCards&quot;)db.Migrator().DropConstraint(&amp;User&#123;&#125;, &quot;fk_users_credit_cards&quot;)</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">type User struct &#123;  gorm.Model  Name string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96;&#125;&#x2F;&#x2F; 为 Name 字段创建索引&#x2F;&#x2F; 以下两行代码等效，同时使用，报错db.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;Name&quot;)db.Migrator().CreateIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;)&#x2F;&#x2F; 为 Name 字段删除索引&#x2F;&#x2F; 以下两行代码等效，同时使用，报错db.Migrator().DropIndex(&amp;User&#123;&#125;, &quot;Name&quot;)db.Migrator().DropIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;)&#x2F;&#x2F; 检查索引是否存在db.Migrator().HasIndex(&amp;User&#123;&#125;, &quot;Name&quot;)db.Migrator().HasIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;)type User struct &#123;  gorm.Model  Name  string &#96;gorm:&quot;size:255;index:idx_name,unique&quot;&#96;  Name2 string &#96;gorm:&quot;size:255;index:idx_name_2,unique&quot;&#96;&#125;&#x2F;&#x2F; 修改索引名&#x2F;&#x2F; 以下两行代码等效db.Migrator().RenameIndex(&amp;User&#123;&#125;, &quot;Name&quot;, &quot;Name2&quot;)db.Migrator().RenameIndex(&amp;User&#123;&#125;, &quot;idx_name&quot;, &quot;idx_name_2&quot;)</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>具有相同意义的语句，在<code>创建/删除</code>时候会报错<code>重复/不存在</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://gorm.io/zh_CN/docs/migration.html" target="_blank" >gorm migration</a></p><p><a href="https://learnku.com/docs/gorm/v2/migration/9746" target="_blank" >gorm 数据库迁移</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm 关联</title>
      <link href="//post/2022-10-20gorm%E5%85%B3%E8%81%94.html"/>
      <url>//post/2022-10-20gorm%E5%85%B3%E8%81%94.html</url>
      
        <content type="html"><![CDATA[<h2 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h2><p><a href="https://github.com/go-gorm/playground/blob/master/models.go" target="_blank" >playground</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;database&#x2F;sql&quot;&quot;time&quot;&quot;gorm.io&#x2F;gorm&quot;)&#x2F;&#x2F; User has one &#96;Account&#96; (has one), many &#96;Pets&#96; (has many) and &#96;Toys&#96; (has many - polymorphic)&#x2F;&#x2F; He works in a Company (belongs to), he has a Manager (belongs to - single-table), and also managed a Team (has many - single-table)&#x2F;&#x2F; He speaks many languages (many to many) and has many friends (many to many - single-table)&#x2F;&#x2F; His pet also has one Toy (has one - polymorphic)&#x2F;&#x2F;用户有一个“帐户”（有一个），多个“宠物”（有很多）和“玩具”（有许多多态性）&#x2F;&#x2F;他在一家公司工作（属于），他有一个经理（属于-单表），还管理一个团队（有多-单表）&#x2F;&#x2F;他会说多种语言（多对多），有许多朋友（多对多-单表）&#x2F;&#x2F;他的宠物也有一个玩具（有一个多态性）type User struct &#123;gorm.ModelName      stringAge       uintBirthday  *time.Time  &#x2F;&#x2F; has oneAccount   Account &#x2F;&#x2F; 有一个“帐户”（有一个）  &#x2F;&#x2F; has many 这两个怎么不一样？  &#x2F;&#x2F; 反向引用Pets      []*Pet &#x2F;&#x2F; 有多个宠物  &#x2F;&#x2F; has manyToys      []Toy &#96;gorm:&quot;polymorphic:Owner&quot;&#96; &#x2F;&#x2F; 有多个玩具  &#x2F;&#x2F; belong toCompanyID *int &#x2F;&#x2F; 在一家公司工作（属于）Company   Company &#x2F;&#x2F; 在一家公司工作（属于）  &#x2F;&#x2F; belong toManagerID *uint &#x2F;&#x2F; 他有一个经理（属于-单表）Manager   *User &#x2F;&#x2F; 他有一个经理（属于-单表）  &#x2F;&#x2F; has manyTeam      []User     &#96;gorm:&quot;foreignkey:ManagerID&quot;&#96; &#x2F;&#x2F; 还管理一个团队（有多个单表）  &#x2F;&#x2F; many 2 manyLanguages []Language &#96;gorm:&quot;many2many:UserSpeak&quot;&#96; &#x2F;&#x2F; 他会说多种语言（多对多）  &#x2F;&#x2F; many 2 manyFriends   []*User    &#96;gorm:&quot;many2many:user_friends&quot;&#96; &#x2F;&#x2F; 有许多朋友（多对多-单表）Active    bool&#125;&#x2F;&#x2F; 账号表type Account struct &#123;gorm.ModelUserID sql.NullInt64Number string&#125; &#x2F;&#x2F; 宠物表type Pet struct &#123;gorm.ModelUserID *uintName   stringToy    Toy &#96;gorm:&quot;polymorphic:Owner;&quot;&#96; &#x2F;&#x2F; polymorphic 处理多态，多态  &#x2F;&#x2F; 主键放到 OwnerID ，表名放到 OwnerType  &#x2F;&#x2F; link: https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;gorm&#x2F;v2&#x2F;has_one&#x2F;9737#85d280&#125;&#x2F;&#x2F; 玩具表type Toy struct &#123;gorm.ModelName      stringOwnerID   stringOwnerType string&#125;&#x2F;&#x2F; 公司表type Company struct &#123; &#x2F;&#x2F; 属于ID   intName string&#125;&#x2F;&#x2F; 语言表type Language struct &#123; &#x2F;&#x2F; 多种语言Code string &#96;gorm:&quot;primarykey&quot;&#96;Name string&#125;</code></pre><h2 id="Belong-to"><a href="#Belong-to" class="headerlink" title="Belong to"></a>Belong to</h2><h3 id="belong-to-属于"><a href="#belong-to-属于" class="headerlink" title="belong to 属于"></a>belong to 属于</h3><h3 id="has-one-拥有"><a href="#has-one-拥有" class="headerlink" title="has one 拥有"></a>has one 拥有</h3><p><a href="https://gorm.io/zh_CN/docs/has_one.html" target="_blank" >见</a></p><h3 id="谁是拥有者"><a href="#谁是拥有者" class="headerlink" title="谁是拥有者"></a>谁是拥有者</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; User 有一张 CreditCard，UserID 是外键type User struct &#123; &#x2F;&#x2F; 拥有者  gorm.Model  CreditCard CreditCard&#125;type CreditCard struct &#123;  gorm.Model  Number string  UserID uint &#x2F;&#x2F; 拥有者模型的主键&#125;</code></pre><h3 id="什么是外键"><a href="#什么是外键" class="headerlink" title="什么是外键"></a>什么是外键</h3><p>外键是某个表中的一列，它包含在另一个表的主键中。<br>外键也是索引的一种，是通过一张表中的一列指向另一张表中的主键，来对两张表进行关联。</p><h3 id="重写外键"><a href="#重写外键" class="headerlink" title="重写外键"></a>重写外键</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type User struct &#123;  gorm.Model  CreditCard CreditCard &#96;gorm:&quot;foreignKey:UserName&quot;&#96; &#x2F;&#x2F; 使用 UserName 作为外键&#125;type CreditCard struct &#123;  gorm.Model  Number   string  UserName string &#x2F;&#x2F; 这里是外键&#125;</code></pre><h3 id="重写引用-注意-官方文档存在问题，已提-issue"><a href="#重写引用-注意-官方文档存在问题，已提-issue" class="headerlink" title="重写引用 注意 官方文档存在问题，已提 issue"></a>重写引用 注意 官方文档存在问题，已提 issue</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type User struct &#123;  gorm.Model  Name       string     &#96;gorm:&quot;index&quot;&#96; &#x2F;&#x2F; 这个是引用，对应 references  CreditCard CreditCard &#96;gorm:&quot;foreignkey:UserName;references:name&quot;&#96;&#125;type CreditCard struct &#123;  gorm.Model  Number   string  UserName string&#125;</code></pre><p><a href="https://github.com/go-gorm/gorm/issues/5793" target="_blank" >#5793</a></p><h2 id="Has-one"><a href="#Has-one" class="headerlink" title="Has one"></a>Has one</h2><h2 id="Has-many"><a href="#Has-many" class="headerlink" title="Has many"></a>Has many</h2><h2 id="Many-to-many"><a href="#Many-to-many" class="headerlink" title="Many to many"></a>Many to many</h2>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js表达式</title>
      <link href="//post/2022-10-19js%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>//post/2022-10-19js%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-逗号操作符-没你想象的那么简单"><a href="#1-逗号操作符-没你想象的那么简单" class="headerlink" title="1. 逗号操作符, 没你想象的那么简单"></a>1. 逗号操作符, 没你想象的那么简单</h2><p>对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let x &#x3D; 1;x &#x3D; (x++, x);console.log(x);&#x2F;&#x2F; expected output: 2x &#x3D; (2, 3);console.log(x);&#x2F;&#x2F; expected output: 3</code></pre><p>这也太难了吧</p><h2 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h2><ul><li>在类中使用 super<ul><li>调用父类上的静态方法</li><li>删除 super 上的属性将抛出异常</li><li>super.prop 不能覆写不可写属性</li></ul></li><li>在对象字面量中使用 super.prop (先用 Object.setPrototypeOf() 建立关系)</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" >见</a></p><h2 id="3-void"><a href="#3-void" class="headerlink" title="3. void"></a>3. void</h2><h3 id="void-运算符对给定的表达式进行求值，然后返回-undefined。"><a href="#void-运算符对给定的表达式进行求值，然后返回-undefined。" class="headerlink" title="void 运算符对给定的表达式进行求值，然后返回 undefined。"></a>void 运算符对给定的表达式进行求值，然后返回 undefined。</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const output &#x3D; void 1;console.log(output);&#x2F;&#x2F; expected output: undefinedvoid console.log(&quot;expression evaluated&quot;);&#x2F;&#x2F; expected output: &quot;expression evaluated&quot;void (function iife() &#123;  console.log(&quot;iife is executed&quot;);&#125;)();&#x2F;&#x2F; expected output: iife is executedvoid function test() &#123;  console.log(&quot;test function executed&quot;);&#125;;try &#123;  test();&#125; catch (e) &#123;  console.log(&quot;test function is not defined&quot;);  &#x2F;&#x2F; expected output: &quot;test function is not defined&quot;&#125;&#x2F;&#x2F; &gt; undefined&#x2F;&#x2F; &gt; &quot;expression evaluated&quot;&#x2F;&#x2F; &gt; &quot;iife is executed&quot;&#x2F;&#x2F; &gt; &quot;test function is not defined&quot;</code></pre><h3 id="优先级高于比较运算符"><a href="#优先级高于比较运算符" class="headerlink" title="优先级高于比较运算符"></a>优先级高于比较运算符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">void 2 &#x3D;&#x3D;&#x3D; &quot;2&quot;; &#x2F;&#x2F; (void 2) &#x3D;&#x3D;&#x3D; &#39;2&#39;，返回 falsevoid (2 &#x3D;&#x3D;&#x3D; &quot;2&quot;); &#x2F;&#x2F; void (2 &#x3D;&#x3D;&#x3D; &#39;2&#39;)，返回 undefined</code></pre><h3 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h3><ul><li>在所有的一元运算符中，void 提供了最好的语义，因为它明确表示函数调用的返回值应该被丢弃</li><li>比用圆括号包裹函数表达式要长一些，圆括号的作用是强迫 function 关键字被解析为表达式的开始，而不是语句</li></ul><h3 id="javascript-url"><a href="#javascript-url" class="headerlink" title="javascript url"></a>javascript url</h3><p>当用户点击<code>一个以 javascript: 开头的 URI 时，它会执行 URI 中的代码，然后用返回的值替换页面内容，除非返回的值是 undefined</code>。void 运算符可用于返回 undefined</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;a href&#x3D;&quot;javascript:void(0);&quot;&gt; 这个链接点击之后不会做任何事情 &lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;javascript:void(document.body.style.backgroundColor&#x3D;&#39;green&#39;);&quot;&gt;  点击这个链接会让页面背景变成绿色。&lt;&#x2F;a&gt;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>利用 javascript: 伪协议来执行 JavaScript 代码是不推荐的，推荐的做法是为链接元素绑定事件</p></div><h3 id="在箭头函数中避免泄漏"><a href="#在箭头函数中避免泄漏" class="headerlink" title="在箭头函数中避免泄漏"></a>在箭头函数中避免泄漏</h3><p>箭头函数标准中，允许在函数体不使用括号来直接返回值。如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用。安全起见，当函数返回值不会被使用到的时候，应该使用 void 运算符，来确保 API 改变时，并不会改变箭头函数的行为。</p><pre class="line-numbers language-JS" data-language="JS"><code class="language-JS">button.onclick &#x3D; () &#x3D;&gt; void doSomething();&#x2F;&#x2F; 这确保了当 doSomething 的返回值从 undefined 变为 true 的时候，不会改变代码的行为。</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/void" target="_blank" >void 运算符</a></p><h2 id="4-await"><a href="#4-await" class="headerlink" title="4. await"></a>4. await</h2><ul><li><p>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。</p></li><li><p>若 Promise 正常处理 (fulfilled)，其回调的 resolve 函数参数作为 await 表达式的值，继续执行 async function。</p></li><li><p>若 Promise 处理异常 (rejected)，await 表达式会把 Promise 的异常原因抛出。</p></li><li><p>另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 例1async function f3() &#123;  var z &#x3D; await Promise.reject(30);&#125;f3(); &#x2F;&#x2F; 报错  Uncaught (in promise)&#x2F;&#x2F; 例2 try catchasync function f3() &#123;  try &#123;    var z &#x3D; await Promise.reject(30);  &#125; catch (e) &#123;    console.log(e); &#x2F;&#x2F; 30  &#125;&#125;f3(); &#x2F;&#x2F; 报错  Uncaught (in promise)&#x2F;&#x2F; 例3 .catch捕获async function f3() &#123;  var z &#x3D; await Promise.reject(30);&#125;f3().catch((e) &#x3D;&gt; &#123;  console.log(&quot;e&quot;, e); &#x2F;&#x2F; e 30&#125;);</code></pre><h2 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5. 解构赋值"></a>5. 解构赋值</h2><p>解构赋值语法是一种 Javascript 表达式。通过解构赋值，可以将“属性&#x2F;值”从对“象&#x2F;数组”中取出，赋值给其他变量。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>变量声明并赋值时的解构</li><li>变量先声明后赋值时的解构</li><li>默认值 （为了防止从数组中取出一个值为 undefined 的对象，可以在表达式左边的数组中为任意对象预设默认值。）</li><li>交换变量</li><li>解析一个从函数返回的数组</li><li>忽略某些返回值 <code>[,,] = f();</code></li><li>将剩余数组赋值给一个变量</li><li>用正则表达式匹配提取值</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul><li>基本赋值</li><li>无声明赋值 <code>var a, b; (&#123;a, b&#125; = &#123;a: 1, b: 2&#125;);</code> 括号必须</li><li>给新的变量名赋值</li><li>默认值</li><li>给新的变量命名并提供默认值 <code>var &#123;a:aa = 10, b:bb = 5&#125; = &#123;a: 3&#125;;</code></li><li>对象属性计算名和解构<code>let key = &quot;z&quot;;let &#123; [key]: foo &#125; = &#123; z: &quot;bar&quot; &#125;;</code></li><li>对象解构中的 Rest</li><li>解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 声明对象 和 自身 self 属性var obj &#x3D; &#123; self: &quot;123&quot; &#125;;&#x2F;&#x2F; 在原型链中定义一个属性 protobj.__proto__.prot &#x3D; &quot;456&quot;;&#x2F;&#x2F; testconst &#123; self, prot &#125; &#x3D; obj;&#x2F;&#x2F; self &quot;123&quot;&#x2F;&#x2F; prot &quot;456&quot;（访问到了原型链）</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>函数参数默认值</li><li>从作为函数实参的对象中提取数据</li></ul><h3 id="解构嵌套对象和数组"><a href="#解构嵌套对象和数组" class="headerlink" title="解构嵌套对象和数组"></a>解构嵌套对象和数组</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let &#123;  title: englishTitle, &#x2F;&#x2F; rename  translations: [    &#123;      title: localeTitle, &#x2F;&#x2F; rename    &#125;,  ],&#125; &#x3D; metadata;</code></pre><h3 id="For-of-迭代和解构"><a href="#For-of-迭代和解构" class="headerlink" title="For of 迭代和解构"></a>For of 迭代和解构</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (var &#123;  name: n,  family: &#123; father: f &#125;,&#125; of people) &#123;  console.log(&quot;Name: &quot; + n + &quot;, Father: &quot; + f);&#125;</code></pre><h2 id="6-null"><a href="#6-null" class="headerlink" title="6. null"></a>6. null</h2><h3 id="null-的作用"><a href="#null-的作用" class="headerlink" title="null 的作用"></a>null 的作用</h3><ul><li>值 null 是一个字面量，不像 undefined，它不是全局对象的一个属性。</li><li><strong>null 表示缺少的标识，表示变量未指向任何对象。</strong></li><li>把 null 作为尚未创建的对象，也许更好理解。</li><li>在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。</li></ul><h3 id="null-与-undefined-的不同点："><a href="#null-与-undefined-的不同点：" class="headerlink" title="null 与 undefined 的不同点："></a>null 与 undefined 的不同点：</h3><p>当检测 null 或 undefined 时</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">typeof null; &#x2F;&#x2F; &quot;object&quot; (因为一些以前的原因而不是&#39;null&#39;)typeof undefined; &#x2F;&#x2F; &quot;undefined&quot;null &#x3D;&#x3D;&#x3D; undefined; &#x2F;&#x2F; false&#x2F;&#x2F; 1 + null &#x3D; 1&#x2F;&#x2F; 1 + undefined &#x3D; NaNisNaN(1 + null); &#x2F;&#x2F; falseisNaN(1 + undefined); &#x2F;&#x2F; trueNumber.isNaN(1 + null); &#x2F;&#x2F; falseNumber.isNaN(1 + undefined); &#x2F;&#x2F; true</code></pre><h2 id="7-new"><a href="#7-new" class="headerlink" title="7. new"></a>7. new</h2><h3 id="new-关键字做了什么"><a href="#new-关键字做了什么" class="headerlink" title="new 关键字做了什么"></a>new 关键字做了什么</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new#:~:text=%E6%8F%8F%E8%BF%B0-,new%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%A6%82%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C,-%EF%BC%9A" target="_blank" >见</a></p><ol><li>创建一个空的简单 JavaScript 对象（即 <strong>{}</strong> ）；</li><li>新创建的对象添加属性<strong>proto</strong> ，将该属性链接至构造函数的原型对象；</li><li>新创建的对象作为 this 的上下文；</li><li>如果该函数没有返回对象，则返回<strong>this</strong></li></ol><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><p><strong>创建一个用户自定义的对象需要两步：</strong></p><ul><li>通过编写函数来定义对象类型。（创建一个指定其名称和属性的函数）</li><li>通过 new 来创建对象实例。</li></ul><h2 id="8-new-target"><a href="#8-new-target" class="headerlink" title="8. new.target"></a>8. new.target</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>new.target 语法由一个关键字”new”，一个点，和一个属性名”target”组成。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通常”new.”的作用: <code>是提供属性访问的上下文</code>，但这里<code>&quot;new.&quot;其实不是一个真正的对象</code>。</p><p><strong>new.target</strong>属性允许你<code>检测函数或构造方法是否是通过 new 运算符被调用的</code>。<br>在通过 new 运算符被初始化的函数或构造方法中，<code>new.target</code> 返回一个指向构造方法或函数的引用。</p><h3 id="不同函数中的区别"><a href="#不同函数中的区别" class="headerlink" title="不同函数中的区别"></a>不同函数中的区别</h3><p><em>不过在构造方法调用中，new.target 指向被 new 调用的构造函数，所以”new.”成为了一个虚拟上下文。</em></p><p><em>在普通的函数调用中，</em> <code>new.target</code> 的值是 <code>undefined</code>。</p><p><em>在 arrow functions 中，new.target 指向最近的外层函数的 new.target</em></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" >见</a></p><h2 id="9-window"><a href="#9-window" class="headerlink" title="9. window"></a>9. window</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这个恒成立window.window.window.(无论多少个.window).window &#x3D;&#x3D;&#x3D; window&#x2F;&#x2F; 全局&#x2F;&#x2F; this.window &#x3D;&#x3D;&#x3D; window&#x2F;&#x2F; this &#x3D;&#x3D;&#x3D; window</code></pre><h3 id="为什么-window-window-x3D-x3D-x3D-window"><a href="#为什么-window-window-x3D-x3D-x3D-window" class="headerlink" title="为什么 window.window &#x3D;&#x3D;&#x3D; window"></a>为什么 window.window &#x3D;&#x3D;&#x3D; window</h3><ul><li>将 window 属性指向该 window 对象本身的目的，是为了更容易引用全局对象</li></ul><h2 id="10-this"><a href="#10-this" class="headerlink" title="10. this"></a>10. this</h2><p><em>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）</em><br><em>this 不能在执行期间被赋值,</em> 并且在每次函数被调用时 this 的值也可能会不同。</p><p><em>ES5</em> 引入了 bind 方法来设置函数的 this 值，而不用考虑函数如何被调用的。<br><em>ES2015</em> 引入了箭头函数，箭头函数不提供自身的 this 绑定（this 的值将保持为闭合词法上下文的值）。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><h3 id="eval-上下文-中执行同普通函数"><a href="#eval-上下文-中执行同普通函数" class="headerlink" title="eval 上下文 中执行同普通函数"></a>eval 上下文 中执行同普通函数</h3><h3 id="几种情况"><a href="#几种情况" class="headerlink" title="几种情况"></a>几种情况</h3><h4 id="函数上下文中的-this"><a href="#函数上下文中的-this" class="headerlink" title="函数上下文中的 this"></a>函数上下文中的 this</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj &#x3D; &#123;  bar: function () &#123;    var x &#x3D; () &#x3D;&gt; this;    return x;  &#125;,&#125;;&#x2F;&#x2F; 作为 obj 对象的一个方法来调用 bar，把它的 this 绑定到 obj。&#x2F;&#x2F; 将返回的函数的引用赋值给 fn。var fn &#x3D; obj.bar();&#x2F;&#x2F; 直接调用 fn 而不设置 this，&#x2F;&#x2F; 通常 (即不使用箭头函数的情况) 默认为全局对象&#x2F;&#x2F; 若在严格模式则为 undefinedconsole.log(fn() &#x3D;&#x3D;&#x3D; obj); &#x2F;&#x2F; tru</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><h4 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h4><p>当一个函数用作构造函数时（使用 new 关键字），它的 this 被绑定到正在构造的新对象。</p><h4 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h4><p>在调用 super() 之前引用 this 会抛出错误。</p><p><em>原因：</em></p><p>派生类的构造函数没有初始的 this 绑定。在构造函数中调用 super() 会生成一个 this 绑定，并相当于执行如下代码，Base 为基类：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">this &#x3D; new Base();</code></pre><h4 id="this-和对象转换-call-x2F-apply"><a href="#this-和对象转换-call-x2F-apply" class="headerlink" title="this 和对象转换 call&#x2F;apply"></a>this 和对象转换 call&#x2F;apply</h4><h4 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h4><h4 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h4><p>当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。</p><h4 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 this</h4><p>如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样</p><h4 id="getter-与-setter-中的-this"><a href="#getter-与-setter-中的-this" class="headerlink" title="getter 与 setter 中的 this"></a>getter 与 setter 中的 this</h4><p>用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。</p><p>如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object.defineProperty(o, &quot;sum&quot;, &#123;  get: sum,  enumerable: true,  configurable: true,&#125;);</code></pre><h4 id="作为一个-DOM-事件处理函数"><a href="#作为一个-DOM-事件处理函数" class="headerlink" title="作为一个 DOM 事件处理函数"></a>作为一个 DOM 事件处理函数</h4><p>当函数被用作事件处理函数时，它的 this <code>指向触发事件的元素</code></p><p>（一些浏览器在使用<code>非addEventListener 的函数动态地添加监听函数时不遵守这个约定</code>）</p><h4 id="作为一个内联事件处理函数"><a href="#作为一个内联事件处理函数" class="headerlink" title="作为一个内联事件处理函数"></a>作为一个内联事件处理函数</h4><p>当代码被内联 on-event 处理函数 (en-US) 调用时，它的 this <code>指向监听器所在的 DOM 元素</code>：</p><h4 id="类中的-this-补充"><a href="#类中的-this-补充" class="headerlink" title="类中的 this(补充)"></a>类中的 this(补充)</h4><p>类声明和类表达式的主体都执行在严格模式下 <strong>同样遵循谁调用指向谁：</strong></p><ol><li>实例调用实例方法，指向实例</li><li>类调用静态方法，指向类</li><li><code>实例方法</code>、<code>类的静态方法</code>， 在全局调用，由于是严格模式，所以 this 是 undefined</li></ol><h3 id="综上总结如下："><a href="#综上总结如下：" class="headerlink" title="综上总结如下："></a>综上总结如下：</h3><img src="http://t-blog-images.aijs.top/img/202210192313834.svg" style="max-width:100%; width: 500px" /><h2 id="11-Error"><a href="#11-Error" class="headerlink" title="11. Error"></a>11. Error</h2><p>当运行时错误产生时，Error 对象会被抛出。Error 对象也可用于用户自定义的异常的基础对象</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>Error</code>创建一个新的 Error 对象</p><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><ul><li><code>TypeError</code> 变量或参数不属于有效类型</li><li><code>RangeError</code> 数值变量或参数超出其有效范围</li><li><code>ReferenceError</code> 无效引用</li><li><code>SyntaxError</code> 语法错误<div style="height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px"></div></li><li><code>EvalError</code> 与 eval() 有关</li><li><code>URLError</code> 给 encodeURI() 或 decodeURI() 传递的参数无效。</li><li><code>InternalError</code> 代表 Javascript 引擎内部错误的异常抛出的实例。如：递归太多<div style="height:1px; background: red; width: 200px; margin-top: 10px; margin-bottom: 10px"></div></li><li><code>AggregateError</code> 包裹了由一个操作产生且需要报告的多个错误 如：Promise.any() 产生的错误</li></ul><p>可使用 instanceof 关键字，处理特定错误</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul><li>错误名 <code>Error.prototype.name</code></li><li>错误消息 <code>Error.prototype.message</code></li><li>错误原因 <code>Error.prototype.cause</code></li><li>错误文件路径 <code>Error.prototype.fileName</code></li><li>错误行号 <code>Error.prototype.lineNumber</code></li><li>错误列号 <code>Error.prototype.columnNumber</code></li><li>错误堆栈跟踪 <code>Error.prototype.stack</code></li></ul><p><strong>助记忆</strong></p><ol><li>在哪里产生的错误： filename、lineNumber、columnNumber</li><li>错误栈是什么：stack</li><li>错误信息有哪些：name、message、cause</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 刚好遇到</title>
      <link href="//post/2022-10-19mysql.html"/>
      <url>//post/2022-10-19mysql.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据库密码修改"><a href="#数据库密码修改" class="headerlink" title="数据库密码修改"></a>数据库密码修改</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 登陆 原密码 12345678,为了保证同一份代码可以在两台电脑上，无差别运行，密码改成一致的123456👑 ~ $ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 9Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.# 修改密码mysql&gt; set password for root@localhost &#x3D; password(&#39;123456&#39;)    -&gt; ;Query OK, 0 rows affected, 1 warning (0.01 sec)mysql&gt; quitBye# 重新登陆👑 ~ $ mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 10Server version: 5.7.18 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt;</code></pre><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>命令查看、删除，比管理工具要方便</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看数据库mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || api_data           || basic_platform     || cache_data         || cnpmcore           || cnpmjs             || cnpmjs_test        || learn-gorm         || mysql              || nest-app           || performance_schema || sys                || test               || ty_feedback      || ty_rms           |+--------------------+15 rows in set (0.00 sec)# 使用数据库mysql&gt; use learn-gorm;Database changedmysql&gt; show tables;Empty set (0.01 sec)# 查看表mysql&gt; show tables;+----------------------+| Tables_in_learn-gorm |+----------------------+| dogs                 || girl_gods            |+----------------------+2 rows in set (0.00 sec)# 查看表信息mysql&gt; desc dogs;+-------------+---------------------+------+-----+---------+----------------+| Field       | Type                | Null | Key | Default | Extra          |+-------------+---------------------+------+-----+---------+----------------+| id          | bigint(20) unsigned | NO   | PRI | NULL    | auto_increment || created_at  | datetime(3)         | YES  |     | NULL    |                || updated_at  | datetime(3)         | YES  |     | NULL    |                || deleted_at  | datetime(3)         | YES  | MUL | NULL    |                || name        | longtext            | YES  |     | NULL    |                || girl_god_id | bigint(20) unsigned | YES  | MUL | NULL    |                |+-------------+---------------------+------+-----+---------+----------------+6 rows in set (0.01 sec)mysql&gt;</code></pre><h2 id="key、primary-key、unique-key、index-区别"><a href="#key、primary-key、unique-key、index-区别" class="headerlink" title="key、primary key、unique key、index 区别"></a>key、primary key、unique key、index 区别</h2><p><a href="https://blog.51cto.com/u_10980859/5323031" target="_blank" >见， 没看懂</a></p><h2 id="mysql-命令行清屏"><a href="#mysql-命令行清屏" class="headerlink" title="mysql 命令行清屏"></a>mysql 命令行清屏</h2><p>linux</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ctrl + l</code></pre><h2 id="select-…-for-update-查询"><a href="#select-…-for-update-查询" class="headerlink" title="select … for update 查询"></a>select … for update 查询</h2><p>select 查询是不加锁的，select…for update 是会加锁的，而且是悲观锁，但是在不同查询条件时候加的锁的类型（行锁，表锁）是不同的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from t_user where id &#x3D; 1 for update；</code></pre><p>在 where 后面查询条件是主键索引，唯一索引时候是行锁<br>查询条件是普通字段时候加的是表锁</p><h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><p><a href="http://www.wjhsh.net/zhaoyl9-p-10856170.html" target="_blank" >sql 语句对数据库表进行加锁和解锁, 一脸懵逼</a></p><h2 id="MySQL-HAVING-用法"><a href="#MySQL-HAVING-用法" class="headerlink" title="MySQL HAVING 用法"></a>MySQL HAVING 用法</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="https://gorm.io/zh_CN/docs/advanced_query.html#%E5%AD%90%E6%9F%A5%E8%AF%A2" target="_blank" >gorm 子查询</a></p><p><a href="https://www.jianshu.com/p/7701bf10167b" target="_blank" >MySQL HAVING 用法</a></p><h3 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h3><p><strong>什么时候用 WHERE 什么时候使用 HAVING 呢？</strong></p><ul><li>WHERE 子句 &#x3D; 指定行所对应的条件</li><li>HAVING 子句 &#x3D; 指定组所对应的条件</li><li>WHERE 处理速度比 HAVING 处理速度高</li><li>聚合键所对应的条件不应该书写在 HAVING 子句当中，而应该书写在 WHERE 子句当中。</li></ul><p>作者：RicherYY<br>链接：<a href="https://www.jianshu.com/p/7701bf10167b">https://www.jianshu.com/p/7701bf10167b</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="mysql-insert-ignore-into"><a href="#mysql-insert-ignore-into" class="headerlink" title="mysql insert ignore into"></a>mysql insert ignore into</h3><p><a href="https://blog.csdn.net/zgaoq/article/details/124432806" target="_blank" >见</a></p><p>insert ignore into : 忽略重复的记录，直接插入数据。</p><p><strong>1、插入的数据是主键冲突时</strong></p><p>insert ignore into 会给出 warnings，show warnings 就可以看到提示主键冲突；并且本次插入无效</p><p><em>Query OK, 0 rows affected, 3 warnings (0.01 sec)</em></p><p><strong>2、没有主键冲突时，直接插入数据</strong></p><p>insert into 与 insert ignore into 都是直接插入数据</p><h2 id="mysql-如何对多个行数据，执行不同的更新操作"><a href="#mysql-如何对多个行数据，执行不同的更新操作" class="headerlink" title="mysql 如何对多个行数据，执行不同的更新操作"></a>mysql 如何对多个行数据，执行不同的更新操作</h2><p>TODO：? 只能用循环执行多次 Update? 有没有并发执行？</p><h2 id="mysql-命令行执行命令加上注释"><a href="#mysql-命令行执行命令加上注释" class="headerlink" title="mysql 命令行执行命令加上注释"></a>mysql 命令行执行命令加上注释</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql&gt; show create table  users \G; #hello-- *************************** 1. row ***************************--        Table: users-- Create Table: CREATE TABLE &#96;users&#96; (--   &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT,--   &#96;created_at&#96; datetime(3) DEFAULT NULL,--   &#96;updated_at&#96; datetime(3) DEFAULT NULL,--   &#96;deleted_at&#96; datetime(3) DEFAULT NULL,--   &#96;name&#96; varchar(255) DEFAULT NULL,--   PRIMARY KEY (&#96;id&#96;),--   KEY &#96;idx_users_deleted_at&#96; (&#96;deleted_at&#96;)-- ) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4-- 1 row in set (0.00 sec)</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>条件是辅助索引，先找到主索引，通过主索引找到数据记录</p><img src="http://t-blog-images.aijs.top/img/202210212251698.png" /><p><strong>这里涉及到一个优化：</strong></p><p>如果通过辅助索引，查到覆盖索引相关字段，就不用做二次查询，也就是上图的 ②，省了一次查询自然快很多；</p><p>如果 select 的内容不在覆盖索引字段中，会启动二次查询，所以吧，不要用<code>select *</code></p><p><a href="https://gorm.io/zh_CN/docs/indexes.html" target="_blank" >gorm 索引不是很懂，抱着怀疑态度，学习下</a><br><a href="https://zhuanlan.zhihu.com/p/453658511?utm_id=0" target="_blank" >mysql 索引相关</a><br><a href="https://www.bilibili.com/video/BV1Sp4y1e7W6" target="_blank" >Mysql 底层原理系列</a></p><h3 id="什么是-B-树-B-树-B-树"><a href="#什么是-B-树-B-树-B-树" class="headerlink" title="什么是 B 树 B+树 B-树"></a>什么是 B 树 B+树 B-树</h3><p>+号，-号什么意思？</p><h3 id="为什不用-hash-而用-b-树"><a href="#为什不用-hash-而用-b-树" class="headerlink" title="为什不用 hash 而用 b+树"></a>为什不用 hash 而用 b+树</h3><p>演示链接： <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" >https://www.cs.usfca.edu/~galles&#x2F;visualization&#x2F;Algorithms.html</a></p><ul><li>hash 无序，查询中<code>&gt;</code>、<code>&lt; </code>等无效，值不同 hash 可能相同</li></ul><h2 id="比较-x2F-进化"><a href="#比较-x2F-进化" class="headerlink" title="比较&#x2F;进化"></a>比较&#x2F;进化</h2><p><strong>平衡树</strong>：左子树个数 几乎等于 右子树个数，随数据量增加，查询越来越慢 （存在回旋查找）</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" >Data Structure Visualizations 平衡树</a></p><p><strong>B 树：</strong>相对 平衡树，高度变矮，查询速度自然快（存在回旋查找）<br><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" >Data Structure Visualizations B 树</a><br><img src="http://t-blog-images.aijs.top/img/202210212320456.png" /></p><p><strong>B+树：</strong>为了解决 B 树回旋查找的问题<br><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html" target="_blank" >Data Structure Visualizations B+树</a><br><img src="http://t-blog-images.aijs.top/img/202210212328461.png" /></p><ul><li>非叶子节点：存 K</li><li>叶子节点：存 K-V</li><li>查询节点 1 与查询节点 10，会比 B 树多一步，其他节点与 B 查询次数一致</li><li>回旋问题：直接通过叶子节点解决（因为叶子节点的链表是有序的）</li></ul><h2 id="SQL-NO-CACHE"><a href="#SQL-NO-CACHE" class="headerlink" title="SQL_NO_CACHE"></a>SQL_NO_CACHE</h2><p>不使用缓存来查询数据</p><h2 id="百万数据-sql-优化"><a href="#百万数据-sql-优化" class="headerlink" title="百万数据 sql 优化"></a>百万数据 sql 优化</h2><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><img src="http://t-blog-images.aijs.top/img/202210212342616.png" /><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><img src="http://t-blog-images.aijs.top/img/202210212343585.png" /><h4 id="最左原则"><a href="#最左原则" class="headerlink" title="最左原则"></a>最左原则</h4><img src="http://t-blog-images.aijs.top/img/202210212346011.png" /><h4 id="破坏最左原则"><a href="#破坏最左原则" class="headerlink" title="破坏最左原则"></a>破坏最左原则</h4><img src="http://t-blog-images.aijs.top/img/202210212349688.png" /><img src="http://t-blog-images.aijs.top/img/202210212351307.png" /><h4 id="不对索引做一些运算操作"><a href="#不对索引做一些运算操作" class="headerlink" title="不对索引做一些运算操作"></a>不对索引做一些运算操作</h4><img src="http://t-blog-images.aijs.top/img/202210212352390.png" /><h4 id="索引不要放在范围查询右侧"><a href="#索引不要放在范围查询右侧" class="headerlink" title="索引不要放在范围查询右侧"></a>索引不要放在范围查询右侧</h4><img src="http://t-blog-images.aijs.top/img/202210212354861.png" /><h4 id="减少select"><a href="#减少select" class="headerlink" title="减少select *"></a>减少<code>select *</code></h4><img src="http://t-blog-images.aijs.top/img/202210212355505.png" /><h4 id="like-没用到索引"><a href="#like-没用到索引" class="headerlink" title="like 没用到索引"></a>like 没用到索引</h4><p><strong>这种索引失效</strong></p><img src="http://t-blog-images.aijs.top/img/202210212357873.png" /><p><strong>失效的索引也可以进行优化，使用覆盖索引</strong></p><p>时间介于无索引和有索引之间</p><img src="http://t-blog-images.aijs.top/img/202210220000120.png" /><p><strong>索引有效</strong></p><img src="http://t-blog-images.aijs.top/img/202210212358442.png" /><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p><strong>优化前</strong><br><img src="http://t-blog-images.aijs.top/img/202210220002406.png" /></p><p><strong>优化后</strong><br><img src="http://t-blog-images.aijs.top/img/202210220004580.png" /></p><p>这种适用范围小，视频说要在代码中放内存中进行排序</p><h2 id="mysql-中的坑"><a href="#mysql-中的坑" class="headerlink" title="mysql 中的坑"></a>mysql 中的坑</h2><p><a href="https://www.bilibili.com/video/BV1pg411A7p3" target="_blank" >https://www.bilibili.com/video/BV1pg411A7p3</a></p><ul><li>遇到字段 null 值，count 数据丢失 解决: 用主键，或数字</li><li>distinct 数据丢失，也是 null 引起</li><li>执行<code>&lt;&gt; 、!=</code>查询，遇到 null 丢数据， 解决:需要 <code>or isNull(column名)</code></li><li>null 会导致 sum 求和时候，返回 null 而非 0， 会发生异常， 这个看需求把 null 做 0 处理，避开 null,视频讲错了，视频统计值最终为 0</li><li><code>!=null</code> 和 <code>&lt;&gt;null</code>的查询不到数据，应该使用 <code>!isNull(column名)</code></li></ul><h2 id="explain-来分析查询计划"><a href="#explain-来分析查询计划" class="headerlink" title="explain 来分析查询计划"></a>explain 来分析查询计划</h2><img src="http://t-blog-images.aijs.top/img/202210212311527.png" /><h2 id="查看连接数"><a href="#查看连接数" class="headerlink" title="查看连接数"></a>查看连接数</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show PROCESSLIST</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/m0_67683346/article/details/126139404" target="_blank" >MySQL 数据库的基础操作</a><br><a href="http://c.biancheng.net/view/7152.html" target="_blank" >MySQL 修改密码的 3 种方式</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web api history</title>
      <link href="//post/2022-10-18history.html"/>
      <url>//post/2022-10-18history.html</url>
      
        <content type="html"><![CDATA[<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" >https://developer.mozilla.org/en-US/docs/Web/API/History</a></p><h2 id="replaceState-不刷新页面"><a href="#replaceState-不刷新页面" class="headerlink" title="replaceState 不刷新页面"></a>replaceState 不刷新页面</h2><p>更改页面参数不刷新页面</p><ul><li>用来存 hash</li><li>用来存页面查询参数</li></ul><p><a href="/#/post/2022-10-14useSearchParams" target="_blank" >&#x2F;#&#x2F;post&#x2F;2022-10-14useSearchParams</a></p><h2 id="scrollRestoration-滚动恢复属性"><a href="#scrollRestoration-滚动恢复属性" class="headerlink" title="scrollRestoration 滚动恢复属性"></a>scrollRestoration 滚动恢复属性</h2><p><strong>auto</strong><br>将恢复用户已滚动到的页面上的位置。</p><p><strong>manual</strong><br>未还原页上的位置。用户必须手动滚动到该位置</p><p>主要来说下这个东西，直接拿 <a href="https://www.runoob.com/" target="_blank" >《菜鸟教程》</a> 演示</p><img src="http://t-blog-images.aijs.top/img/202210181643614.gif" style="width: 800px;max-width: 100%;margin-bottom:16px" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" >https://developer.mozilla.org/en-US/docs/Web/API/History</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题</title>
      <link href="//post/2022-10-16js.html"/>
      <url>//post/2022-10-16js.html</url>
      
        <content type="html"><![CDATA[<h2 id="B-站爬取脚本"><a href="#B-站爬取脚本" class="headerlink" title="B 站爬取脚本"></a>B 站爬取脚本</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var list &#x3D; document.getElementsByClassName(&quot;video-list&quot;)[0];Array.from(list.children).forEach((item) &#x3D;&gt; &#123;  var t &#x3D; item.children[1].innerText;  document.body.append(t);  var br &#x3D; document.createElement(&quot;br&quot;);  document.body.append(br);&#125;);</code></pre><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="js-的-typeof-返回哪些数据类型"><a href="#js-的-typeof-返回哪些数据类型" class="headerlink" title="js 的 typeof 返回哪些数据类型"></a>js 的 typeof 返回哪些数据类型</h3><p>string, boolean, number, undefined, function, object。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">typeof console;&#x2F;&#x2F; &#39;object&#39;typeof console.log;&#x2F;&#x2F; &#39;function&#39;typeof console.log();&#x2F;&#x2F; &#39;undefined&#39;</code></pre><p>首先在 JS 中，分两种数据类型：</p><p><strong>基本数据类型：</strong> Number、String、Boolean、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值。同时要记住，这这些值他是存放在栈中的。</p><p><strong>引用数据类型：</strong> Object（<em>在 JS 中除了基本数据类型以外的都是对象</em> )</p><ol><li>函数-Function 是对象</li><li>数据-Array 是对象</li><li>日期时间-Date 是对象</li><li>正则表达式-Reg 是对象</li></ol><p>然后到目前为止，ECMAScript 标准中定义了 8 种数据类型，它们分别是 Undefined、Null、Number、Boolean、String、<code>Symbol</code>、<code>BigInt</code>、Object。<br>————————————————<br>版权声明：本文为 CSDN 博主「伍文亮」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_44963070/article/details/124046875">https://blog.csdn.net/weixin_44963070/article/details/124046875</a></p><h3 id="JS-中-this-相关问题"><a href="#JS-中-this-相关问题" class="headerlink" title="JS 中 this 相关问题"></a>JS 中 this 相关问题</h3><h3 id="ajax、axios、fetch-的区别"><a href="#ajax、axios、fetch-的区别" class="headerlink" title="ajax、axios、fetch 的区别"></a>ajax、axios、fetch 的区别</h3><p>参考答案：</p><p><strong>（1）AJAX</strong> 即<code>“Asynchronous Javascript And XML”</code>（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。</p><ul><li>它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li><li>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。</li><li>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</li></ul><p><em>其缺点如下：</em></p><ul><li>本身是针对 MVC 编程，不符合前端 MVVM 的浪潮</li><li>基于原生 XHR 开发，XHR 本身的架构不清晰</li><li>不符合关注分离（Separation of Concerns）的原则</li><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul><p><strong>（2）Fetch</strong></p><ul><li>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</li><li>fetch 号称是 XMLHttpRequest 的替代品</li><li>Fetch 是基于 promise 设计的。</li><li>Fetch 的代码结构比起 ajax 简单多。</li></ul><p><em>fetch 的优点：</em></p><ol><li>脱离了 XHR，是 ES 规范里新的实现方式</li><li>更加底层，提供的 API 丰富（request, response）</li><li>基于标准 Promise 实现，支持 async&#x2F;await</li><li>语法简洁，更加语义化</li></ol><p><em>fetch 的缺点：</em></p><ul><li><p>fetch 没有办法原生监测请求的进度，而 XHR 可以 3. <code>HTTP 404 状态并不被认为是网络错误</code>。</p></li><li><p>fetch <code>只对网络请求报错才会被 reject,其他情况会被 resolved 掉</code></p><ol><li>当遇到网络错误时，fetch() 返回的 promise 会被 reject，并传回 <code>TypeError</code>，虽然这也可能因为权限或其它问题导致。</li><li>成功的 fetch() 检查不仅要包括 promise 被 resolve，还要包括 <code>Response.ok</code> 属性为 true。</li></ol></li><li><p>fetch 默认不会带 cookie，需要添加配置项： fetch(url, {<code>credentials: &#39;include&#39;</code>})</p></li><li><p>fetch 支持 abort（利用 signal 结合 AbortController），不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费 <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch" target="_blank" >见</a></p></li><li><p><code>AbortError</code>： 请求被 <code>AbortController.abort()</code>终止。</p></li><li><p><code>TypeError</code> ：</p><ol><li>method 为<code>get</code> <code>head</code> 方法, 配置 <code>body</code> <code>non-null</code> 或者不是 <code>undefined</code> 时候</li><li>url 有误</li><li>如果 fetch()接收到含有用户名和密码的 URL（例如 <a href="http://user:password@example.com),它将会抛出一个/">http://user:password@example.com），它将会抛出一个</a> TypeError 。</li><li>请求头配置有误</li><li><code>cache</code> 字段为<code>only-if-cached</code>， <code>mode</code>不是 <code>same-origin</code></li><li><code>no-cors</code> 非 <code>get</code>、<code>head</code>、<code>post</code> 时候会报错</li></ol></li></ul><p><strong>（3）Axios</strong> Axios 是一种基于 Promise 封装的 HTTP 客户端，其特点如下：</p><ol><li>浏览器端发起 XMLHttpRequests 请求, node 端发起 http 请求</li><li>支持 Promise API</li><li>监听请求和返回</li><li>对请求和返回进行转化</li><li>取消请求</li><li>自动转换 json 数据</li><li>客户端支持抵御 CSRF 攻击</li></ol><h3 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别"></a>for…in 和 for…of 的区别</h3><ol><li><p>for…of 循环是 ES6 新增的遍历方法。</p></li><li><p>for…of 循环可用于<code>数组/类数组</code>，包括<code>字符串</code>、<code>数组</code>、<code>Set</code> 和 <code>Map</code> 结构、某些类似数组的对象(比如 <code>arguments</code> 对象、<code>DOM NodeList</code> 对象)、<code>Generator</code> 对象；</p></li><li><p><code>对于普通的对象，for...of 循环不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。for...of 循环遍历得到键值。</code></p></li><li><p>for…in 循环不适用于遍历数组，主要是为了遍历对象而生，但是只能获得对象的键名，不能直接获得键值。</p></li><li><p>对于数组的遍历，for…in 循环会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)；for…of 循环只返回数组的下标对应的属性值。</p></li><li><p><code>for…in 循环会遍历对象的整个原型链，性能非常差不推荐使用</code>；而 for…of 循环只遍历当前对象不会遍历原型链。</p></li></ol><p>作者：光头络腮胡<br>链接：<a href="https://juejin.cn/post/7148367249257005086">https://juejin.cn/post/7148367249257005086</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h3><p>instanceof</p><p>Object.prototype.toString.call()</p><h3 id="谈谈尾调用及其好处？"><a href="#谈谈尾调用及其好处？" class="headerlink" title="谈谈尾调用及其好处？"></a>谈谈尾调用及其好处？</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>尾调用指的是函数的最后一步调用另一个函数。</p><p>我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。</p><p><em>但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</em></p><h3 id="escape、encodeURI、encodeURIComponent-的区别"><a href="#escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="escape、encodeURI、encodeURIComponent 的区别"></a>escape、encodeURI、encodeURIComponent 的区别</h3><ul><li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li><li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li><li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li></ul><h3 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h3><p>isNaN 接收参数，会尝试将这个参数转化成数值，任何不能被转换为数值的值都会返回 true,<br>因此非数字值传入也会返回 true,会影响 NaN 的判断。</p><p>Number.isNaN 也会首先判断传入的参数是否为数字，如果是数字再继续判断是否为 NaN，不会进行数据类型的转化，这种方法对 NaN 的判断更准确</p><h3 id="说说你对堆区和栈区的理解"><a href="#说说你对堆区和栈区的理解" class="headerlink" title="说说你对堆区和栈区的理解"></a>说说你对堆区和栈区的理解</h3><p><strong>数据结构：</strong><br>(1)、栈：栈在数据结构中的特性是后进先出的特性。<br>(2)、堆：对在数据结构中是一个优先队列，按照优先级进行排序，其中完全二叉树是堆数据结构的一个实现。</p><p><strong>操作系统：</strong><br>在操作系统中将内存分为栈区和堆区。<br>(1)、栈：基本的数据类型，函数参数等存放在栈中，是计算机自动分配的内存空间<br>(2)、堆：一些函数，对象等数据类型的数据存放在堆中，堆中的内存程序员自己进行分配和释放，如果程序员不释放，在程序执行结束后，系统会自动释放。<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/122503152">https://blog.csdn.net/weixin_47450807/article/details/122503152</a></p><h3 id="说说-Ajax-组成部分"><a href="#说说-Ajax-组成部分" class="headerlink" title="说说 Ajax 组成部分"></a>说说 Ajax 组成部分</h3><p><code>Asynchronous</code> <code>JavaScript</code> and <code>XML</code></p><h3 id="JavaScript-中-BOM-与-DOM-的区别"><a href="#JavaScript-中-BOM-与-DOM-的区别" class="headerlink" title="JavaScript 中 BOM 与 DOM 的区别"></a>JavaScript 中 BOM 与 DOM 的区别</h3><p>DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性</p><p>BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器</p><p>Javascript 由三部分构成，<code>ECMAScript</code>，<code>DOM</code> 和 <code>BOM</code></p><ol><li><em>ECMAScript(核心)</em> , 描述了 JS 的语法和基本对象</li><li><em>DOM 是文档对象模型</em> , 处理网页内容的方法和接口。是 W3C 的标准； <code>[所有浏览器公共遵守的标准]</code></li><li><em>BOM 是浏览器对象模型</em> , 提供与浏览器交互的方法和接口。各个浏览器厂商根据 DOM 在各自浏览器上的实现;<code>[表现为不同浏览器定义有差别,实现方式不同]</code></li></ol><p><strong>DOM</strong></p><p><em>这个 DOM 定义了一个 HTMLDocument 和 HTMLElement 做为这种实现的基础,就是说为了能以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素）</em></p><p><strong>BOM</strong></p><p><em>比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数</em></p><p>Window 对象包含属性：document、location、navigator、screen、history、frames<br>Document 根节点包含子节点：forms、embeds、anchors、images、links</p><p>从 window.document 已然可以看出，DOM 的最根本的对象是 BOM 的 window 对象的子对象。</p><p>由于 BOM 的 window 包含了 document，因此可以直接使用 window 对象的 document 属性，通过 document 属性就可以访问、检索、修改 XHTML 文档内容与结构。</p><p>因为 document 对象又是 DOM（Document Object Model）模型的根节点。</p><p>可以说，BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象，<br>从而 js 可以操作浏览器以及浏览器读取到的文档。</p><p><strong>总结：</strong></p><ol><li><code>描述的内容不同</code>: DOM 以编程的方法操作这个 HTML 的内容（比如添加某些元素、修改元素的内容、删除某些元素），BOM 比如跳转到另一个页面、前进、后退等等，程序还可能需要获取屏幕的大小之类的参数</li><li><code>描述的范围不同</code>: BOM 包含了 DOM(对象)，浏览器提供出来给予访问的是 BOM 对象，从 BOM 对象再访问到 DOM 对象</li></ol><p>作者：王小端 coder<br>链接：<a href="https://juejin.cn/post/6844903939008102413">https://juejin.cn/post/6844903939008102413</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="你是怎么理解闭包的？"><a href="#你是怎么理解闭包的？" class="headerlink" title="你是怎么理解闭包的？"></a>你是怎么理解闭包的？</h3><h3 id="说下-JS-的基本数据类型"><a href="#说下-JS-的基本数据类型" class="headerlink" title="说下 JS 的基本数据类型"></a>说下 JS 的基本数据类型</h3><h2 id="use-strict-及其作用？"><a href="#use-strict-及其作用？" class="headerlink" title="use strict 及其作用？"></a>use strict 及其作用？</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" >MDN use strict</a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>es5 的严格模式:</p><p><strong>在不使用严格模式时，程序猿开发的代码会有 sloppy 现象，严格模式是为了让程序员避免 sloppy 模式。</strong></p><p>为了形成与正常代码不同的语义，为此对正常的 JavaScript 语义做了一些更改<br>从而使代码隐式地脱离<code>“马虎模式/稀松模式/懒散模式“</code>（sloppy）模式</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>不支持严格模式与支持严格模式的浏览器，在执行严格模式代码时会采用不同行为。</li><li>不支持严格模式的浏览器，即使代码设置了严格模式，严格模式也不生效</li><li>严格模式代码和非严格模式代码可以共存</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>严格模式：通过抛出错误来消除了一些原有静默错误。</li><li>严格模式：修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</li><li>严格模式：为未来的 ECMAScript 版本铺平道路,禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。</li></ol><h3 id="体现："><a href="#体现：" class="headerlink" title="体现："></a>体现：</h3><p><strong>将过失错误转成异常</strong></p><ol><li>严格模式下无法再意外创建全局变量</li><li>在严格模式下，试图删除不可删除的属性时会抛出异常</li><li>严格模式会使引起静默失败 (silently fail，注：不报错也没有任何效果) 的赋值操作抛出异常 如：<small>（给 NaN 赋值会抛出一个异常、给不可写属性赋值）</small></li><li>Gecko 版本 34 之前，严格模式要求一个对象内的所有属性名在对象内必须唯一</li><li>严格模式要求函数的参数名唯一</li><li>严格模式禁止八进制数字语法（ECMAScript 并不包含八进制语法， ECMAScript 6 中支持为一个数字加”0o”的前缀来表示八进制数）</li></ol><p><strong>简化变量使用</strong></p><ul><li><p>在严格模式下 eval 仅仅为被运行的代码创建变量，所以 eval 不会使得名称映射到外部变量或者其他局部变量：</p></li><li><p>让 eval 和 arguments 变的简单</p></li></ul><p><em>arguments</em></p><p>名称 eval 和 arguments 不能通过程序语法被绑定 (be bound) 或赋值<br>严格模式下，参数的值不会随 arguments 对象的值的改变而变化<br>不再支持 arguments.callee</p><p><strong>更安全（有性能&#x2F;安全问题的不予实现）</strong></p><ol><li><p>严格模式下，<code>通过 this 传递给一个函数的值不会被强制转换为一个对象</code>，对一个普通的函数来说，this 总会是一个对象，这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患</p></li><li><p>在严格模式下，<code>那么 fun.caller 和 fun.arguments </code>都是不可删除的属性而且在存值、取值时都会报错</p></li><li><p>严格模式下的 arguments 不会再提供访问与调用这个函数相关的变量的途径，旧时的 ECMAScript 实现中 arguments.caller 曾经是一个对象，里面存储的属性指向那个函数的变量，有安全隐患，还会有性能问题。现在的浏览器没有实现这个</p></li></ol><h2 id="继承原型链"><a href="#继承原型链" class="headerlink" title="继承原型链"></a>继承原型链</h2><h3 id="new-做了什么"><a href="#new-做了什么" class="headerlink" title="new 做了什么"></a>new 做了什么</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#:~:text=Copy%20to%20Clipboard-,JavaScript%20%E5%AE%9E%E9%99%85%E4%B8%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AF%EF%BC%9A,-var%20o%20%3D" target="_blank" >JavaScript 实际上执行的是：</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这里并没有像很多面试题实现new那样，注意问题，new做了什么，而不是如何实现var o &#x3D; new Object();&#x2F;&#x2F; 私有属性（称之为 __proto__）指向它的构造函数的原型对象（prototype&#x2F;&#x2F; 这里要注意下，实例对象的属性能不能改是配置决定，而不是是不是私有决定o.__proto__ &#x3D; Foo.prototype;Foo.call(o);</code></pre><h2 id="并发模型与事件循环"><a href="#并发模型与事件循环" class="headerlink" title="并发模型与事件循环"></a>并发模型与事件循环</h2><h2 id="为什么-js-是单线程"><a href="#为什么-js-是单线程" class="headerlink" title="为什么 js 是单线程"></a>为什么 js 是单线程</h2><p>这主要和 js 的用途有关，<em>js 是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作 dom</em> ；<br>这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>举个例子：如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，<br><em>此时浏览器就会一脸茫然，不知所措</em> 。所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，<br>这已经成了这门语言的核心特征，将来也不会改变。</p><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p><strong>什么是进程:</strong><br><em>进程：</em>是 cpu 分配资源的最小单位；（是能拥有资源和独立运行的最小单位）</p><p><strong>什么是线程:</strong><br><em>线程：</em>是 cpu 调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p><p><strong>浏览器是多进程的？</strong><br>放在浏览器中，每打开一个 tab 页面，其实就是新开了一个进程，<br>在这个进程中，还有 <em>ui 渲染线程</em> 、 <em>js 引擎线程</em> 、 <em>http 请求线程</em>等。 所以，浏览器是一个多进程的。</p><p><em>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准</em> ，允许 JavaScript 脚本创建多个线程，<br>但是<code>子线程完全受主线程控制</code>，且<code>不得操作 DOM</code>。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="宏微任务以及执行顺序"><a href="#宏微任务以及执行顺序" class="headerlink" title="宏微任务以及执行顺序"></a>宏微任务以及执行顺序</h2><p>JS 中用来存储待执行回调函数的队列包含 2 个不同特定的列队。<br>1、<strong>宏任务:</strong> 用来保存待执行的宏任务（回调），比如：<code>定时器回调</code>、<code>DOM 事件回调</code>、<code>ajax 回调</code><br>2、<strong>微任务:</strong> 用来保存待执行的微任务（回调），比如：<code>promise 的回调</code>、<code>MutationObserver 的回调</code></p><p>JS 执行时会区别这 2 个队列<br>1、JS 引擎首先必须先执行所有的初始化<em>同步任务代码</em><br>2、<em>每次在准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行</em> ，也就是微任务优先级比宏任务高，且与微任务所处的代码位置无关<br>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/124533748">https://blog.csdn.net/weixin_47450807/article/details/124533748</a></p><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>参考答案:<br>暂时性死区的本质就是，只要一进入当前作用域，<em>所要使用的变量就已经存在了，但是不可获取</em> , <em>直到声明变量的那一行代码出现</em> , 才可以获取和使用该变量。</p><p><strong>let 、const 与暂时性死区</strong><br>let 或 const 声明的变量拥有暂时性死区（TDZ）：当进入它的作用域，它不能被访问（获取或设置）直到执行到达声明。</p><p><strong>首先看看不具有暂时性死区的 var：</strong><br>当进入 var 变量的作用域（包围它的函数），<em>立即为它创建（绑定）存储空间。变量会立即被初始化并赋值为 undefined。</em><br>当执行到变量声明的时候，如果变量定义了值则会被赋值。</p><p><strong>通过 let 声明的变量拥有暂时性死区，生命周期如下：</strong><br>当进入 let 变量的作用域（包围它的语法块），<em>立即为它创建（绑定）存储空间。此时变量仍是未初始化的。</em><br>获取或设置未初始化的变量将抛出异常 <code>ReferenceError</code>。<br>当执行到变量声明的时候，如果变量定义了值则会被赋值。如果没有定义值，则赋值为 undefined。</p><p>const 工作方式与 let 类似，<code>但是定义的时候必须赋值并且不能改变</code></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>B 站：小甲鱼 鱼 C，讲闭包讲的很好</p><p>闭包：不是 js 特有的，几乎所有的变成语言中，都存在闭包</p><p>闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。在学过的编程语言中 js、oc、swift、android、kotlin、dart、golang、python 以及 Java（Java8 及以上）等语言中都能找到对闭包不同程度的支持。</p><p><a href="https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873?fr=kg_general" target="_blank" >见百度百科</a></p><h2 id="面向对象的三大特性，分别说一下什么意思"><a href="#面向对象的三大特性，分别说一下什么意思" class="headerlink" title="面向对象的三大特性，分别说一下什么意思?"></a>面向对象的三大特性，分别说一下什么意思?</h2><p>1、<em>封装:</em> 将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。</p><p>对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。</p><p>2、<em>继承:</em> 继承可以解决代码复用，让编程更加靠近人类思维。</p><p>当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。</p><p>3、<em>多态:</em> 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：<em>多态是指通过指向父类的引用，来调用在不同子类中实现的方法。</em></p><h2 id="Promise-和-async-await-的区别"><a href="#Promise-和-async-await-的区别" class="headerlink" title="Promise 和 async await 的区别"></a>Promise 和 async await 的区别</h2><p><strong>1、概念:</strong><br><strong>Promise</strong> 是异步编程的一种解决方案，比传统的解决方案——<em>回调函数</em>和<em>事件</em>——更合理和更强大</p><p>简单地说，Promise 好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的。</p><p><strong>async await</strong>也是异步编程的一种解决方案，他遵循的是 <em>Generator 函数的语法糖</em> ，他拥有<em>内置执行器</em> ，不需要额外的调用直接会自动执行并输出结果，它返回的是一个 Promise 对象。</p><p><strong>两者的区别:</strong></p><p><em>相同点</em></p><ol><li><em>async await 与 Promise 一样，是非阻塞的</em></li></ol><p><em>不同点</em></p><ol><li><p><em>版本不同:</em> promise 是 ES6，async&#x2F;await 是 ES7</p></li><li><p><em>背景不同:</em><br>2.1. <code> Promise 的出现是为了解决了传统 callback 函数导致的“地域回调”问题,</code>语法导致了它向纵向发展行成了一个<em>回调链</em>，遇到复杂的业务场景，这样的语法显然也是不美观的。</p><br/><p>2.2. <code> 而 async await 代码看起来会简洁些,使得异步代码看起来像同步代码,</code> await 的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。</p></li><li><p><em>async await 是基于 Promise 实现的，可以说是改良版的 Promise，它不能用于普通的回调函数</em></p></li><li><p>错误捕获 Promise 有<code>.catch</code>,async await 既可以用<code>.then</code> 又可以用 <code>try-catch</code> 捕捉</p></li></ol><h2 id="setTimeout-值打印"><a href="#setTimeout-值打印" class="headerlink" title="setTimeout 值打印"></a>setTimeout 值打印</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 输出 10个10for (var i &#x3D; 0; i &lt; 10; i++) &#123;  setTimeout(() &#x3D;&gt; &#123;    console.log(i);  &#125;, 100);&#125;&#x2F;&#x2F; 打印出0 - 9;&#x2F;&#x2F; var -&gt; letfor (let i &#x3D; 0; i &lt; 10; i++) &#123;  setTimeout(() &#x3D;&gt; &#123;    console.log(i);  &#125;, 100);&#125;&#x2F;&#x2F; 立即执行函数for (var i &#x3D; 0; i &lt; 10; i++) &#123;  (function (i) &#123;    setTimeout(() &#x3D;&gt; &#123;      console.log(i);    &#125;, 100);  &#125;)(i);&#125;&#x2F;&#x2F; setTimeout传入参数的方式for (var i &#x3D; 0; i &lt; 10; i++) &#123;  setTimeout(    (n) &#x3D;&gt; &#123;      console.log(n);    &#125;,    100,    i  );&#125;</code></pre><h2 id="立即执行函数有什么用，作用域是怎样的"><a href="#立即执行函数有什么用，作用域是怎样的" class="headerlink" title="立即执行函数有什么用，作用域是怎样的"></a>立即执行函数有什么用，作用域是怎样的</h2><p><strong>只有一个作用：创建一个独立的作用域。</strong></p><p><em>这个作用域里面的变量，外面访问不到（即避免「变量污染」）。</em></p><p><a href="https://zhuanlan.zhihu.com/p/22465092" target="_blank" >什么是立即执行函数？有什么作用？</a></p><h2 id="默认类型转化？"><a href="#默认类型转化？" class="headerlink" title="默认类型转化？"></a>默认类型转化？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 打印出 1let a &#x3D; ?if (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;  console.log(&#39;1&#39;)&#125;let a &#x3D; &#123;  i: 1,  [Symbol.toPrimitive]() &#123;    return this.i++  &#125;&#125;if (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) &#123;  console.log(&#39;hhhhhh&#39;)&#125;</code></pre><h2 id="require-和-import-的区别？"><a href="#require-和-import-的区别？" class="headerlink" title="require 和 import 的区别？"></a>require 和 import 的区别？</h2><h3 id="遵循规范："><a href="#遵循规范：" class="headerlink" title="遵循规范："></a>遵循规范：</h3><p>require 是 Commonjs 规范引入方式<br>import 是 ES6 的一个语法标准，如果要兼容浏览器的话必须转化成 ES5 的语法</p><h3 id="调用时间："><a href="#调用时间：" class="headerlink" title="调用时间："></a>调用时间：</h3><p>require 是运行时调用，所以 require 理论上可以运用在代码的任何地方<br>import 是编译时调用，所以必须放在文件开头</p><h3 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h3><p><em>require 是赋值过程。</em> module.exports 后面的内容是什么，require 的结果就是什么，比如对象、数字、字符串、函数等，然后再把 require 的结果赋值给某个变量，它相当于 module.exports 的传送门</p><p><em>import 是解构过程,</em> 但是目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require</p><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p><em>require() | exports 的用法</em><br>通过 require 引入基础数据类型时，属于复制该变量。通过 require 引入复杂数据类型时，属于浅拷贝该对象。</p><p><em>导入模块 require() 的用法</em><br>require() 函数用于在当前模块中加载别的模块。在函数内写入模块的路径即可（相对路径和绝对路径都行）</p><p><code>exports</code> 是 module.exports 的一种简写形式，不能直接给 exports 赋值。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><em>当直接给 module.exports 赋值时，exports 会失效。</em></p><p><a href="https://blog.csdn.net/wwf1225/article/details/124150794" target="_blank" >见</a></p><h2 id="src-和-href-的区别，并且-img-中的-srcset-的作用是什么"><a href="#src-和-href-的区别，并且-img-中的-srcset-的作用是什么" class="headerlink" title="src 和 href 的区别，并且 img 中的 srcset 的作用是什么"></a>src 和 href 的区别，并且 img 中的 srcset 的作用是什么</h2><h3 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h3><p><strong>总结：</strong></p><ul><li><code>资源</code>：src 会将资源加载到标签所在的位置；href 用来建立与当前元素&#x2F;文档之间的链接</li><li><code>元素</code>：src 用于 js 脚本、img、frame 等标签；href 用与 link、a 标签</li><li><code>阻塞</code>：src 会暂停其他资源的下载和处理，一般放到底部；link 会并行下载，不会阻塞</li></ul><p><em>src</em> 是指向外部资源的位置，</p><ul><li>指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，如 js 脚本，img 图⽚和 frame 等元素。</li><li><code>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在底部⽽不是头部</code>。</li></ul><p><em>href</em> 是指网络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。比如 link 标签。</p><h3 id="知道-img-的-srcset-的作用是什么？"><a href="#知道-img-的-srcset-的作用是什么？" class="headerlink" title="知道 img 的 srcset 的作用是什么？"></a>知道 img 的 srcset 的作用是什么？</h3><p>可以设计响应式图片,我们可以使⽤两个新的属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择正确的⼀个资源。<br><code>srcset 定义了我们允许浏览器选择的图像集，以及每个图像的⼤⼩</code>。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;img  src&#x3D;&quot;.&#x2F;img&#x2F;1.jpg&quot;  srcset&#x3D;&quot;.&#x2F;img&#x2F;2.jpg 500w, .&#x2F;img&#x2F;3.jpg 1000w, .&#x2F;img&#x2F;4.jpg 1200w&quot;  sizes&#x3D;&quot;(max-width:500px) 600px, (max-width: 1000px) 1500px&quot;  alt&#x3D;&quot;&quot;&#x2F;&gt;&lt;!-- 这里size中max-width:500px表示最大为500px时,将其当做600px,然后和srcset进行匹配 --&gt;</code></pre><p>————————————————<br>版权声明：本文为 CSDN 博主「卖菜的小白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_47450807/article/details/124214601">https://blog.csdn.net/weixin_47450807/article/details/124214601</a></p><h3 id="还有哪⼀个标签能起到跟-srcset-相似作⽤？"><a href="#还有哪⼀个标签能起到跟-srcset-相似作⽤？" class="headerlink" title="还有哪⼀个标签能起到跟 srcset 相似作⽤？"></a>还有哪⼀个标签能起到跟 srcset 相似作⽤？</h3><p><code>&lt;picture&gt;</code>元素通过包含零或多个<code>&lt;source&gt;</code>元素和一个<code>&lt;img&gt;</code>元素来为不同的显示&#x2F;设备场景提供图像版本。</p><p>浏览器会选择最匹配的⼦ <code>&lt;source&gt;</code> 元素，</p><p>如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的 URL。</p><p>然后，所选图像呈现在 <code>&lt;img&gt;</code> 元素占据的空间中。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;picture&gt;  &lt;source    srcset&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;surfer-240-200.jpg&quot;    media&#x3D;&quot;(min-width: 800px)&quot;  &#x2F;&gt;  &lt;img src&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;painted-hand-298-332.jpg&quot; &#x2F;&gt;&lt;&#x2F;picture&gt;</code></pre><h2 id="存在哪些常用的-meta-标签？"><a href="#存在哪些常用的-meta-标签？" class="headerlink" title="存在哪些常用的 meta 标签？"></a>存在哪些常用的 meta 标签？</h2><p><a href="/#/post/2022-07-17html" target="_blank" >有哪些常⽤的 meta 标签？</a></p><h2 id="客户端渲染-与-服务器渲染-的区别？"><a href="#客户端渲染-与-服务器渲染-的区别？" class="headerlink" title="客户端渲染 与 服务器渲染 的区别？"></a>客户端渲染 与 服务器渲染 的区别？</h2><p><strong>区分依据</strong></p><p>DOM 树在服务端生成还是在客户端生成的。</p><p><strong>服务端渲染的优点：</strong></p><p>1、尽量不占用前端的资源，前端这块耗时少，速度快。</p><p>2、有利于 SEO（search engine optimization）优化，因为在后端有完整的 html 页面，所以爬虫更容易爬取信息。</p><p><strong>服务端渲染的缺点：</strong></p><p>1、不利于前后端分离，开发的效率降低了。</p><p>2、对 html 的解析，对前端来说加快了速度，但是加大了服务器的压力。</p><p><strong>客户端渲染的优点：</strong></p><p>1、前后端分离，开发效率高。</p><p>2、用户体验更好，我们将网站做成 SPA（单页面应用）或者部分内容做成 SPA，当用户点击时，不会形成频繁的跳转。</p><p><strong>客户端渲染的缺点：</strong></p><p>1、前端响应速度慢，特别是首屏，这样用户是受不了的。</p><p>2、不利于 SEO 优化，因为爬虫不认识 SPA，所以它只是记录了一个页面。</p><p><strong>实际开发中</strong></p><p><a href="https://blog.csdn.net/weixin_47450807/category_11593058.html" target="_blank" >见</a></p><p><strong>如何选择</strong></p><p>我们要根据业务场景去选择渲染的方式。</p><p><strong>如果是企业级网站</strong>，主要功能是页面展示，它没有复杂的交互，并且需要良好的 SEO，那我们应该使用服务端渲染。</p><p><strong>如果是后台管理页面</strong>，交互性很强，它不需要考虑到 SEO，那我们应该使用客户端渲染。</p><p>具体使用哪种渲染方式也不是绝对的，<strong>现在很多网站使用服务端渲染和客户端渲染结合的方式</strong>：首屏使用服务端渲染，其他页面使用客户端渲染。这样可以保证首屏的加载速度，也完成了前后端分离。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.iamshuaidi.com/4997.html" target="_blank" > escape、encodeURI、encodeURIComponent 的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm</title>
      <link href="//post/2022-10-16gorm.html"/>
      <url>//post/2022-10-16gorm.html</url>
      
        <content type="html"><![CDATA[<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/go-gorm/gorm">https://github.com/go-gorm/gorm</a><img src="https://img.shields.io/github/stars/go-gorm/gorm?style=social" /></div><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><img src="http://t-blog-images.aijs.top/img/202210161834906.png" style="width: 500px;max-width:100%" /><h2 id="orm-解决的问题"><a href="#orm-解决的问题" class="headerlink" title="orm 解决的问题"></a>orm 解决的问题</h2><p><strong>专注于语言，弱化 sql</strong></p><img src="http://t-blog-images.aijs.top/img/202210161839151.png" /><img src="http://t-blog-images.aijs.top/img/202210161839663.png" /><h2 id="gorm-内部如何实现"><a href="#gorm-内部如何实现" class="headerlink" title="gorm 内部如何实现"></a>gorm 内部如何实现</h2><p>GORM 内部使用 SQL builder 生成 SQL。</p><p>对于每个操作，GORM 都会创建一个 <code>*gorm.Statement</code> 对象，所有的 GORM API 都是在为 <code>statement</code> 添加、修改 子句，最后，GORM 会根据这些子句生成 SQL</p><h3 id="自定义操作"><a href="#自定义操作" class="headerlink" title="自定义操作"></a>自定义操作</h3><h4 id="表名自定义"><a href="#表名自定义" class="headerlink" title="表名自定义"></a>表名自定义</h4><h4 id="外键自定义"><a href="#外键自定义" class="headerlink" title="外键自定义"></a>外键自定义</h4><h2 id="gorm-关系"><a href="#gorm-关系" class="headerlink" title="gorm 关系"></a>gorm 关系</h2><img src="http://t-blog-images.aijs.top/img/202210161838476.png" /><img src="http://t-blog-images.aijs.top/img/202210161838476.png" /><h2 id="gorm-First、Take、Last-区别"><a href="#gorm-First、Take、Last-区别" class="headerlink" title="gorm First、Take、Last 区别"></a>gorm First、Take、Last 区别</h2><ul><li><code>First</code> 获取第一条记录 <strong>（主键升序）</strong></li><li><code>Take</code> 获取一条记录，<strong>没有指定排序字段</strong></li><li><code>Last</code> 获取最后一条记录 <strong>（主键降序）</strong></li></ul><p><strong>First 和 Last 的使用有条件限制</strong></p><p>只有在目标 struct 是指针或者通过 db.Model() 指定 model 时，该方法才有效</p><p>如果相关 model 没有定义主键，那么将按 model 的第一个字段进行排序</p><h2 id="gorm-Find-与-Scan-的区别"><a href="#gorm-Find-与-Scan-的区别" class="headerlink" title="gorm Find 与 Scan 的区别"></a>gorm Find 与 Scan 的区别</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 超过一列的查询，应该使用 &#96;Scan&#96; 或者 &#96;Find&#96;，例如：db.Select(&quot;name&quot;, &quot;age&quot;).Scan(&amp;users)db.Select(&quot;name&quot;, &quot;age&quot;).Find(&amp;users)</code></pre><h2 id="gorm-Struct-与-Map-的区别"><a href="#gorm-Struct-与-Map-的区别" class="headerlink" title="gorm Struct 与 Map 的区别"></a>gorm Struct 与 Map 的区别</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><ul><li>都可做查询条件</li></ul><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ul><li>是否含有零值： struct 不包含零值查询条件 <code>&amp;User&#123;键值对&#125;</code>，map 包含零值查询条件 <code>map[string]interface&#123;&#125;&#123;键值对&#125;</code></li><li>指定查询 通过向 Where() 传入 struct 来指定查询条件的字段、值、表名（这个地方要注意拼接后的 sql 是否正常执行）</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;&#125;, &quot;name&quot;, &quot;Age&quot;).Find(&amp;users)&#x2F;&#x2F; SELECT * FROM users WHERE name &#x3D; &quot;jinzhu&quot; AND age &#x3D; 0;db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;&#125;, &quot;Age&quot;).Find(&amp;users)&#x2F;&#x2F; SELECT * FROM users WHERE age &#x3D; 0;</code></pre><h2 id="gorm-哪些类型语句可以作查询"><a href="#gorm-哪些类型语句可以作查询" class="headerlink" title="gorm 哪些类型语句可以作查询"></a>gorm 哪些类型语句可以作查询</h2><ul><li>主键</li><li>sql 语句</li><li>struct 结构体</li><li>map</li></ul><h2 id="gorm-哪些不会触发查询"><a href="#gorm-哪些不会触发查询" class="headerlink" title="gorm 哪些不会触发查询"></a>gorm 哪些不会触发查询</h2><ul><li>where 条件</li><li>not 条件</li><li>or 条件</li><li>select 选择</li><li>order 排序</li><li>limit &amp; offset (这里要注意 mysql 不支持 offset 单独使用)</li></ul><h2 id="gorm-哪些会触发查询"><a href="#gorm-哪些会触发查询" class="headerlink" title="gorm 哪些会触发查询"></a>gorm 哪些会触发查询</h2><ul><li>First 主键排序第一个</li><li>Last 主键排序最后一个</li><li>Take 无主键排序第一个</li><li>Find</li><li>Scan</li><li>Pluck 只返回单列</li><li>Count</li><li>批查询，一次查询多少个，允许多次查询</li><li>FirstOrInit 不更新数据库</li><li>FirstOrCreate 查不到更新数据库</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">var user Userdb.Debug().FirstOrInit(&amp;user, User&#123;Name: &quot;non_existing&quot;&#125;)db.Debug().FirstOrCreate(&amp;user, User&#123;Name: &quot;non_create&quot;&#125;)&#x2F;&#x2F; 第一次查询&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:29:38 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:431&#x2F;&#x2F; [7.830ms] [rows:0] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_existing&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:29:38 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:432&#x2F;&#x2F; [2.192ms] [rows:0] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_create&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:29:38 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:432&#x2F;&#x2F; [38.437ms] [rows:1] INSERT INTO &#96;users&#96; (&#96;name&#96;,&#96;age&#96;,&#96;email&#96;,&#96;birthday&#96;,&#96;member_number&#96;,&#96;activated_at&#96;,&#96;created_at&#96;,&#96;updated_at&#96;,&#96;active&#96;) VALUES (&#39;non_create&#39;,18,NULL,NULL,NULL,NULL,&#39;2022-10-20 10:29:38.008&#39;,&#39;2022-10-20 10:29:38.008&#39;,true)&#x2F;&#x2F; 第二次查询&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:30:07 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:431&#x2F;&#x2F; [8.054ms] [rows:0] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_existing&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1&#x2F;&#x2F;&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:30:07 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:432&#x2F;&#x2F; [0.680ms] [rows:1] SELECT * FROM &#96;users&#96; WHERE &#96;users&#96;.&#96;name&#96; &#x3D; &#39;non_create&#39; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1&#x2F;&#x2F; | 19 | galeone                           | NULL  |   18 | 2022-10-19 11:21:56.089 | NULL          | NULL         | 2022-10-19 11:21:56.090 | 2022-10-19 11:21:56.090 |      1 |&#x2F;&#x2F; | 20 | galeone                           | NULL  |   18 | 2022-10-19 11:26:50.011 | NULL          | NULL         | 2022-10-19 11:26:50.012 | 2022-10-19 11:26:50.012 |      1 |&#x2F;&#x2F; | 21 | 我要存false，不要默认true         | NULL  |   18 | 2022-10-19 11:28:52.852 | NULL          | NULL         | 2022-10-19 11:28:52.852 | 2022-10-19 11:28:52.852 |      0 |&#x2F;&#x2F; | 22 | non_create                        | NULL  |   18 | NULL                    | NULL          | NULL         | 2022-10-20 10:29:38.008 | 2022-10-20 10:29:38.008 |      1 |&#x2F;&#x2F; +----+-----------------------------------+-------+------+-------------------------+---------------+--------------+-------------------------+-------------------------+--------+&#x2F;&#x2F; 22 rows in set (0.01 sec)</code></pre><h2 id="mysql-offset-amp-limit-与-where-amp-limit"><a href="#mysql-offset-amp-limit-与-where-amp-limit" class="headerlink" title="mysql offset &amp; limit 与 where &amp;limit"></a>mysql offset &amp; limit 与 where &amp;limit</h2><img src="http://t-blog-images.aijs.top/img/202210201019656.svg" style="width:500px;max-width:100%" /><h2 id="gorm-Model-与-Table-的区别"><a href="#gorm-Model-与-Table-的区别" class="headerlink" title="gorm Model 与 Table 的区别"></a>gorm Model 与 Table 的区别</h2><p>GORM 允许扫描结果至 map[string]interface{} 或 []map[string]interface{}，此时别忘了指定 Model 或 Table</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">result :&#x3D; map[string]interface&#123;&#125;&#123;&#125;db.Model(&amp;User&#123;&#125;).First(&amp;result, &quot;id &#x3D; ?&quot;, 1)var results []map[string]interface&#123;&#125;db.Table(&quot;users&quot;).Find(&amp;results)</code></pre><h2 id="gorm-删除"><a href="#gorm-删除" class="headerlink" title="gorm 删除"></a>gorm 删除</h2><p>先了解这个，这个简单，不会太受 👊</p><ul><li>主键删除</li><li>条件删除</li><li>批量删除</li><li>全局删除(规避)</li><li>返回删除行的数据</li><li>软删除</li><li>查询被软删记录</li><li>永久删除</li><li>删除标记 Flag</li><li>勾子暂时跳过</li></ul><h3 id="主键删除"><a href="#主键删除" class="headerlink" title="主键删除"></a>主键删除</h3><ul><li>传入一个实例地址 <code>&amp;user</code></li><li>结构体：<code>db.Delete(&amp;User&#123;&#125;, string/number) // 结构体</code></li><li>批量主键 <code>db.Delete(&amp;users, []int&#123;1,2,3&#125;) // &amp;users</code></li></ul><h3 id="条件删除"><a href="#条件删除" class="headerlink" title="条件删除"></a>条件删除</h3><p><code>db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email)</code></p><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><ul><li>like 条件删除</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 这种叫啥，先where, 后删除db.Where(&quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;).Delete(&amp;Email&#123;&#125;)&#x2F;&#x2F; DELETE from emails where email LIKE &quot;%jinzhu%&quot;;&#x2F;&#x2F; 结构体删除？db.Delete(&amp;Email&#123;&#125;, &quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;)&#x2F;&#x2F; DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</code></pre><h3 id="全局删除-规避"><a href="#全局删除-规避" class="headerlink" title="全局删除(规避)"></a>全局删除(规避)</h3><ul><li>有条件，且查到的结果是全部数据 <code>Where 条件为&quot;true&quot; 都会清空</code></li><li>原生 sql</li><li>AllowGlobalUpdate</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Delete(&amp;User&#123;&#125;).Error &#x2F;&#x2F; gorm.ErrMissingWhereClause&#x2F;&#x2F; 会清表db.Where(&quot;1 &#x3D; 1&quot;).Delete(&amp;User&#123;&#125;)&#x2F;&#x2F; DELETE FROM &#96;users&#96; WHERE 1&#x3D;1&#x2F;&#x2F; Where条件为&quot;true&quot; 都会清空var users []Userdb.Debug().Where(&quot;1 &#x3D; 1&quot;).Find(&amp;users)&#x2F;&#x2F; [4.435ms] [rows:22] SELECT * FROM &#96;users&#96; WHERE 1 &#x3D; 1db.Debug().Where(&quot;true&quot;).Find(&amp;users)&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:54:53 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:459&#x2F;&#x2F; [3.312ms] [rows:22] SELECT * FROM &#96;users&#96; WHERE truedb.Debug().Where(&quot;2&#x3D;2&quot;).Find(&amp;users)&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 10:54:53 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:460&#x2F;&#x2F; [0.305ms] [rows:22] SELECT * FROM &#96;users&#96; WHERE 2&#x3D;2&#x2F;&#x2F; 会清表db.Exec(&quot;DELETE FROM users&quot;)&#x2F;&#x2F; DELETE FROM users&#x2F;&#x2F; 会清表db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: true&#125;).Delete(&amp;User&#123;&#125;)&#x2F;&#x2F; DELETE FROM users</code></pre><h3 id="返回删除行的数据"><a href="#返回删除行的数据" class="headerlink" title="返回删除行的数据"></a>返回删除行的数据</h3><p><code>Clauses(clause.Returning&#123;&#125;)</code> 仅适用于支持 Returning 的数据库</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 返回所有列var users []UserDB.Clauses(clause.Returning&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Delete(&amp;users)&#x2F;&#x2F; DELETE FROM &#96;users&#96; WHERE role &#x3D; &quot;admin&quot; RETURNING *&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 1, Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Salary: 100&#125;, &#123;ID: 2, Name: &quot;jinzhu.2&quot;, Role: &quot;admin&quot;, Salary: 1000&#125;&#125;&#x2F;&#x2F; 返回指定的列DB.Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: &quot;name&quot;&#125;, &#123;Name: &quot;salary&quot;&#125;&#125;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Delete(&amp;users)&#x2F;&#x2F; DELETE FROM &#96;users&#96; WHERE role &#x3D; &quot;admin&quot; RETURNING &#96;name&#96;, &#96;salary&#96;&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 0, Name: &quot;jinzhu&quot;, Role: &quot;&quot;, Salary: 100&#125;, &#123;ID: 0, Name: &quot;jinzhu.2&quot;, Role: &quot;&quot;, Salary: 1000&#125;&#125;</code></pre><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><ul><li>引入 <code>gorm.Model</code></li><li>不引入 <code>gorm.Model</code> ， <code>Deleted gorm.DeletedAt</code></li></ul><h3 id="查询被软删记录"><a href="#查询被软删记录" class="headerlink" title="查询被软删记录"></a>查询被软删记录</h3><p>Unscoped 译为： 未限定范围</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Unscoped().Where(&quot;age &#x3D; 20&quot;).Find(&amp;users)&#x2F;&#x2F; SELECT * FROM users WHERE age &#x3D; 20;</code></pre><h3 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Unscoped().Delete(&amp;order)&#x2F;&#x2F; DELETE FROM orders WHERE id&#x3D;10;</code></pre><h3 id="删除标记-Flag"><a href="#删除标记-Flag" class="headerlink" title="删除标记 Flag"></a>删除标记 Flag</h3><ul><li>unix 时间戳</li><li>1&#x2F;0 标记</li><li>混合模式</li></ul><h4 id="unix-时间戳"><a href="#unix-时间戳" class="headerlink" title="unix 时间戳"></a>unix 时间戳</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">type User struct &#123;  ID    uint  Name  string  &#x2F;&#x2F; DeletedAt *time.Time &#x2F;&#x2F; 我觉得吧还是使用这个，有删除时间，前端想展示就展示，不想展示就当false&#x2F;true处理  DeletedAt soft_delete.DeletedAt &#96;gorm:&quot;softDelete:milli&quot;&#96;  &#x2F;&#x2F; DeletedAt soft_delete.DeletedAt &#96;gorm:&quot;softDelete:nano&quot;&#96;&#125;&#x2F;&#x2F; 查询SELECT * FROM users WHERE deleted_at &#x3D; 0;&#x2F;&#x2F; 删除UPDATE users SET deleted_at &#x3D; &#x2F;* 当前毫秒、纳秒时间戳 *&#x2F; WHERE ID &#x3D; 1;</code></pre><h4 id="1-x2F-0-标记"><a href="#1-x2F-0-标记" class="headerlink" title="1&#x2F;0 标记"></a>1&#x2F;0 标记</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">import &quot;gorm.io&#x2F;plugin&#x2F;soft_delete&quot; &#x2F;&#x2F; 这里引入了个插件type User struct &#123;  ID    uint  Name  string  IsDel soft_delete.DeletedAt &#96;gorm:&quot;softDelete:flag&quot;&#96; &#x2F;&#x2F; 这里使用tab进行标记&#125;&#x2F;&#x2F; 查询SELECT * FROM users WHERE is_del &#x3D; 0;&#x2F;&#x2F; 删除UPDATE users SET is_del &#x3D; 1 WHERE ID &#x3D; 1;</code></pre><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">type User struct &#123;  ID        uint  Name      string  DeletedAt time.Time &#x2F;&#x2F; 这个  IsDel     soft_delete.DeletedAt &#96;gorm:&quot;softDelete:flag,DeletedAtField:DeletedAt&quot;&#96; &#x2F;&#x2F; 使用 &#96;1&#96; &#96;0&#96; 标识  &#x2F;&#x2F; IsDel     soft_delete.DeletedAt &#96;gorm:&quot;softDelete:,DeletedAtField:DeletedAt&quot;&#96; &#x2F;&#x2F; 使用 &#96;unix second&#96; 标识  &#x2F;&#x2F; IsDel     soft_delete.DeletedAt &#96;gorm:&quot;softDelete:nano,DeletedAtField:DeletedAt&quot;&#96; &#x2F;&#x2F; 使用 &#96;unix nano second&#96; 标识&#125;&#x2F;&#x2F; 查询SELECT * FROM users WHERE is_del &#x3D; 0; &#x2F;&#x2F; 一个查询条件就够了&#x2F;&#x2F; 在gorm中，这里有个问题，如果find，在不加Unscoped会不会查不到呢？ TODO:&#x2F;&#x2F; 删除，比较两个都要改啊，这么用的场景是什么UPDATE users SET is_del &#x3D; 1, deleted_at &#x3D; &#x2F;* current unix second *&#x2F; WHERE ID &#x3D; 1;</code></pre><h2 id="原生-SQL-和-SQL-生成器"><a href="#原生-SQL-和-SQL-生成器" class="headerlink" title="原生 SQL 和 SQL 生成器"></a>原生 SQL 和 SQL 生成器</h2><p>这个比较有用</p><ul><li><code>db.Raw</code> + Scan Raw：译为原生</li><li><code>db.Exec</code> Exec： 执行</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; db.Raw + Scandb.Raw(&quot;SELECT id, name, age FROM users WHERE name &#x3D; ?&quot;, 3).Scan(&amp;result)&#x2F;&#x2F; db.Execdb.Exec(&quot;UPDATE orders SET shipped_at &#x3D; ? WHERE id IN ?&quot;, time.Now(), []int64&#123;1, 2, 3&#125;)&#x2F;&#x2F; Exec with SQL Expressiondb.Exec(&quot;UPDATE users SET money &#x3D; ? WHERE name &#x3D; ?&quot;, gorm.Expr(&quot;money * ? + ?&quot;, 10000, 1), &quot;jinzhu&quot;)</code></pre><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>GORM 支持 sql.NamedArg、map[string]interface{}{} 或 struct 形式的命名参数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Where(&quot;name1 &#x3D; @name OR name2 &#x3D; @name&quot;, sql.Named(&quot;name&quot;, &quot;jinzhu&quot;)).Find(&amp;user) &#x2F;&#x2F; name 替换前面的@name&#x2F;&#x2F; SELECT * FROM &#96;users&#96; WHERE name1 &#x3D; &quot;jinzhu&quot; OR name2 &#x3D; &quot;jinzhu&quot;&#x2F;&#x2F; map[string]interface&#123;&#125;&#123;&#125;db.Where(&quot;name1 &#x3D; @name OR name2 &#x3D; @name&quot;, map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu2&quot;&#125;).First(&amp;result3)&#x2F;&#x2F; SELECT * FROM &#96;users&#96; WHERE name1 &#x3D; &quot;jinzhu2&quot; OR name2 &#x3D; &quot;jinzhu2&quot; ORDER BY &#96;users&#96;.&#96;id&#96; LIMIT 1&#x2F;&#x2F; struct 形式的命名参数type NamedArgument struct &#123;    Name string    Name2 string&#125;db.Raw(  &quot;SELECT * FROM users WHERE (name1 &#x3D; @Name AND name3 &#x3D; @Name) AND name2 &#x3D; @Name2&quot;,  NamedArgument&#123;Name: &quot;jinzhu&quot;, Name2: &quot;jinzhu2&quot;&#125;).Find(&amp;user)</code></pre><h3 id="预检-DryRun-模式"><a href="#预检-DryRun-模式" class="headerlink" title="预检 DryRun 模式"></a>预检 DryRun 模式</h3><p>生成语句不执行</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">stmt :&#x3D; db.Session(&amp;Session&#123;DryRun: true&#125;).First(&amp;user, 1).Statementstmt.SQL.String() &#x2F;&#x2F;&#x3D;&gt; SELECT * FROM &#96;users&#96; WHERE &#96;id&#96; &#x3D; $1 ORDER BY &#96;id&#96;stmt.Vars         &#x2F;&#x2F;&#x3D;&gt; []interface&#123;&#125;&#123;1&#125;</code></pre><h3 id="ToSql"><a href="#ToSql" class="headerlink" title="ToSql"></a>ToSql</h3><p>生成语句不执行</p><p>GORM 使用 database&#x2F;sql 的参数占位符来构建 SQL 语句，它会自动转义参数以避免 SQL 注入</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">sql :&#x3D; DB.ToSQL(func(tx *gorm.DB) *gorm.DB &#123;  return tx.Model(&amp;User&#123;&#125;).Where(&quot;id &#x3D; ?&quot;, 100).Limit(10).Order(&quot;age desc&quot;).Find(&amp;[]User&#123;&#125;)&#125;)sql &#x2F;&#x2F;&#x3D;&gt; SELECT * FROM &quot;users&quot; WHERE id &#x3D; 100 AND &quot;users&quot;.&quot;deleted_at&quot; IS NULL ORDER BY age desc LIMIT 10</code></pre><h3 id="Row-amp-Rows"><a href="#Row-amp-Rows" class="headerlink" title="Row &amp; Rows"></a>Row &amp; Rows</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 使用 GORM API 构建 SQLrow :&#x3D; db.Table(&quot;users&quot;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Select(&quot;name&quot;, &quot;age&quot;).Row()row.Scan(&amp;name, &amp;age)&#x2F;&#x2F; 使用原生 SQLrow :&#x3D; db.Raw(&quot;select name, age, email from users where name &#x3D; ?&quot;, &quot;jinzhu&quot;).Row()row.Scan(&amp;name, &amp;age, &amp;email)</code></pre><p>获取 <code>*sql.Rows</code> 结果</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 使用 GORM API 构建 SQLrows, err :&#x3D; db.Model(&amp;User&#123;&#125;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age, email&quot;).Rows()defer rows.Close()&#x2F;&#x2F; 数据情况，需要用到循环for rows.Next() &#123; &#x2F;&#x2F; 这个是while循环， 在go中为简化版for  rows.Scan(&amp;name, &amp;age, &amp;email)  &#x2F;&#x2F; 业务逻辑...&#125;&#x2F;&#x2F; 原生 SQLrows, err :&#x3D; db.Raw(&quot;select name, age, email from users where name &#x3D; ?&quot;, &quot;jinzhu&quot;).Rows()defer rows.Close()for rows.Next() &#123;  rows.Scan(&amp;name, &amp;age, &amp;email)  &#x2F;&#x2F; 业务逻辑...&#125;&#x2F;&#x2F; sql.rows 扫描至 modelrows, err :&#x3D; db.Model(&amp;User&#123;&#125;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Select(&quot;name, age, email&quot;).Rows() &#x2F;&#x2F; (*sql.Rows, error)defer rows.Close()var user Userfor rows.Next() &#123;  &#x2F;&#x2F; ScanRows 将一行扫描至 user  db.ScanRows(rows, &amp;user)  &#x2F;&#x2F; 业务逻辑...&#125;</code></pre><h3 id="单连接-多操作"><a href="#单连接-多操作" class="headerlink" title="单连接,多操作"></a>单连接,多操作</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 在一条 tcp DB 连接中运行多条 SQL (不是事务)db.Connection(func(tx *gorm.DB) error &#123;  tx.Exec(&quot;SET my.role &#x3D; ?&quot;, &quot;admin&quot;)  tx.First(&amp;User&#123;&#125;)&#125;)</code></pre><h3 id="子句"><a href="#子句" class="headerlink" title="子句"></a>子句</h3><p>TODO： 先不学</p><h3 id="StatementModifier-语句修改器"><a href="#StatementModifier-语句修改器" class="headerlink" title="StatementModifier 语句修改器"></a>StatementModifier 语句修改器</h3><p>TODO： 先不学</p><hr/><h2 id="gorm-更新"><a href="#gorm-更新" class="headerlink" title="gorm 更新"></a>gorm 更新</h2><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><p>Save <strong>会保存所有的字段，即使字段是零值</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.First(&amp;user)user.Name &#x3D; &quot;jinzhu 2&quot;user.Age &#x3D; 100db.Save(&amp;user)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;jinzhu 2&#39;, age&#x3D;100, birthday&#x3D;&#39;2016-01-01&#39;, updated_at &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;</code></pre><h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><p>这里直接用的键值对</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 条件更新db.Model(&amp;User&#123;&#125;).Where(&quot;active &#x3D; ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE active&#x3D;true;&#x2F;&#x2F; User 的 ID 是 &#96;111&#96;db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;&#x2F;&#x2F; 根据条件和 model 的值进行更新db.Model(&amp;user).Where(&quot;active &#x3D; ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111 AND active&#x3D;true;</code></pre><h3 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h3><ul><li><code>struct</code> 更新非零值字段</li><li><code>map[string]interface&#123;&#125;</code></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 根据 &#96;struct&#96; 更新属性，只会更新非零值的字段db.Model(&amp;user).Updates(User&#123;Name: &quot;hello&quot;, Age: 18, Active: false&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18, updated_at &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE id &#x3D; 111;&#x2F;&#x2F; 根据 &#96;map&#96; 更新属性db.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18, active&#x3D;false, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;</code></pre><h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><ul><li>Select 选择字段</li><li>Omit 剔除字段</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 使用 Map 进行 Select&#x2F;&#x2F; User&#39;s ID is &#96;111&#96;:&#x2F;&#x2F;只更新namedb.Model(&amp;user).Select(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39; WHERE id&#x3D;111;&#x2F;&#x2F; 不更新namedb.Model(&amp;user).Omit(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)&#x2F;&#x2F; UPDATE users SET age&#x3D;18, active&#x3D;false, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;&#x2F;&#x2F; 使用 Struct 进行 Select（会 select 零值的字段） 这么特殊的吗？哦，大概晓得了： 默认是不更新，但Select要更新db.Model(&amp;user).Select(&quot;Name&quot;, &quot;Age&quot;).Updates(User&#123;Name: &quot;new_name&quot;, Age: 0&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;new_name&#39;, age&#x3D;0 WHERE id&#x3D;111;&#x2F;&#x2F; Select 所有字段（查询包括零值字段的所有字段）&#x2F;&#x2F; 还支持 *呢db.Model(&amp;user).Select(&quot;*&quot;).Update(User&#123;Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Age: 0&#125;)&#x2F;&#x2F; Select 除 Role 外的所有字段（包括零值字段的所有字段）&#x2F;&#x2F; 组合使用db.Model(&amp;user).Select(&quot;*&quot;).Omit(&quot;Role&quot;).Update(User&#123;Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Age: 0&#125;)</code></pre><h3 id="更新-Hook"><a href="#更新-Hook" class="headerlink" title="更新 Hook"></a>更新 Hook</h3><p>勾子无非就是校验和改变</p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>不指定主键就是批更新</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 根据 struct 更新&#x2F;&#x2F; 给gorm个模型，让它来找表db.Model(User&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE role &#x3D; &#39;admin&#39;;&#x2F;&#x2F; 根据 map 更新&#x2F;&#x2F; db.Table 选择某个表db.Table(&quot;users&quot;).Where(&quot;id IN ?&quot;, []int&#123;10, 11&#125;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE id IN (10, 11);</code></pre><h3 id="阻止全局更新"><a href="#阻止全局更新" class="headerlink" title="阻止全局更新"></a>阻止全局更新</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;jinzhu&quot;).Error &#x2F;&#x2F; gorm.ErrMissingWhereClause&#x2F;&#x2F; .Where(&quot;true&quot;) 模式db.Model(&amp;User&#123;&#125;).Where(&quot;1 &#x3D; 1&quot;).Update(&quot;name&quot;, &quot;jinzhu&quot;)&#x2F;&#x2F; UPDATE users SET &#96;name&#96; &#x3D; &quot;jinzhu&quot; WHERE 1&#x3D;1&#x2F;&#x2F; 原生db.Exec(&quot;UPDATE users SET name &#x3D; ?&quot;, &quot;jinzhu&quot;)&#x2F;&#x2F; UPDATE users SET name &#x3D; &quot;jinzhu&quot;&#x2F;&#x2F; AllowGlobalUpdatedb.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: true&#125;).Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;jinzhu&quot;)&#x2F;&#x2F; UPDATE users SET &#96;name&#96; &#x3D; &quot;jinzhu&quot;</code></pre><h3 id="更新的受影响数"><a href="#更新的受影响数" class="headerlink" title="更新的受影响数"></a>更新的受影响数</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 通过 &#96;RowsAffected&#96; 得到更新的记录数result :&#x3D; db.Model(User&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE role &#x3D; &#39;admin&#39;;result.RowsAffected &#x2F;&#x2F; 更新的记录数result.Error        &#x2F;&#x2F; 更新的错误</code></pre><h3 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h3><h3 id="使用-SQL-表达式更新"><a href="#使用-SQL-表达式更新" class="headerlink" title="使用 SQL 表达式更新"></a>使用 SQL 表达式更新</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; product 的 ID 是 &#96;3&#96;db.Model(&amp;product).Update(&quot;price&quot;, gorm.Expr(&quot;price * ? + ?&quot;, 2, 100))&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;price&quot; &#x3D; price * 2 + 100, &quot;updated_at&quot; &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE &quot;id&quot; &#x3D; 3;db.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;&quot;price&quot;: gorm.Expr(&quot;price * ? + ?&quot;, 2, 100)&#125;)&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;price&quot; &#x3D; price * 2 + 100, &quot;updated_at&quot; &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE &quot;id&quot; &#x3D; 3;db.Model(&amp;product).UpdateColumn(&quot;quantity&quot;, gorm.Expr(&quot;quantity - ?&quot;, 1))&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;quantity&quot; &#x3D; quantity - 1 WHERE &quot;id&quot; &#x3D; 3;db.Model(&amp;product).Where(&quot;quantity &gt; 1&quot;).UpdateColumn(&quot;quantity&quot;, gorm.Expr(&quot;quantity - ?&quot;, 1))&#x2F;&#x2F; UPDATE &quot;products&quot; SET &quot;quantity&quot; &#x3D; quantity - 1 WHERE &quot;id&quot; &#x3D; 3 AND quantity &gt; 1;&#x2F;&#x2F; 将链式调用拆解  &#x2F;&#x2F; db.Model(&amp;product) 选表  &#x2F;&#x2F; .UpdateColumn(&quot;quantity&quot;, &#x2F;&#x2F; 更新操作  &#x2F;&#x2F; .Where(&quot;quantity &gt; 1&quot;) &#x2F;&#x2F; 判断条件&#x2F;&#x2F; 我有个疑问：gorm 是如何进行链式调用而保证顺序的？&#x2F;&#x2F; func (db *DB) Model(value interface&#123;&#125;) (tx *DB) &#123;&#x2F;&#x2F; tx &#x3D; db.getInstance()&#x2F;&#x2F; tx.Statement.Model &#x3D; value&#x2F;&#x2F; return&#x2F;&#x2F; &#125;&#x2F;&#x2F; 把所有的.节点 都放到Statement上，UpdateColumn是执行 tx.callbacks.Update().Execute， 最后怎么组织的 Execute执行了啥？往下好像看不懂了&#x2F;&#x2F; func (db *DB) UpdateColumn(column string, value interface&#123;&#125;) (tx *DB) &#123;&#x2F;&#x2F; tx &#x3D; db.getInstance()&#x2F;&#x2F; tx.Statement.Dest &#x3D; map[string]interface&#123;&#125;&#123;column: value&#125;&#x2F;&#x2F; tx.Statement.SkipHooks &#x3D; true&#x2F;&#x2F; return tx.callbacks.Update().Execute(tx)&#x2F;&#x2F; &#125;&#x2F;&#x2F; for _, f :&#x3D; range p.fns &#123; &#x2F;&#x2F; p *processor&#x2F;&#x2F; f(db)&#x2F;&#x2F; &#125;</code></pre><p>TODO:这里有个自定义数据类型，在下面章节里有，先跳过</p><h3 id="根据子查询进行更新"><a href="#根据子查询进行更新" class="headerlink" title="根据子查询进行更新"></a>根据子查询进行更新</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">db.Model(&amp;user).Update(  &quot;company_name&quot;,  db.Model(&amp;Company&#123;&#125;).Select(&quot;name&quot;).Where(&quot;companies.id &#x3D; users.company_id&quot;))&#x2F;&#x2F; UPDATE &quot;users&quot; SET &quot;company_name&quot; &#x3D; (SELECT name FROM companies WHERE companies.id &#x3D; users.company_id);&#x2F;&#x2F; 表明是复数db.Table(&quot;users as u&quot;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Update(  &quot;company_name&quot;,  db.Table(&quot;companies as c&quot;).Select(&quot;name&quot;).Where(&quot;c.id &#x3D; u.company_id&quot;))db.Table(&quot;users as u&quot;).Where(&quot;name &#x3D; ?&quot;, &quot;jinzhu&quot;).Updates(map[string]interface&#123;&#125;&#123;  &quot;company_name&quot;: db.Table(&quot;companies as c&quot;).Select(&quot;name&quot;).Where(&quot;c.id &#x3D; u.company_id&quot;)&#125;)</code></pre><h3 id="不使用-Hook-和时间追踪"><a href="#不使用-Hook-和时间追踪" class="headerlink" title="不使用 Hook 和时间追踪"></a>不使用 Hook 和时间追踪</h3><p>官方文档上是错误的， 没有主键，没有查询条件，不会更新<br>注意：下面这几个 <em>不追踪更新时间</em></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var user Userdb.Debug().Model(&amp;user).Where(&quot;id &#x3D; ?&quot;,1).UpdateColumn(&quot;name&quot;, &quot;hello&quot;)&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 14:52:17 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:468 WHERE conditions required&#x2F;&#x2F; [0.496ms] [rows:0] UPDATE &#96;users&#96; SET &#96;name&#96;&#x3D;&#39;hello&#39; where &#96;id&#96;&#x3D;1&#x2F;&#x2F; 更新多个列db.Model(&amp;user).Where(&quot;id &#x3D; ?&quot;,1).UpdateColumns(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 14:53:09 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:473 WHERE conditions required&#x2F;&#x2F; [0.567ms] [rows:0] UPDATE &#96;users&#96; SET &#96;name&#96;&#x3D;&#39;hello&#39;,&#96;age&#96;&#x3D;18 where &#96;id&#96;&#x3D;1&#x2F;&#x2F; 更新选中的列db.Model(&amp;user).Select(&quot;name&quot;, &quot;age&quot;).Where(&quot;id &#x3D; ?&quot;,1).UpdateColumns(User&#123;Name: &quot;hello&quot;, Age: 0&#125;)&#x2F;&#x2F; 2022&#x2F;10&#x2F;20 14:53:59 &#x2F;Users&#x2F;haotian&#x2F;haotian&#x2F;github&#x2F;go&#x2F;learn-gorm&#x2F;crud&#x2F;r.go:478 WHERE conditions required&#x2F;&#x2F; [0.539ms] [rows:0] UPDATE &#96;users&#96; SET &#96;name&#96;&#x3D;&#39;hello&#39;,&#96;age&#96;&#x3D;0 where &#96;id&#96;&#x3D;1</code></pre><h3 id="返回修改行的数据"><a href="#返回修改行的数据" class="headerlink" title="返回修改行的数据"></a>返回修改行的数据</h3><p>这个有用，可以给前端同步数据，而不需要前端再发个请求到后端查询数据，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 返回所有列var users []UserDB.Model(&amp;users).Clauses(clause.Returning&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Update(&quot;salary&quot;, gorm.Expr(&quot;salary * ?&quot;, 2))&#x2F;&#x2F; UPDATE &#96;users&#96; SET &#96;salary&#96;&#x3D;salary * 2,&#96;updated_at&#96;&#x3D;&quot;2021-10-28 17:37:23.19&quot; WHERE role &#x3D; &quot;admin&quot; RETURNING *&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 1, Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Salary: 100&#125;, &#123;ID: 2, Name: &quot;jinzhu.2&quot;, Role: &quot;admin&quot;, Salary: 1000&#125;&#125;&#x2F;&#x2F; 返回指定的列DB.Model(&amp;users).Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: &quot;name&quot;&#125;, &#123;Name: &quot;salary&quot;&#125;&#125;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Update(&quot;salary&quot;, gorm.Expr(&quot;salary * ?&quot;, 2))&#x2F;&#x2F; UPDATE &#96;users&#96; SET &#96;salary&#96;&#x3D;salary * 2,&#96;updated_at&#96;&#x3D;&quot;2021-10-28 17:37:23.19&quot; WHERE role &#x3D; &quot;admin&quot; RETURNING &#96;name&#96;, &#96;salary&#96;&#x2F;&#x2F; users &#x3D;&gt; []User&#123;&#123;ID: 0, Name: &quot;jinzhu&quot;, Role: &quot;&quot;, Salary: 100&#125;, &#123;ID: 0, Name: &quot;jinzhu.2&quot;, Role: &quot;&quot;, Salary: 1000&#125;&#125;</code></pre><h3 id="检查字段是否有变更？"><a href="#检查字段是否有变更？" class="headerlink" title="检查字段是否有变更？"></a>检查字段是否有变更？</h3><h3 id="在-Update-时修改值"><a href="#在-Update-时修改值" class="headerlink" title="在 Update 时修改值"></a>在 Update 时修改值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 给谁加的勾子？ 给user?,加勾子都加载字段上的吗func (user *User) BeforeSave(tx *gorm.DB) (err error) &#123;  if pw, err :&#x3D; bcrypt.GenerateFromPassword(user.Password, 0); err &#x3D;&#x3D; nil &#123;    tx.Statement.SetColumn(&quot;EncryptedPassword&quot;, pw)  &#125;  if tx.Statement.Changed(&quot;Code&quot;) &#123;    user.Age +&#x3D; 20    tx.Statement.SetColumn(&quot;Age&quot;, user.Age)  &#125;&#125;db.Model(&amp;user).Update(&quot;Name&quot;, &quot;jinzhu&quot;)</code></pre><hr/><h2 id="gorm-安全"><a href="#gorm-安全" class="headerlink" title="gorm 安全"></a>gorm 安全</h2><h3 id="gorm-SQL-注入"><a href="#gorm-SQL-注入" class="headerlink" title="gorm SQL 注入"></a>gorm SQL 注入</h3><p><strong>应对</strong></p><p>GORM 使用 database&#x2F;sql 的<em>参数占位符来构造 SQL 语句，这可以自动转义参数</em>，避免 SQL 注入数据</p><h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><h3 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h3><p>当通过用户输入的整形主键检索记录时，你应该对变量进行类型检查。</p><h3 id="避免-Sql-注入的原则："><a href="#避免-Sql-注入的原则：" class="headerlink" title="避免 Sql 注入的原则："></a>避免 Sql 注入的原则：</h3><ul><li>避免 SQL 注入的一般原则是，不信任用户提交的数据。</li><li>您可以进行白名单验证来测试用户的输入是否为已知安全的、已批准、已定义的输入 TODO: 如何实现？</li><li>在使用用户的输入时，仅将它们作为参数。</li></ul><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><h2 id="零值-默认值"><a href="#零值-默认值" class="headerlink" title="零值 || 默认值"></a>零值 || 默认值</h2><ul><li>方式 1: 指针</li><li>方式 2: sql 结构体</li></ul><h2 id="map-string-interface-啥意思？"><a href="#map-string-interface-啥意思？" class="headerlink" title="map[string]interface{}{}啥意思？"></a><code>map[string]interface&#123;&#125;&#123;&#125;</code>啥意思？</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">.Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)</code></pre><h2 id="软删除后查询全量数据"><a href="#软删除后查询全量数据" class="headerlink" title="软删除后查询全量数据"></a>软删除后查询全量数据</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Unscoped 翻译为：无范围&#x2F;&#x2F; Unscoped 方法可以查询被软删除的记录db.Unscoped().Where(&quot;age &#x3D; 20&quot;).Find(&amp;users)&#x2F;&#x2F;&#x2F;&#x2F; SELECT * FROM users WHERE age &#x3D; 20;</code></pre><h2 id="实战学习"><a href="#实战学习" class="headerlink" title="实战学习"></a>实战学习</h2><p>找个项目瞅瞅，</p><p><a href="https://github.com/Q1mi/bubble" target="_blank" >见</a></p><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><img src="http://t-blog-images.aijs.top/img/202210162226393.png" /><h2 id="博客收集"><a href="#博客收集" class="headerlink" title="博客收集"></a>博客收集</h2><p><a href="https://www.liwenzhou.com/posts/Go/golang-menu/" target="_blank" >liwenzhou.com golang 菜单</a></p><p><a href="https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-0-0" target="_blank" >liwenzhou.com 创建</a></p><p><a href="https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-1-3" target="_blank" >liwenzhou.com 查询</a></p><p><a href="https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-3-4" target="_blank" >liwenzhou.com 更新</a></p><p><a href="https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-4-8" target="_blank" >liwenzhou.com 删除</a></p><p><a href="https://www.liwenzhou.com/posts/Go/gorm_crud/#autoid-1-2-11" target="_blank" >liwenzhou.com 链式调用</a></p><p><a href="https://www.bilibili.com/video/BV1gJ411p7xC?p=19" target="_blank" >B 站视频 gorm</a></p><p><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/Golang/Gin%E6%A1%86%E6%9E%B6/" target="_blank" >课程代码</a></p><p>学高级的都要钱，呜呜～，有钱真好</p><p><a href="https://study.163.com/course/introduction.htm?courseId=1210171207#/courseDetail?tab=1" target="_blank" >哪位老哥有买此课程，借阅,三克油了</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B站播放速度修改</title>
      <link href="//post/2022-10-16Bplayer-rate.html"/>
      <url>//post/2022-10-16Bplayer-rate.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>B 站视频播放速度可选项太少了，有的视频被转化的语速快，有的视频被转化的特慢，不能忍～</p><h2 id="更改-dom"><a href="#更改-dom" class="headerlink" title="更改 dom"></a>更改 dom</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;ul class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu&quot;&gt;  &lt;!-- 增加个三倍速选项，B站没做校验，所以3倍速也是有效的 --&gt;  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;3&quot;&gt;3.0x&lt;&#x2F;li&gt;  &lt;li    class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item bpx-state-active&quot;    data-value&#x3D;&quot;2&quot;  &gt;    2.0x  &lt;&#x2F;li&gt;  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;1.5&quot;&gt;1.5x&lt;&#x2F;li&gt;  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;1.25&quot;&gt;    1.25x  &lt;&#x2F;li&gt;  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;1&quot;&gt;1.0x&lt;&#x2F;li&gt;  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;0.75&quot;&gt;    0.75x  &lt;&#x2F;li&gt;  &lt;li class&#x3D;&quot;bpx-player-ctrl-playbackrate-menu-item&quot; data-value&#x3D;&quot;0.5&quot;&gt;0.5x&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><img src="http://t-blog-images.aijs.top/img/202210161559283.png" /><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p><video controls src="http://t-blog-images.aijs.top/img/1665906886540.mp4" style="width: 600px;max-width: 100%"></video></p><h2 id="书写脚本"><a href="#书写脚本" class="headerlink" title="书写脚本"></a>书写脚本</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var value &#x3D; &quot;4&quot;; &#x2F;&#x2F; 几倍速var pvaldoms1 &#x3D; document.getElementsByClassName(  &quot;bpx-player-ctrl-playbackrate-menu&quot;)[0];var newItemDom &#x3D; document.createElement(&quot;li&quot;);newItemDom.className &#x3D; &quot;bpx-player-ctrl-playbackrate-menu-item&quot;;newItemDom.dataset.value &#x3D; value;newItemDom.innerHTML &#x3D; &#96;$&#123;value&#125;.0x&#96;;pvaldoms1.prepend(newItemDom);</code></pre><h2 id="更改结果"><a href="#更改结果" class="headerlink" title="更改结果"></a>更改结果</h2><img src="http://t-blog-images.aijs.top/img/202210161617642.png" />]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin Examples</title>
      <link href="//post/2022-10-16gin-examples.html"/>
      <url>//post/2022-10-16gin-examples.html</url>
      
        <content type="html"><![CDATA[<h2 id="运行记录"><a href="#运行记录" class="headerlink" title="运行记录"></a>运行记录</h2><p>[GIN-debug] [WARNING] Running in “debug” mode. Switch to “release” mode in production.</p><p>生产环境切到 release 模式</p><p>[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.</p><p>不安全警告</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">[Running] go run &quot;&#x2F;Users&#x2F;chenhailong&#x2F;code&#x2F;github&#x2F;go&#x2F;gin-examples&#x2F;app-engine&#x2F;go11x&#x2F;hello.go&quot;2022&#x2F;10&#x2F;16 07:50:16 Defaulting to port 80802022&#x2F;10&#x2F;16 07:50:16 Listening on port 8080[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production. - using env:export GIN_MODE&#x3D;release - using code:gin.SetMode(gin.ReleaseMode)[GIN-debug] GET    &#x2F;                         --&gt; main.main.func1 (1 handlers)[GIN-debug] GET    &#x2F;ping                     --&gt; main.main.func2 (1 handlers)[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.Please check https:&#x2F;&#x2F;pkg.go.dev&#x2F;github.com&#x2F;gin-gonic&#x2F;gin#readme-don-t-trust-all-proxies for details.[GIN-debug] Listening and serving HTTP on :8080</code></pre><h2 id="报红"><a href="#报红" class="headerlink" title="报红"></a>报红</h2><img src="http://t-blog-images.aijs.top/img/202210161459465.png" /><h2 id="路由匹配错误"><a href="#路由匹配错误" class="headerlink" title="路由匹配错误"></a>路由匹配错误</h2><img src="http://t-blog-images.aijs.top/img/202210161502996.png" />]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go vscode</title>
      <link href="//post/2022-10-15vscode.html"/>
      <url>//post/2022-10-15vscode.html</url>
      
        <content type="html"><![CDATA[<h2 id="go-配置代理"><a href="#go-配置代理" class="headerlink" title="go 配置代理"></a>go 配置代理</h2><pre class="line-numbers language-none"><code class="language-none">♠ &#x2F;Users&#x2F;chenhailong $ go versiongo version go1.19.2 darwin&#x2F;amd64♠ &#x2F;Users&#x2F;chenhailong $ go install golang.org&#x2F;x&#x2F;tools&#x2F;gopls@latestgo: golang.org&#x2F;x&#x2F;tools&#x2F;gopls@latest: module golang.org&#x2F;x&#x2F;tools&#x2F;gopls: Get &quot;https:&#x2F;&#x2F;proxy.golang.org&#x2F;golang.org&#x2F;x&#x2F;tools&#x2F;gopls&#x2F;@v&#x2F;list&quot;: dial tcp 172.217.163.49:443: i&#x2F;o timeout♠ &#x2F;Users&#x2F;chenhailong $ go envGO111MODULE&#x3D;&quot;&quot;GOARCH&#x3D;&quot;amd64&quot;GOBIN&#x3D;&quot;&quot;GOCACHE&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;Library&#x2F;Caches&#x2F;go-build&quot;GOENV&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;Library&#x2F;Application Support&#x2F;go&#x2F;env&quot;GOEXE&#x3D;&quot;&quot;GOEXPERIMENT&#x3D;&quot;&quot;GOFLAGS&#x3D;&quot;&quot;GOHOSTARCH&#x3D;&quot;amd64&quot;GOHOSTOS&#x3D;&quot;darwin&quot;GOINSECURE&#x3D;&quot;&quot;GOMODCACHE&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;go&#x2F;pkg&#x2F;mod&quot;GONOPROXY&#x3D;&quot;&quot;GONOSUMDB&#x3D;&quot;&quot;GOOS&#x3D;&quot;darwin&quot;GOPATH&#x3D;&quot;&#x2F;Users&#x2F;chenhailong&#x2F;go&quot;GOPRIVATE&#x3D;&quot;&quot;GOPROXY&#x3D;&quot;https:&#x2F;&#x2F;proxy.golang.org,direct&quot;GOROOT&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&quot;GOSUMDB&#x3D;&quot;sum.golang.org&quot;GOTMPDIR&#x3D;&quot;&quot;GOTOOLDIR&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&#x2F;pkg&#x2F;tool&#x2F;darwin_amd64&quot;GOVCS&#x3D;&quot;&quot;GOVERSION&#x3D;&quot;go1.19.2&quot;GCCGO&#x3D;&quot;gccgo&quot;GOAMD64&#x3D;&quot;v1&quot;AR&#x3D;&quot;ar&quot;CC&#x3D;&quot;clang&quot;CXX&#x3D;&quot;clang++&quot;CGO_ENABLED&#x3D;&quot;1&quot;GOMOD&#x3D;&quot;&#x2F;dev&#x2F;null&quot;GOWORK&#x3D;&quot;&quot;CGO_CFLAGS&#x3D;&quot;-g -O2&quot;CGO_CPPFLAGS&#x3D;&quot;&quot;CGO_CXXFLAGS&#x3D;&quot;-g -O2&quot;CGO_FFLAGS&#x3D;&quot;-g -O2&quot;CGO_LDFLAGS&#x3D;&quot;-g -O2&quot;PKG_CONFIG&#x3D;&quot;pkg-config&quot;GOGCCFLAGS&#x3D;&quot;-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length&#x3D;0 -fdebug-prefix-map&#x3D;&#x2F;var&#x2F;folders&#x2F;qk&#x2F;bj_mbvq54zs663fjmkykq4cc0000gn&#x2F;T&#x2F;go-build1271542645&#x3D;&#x2F;tmp&#x2F;go-build -gno-record-gcc-switches -fno-common&quot;♠ &#x2F;Users&#x2F;chenhailong $</code></pre><p><a href="https://goproxy.cn/" target="_blank" >goproxy</a></p><p>打开你的终端并执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go env -w GO111MODULE&#x3D;on$ go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</code></pre><p><a href="https://pkg.go.dev/golang.org/x/tools/gopls#readme-installation" target="_blank" >gopls 安装</a></p><pre class="line-numbers language-none"><code class="language-none">go install golang.org&#x2F;x&#x2F;tools&#x2F;gopls@latest</code></pre><!-- <img src="go install golang.org/x/tools/gopls@latest" /> --><!-- **macOS 或 Linux** --><!-- 打开你的终端并执行```shell$ export GO111MODULE=on$ export GOPROXY=https://goproxy.cn``` --><img src="http://t-blog-images.aijs.top/img/202210160025921.png" /><h2 id="code-run"><a href="#code-run" class="headerlink" title="code run"></a>code run</h2><img src="http://t-blog-images.aijs.top/img/202210160751306.png" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://goproxy.cn/" target="_blank" >https://goproxy.cn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Gin</title>
      <link href="//post/2022-10-15gin.html"/>
      <url>//post/2022-10-15gin.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>巩固 go 语言学习</li><li>听说很多大公司用 go 来开发服务器，我特来看看</li><li>了解 go web 开发</li></ul><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><p>选这个框架原因如下：</p><p><strong>社区活跃</strong></p><ul><li>Go 官网推荐<a href="https://golang.google.cn/doc/tutorial/web-service-gin" target="_blank" >Tutorial: Developing a RESTful API with Go and Gin</a></li><li>github 上 star 多 <div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a><img src="https://img.shields.io/github/stars/gin-gonic/gin?style=social" /></div></li><li>Gin 官网支持多语言有中文版的文档，本着爱国，我还是爱看<a href="https://gin-gonic.com/zh-cn/" target="_blank" >中文文档</a>的</li><li>B 站 “七米” <a href="https://www.bilibili.com/video/BV1gJ411p7xC" target="_blank" >视频</a> <a href="/#/post/2022-10-16Bplayer-rate" target="_blank" >播放速度太慢？帮你解决</a></li></ul><p><strong>Gin 官网简介很厉害的样子</strong></p><p>Gin Web Framework</p><p>The fastest full-featured web framework for Go. Crystal clear.</p><p>What is Gin?</p><p>Gin is a web framework written in Golang.</p><p>It features a <a href="https://segmentfault.com/q/1010000041982845" target="_blank" >Martini-like API</a>, but with performance up to 40 times faster than Martini.</p><p>If you need performance and productivity, you will love Gin.</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>快： 基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。 <a href="https://github.com/julienschmidt/httprouter" target="_blank" >httprouter</a></li><li>中间件：传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。</li><li>Crash 处理： Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！</li><li>JSON 验证： Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。</li><li>路由组： Gin 帮助您更好地组织您的路由，例如，按照需要授权和不需要授权和不同 API 版本进行分组。此外，路由分组可以无限嵌套而不降低性能。</li><li>错误管理：Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。</li><li>内置渲染：Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。</li><li>扩展性好： 新建一个中间件非常简单<small>（不信能比 Django 中间件还简单，你是来捣乱的吧～）</small></li></ul><h2 id="参考事例"><a href="#参考事例" class="headerlink" title="参考事例"></a>参考事例</h2><p><a href="https://gin-gonic.com/zh-cn/docs/examples/" target="_blank" >见</a></p><p>这么直接，也没个 API 文档，害的我找了半天没找到～</p><h2 id="web-服务组成"><a href="#web-服务组成" class="headerlink" title="web 服务组成"></a>web 服务组成</h2><p>根据以往经验服务端涵盖如下内容：</p><ul><li>启动个端口监听请求</li><li>静态资源路径</li><li>GET、POST、Delete、PUT、PATCH、OPTIONS 等请求处理</li><li>参数接收 urlparams、body</li><li>返回渲染 html</li><li>返回 JSON</li><li>用户登录</li><li>登录信息管理 cookie 、 redis 、session</li><li>身份校验、权限校验</li><li>日志信息</li><li>数据持久化 DB 系列、ORM</li></ul><p>还是看<a href="https://github.com/gin-gonic/gin" target="_blank" >README.md</a>比较方便，官网要是能好好写写就好了</p><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><p><a href="/#/post/2022-10-15vscode" target="_blank" >相关配置</a></p><h2 id="Gin-API-文档"><a href="#Gin-API-文档" class="headerlink" title="Gin API 文档"></a>Gin API 文档</h2><p><strong>找不到 API 文档</strong>，有 examples 文档和 examples 项目，不像 nestjs、Django 文档一堆</p><p><strong>这两天学习总结到</strong>：大致了解 gin 的相关东西，真正开发时候会有语法提示，也可以点进去看看源码，这样也就了解了对应接口&#x2F;结构体的 API</p><p><strong>睡了一觉略有所感</strong>：中午看了点视频，又睡了一觉，醒来一想为什么没有 API 文档,或许是作者认为太简单了，根本不需要，我觉得是这样</p><p><strong>闲逛 gorm 发现了 Gin 的 api 文档了</strong>：<a href="https://pkg.go.dev/github.com/gin-gonic/gin" target="_blank" >https://pkg.go.dev/github.com/gin-gonic/gin</a></p><h2 id="看下-Gin-Example-带来的-API"><a href="#看下-Gin-Example-带来的-API" class="headerlink" title="看下 Gin Example 带来的 API"></a>看下 Gin Example 带来的 API</h2><p>将 <a href="https://github.com/gin-gonic/examples">https://github.com/gin-gonic/examples</a> fork 到自己 github ,clone 到本地，对照文档运行起来看看效果</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><h3 id="Using-GET-POST-PUT-PATCH-DELETE-and-OPTIONS"><a href="#Using-GET-POST-PUT-PATCH-DELETE-and-OPTIONS" class="headerlink" title="Using GET, POST, PUT, PATCH, DELETE and OPTIONS"></a>Using GET, POST, PUT, PATCH, DELETE and OPTIONS</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;net&#x2F;http&quot;&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;  &#x2F;&#x2F; Creates a gin router with default middleware:  &#x2F;&#x2F; logger and recovery (crash-free) middleware  &#x2F;&#x2F; 默认中间件情况下，创建 gin router  router :&#x3D; gin.Default()  router.GET(&quot;&#x2F;someGet&quot;, getting)  router.POST(&quot;&#x2F;somePost&quot;, posting)  router.PUT(&quot;&#x2F;somePut&quot;, putting)  router.DELETE(&quot;&#x2F;someDelete&quot;, deleting)  router.PATCH(&quot;&#x2F;somePatch&quot;, patching)  router.HEAD(&quot;&#x2F;someHead&quot;, head)  router.OPTIONS(&quot;&#x2F;someOptions&quot;, options)  &#x2F;&#x2F; By default it serves on :8080 unless a  &#x2F;&#x2F; PORT environment variable was defined.  &#x2F;&#x2F; 运行服务，默认启用的是8080端口  router.Run()  &#x2F;&#x2F; router.Run(&quot;:3000&quot;) for a hard coded port  &#x2F;&#x2F; 可以使用 router.Run(&quot;:3000&quot;)， 硬编码的方式改变端口&#125;</code></pre><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><h3 id="Parameters-in-path"><a href="#Parameters-in-path" class="headerlink" title="Parameters in path"></a>Parameters in path</h3><p>获取路径中的参数</p><p><code>Param</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;net&#x2F;http&quot;&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;  router :&#x3D; gin.Default()  &#x2F;&#x2F; This handler will match &#x2F;user&#x2F;john but will not match &#x2F;user&#x2F; or &#x2F;user  &#x2F;&#x2F; 这个处理器会匹配  &#x2F;user&#x2F;john ，但不会匹配  &#x2F;user&#x2F; 或者 &#x2F;user这种  router.GET(&quot;&#x2F;user&#x2F;:name&quot;, func(c *gin.Context) &#123;    name :&#x3D; c.Param(&quot;name&quot;) &#x2F;&#x2F; 通过指针.Param获取路径中的参数    c.String(http.StatusOK, &quot;Hello %s&quot;, name)  &#125;)  &#x2F;&#x2F; However, this one will match &#x2F;user&#x2F;john&#x2F; and also &#x2F;user&#x2F;john&#x2F;send  &#x2F;&#x2F; If no other routers match &#x2F;user&#x2F;john, it will redirect to &#x2F;user&#x2F;john&#x2F;  &#x2F;&#x2F; 这个会匹配到 &#x2F;user&#x2F;john&#x2F; 、  &#x2F;user&#x2F;john&#x2F;send， 对于&#x2F;user&#x2F;john 这样一个路径，如果没有其他路径匹配到，会重定向到 &#x2F;user&#x2F;john&#x2F;  router.GET(&quot;&#x2F;user&#x2F;:name&#x2F;*action&quot;, func(c *gin.Context) &#123; &#x2F;&#x2F; 这里的 :name 和 *action 怎么不一样呢？    name :&#x3D; c.Param(&quot;name&quot;)    action :&#x3D; c.Param(&quot;action&quot;)    message :&#x3D; name + &quot; is &quot; + action    c.String(http.StatusOK, message)  &#125;)  &#x2F;&#x2F; For each matched request Context will hold the route definition  &#x2F;&#x2F; 对于每个匹配的请求，Context将保存路由定义  router.POST(&quot;&#x2F;user&#x2F;:name&#x2F;*action&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; FullPath方法可以获取到路由定义    b :&#x3D; c.FullPath() &#x3D;&#x3D; &quot;&#x2F;user&#x2F;:name&#x2F;*action&quot; &#x2F;&#x2F; true    c.String(http.StatusOK, &quot;%t&quot;, b)  &#125;)  &#x2F;&#x2F; This handler will add a new router for &#x2F;user&#x2F;groups.  &#x2F;&#x2F; Exact routes are resolved before param routes, regardless of the order they were defined.  &#x2F;&#x2F; Routes starting with &#x2F;user&#x2F;groups are never interpreted as &#x2F;user&#x2F;:name&#x2F;... routes  &#x2F;&#x2F; 这个处理，会为&#x2F;user&#x2F;groups 增加一个新路径  &#x2F;&#x2F; 精确路由在参数路由之前解析，而不管它们的定义顺序如何。  &#x2F;&#x2F; 以&#x2F;user&#x2F;groups开头的路由永远不会解释为&#x2F;user&#x2F;:name&#x2F;…路由  router.GET(&quot;&#x2F;user&#x2F;groups&quot;, func(c *gin.Context) &#123;    c.String(http.StatusOK, &quot;The available groups are [...]&quot;)  &#125;)  router.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="Querystring-parameters"><a href="#Querystring-parameters" class="headerlink" title="Querystring parameters"></a>Querystring parameters</h3><p><code>DefaultQuery</code>、<code>Query</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;net&#x2F;http&quot;&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;  router :&#x3D; gin.Default()  &#x2F;&#x2F; Query string parameters are parsed using the existing underlying request object.  &#x2F;&#x2F; The request responds to a url matching:  &#x2F;welcome?firstname&#x3D;Jane&amp;lastname&#x3D;Doe  &#x2F;&#x2F; 查询字符串参数使用现有的底层请求对象进行解析。  &#x2F;&#x2F; 请求响应一个匹配的url：&#x2F;welcome?firstname&#x3D;Jane&amp;lastname&#x3D;Doe  router.GET(&quot;&#x2F;welcome&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; 带有默认值，取参数（如果firstname，没有，则用第二参数Guest）    firstname :&#x3D; c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)    &#x2F;&#x2F; 这个是简写    lastname :&#x3D; c.Query(&quot;lastname&quot;) &#x2F;&#x2F; shortcut for c.Request.URL.Query().Get(&quot;lastname&quot;)    c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)  &#125;)  router.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="Multipart-x2F-Urlencoded-Form"><a href="#Multipart-x2F-Urlencoded-Form" class="headerlink" title="Multipart&#x2F;Urlencoded Form"></a>Multipart&#x2F;Urlencoded Form</h3><p>表单参数</p><p><code>DefaultPostForm</code>、<code>PostForm</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;net&#x2F;http&quot;&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;router :&#x3D; gin.Default()router.POST(&quot;&#x2F;form_post&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; message参数message :&#x3D; c.PostForm(&quot;message&quot;)    &#x2F;&#x2F; form表单，带有默认值nick :&#x3D; c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;)c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;:  &quot;posted&quot;,&quot;message&quot;: message,&quot;nick&quot;:    nick,&#125;)&#125;)router.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="query-post-form"><a href="#query-post-form" class="headerlink" title="query + post form"></a>query + post form</h3><pre class="line-numbers language-http" data-language="http"><code class="language-http">POST &#x2F;post?id&#x3D;1234&amp;page&#x3D;1 HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencodedname&#x3D;manu&amp;message&#x3D;this_is_great</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  router.POST(&quot;&#x2F;post&quot;, func(c *gin.Context) &#123;      &#x2F;&#x2F; query参数      id :&#x3D; c.Query(&quot;id&quot;)      page :&#x3D; c.DefaultQuery(&quot;page&quot;, &quot;0&quot;)      &#x2F;&#x2F; form参数      name :&#x3D; c.PostForm(&quot;name&quot;)      message :&#x3D; c.PostForm(&quot;message&quot;)      fmt.Printf(&quot;id: %s; page: %s; name: %s; message: %s&quot;, id, page, name, message)  &#125;)  router.Run(&quot;:8080&quot;)&#125;&#x2F;&#x2F; id: 1234; page: 1; name: manu; message: this_is_great</code></pre><h3 id="Map-as-querystring-or-postform-parameters"><a href="#Map-as-querystring-or-postform-parameters" class="headerlink" title="Map as querystring or postform parameters"></a>Map as querystring or postform parameters</h3><pre class="line-numbers language-http" data-language="http"><code class="language-http">POST &#x2F;post?ids[a]&#x3D;1234&amp;ids[b]&#x3D;hello HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencodednames[first]&#x3D;thinkerou&amp;names[second]&#x3D;tianou</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  router.POST(&quot;&#x2F;post&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; query map    ids :&#x3D; c.QueryMap(&quot;ids&quot;)    &#x2F;&#x2F; form map    names :&#x3D; c.PostFormMap(&quot;names&quot;)    fmt.Printf(&quot;ids: %v; names: %v&quot;, ids, names)  &#125;)  router.Run(&quot;:8080&quot;)&#125;&#x2F;&#x2F; ids: map[b:hello a:1234]; names: map[second:tianou first:thinkerou]</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="Single-file-upload"><a href="#Single-file-upload" class="headerlink" title="Single file upload"></a>Single file upload</h3><p><code>file.Filename</code> 获取的文件名不可信</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  &#x2F;&#x2F; Set a lower memory limit for multipart forms (default is 32 MiB)  &#x2F;&#x2F; 默认 multipart forms  是 32MB, 设个低点的值的8M，是缓存不是上传大小限制  router.MaxMultipartMemory &#x3D; 8 &lt;&lt; 20  &#x2F;&#x2F; 8 MiB  router.POST(&quot;&#x2F;upload&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; Single file    file, _ :&#x3D; c.FormFile(&quot;file&quot;)    log.Println(file.Filename)    &#x2F;&#x2F; Upload the file to specific dst.    &#x2F;&#x2F; 上传文件到具体的目的地    c.SaveUploadedFile(file, dst)    c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded!&quot;, file.Filename))  &#125;)  router.Run(&quot;:8080&quot;)&#125;&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;localhost:8080&#x2F;upload \&#x2F;&#x2F;   -F &quot;file&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test.zip&quot; \&#x2F;&#x2F;   -H &quot;Content-Type: multipart&#x2F;form-data&quot;</code></pre><h3 id="Multiple-files"><a href="#Multiple-files" class="headerlink" title="Multiple files"></a>Multiple files</h3><p>See the detail example code.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  &#x2F;&#x2F; Set a lower memory limit for multipart forms (default is 32 MiB)  &#x2F;&#x2F; 默认 multipart forms  是 32MB, 设个低点的值的8M  router.MaxMultipartMemory &#x3D; 8 &lt;&lt; 20 &#x2F;&#x2F; 8 MiB  router.POST(&quot;&#x2F;upload&quot;, func(c *gin.Context) &#123;  &#x2F;&#x2F; Multipart form  form, _ :&#x3D; c.MultipartForm()  &#x2F;&#x2F; 多文件上传  files :&#x3D; form.File[&quot;upload[]&quot;]      for _, file :&#x3D; range files &#123;        log.Println(file.Filename)        &#x2F;&#x2F; Upload the file to specific dst.        c.SaveUploadedFile(file, dst)      &#125;      c.String(http.StatusOK, fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)))  &#125;)  router.Run(&quot;:8080&quot;)&#125;&#x2F;&#x2F; How to curl:&#x2F;&#x2F; curl -X POST http:&#x2F;&#x2F;localhost:8080&#x2F;upload \&#x2F;&#x2F;  -F &quot;upload[]&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test1.zip&quot; \&#x2F;&#x2F;  -F &quot;upload[]&#x3D;@&#x2F;Users&#x2F;appleboy&#x2F;test2.zip&quot; \&#x2F;&#x2F;  -H &quot;Content-Type: multipart&#x2F;form-data&quot;</code></pre><h2 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h2><h3 id="Grouping-routes"><a href="#Grouping-routes" class="headerlink" title="Grouping routes"></a>Grouping routes</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()    &#x2F;&#x2F; 以版本分组，也就移动端用的到，我记得java,有个包可以自动降级处理接口版本  &#x2F;&#x2F; Simple group: v1  v1 :&#x3D; router.Group(&quot;&#x2F;v1&quot;)  &#123;    v1.POST(&quot;&#x2F;login&quot;, loginEndpoint)    v1.POST(&quot;&#x2F;submit&quot;, submitEndpoint)    v1.POST(&quot;&#x2F;read&quot;, readEndpoint)  &#125;  &#x2F;&#x2F; Simple group: v2  v2 :&#x3D; router.Group(&quot;&#x2F;v2&quot;)  &#123;    v2.POST(&quot;&#x2F;login&quot;, loginEndpoint)    v2.POST(&quot;&#x2F;submit&quot;, submitEndpoint)    v2.POST(&quot;&#x2F;read&quot;, readEndpoint)  &#125;  router.Run(&quot;:8080&quot;)&#125;</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Blank-Gin-without-middleware-by-default"><a href="#Blank-Gin-without-middleware-by-default" class="headerlink" title="Blank Gin without middleware by default"></a>Blank Gin without middleware by default</h3><p>只是用默认的中间件，无其他中间件</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r :&#x3D; gin.New() &#x2F;&#x2F; 不使用任何中间件&#x2F;&#x2F; Default With the Logger and Recovery middleware already attachedr :&#x3D; gin.Default() &#x2F;&#x2F; 使用默认中间件</code></pre><h3 id="Using-middleware"><a href="#Using-middleware" class="headerlink" title="Using middleware"></a>Using middleware</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  &#x2F;&#x2F; Creates a router without any middleware by default  r :&#x3D; gin.New() &#x2F;&#x2F; 创建无中间件的路由  &#x2F;&#x2F; Global middleware  &#x2F;&#x2F; Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE&#x3D;release.  &#x2F;&#x2F; 记录器中间件将日志写入gin。即使您使用GIN_MODE&#x3D;release设置了DefaultWriter。  &#x2F;&#x2F; By default gin.DefaultWriter &#x3D; os.Stdout  &#x2F;&#x2F; 默认情况，只是打印  &#x2F;&#x2F; 全局中间件  r.Use(gin.Logger())  &#x2F;&#x2F; Recovery middleware recovers from any panics and writes a 500 if there was one.  &#x2F;&#x2F; recovery 中间件用于从 panic 中恢复, 并返回 500 响应. 还是不懂啥意思  r.Use(gin.Recovery())  &#x2F;&#x2F; Per route middleware, you can add as many as you desire.  &#x2F;&#x2F; 根据路由中间件，您可以添加任意数量的中间件。  r.GET(&quot;&#x2F;benchmark&quot;, MyBenchLogger(), benchEndpoint)  &#x2F;&#x2F; Authorization group  &#x2F;&#x2F; authorized :&#x3D; r.Group(&quot;&#x2F;&quot;, AuthRequired())  &#x2F;&#x2F; exactly the same as:  authorized :&#x3D; r.Group(&quot;&#x2F;&quot;)  &#x2F;&#x2F; per group middleware! in this case we use the custom created  &#x2F;&#x2F; AuthRequired() middleware just in the &quot;authorized&quot; group.  &#x2F;&#x2F;每组中间件！在本例中，我们使用自定义创建的  &#x2F;&#x2F;AuthRequired（）中间件仅位于“授权”组中。  authorized.Use(AuthRequired())  &#123;    authorized.POST(&quot;&#x2F;login&quot;, loginEndpoint)    authorized.POST(&quot;&#x2F;submit&quot;, submitEndpoint)    authorized.POST(&quot;&#x2F;read&quot;, readEndpoint)    &#x2F;&#x2F; nested group    &#x2F;&#x2F; 级联分组    testing :&#x3D; authorized.Group(&quot;testing&quot;)    &#x2F;&#x2F; visit 0.0.0.0:8080&#x2F;testing&#x2F;analytics    testing.GET(&quot;&#x2F;analytics&quot;, analyticsEndpoint)  &#125;  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="Custom-Recovery-behavior"><a href="#Custom-Recovery-behavior" class="headerlink" title="Custom Recovery behavior"></a>Custom Recovery behavior</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  &#x2F;&#x2F; Creates a router without any middleware by default  r :&#x3D; gin.New()  &#x2F;&#x2F; Global middleware  &#x2F;&#x2F; Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE&#x3D;release.  &#x2F;&#x2F; By default gin.DefaultWriter &#x3D; os.Stdout  r.Use(gin.Logger())  &#x2F;&#x2F; Recovery middleware recovers from any panics and writes a 500 if there was one.  r.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface&#123;&#125;) &#123;    if err, ok :&#x3D; recovered.(string); ok &#123; &#x2F;&#x2F; 这个地方怎么是分号？      c.String(http.StatusInternalServerError, fmt.Sprintf(&quot;error: %s&quot;, err))    &#125;    &#x2F;&#x2F; 丢弃    c.AbortWithStatus(http.StatusInternalServerError)  &#125;))  r.GET(&quot;&#x2F;panic&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; panic with a string -- the custom middleware could save this to a database or report it to the user    &#x2F;&#x2F; 定义中间件，将 panic 保存到数据库。或者是向用户报告问题    panic(&quot;foo&quot;)  &#125;)  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;    c.String(http.StatusOK, &quot;ohai&quot;)  &#125;)  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)&#125;</code></pre><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="How-to-write-log-file"><a href="#How-to-write-log-file" class="headerlink" title="How to write log file"></a>How to write log file</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    &#x2F;&#x2F; Disable Console Color, you don&#39;t need console color when writing the logs to file.    &#x2F;&#x2F; 关闭console颜色，向文件中写入日志不需要颜色    gin.DisableConsoleColor()    &#x2F;&#x2F; Logging to a file.    f, _ :&#x3D; os.Create(&quot;gin.log&quot;) &#x2F;&#x2F; 创建文件    gin.DefaultWriter &#x3D; io.MultiWriter(f) &#x2F;&#x2F; 写入日志    &#x2F;&#x2F; Use the following code if you need to write the logs to file and console at the same time.    &#x2F;&#x2F; 如果既要写日志到文件，也要打印，就需要用到下面的代码    &#x2F;&#x2F; gin.DefaultWriter &#x3D; io.MultiWriter(f, os.Stdout)    router :&#x3D; gin.Default()    router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;        c.String(http.StatusOK, &quot;pong&quot;)    &#125;)    router.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="Custom-Log-Format"><a href="#Custom-Log-Format" class="headerlink" title="Custom Log Format"></a>Custom Log Format</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.New()  &#x2F;&#x2F; LoggerWithFormatter middleware will write the logs to gin.DefaultWriter  &#x2F;&#x2F; By default gin.DefaultWriter &#x3D; os.Stdout  router.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string &#123;    &#x2F;&#x2F; your custom format    return fmt.Sprintf(&quot;%s - [%s] \&quot;%s %s %s %d %s \&quot;%s\&quot; %s\&quot;\n&quot;,        param.ClientIP,        param.TimeStamp.Format(time.RFC1123),        param.Method,        param.Path,        param.Request.Proto, &#x2F;&#x2F; HTTP&#x2F;1.1        param.StatusCode, &#x2F;&#x2F; 200        param.Latency, &#x2F;&#x2F;  122.767µs        param.Request.UserAgent(), &#x2F;&#x2F; &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.80 Safari&#x2F;537.36&quot;        param.ErrorMessage,    )  &#125;))  router.Use(gin.Recovery())  router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;    c.String(http.StatusOK, &quot;pong&quot;)  &#125;)  router.Run(&quot;:8080&quot;)&#125;&#x2F;&#x2F; ::1 - [Fri, 07 Dec 2018 17:04:38 JST] &quot;GET &#x2F;ping HTTP&#x2F;1.1 200 122.767µs &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.80 Safari&#x2F;537.36&quot; &quot;</code></pre><h3 id="Controlling-Log-output-coloring"><a href="#Controlling-Log-output-coloring" class="headerlink" title="Controlling Log output coloring"></a>Controlling Log output coloring</h3><p>By default, logs output on console should be colorized depending on the detected TTY.</p><p>默认情况下，控制台上的日志输出应根据检测到的 TTY 进行着色。</p><p><strong>Never colorize logs:</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;&#x2F;&#x2F; Disable log&#39;s colorgin.DisableConsoleColor()    &#x2F;&#x2F; Creates a gin router with default middleware:    &#x2F;&#x2F; logger and recovery (crash-free) middleware    router :&#x3D; gin.Default()    router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;        c.String(http.StatusOK, &quot;pong&quot;)    &#125;)    router.Run(&quot;:8080&quot;)&#125;</code></pre><p><strong>Always colorize logs:</strong></p><p>通常会定制颜色</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;    &#x2F;&#x2F; Force log&#39;s color    gin.ForceConsoleColor()    &#x2F;&#x2F; Creates a gin router with default middleware:    &#x2F;&#x2F; logger and recovery (crash-free) middleware    router :&#x3D; gin.Default()    router.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;        c.String(http.StatusOK, &quot;pong&quot;)    &#125;)    router.Run(&quot;:8080&quot;)&#125;</code></pre><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><h3 id="Model-binding-and-validation"><a href="#Model-binding-and-validation" class="headerlink" title="Model binding and validation ?"></a>Model binding and validation ?</h3><p>要将请求体绑定到结构体中，使用模型绑定。 Gin 目前支持 JSON、XML、YAML 和标准表单值的绑定（foo&#x3D;bar＆boo&#x3D;baz）。</p><p>Gin 使用 go-playground&#x2F;validator&#x2F;v10 进行验证。 查看标签用法的全部文档.</p><p>使用时，需要在要绑定的所有字段上，设置相应的 tag。 例如，使用 JSON 绑定时，设置字段标签为 json:”fieldname”。</p><p>Gin 提供了两类绑定方法：</p><p><strong>Type - Must bind</strong></p><p><code>Methods </code>- Bind, BindJSON, BindXML, BindQuery, BindYAML<br><code>Behavior</code> - 这些方法属于 MustBindWith 的具体调用。 如果发生绑定错误，则请求终止，并触发 c.AbortWithError(400, err).SetType(ErrorTypeBind)。响应状态码被设置为 400 并且 Content-Type 被设置为 text&#x2F;plain; <strong>太死板，不好用</strong>charset&#x3D;utf-8。 如果您在此之后尝试设置响应状态码，Gin 会输出日志 [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422。 如果您希望更好地控制绑定，考虑使用 ShouldBind 等效方法。</p><p><strong>Type - Should bind</strong></p><p><code>Methods</code> - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML<br><code>Behavior</code> - 这些方法属于 ShouldBindWith 的具体调用。 <strong>如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。</strong></p><p>使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用 MustBindWith 或 ShouldBindWith。</p><p><strong>你也可以指定必须绑定的字段。 如果一个字段的 tag 加上了 binding:”required”，但绑定时是空值, Gin 会报错。</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 绑定 JSONtype Login struct &#123;User     string &#96;form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;&#96;Password string &#96;form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;&#96;&#125;func main() &#123;router :&#x3D; gin.Default()&#x2F;&#x2F; 绑定 JSON (&#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;)router.POST(&quot;&#x2F;loginJSON&quot;, func(c *gin.Context) &#123;var json Login &#x2F;&#x2F; Login结构体    &#x2F;&#x2F; if initialization; condition &#123;    &#x2F;&#x2F;     &#x2F;&#x2F; do something    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; 例如:    &#x2F;&#x2F; val :&#x3D; 10    &#x2F;&#x2F; if val &gt; max &#123;    &#x2F;&#x2F;     &#x2F;&#x2F; do something    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; 你也可以这样写:    &#x2F;&#x2F; if val :&#x3D; 10; val &gt; max &#123;    &#x2F;&#x2F;     &#x2F;&#x2F; do something    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; ————————————————    &#x2F;&#x2F; 原文作者：Go 技术论坛文档：《Go 入门指南（）》    &#x2F;&#x2F; 转自链接：https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;the-way-to-go&#x2F;if-else-structure&#x2F;3592    &#x2F;&#x2F; 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接if err :&#x3D; c.ShouldBindJSON(&amp;json); err !&#x3D; nil &#123;c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)return&#125;if json.User !&#x3D; &quot;manu&quot; || json.Password !&#x3D; &quot;123&quot; &#123;c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)return&#125;c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)&#125;)&#x2F;&#x2F; 绑定 XML (&#x2F;&#x2F;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&#x2F;&#x2F;&lt;root&gt;&#x2F;&#x2F;&lt;user&gt;manu&lt;&#x2F;user&gt;&#x2F;&#x2F;&lt;password&gt;123&lt;&#x2F;password&gt;&#x2F;&#x2F;&lt;&#x2F;root&gt;)router.POST(&quot;&#x2F;loginXML&quot;, func(c *gin.Context) &#123;var xml Loginif err :&#x3D; c.ShouldBindXML(&amp;xml); err !&#x3D; nil &#123;c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)return&#125;if xml.User !&#x3D; &quot;manu&quot; || xml.Password !&#x3D; &quot;123&quot; &#123;c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)return&#125;c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)&#125;)&#x2F;&#x2F; 绑定 HTML 表单 (user&#x3D;manu&amp;password&#x3D;123)router.POST(&quot;&#x2F;loginForm&quot;, func(c *gin.Context) &#123;var form Login&#x2F;&#x2F; 根据 Content-Type Header 推断使用哪个绑定器。if err :&#x3D; c.ShouldBind(&amp;form); err !&#x3D; nil &#123;c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)return&#125;if form.User !&#x3D; &quot;manu&quot; || form.Password !&#x3D; &quot;123&quot; &#123;c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)return&#125;c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)&#125;)&#x2F;&#x2F; 监听并在 0.0.0.0:8080 上启动服务router.Run(&quot;:8080&quot;)&#125;</code></pre><p><strong>请求测试</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl -v -X POST \  http:&#x2F;&#x2F;localhost:8080&#x2F;loginJSON \  -H &#39;content-type: application&#x2F;json&#39; \  -d &#39;&#123; &quot;user&quot;: &quot;manu&quot; &#125;&#39;&gt; POST &#x2F;loginJSON HTTP&#x2F;1.1&gt; Host: localhost:8080&gt; User-Agent: curl&#x2F;7.51.0&gt; Accept: *&#x2F;*&gt; content-type: application&#x2F;json&gt; Content-Length: 18&gt;* upload completely sent off: 18 out of 18 bytes&lt; HTTP&#x2F;1.1 400 Bad Request&lt; Content-Type: application&#x2F;json; charset&#x3D;utf-8&lt; Date: Fri, 04 Aug 2017 03:51:31 GMT&lt; Content-Length: 100&lt;&#123;&quot;error&quot;:&quot;Key: &#39;Login.Password&#39; Error:Field validation for &#39;Password&#39; failed on the &#39;required&#39; tag&quot;&#125;</code></pre><h3 id="Custom-Validators"><a href="#Custom-Validators" class="headerlink" title="Custom Validators"></a>Custom Validators</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (  &quot;net&#x2F;http&quot;  &quot;time&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&#x2F;binding&quot;  &quot;github.com&#x2F;go-playground&#x2F;validator&#x2F;v10&quot;)&#x2F;&#x2F; Booking contains binded and validated data.type Booking struct &#123;  CheckIn  time.Time &#96;form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;&#96;  CheckOut time.Time &#96;form:&quot;check_out&quot; binding:&quot;required,gtfield&#x3D;CheckIn&quot; time_format:&quot;2006-01-02&quot;&#96;&#125;&#x2F;&#x2F; 校验函数var bookableDate validator.Func &#x3D; func(fl validator.FieldLevel) bool &#123;  date, ok :&#x3D; fl.Field().Interface().(time.Time)  if ok &#123;    today :&#x3D; time.Now()    if today.After(date) &#123;      return false    &#125;  &#125;  return true&#125;func main() &#123;  route :&#x3D; gin.Default()  if v, ok :&#x3D; binding.Validator.Engine().(*validator.Validate); ok &#123;    &#x2F;&#x2F; 注册校验函数    v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)  &#125;  route.GET(&quot;&#x2F;bookable&quot;, getBookable)  route.Run(&quot;:8085&quot;)&#125;func getBookable(c *gin.Context) &#123;  var b Booking  if err :&#x3D; c.ShouldBindWith(&amp;b, binding.Query); err &#x3D;&#x3D; nil &#123;    c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Booking dates are valid!&quot;&#125;)  &#125; else &#123;    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)  &#125;&#125;</code></pre><p><strong>测试</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ curl &quot;localhost:8085&#x2F;bookable?check_in&#x3D;2030-04-16&amp;check_out&#x3D;2030-04-17&quot;&#123;&quot;message&quot;:&quot;Booking dates are valid!&quot;&#125;$ curl &quot;localhost:8085&#x2F;bookable?check_in&#x3D;2030-03-10&amp;check_out&#x3D;2030-03-09&quot;&#123;&quot;error&quot;:&quot;Key: &#39;Booking.CheckOut&#39; Error:Field validation for &#39;CheckOut&#39; failed on the &#39;gtfield&#39; tag&quot;&#125;$ curl &quot;localhost:8085&#x2F;bookable?check_in&#x3D;2000-03-09&amp;check_out&#x3D;2000-03-10&quot;&#123;&quot;error&quot;:&quot;Key: &#39;Booking.CheckIn&#39; Error:Field validation for &#39;CheckIn&#39; failed on the &#39;bookabledate&#39; tag&quot;&#125;%</code></pre><p><strong>忽略验证</strong></p><p>使用上述的 curl 命令运行上面的示例时会返回错误。<br>因为示例中 Password 使用了 <code>binding:&quot;required&quot;</code>。<br>如果 Password 使用 <code>binding:&quot;-&quot;</code>， 再次运行上面的示例就不会返回错误。</p><p>Struct 级别的校验可以用另一种方式来注册 <strong>struct-lvl-validation example</strong></p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="Only-Bind-Query-String"><a href="#Only-Bind-Query-String" class="headerlink" title="Only Bind Query String"></a>Only Bind Query String</h3><p>ShouldBindQuery function only binds the query params and not the post data. See the detail information.</p><p>ShouldBindQuery 函数只绑定 url 查询参数而忽略 post 数据。<a href="https://github.com/gin-gonic/gin/issues/742#issuecomment-315953017" target="_blank" >参阅详细信息</a>.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (  &quot;log&quot;  &quot;net&#x2F;http&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)type Person struct &#123;  Name    string &#96;form:&quot;name&quot;&#96;  Address string &#96;form:&quot;address&quot;&#96;&#125;func main() &#123;  route :&#x3D; gin.Default()  route.Any(&quot;&#x2F;testing&quot;, startPage)  route.Run(&quot;:8085&quot;)&#125;func startPage(c *gin.Context) &#123;  var person Person  if c.ShouldBindQuery(&amp;person) &#x3D;&#x3D; nil &#123;    log.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Only Bind By Query String &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)    log.Println(person.Name)    log.Println(person.Address)  &#125;  c.String(http.StatusOK, &quot;Success&quot;)&#125;</code></pre><h3 id="Bind-Query-String-or-Post-Data"><a href="#Bind-Query-String-or-Post-Data" class="headerlink" title="Bind Query String or Post Data ?"></a>Bind Query String or Post Data ?</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (  &quot;log&quot;  &quot;net&#x2F;http&quot;  &quot;time&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)type Person struct &#123;        Name       string    &#96;form:&quot;name&quot;&#96;        Address    string    &#96;form:&quot;address&quot;&#96;        Birthday   time.Time &#96;form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;&#96;        CreateTime time.Time &#96;form:&quot;createTime&quot; time_format:&quot;unixNano&quot;&#96;        UnixTime   time.Time &#96;form:&quot;unixTime&quot; time_format:&quot;unix&quot;&#96;&#125;func main() &#123;  route :&#x3D; gin.Default()  route.GET(&quot;&#x2F;testing&quot;, startPage)  route.Run(&quot;:8085&quot;)&#125;func startPage(c *gin.Context) &#123;  var person Person  &#x2F;&#x2F; If &#96;GET&#96;, only &#96;Form&#96; binding engine (&#96;query&#96;) used.  &#x2F;&#x2F; If &#96;POST&#96;, first checks the &#96;content-type&#96; for &#96;JSON&#96; or &#96;XML&#96;, then uses &#96;Form&#96; (&#96;form-data&#96;).  &#x2F;&#x2F; See more at https:&#x2F;&#x2F;github.com&#x2F;gin-gonic&#x2F;gin&#x2F;blob&#x2F;master&#x2F;binding&#x2F;binding.go#L88  if c.ShouldBind(&amp;person) &#x3D;&#x3D; nil &#123;          log.Println(person.Name)          log.Println(person.Address)          log.Println(person.Birthday)          log.Println(person.CreateTime)          log.Println(person.UnixTime)  &#125;  c.String(http.StatusOK, &quot;Success&quot;)&#125;</code></pre><h3 id="Bind-Uri"><a href="#Bind-Uri" class="headerlink" title="Bind Uri"></a>Bind Uri</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (  &quot;net&#x2F;http&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)type Person struct &#123;  ID string &#96;uri:&quot;id&quot; binding:&quot;required,uuid&quot;&#96; &#x2F;&#x2F; uri:&quot;id&quot; 映射到ID  Name string &#96;uri:&quot;name&quot; binding:&quot;required&quot;&#96; &#x2F;&#x2F;  uri:&quot;name&quot; 映射到 Name&#125;func main() &#123;  route :&#x3D; gin.Default()  route.GET(&quot;&#x2F;:name&#x2F;:id&quot;, func(c *gin.Context) &#123;    var person Person    if err :&#x3D; c.ShouldBindUri(&amp;person); err !&#x3D; nil &#123;      c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: err.Error()&#125;)      return    &#125;    c.JSON(http.StatusOK, gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;)  &#125;)  route.Run(&quot;:8088&quot;)&#125;</code></pre><p><strong>test</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -v localhost:8088&#x2F;thinkerou&#x2F;987fbc97-4bed-5078-9f07-9141ba07c9f3curl -v localhost:8088&#x2F;thinkerou&#x2F;not-uuid</code></pre><h3 id="Bind-Header"><a href="#Bind-Header" class="headerlink" title="Bind Header"></a>Bind Header</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (  &quot;fmt&quot;  &quot;net&#x2F;http&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)type testHeader struct &#123;  Rate   int    &#96;header:&quot;Rate&quot;&#96; &#x2F;&#x2F; header中 Rate字段  Domain string &#96;header:&quot;Domain&quot;&#96; &#x2F;&#x2F; header中 Domain字段&#125;func main() &#123;  r :&#x3D; gin.Default()  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;    h :&#x3D; testHeader&#123;&#125;    if err :&#x3D; c.ShouldBindHeader(&amp;h); err !&#x3D; nil &#123;      c.JSON(http.StatusOK, err)    &#125;    fmt.Printf(&quot;%#v\n&quot;, h)    c.JSON(http.StatusOK, gin.H&#123;&quot;Rate&quot;: h.Rate, &quot;Domain&quot;: h.Domain&#125;)  &#125;)  r.Run()&#x2F;&#x2F; client&#x2F;&#x2F; curl -H &quot;rate:300&quot; -H &quot;domain:music&quot; 127.0.0.1:8080&#x2F;&#x2F;&#x2F; output&#x2F;&#x2F; &#123;&quot;Domain&quot;:&quot;music&quot;,&quot;Rate&quot;:300&#125;&#125;</code></pre><h3 id="Bind-HTML-checkboxes"><a href="#Bind-HTML-checkboxes" class="headerlink" title="Bind HTML checkboxes"></a>Bind HTML checkboxes</h3><p>参见 <a href="https://github.com/gin-gonic/gin/issues/129#issuecomment-124260092" target="_blank" >详细信息</a></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)type myForm struct &#123;    Colors []string &#96;form:&quot;colors[]&quot;&#96; &#x2F;&#x2F; 表单中的colors字段&#125;func main() &#123;    r :&#x3D; gin.Default()    r.LoadHTMLGlob(&quot;views&#x2F;*&quot;)    r.GET(&quot;&#x2F;&quot;, indexHandler)    r.POST(&quot;&#x2F;&quot;, formHandler)    r.Run(&quot;:8080&quot;)&#125;func indexHandler(c *gin.Context) &#123;    c.HTML(200, &quot;form.html&quot;, nil)&#125;func formHandler(c *gin.Context) &#123;    var fakeForm myForm    c.Bind(&amp;fakeForm)    c.JSON(200, gin.H&#123;&quot;color&quot;: fakeForm.Colors&#125;)&#125;</code></pre><p><strong>And the form (“views&#x2F;form.html”) :</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;form action&#x3D;&quot;&#x2F;&quot; method&#x3D;&quot;POST&quot;&gt;  &lt;p&gt;Check some colors&lt;&#x2F;p&gt;  &lt;label for&#x3D;&quot;red&quot;&gt;Red&lt;&#x2F;label&gt;  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;colors[]&quot; value&#x3D;&quot;red&quot; id&#x3D;&quot;red&quot; &#x2F;&gt;  &lt;label for&#x3D;&quot;green&quot;&gt;Green&lt;&#x2F;label&gt;  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;colors[]&quot; value&#x3D;&quot;green&quot; id&#x3D;&quot;green&quot; &#x2F;&gt;  &lt;label for&#x3D;&quot;blue&quot;&gt;Blue&lt;&#x2F;label&gt;  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;colors[]&quot; value&#x3D;&quot;blue&quot; id&#x3D;&quot;blue&quot; &#x2F;&gt;  &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;color&quot;:[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;]&#125;</code></pre><h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><h3 id="XML-JSON-YAML-and-ProtoBuf-rendering"><a href="#XML-JSON-YAML-and-ProtoBuf-rendering" class="headerlink" title="XML, JSON, YAML and ProtoBuf rendering"></a>XML, JSON, YAML and ProtoBuf rendering</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  r :&#x3D; gin.Default()  &#x2F;&#x2F; gin.H is a shortcut for map[string]interface&#123;&#125;  r.GET(&quot;&#x2F;someJSON&quot;, func(c *gin.Context) &#123;    c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)  &#125;)  r.GET(&quot;&#x2F;moreJSON&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; You also can use a struct    var msg struct &#123;      Name    string &#96;json:&quot;user&quot;&#96; &#x2F;&#x2F; 前面的会转化成后面的      Message string      Number  int    &#125;    msg.Name &#x3D; &quot;Lena&quot;    msg.Message &#x3D; &quot;hey&quot;    msg.Number &#x3D; 123    &#x2F;&#x2F; Note that msg.Name becomes &quot;user&quot; in the JSON    &#x2F;&#x2F; Will output  :   &#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;    c.JSON(http.StatusOK, msg)  &#125;)  r.GET(&quot;&#x2F;someXML&quot;, func(c *gin.Context) &#123;    c.XML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)  &#125;)  r.GET(&quot;&#x2F;someYAML&quot;, func(c *gin.Context) &#123;    c.YAML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)  &#125;)  r.GET(&quot;&#x2F;someProtoBuf&quot;, func(c *gin.Context) &#123;    reps :&#x3D; []int64&#123;int64(1), int64(2)&#125;    label :&#x3D; &quot;test&quot;    &#x2F;&#x2F; The specific definition of protobuf is written in the testdata&#x2F;protoexample file.    &#x2F;&#x2F; protobuf的具体定义写在testdata&#x2F;protoexample文件中。    data :&#x3D; &amp;protoexample.Test&#123;      Label: &amp;label,      Reps:  reps,    &#125;    &#x2F;&#x2F; Note that data becomes binary data in the response    &#x2F;&#x2F; Will output protoexample.Test protobuf serialized data    &#x2F;&#x2F; 二进制数据返回    c.ProtoBuf(http.StatusOK, data)  &#125;)  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="JSON-数据大小写问题"><a href="#JSON-数据大小写问题" class="headerlink" title="JSON 数据大小写问题"></a>JSON 数据大小写问题</h3><img src="http://t-blog-images.aijs.top/img/202210161145420.png" /><img src="http://t-blog-images.aijs.top/img/202210161144852.png" /><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="SecureJSON"><a href="#SecureJSON" class="headerlink" title="SecureJSON ??"></a>SecureJSON ??</h3><p>Using SecureJSON to prevent json hijacking. Default prepends “while(1),” to response body if the given struct is array values.</p><p>使用 SecureJSON 防止 json 劫持。如果给定的结构是数组值，则默认在响应正文前面加上“while（1）”。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  r :&#x3D; gin.Default()  &#x2F;&#x2F; You can also use your own secure json prefix  &#x2F;&#x2F; r.SecureJsonPrefix(&quot;)]&#125;&#39;,\n&quot;)  r.GET(&quot;&#x2F;someJSON&quot;, func(c *gin.Context) &#123;    names :&#x3D; []string&#123;&quot;lena&quot;, &quot;austin&quot;, &quot;foo&quot;&#125;    &#x2F;&#x2F; Will output  :   while(1);[&quot;lena&quot;,&quot;austin&quot;,&quot;foo&quot;]    c.SecureJSON(http.StatusOK, names)  &#125;)  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>Using JSONP to request data from a server in a different domain.<br>Add callback to response body if the query parameter callback exists.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  r :&#x3D; gin.Default()  r.GET(&quot;&#x2F;JSONP&quot;, func(c *gin.Context) &#123;    data :&#x3D; gin.H&#123;      &quot;foo&quot;: &quot;bar&quot;,    &#125;    &#x2F;&#x2F; callback is x    &#x2F;&#x2F; Will output  :   x(&#123;\&quot;foo\&quot;:\&quot;bar\&quot;&#125;) &#x2F;&#x2F; 回调形式    c.JSONP(http.StatusOK, data)  &#125;)  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)        &#x2F;&#x2F; client        &#x2F;&#x2F; curl http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;JSONP?callback&#x3D;x&#125;</code></pre><h3 id="AsciiJSON"><a href="#AsciiJSON" class="headerlink" title="AsciiJSON"></a>AsciiJSON</h3><p>Using AsciiJSON to Generates ASCII-only JSON with escaped non-ASCII characters.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  r :&#x3D; gin.Default()  r.GET(&quot;&#x2F;someJSON&quot;, func(c *gin.Context) &#123;    data :&#x3D; gin.H&#123;      &quot;lang&quot;: &quot;GO语言&quot;,      &quot;tag&quot;:  &quot;&lt;br&gt;&quot;,    &#125;    &#x2F;&#x2F; will output : &#123;&quot;lang&quot;:&quot;GO\u8bed\u8a00&quot;,&quot;tag&quot;:&quot;\u003cbr\u003e&quot;&#125;    c.AsciiJSON(http.StatusOK, data)  &#125;)  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="PureJSON"><a href="#PureJSON" class="headerlink" title="PureJSON"></a>PureJSON</h3><p>Normally, JSON replaces special HTML characters with their unicode entities, e.g. &lt; becomes \u003c. If you want to encode such characters literally, you can use PureJSON instead. This feature is unavailable in Go 1.6 and lower.</p><p>通常，JSON 使用 unicode 替换特殊 HTML 字符，例如 &lt; 变为 \ u003c。</p><p>如果要按字面对这些字符进行编码，则可以使用 PureJSON。Go 1.6 及更低版本无法使用此功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  r :&#x3D; gin.Default()  &#x2F;&#x2F; Serves unicode entities  r.GET(&quot;&#x2F;json&quot;, func(c *gin.Context) &#123;    c.JSON(http.StatusOK, gin.H&#123;      &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;&#x2F;b&gt;&quot;,    &#125;)  &#125;)  &#x2F;&#x2F; Serves literal characters  r.GET(&quot;&#x2F;purejson&quot;, func(c *gin.Context) &#123;    c.PureJSON(http.StatusOK, gin.H&#123;      &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;&#x2F;b&gt;&quot;,    &#125;)  &#125;)  &#x2F;&#x2F; listen and serve on 0.0.0.0:8080  r.Run(&quot;:8080&quot;)&#125;</code></pre><h2 id="文件资源"><a href="#文件资源" class="headerlink" title="文件资源"></a>文件资源</h2><h3 id="Serving-static-files"><a href="#Serving-static-files" class="headerlink" title="Serving static files"></a>Serving static files</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  &#x2F;&#x2F; 下面这几个有什么区别  &#x2F;&#x2F; router.Static 指定某个目录为静态资源目录，可直接访问这个目录下的资源，url 要具体到资源名称。  &#x2F;&#x2F; router.StaticFS 比前面一个多了个功能，当目录下不存 index.html 文件时，会列出该目录下的所有文件。  &#x2F;&#x2F; router.StaticFile 指定某个具体的文件作为静态资源访问。  &#x2F;&#x2F; router.StaticFileFS 指定某个具体的文件作为静态资源访问,文件不存在，会列出该目录下的所有文件。  &#x2F;&#x2F; 作者：gentyxiao  &#x2F;&#x2F; 链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;09175c17419c  &#x2F;&#x2F; 来源：简书  &#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  router.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;assets&quot;)  router.StaticFS(&quot;&#x2F;more_static&quot;, http.Dir(&quot;my_file_system&quot;))  router.StaticFile(&quot;&#x2F;favicon.ico&quot;, &quot;.&#x2F;resources&#x2F;favicon.ico&quot;)  router.StaticFileFS(&quot;&#x2F;more_favicon.ico&quot;, &quot;more_favicon.ico&quot;, http.Dir(&quot;my_file_system&quot;))  &#x2F;&#x2F; Listen and serve on 0.0.0.0:8080  router.Run(&quot;:8080&quot;)&#125;</code></pre><h3 id="Serving-data-from-file"><a href="#Serving-data-from-file" class="headerlink" title="Serving data from file"></a>Serving data from file</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  router.GET(&quot;&#x2F;local&#x2F;file&quot;, func(c *gin.Context) &#123;    c.File(&quot;local&#x2F;file.go&quot;)  &#125;)  var fs http.FileSystem &#x3D; &#x2F;&#x2F; ...  router.GET(&quot;&#x2F;fs&#x2F;file&quot;, func(c *gin.Context) &#123;    c.FileFromFS(&quot;fs&#x2F;file.go&quot;, fs)  &#125;)&#125;</code></pre><h3 id="Serving-data-from-reader"><a href="#Serving-data-from-reader" class="headerlink" title="Serving data from reader"></a>Serving data from reader</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  router :&#x3D; gin.Default()  router.GET(&quot;&#x2F;someDataFromReader&quot;, func(c *gin.Context) &#123;    response, err :&#x3D; http.Get(&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;gin-gonic&#x2F;logo&#x2F;master&#x2F;color.png&quot;)    if err !&#x3D; nil || response.StatusCode !&#x3D; http.StatusOK &#123;      c.Status(http.StatusServiceUnavailable)      return    &#125;    reader :&#x3D; response.Body     defer reader.Close()    contentLength :&#x3D; response.ContentLength    contentType :&#x3D; response.Header.Get(&quot;Content-Type&quot;)    extraHeaders :&#x3D; map[string]string&#123;      &quot;Content-Disposition&quot;: &#96;attachment; filename&#x3D;&quot;gopher.png&quot;&#96;,    &#125;    c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)  &#125;)  router.Run(&quot;:8080&quot;)&#125;</code></pre><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="HTML-rendering"><a href="#HTML-rendering" class="headerlink" title="HTML rendering"></a>HTML rendering</h3><h3 id="Custom-Template-renderer"><a href="#Custom-Template-renderer" class="headerlink" title="Custom Template renderer"></a>Custom Template renderer</h3><h3 id="Custom-Delimiters"><a href="#Custom-Delimiters" class="headerlink" title="Custom Delimiters"></a>Custom Delimiters</h3><h3 id="Custom-Template-Funcs"><a href="#Custom-Template-Funcs" class="headerlink" title="Custom Template Funcs"></a>Custom Template Funcs</h3><h3 id="Multitemplate"><a href="#Multitemplate" class="headerlink" title="Multitemplate"></a>Multitemplate</h3><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="Redirects"><a href="#Redirects" class="headerlink" title="Redirects"></a>Redirects</h3><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r.GET(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;  c.Redirect(http.StatusMovedPermanently, &quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;)&#125;)</code></pre><p>通过 POST 方法进行 HTTP 重定向。请参考 issue：#444</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r.POST(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;  c.Redirect(http.StatusFound, &quot;&#x2F;foo&quot;)&#125;)</code></pre><p>路由重定向，使用 HandleContext：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">r.GET(&quot;&#x2F;test&quot;, func(c *gin.Context) &#123;    c.Request.URL.Path &#x3D; &quot;&#x2F;test2&quot;    r.HandleContext(c)&#125;)</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">r.GET(&quot;&#x2F;test2&quot;, func(c *gin.Context) &#123;    c.JSON(http.StatusOK, gin.H&#123;&quot;hello&quot;: &quot;world&quot;&#125;)&#125;)</code></pre><h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><p>洋葱模型，不是 koa 原创啊</p><p><strong>图 1： 中间件执行顺序</strong></p><!-- <img src="http://t-blog-images.aijs.top/img/202210161100207.png" /> --><img src="http://t-blog-images.aijs.top/img/202210161109664.png" /><p><strong>续图 1，图 2: 中间件执行顺序</strong><br><img src="http://t-blog-images.aijs.top/img/202210161102580.png" /></p><p><strong>图 3: 阻止中间件往后执行</strong></p><img src="http://t-blog-images.aijs.top/img/202210161106552.png" /><p><strong>图 4：阻止中间件往后、往下执行</strong><br><img src="http://t-blog-images.aijs.top/img/202210161104024.png" /></p><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><div style="display:flex;flex-direction:row; flex-wrap:wrap">  <img src="http://t-blog-images.aijs.top/img/202210161113436.png" style="max-width:100%;width: 300px" />  <div style="width: 6px"></div>  <img src="http://t-blog-images.aijs.top/img/202210161112991.png"  style="max-width:100%; width: 500px"/></div><h3 id="跨中间件存取值"><a href="#跨中间件存取值" class="headerlink" title="跨中间件存取值"></a>跨中间件存取值</h3><h3 id="Custom-Middleware"><a href="#Custom-Middleware" class="headerlink" title="Custom Middleware"></a>Custom Middleware</h3><h3 id="Using-BasicAuth-middleware"><a href="#Using-BasicAuth-middleware" class="headerlink" title="Using BasicAuth() middleware"></a>Using BasicAuth() middleware</h3><h3 id="Goroutines-inside-a-middleware"><a href="#Goroutines-inside-a-middleware" class="headerlink" title="Goroutines inside a middleware"></a>Goroutines inside a middleware</h3><h3 id="Custom-HTTP-configuration"><a href="#Custom-HTTP-configuration" class="headerlink" title="Custom HTTP configuration"></a>Custom HTTP configuration</h3><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="Support-Let’s-Encrypt-没看懂"><a href="#Support-Let’s-Encrypt-没看懂" class="headerlink" title="Support Let’s Encrypt 没看懂"></a>Support Let’s Encrypt 没看懂</h3><h2 id="多服务器"><a href="#多服务器" class="headerlink" title="多服务器"></a>多服务器</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">See the question and try the following example:package mainimport (  &quot;log&quot;  &quot;net&#x2F;http&quot;  &quot;time&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;  &quot;golang.org&#x2F;x&#x2F;sync&#x2F;errgroup&quot;)var (  g errgroup.Group)&#x2F;&#x2F; 服务器1的路由func router01() http.Handler &#123;  e :&#x3D; gin.New()  e.Use(gin.Recovery())  e.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;    c.JSON(      http.StatusOK,      gin.H&#123;        &quot;code&quot;:  http.StatusOK,        &quot;error&quot;: &quot;Welcome server 01&quot;,      &#125;,    )  &#125;)  return e&#125;&#x2F;&#x2F; 服务器2的路由func router02() http.Handler &#123;  e :&#x3D; gin.New()  e.Use(gin.Recovery())  e.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;    c.JSON(      http.StatusOK,      gin.H&#123;        &quot;code&quot;:  http.StatusOK,        &quot;error&quot;: &quot;Welcome server 02&quot;,      &#125;,    )  &#125;)  return e&#125;func main() &#123;  &#x2F;&#x2F; 服务器1  server01 :&#x3D; &amp;http.Server&#123;    Addr:         &quot;:8080&quot;,    Handler:      router01(),    ReadTimeout:  5 * time.Second,    WriteTimeout: 10 * time.Second,  &#125;  &#x2F;&#x2F; 服务器2  server02 :&#x3D; &amp;http.Server&#123;    Addr:         &quot;:8081&quot;,    Handler:      router02(),    ReadTimeout:  5 * time.Second,    WriteTimeout: 10 * time.Second,  &#125;  &#x2F;&#x2F; 错误监听处理， 启动并发？  g.Go(func() error &#123;    err :&#x3D; server01.ListenAndServe()    if err !&#x3D; nil &amp;&amp; err !&#x3D; http.ErrServerClosed &#123;      log.Fatal(err)    &#125;    return err  &#125;)  g.Go(func() error &#123;    err :&#x3D; server02.ListenAndServe()    if err !&#x3D; nil &amp;&amp; err !&#x3D; http.ErrServerClosed &#123;      log.Fatal(err)    &#125;    return err  &#125;)  if err :&#x3D; g.Wait(); err !&#x3D; nil &#123;    log.Fatal(err)  &#125;&#125;</code></pre><h2 id="正常关机-x2F-重启-可能在部署时候会用？"><a href="#正常关机-x2F-重启-可能在部署时候会用？" class="headerlink" title="正常关机&#x2F;重启 ? 可能在部署时候会用？"></a>正常关机&#x2F;重启 ? 可能在部署时候会用？</h2><p>你想优雅地重启或停止 web 服务器吗？有一些方法可以做到这一点。</p><p>我们可以使用 fvbock&#x2F;endless 来替换默认的 ListenAndServe。更多详细信息，请参阅 issue #296。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">router :&#x3D; gin.Default()router.GET(&quot;&#x2F;&quot;, handler)&#x2F;&#x2F; [...]endless.ListenAndServe(&quot;:4242&quot;, router)</code></pre><p>替代方案:</p><p><strong>manners</strong>：可以优雅关机的 Go Http 服务器。<br><strong>graceful</strong>：Graceful 是一个 Go 扩展包，可以优雅地关闭 http.Handler 服务器。<br><strong>grace</strong>：Go 服务器平滑重启和零停机时间部署。<br>如果你使用的是 Go 1.8，可以不需要这些库！考虑使用 http.Server 内置的 Shutdown() 方法优雅地关机. 请参阅 gin 完整的 graceful-shutdown 示例。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; +build go1.8package mainimport (&quot;context&quot;&quot;log&quot;&quot;net&#x2F;http&quot;&quot;os&quot;&quot;os&#x2F;signal&quot;&quot;time&quot;&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;router :&#x3D; gin.Default()router.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;time.Sleep(5 * time.Second)c.String(http.StatusOK, &quot;Welcome Gin Server&quot;)&#125;)srv :&#x3D; &amp;http.Server&#123;Addr:    &quot;:8080&quot;,Handler: router,&#125;go func() &#123;&#x2F;&#x2F; 服务连接if err :&#x3D; srv.ListenAndServe(); err !&#x3D; nil &amp;&amp; err !&#x3D; http.ErrServerClosed &#123;log.Fatalf(&quot;listen: %s\n&quot;, err)&#125;&#125;()&#x2F;&#x2F; 等待中断信号以优雅地关闭服务器（设置 5 秒的超时时间）quit :&#x3D; make(chan os.Signal)signal.Notify(quit, os.Interrupt)&lt;-quitlog.Println(&quot;Shutdown Server ...&quot;)ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 5*time.Second)defer cancel()if err :&#x3D; srv.Shutdown(ctx); err !&#x3D; nil &#123;log.Fatal(&quot;Server Shutdown:&quot;, err)&#125;log.Println(&quot;Server exiting&quot;)&#125;</code></pre><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><h3 id="Build-a-single-binary-with-templates"><a href="#Build-a-single-binary-with-templates" class="headerlink" title="Build a single binary with templates"></a>Build a single binary with templates</h3><p>You can build a server into a single binary containing templates by using go-assets.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func main() &#123;  r :&#x3D; gin.New()  &#x2F;&#x2F; 加载模版  t, err :&#x3D; loadTemplate()  if err !&#x3D; nil &#123;    panic(err)  &#125;  &#x2F;&#x2F; 设置模版  r.SetHTMLTemplate(t)  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;    &#x2F;&#x2F; 返回html    c.HTML(http.StatusOK, &quot;&#x2F;html&#x2F;index.tmpl&quot;,nil)  &#125;)  r.Run(&quot;:8080&quot;)&#125;&#x2F;&#x2F; loadTemplate加载go资产生成器嵌入的模板func loadTemplate() (*template.Template, error) &#123;  t :&#x3D; template.New(&quot;&quot;)  for name, file :&#x3D; range Assets.Files &#123;    defer file.Close()    if file.IsDir() || !strings.HasSuffix(name, &quot;.tmpl&quot;) &#123;      continue    &#125;    h, err :&#x3D; ioutil.ReadAll(file)    if err !&#x3D; nil &#123;      return nil, err    &#125;    t, err &#x3D; t.New(name).Parse(string(h))    if err !&#x3D; nil &#123;      return nil, err    &#125;  &#125;  return t, nil&#125;</code></pre><p>See a complete example in the <a href="https://github.com/gin-gonic/examples/tree/master/assets-in-binary">https://github.com/gin-gonic/examples/tree/master/assets-in-binary</a> directory.</p><h2 id="数据绑定-1"><a href="#数据绑定-1" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="Bind-form-data-request-with-custom-struct"><a href="#Bind-form-data-request-with-custom-struct" class="headerlink" title="Bind form-data request with custom struct"></a>Bind form-data request with custom struct</h3><h3 id="Try-to-bind-body-into-different-structs"><a href="#Try-to-bind-body-into-different-structs" class="headerlink" title="Try to bind body into different structs"></a>Try to bind body into different structs</h3><h3 id="Bind-form-data-request-with-custom-struct-and-custom-tag"><a href="#Bind-form-data-request-with-custom-struct-and-custom-tag" class="headerlink" title="Bind form-data request with custom struct and custom tag"></a>Bind form-data request with custom struct and custom tag</h3><h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><h3 id="http2-server-push"><a href="#http2-server-push" class="headerlink" title="http2 server push"></a>http2 server push</h3><p>实际项目中很少用到</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">http.Pusher is supported only go1.8+. See the golang blog for detail information.package mainimport (  &quot;html&#x2F;template&quot;  &quot;log&quot;  &quot;net&#x2F;http&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)var html &#x3D; template.Must(template.New(&quot;https&quot;).Parse(&#96;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Https Test&lt;&#x2F;title&gt;  &lt;script src&#x3D;&quot;&#x2F;assets&#x2F;app.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;h1 style&#x3D;&quot;color:red;&quot;&gt;Welcome, Ginner!&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#96;))func main() &#123;  r :&#x3D; gin.Default()  &#x2F;&#x2F; 静态文件目录  r.Static(&quot;&#x2F;assets&quot;, &quot;.&#x2F;assets&quot;)  &#x2F;&#x2F;设置html模版  r.SetHTMLTemplate(html)  r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;    if pusher :&#x3D; c.Writer.Pusher(); pusher !&#x3D; nil &#123;      &#x2F;&#x2F; use pusher.Push() to do server push      if err :&#x3D; pusher.Push(&quot;&#x2F;assets&#x2F;app.js&quot;, nil); err !&#x3D; nil &#123;        log.Printf(&quot;Failed to push: %v&quot;, err)      &#125;    &#125;    c.HTML(http.StatusOK, &quot;https&quot;, gin.H&#123;      &quot;status&quot;: &quot;success&quot;,    &#125;)  &#125;)  &#x2F;&#x2F; Listen and Server in https:&#x2F;&#x2F;127.0.0.1:8080  &#x2F;&#x2F; https 证书  r.RunTLS(&quot;:8080&quot;, &quot;.&#x2F;testdata&#x2F;server.pem&quot;, &quot;.&#x2F;testdata&#x2F;server.key&quot;)&#125;</code></pre><h2 id="日志-1"><a href="#日志-1" class="headerlink" title="日志"></a>日志</h2><h3 id="Define-format-for-the-log-of-routes"><a href="#Define-format-for-the-log-of-routes" class="headerlink" title="Define format for the log of routes"></a>Define format for the log of routes</h3><p>The default log of routes is:</p><pre class="line-numbers language-s" data-language="s"><code class="language-s">[GIN-debug] POST &#x2F;foo --&gt; main.main.func1 (3 handlers)[GIN-debug] GET &#x2F;bar --&gt; main.main.func2 (3 handlers)[GIN-debug] GET &#x2F;status --&gt; main.main.func3 (3 handlers)</code></pre><p>If you want to log this information in given format (e.g. JSON, key values or something else), then you can define this format with gin.DebugPrintRouteFunc. In the example below, we log all routes with standard log package but you can use another log tools that suits of your needs.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">import (  &quot;log&quot;  &quot;net&#x2F;http&quot;  &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;  r :&#x3D; gin.Default()  gin.DebugPrintRouteFunc &#x3D; func(httpMethod, absolutePath, handlerName string, nuHandlers int) &#123;    log.Printf(&quot;endpoint %v %v %v %v\n&quot;, httpMethod, absolutePath, handlerName, nuHandlers)  &#125;  r.POST(&quot;&#x2F;foo&quot;, func(c *gin.Context) &#123;    c.JSON(http.StatusOK, &quot;foo&quot;)  &#125;)  r.GET(&quot;&#x2F;bar&quot;, func(c *gin.Context) &#123;    c.JSON(http.StatusOK, &quot;bar&quot;)  &#125;)  r.GET(&quot;&#x2F;status&quot;, func(c *gin.Context) &#123;    c.JSON(http.StatusOK, &quot;ok&quot;)  &#125;)  &#x2F;&#x2F; Listen and Server in http:&#x2F;&#x2F;0.0.0.0:8080  r.Run()&#125;</code></pre><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="Set-and-get-a-cookie"><a href="#Set-and-get-a-cookie" class="headerlink" title="Set and get a cookie"></a>Set and get a cookie</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">import (    &quot;fmt&quot;    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;)func main() &#123;    router :&#x3D; gin.Default()    router.GET(&quot;&#x2F;cookie&quot;, func(c *gin.Context) &#123;        &#x2F;&#x2F; 获取cookie, 没设置“gin_cookie”会报错        cookie, err :&#x3D; c.Cookie(&quot;gin_cookie&quot;)        &#x2F;&#x2F; 遇到错误设置cookie        if err !&#x3D; nil &#123;            cookie &#x3D; &quot;NotSet&quot;            &#x2F;&#x2F; 设置cookie            c.SetCookie(&quot;gin_cookie&quot;, &quot;test&quot;, 3600, &quot;&#x2F;&quot;, &quot;localhost&quot;, false, true)        &#125;        fmt.Printf(&quot;Cookie value: %s \n&quot;, cookie)    &#125;)    router.Run()&#125;</code></pre><h2 id="表名规则"><a href="#表名规则" class="headerlink" title="表名规则"></a>表名规则</h2><p>db.logMode(true)来显示日志</p><ol><li>表名规则，根据 struct 名称改成小写，并且加上复数形式</li></ol><p>例子： struct 名为：</p><ol><li>Test，对应表名为 tests</li><li>TopicClass,表名为 topic_classes 注意复数，英文基础：ch、sh、x、s 结尾时，加 es 变成复数</li></ol><p>可以使用<code>db.SingularTable(true)</code>来使其不为复数</p><h2 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h2><h3 id="session、redis、orm、数据库链接"><a href="#session、redis、orm、数据库链接" class="headerlink" title="session、redis、orm、数据库链接"></a>session、redis、orm、数据库链接</h3><h3 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a><a href="https://zhuanlan.zhihu.com/p/184957074" target="_blank" >热重载</a></h3><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/cosmtrek/air"  >https://github.com/cosmtrek/air</a> <img src="https://img.shields.io/github/stars/cosmtrek/air?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/oxequa/realize">https://github.com/oxequa/realize</a><img src="https://img.shields.io/github/stars/oxequa/realize?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/codegangsta/gin">https://github.com/codegangsta/gin</a><img src="https://img.shields.io/github/stars/codegangsta/gin?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/gravityblast/fresh">https://github.com/gravityblast/fresh</a><img src="https://img.shields.io/github/stars/gravityblast/fresh?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/beego/bee">https://github.com/beego/bee</a><img src="https://img.shields.io/github/stars/beego/bee?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/silenceper/gowatch">https://github.com/silenceper/gowatch</a><img src="https://img.shields.io/github/stars/silenceper/gowatch?style=social" /></div><h3 id="docker-部署"><a href="#docker-部署" class="headerlink" title="docker 部署"></a>docker 部署</h3><h2 id="路很长"><a href="#路很长" class="headerlink" title="路很长"></a>路很长</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/overnote/over-golang">https://github.com/overnote/over-golang</a><img src="https://img.shields.io/github/stars/overnote/over-golang?style=social" /></div><img src="https://github.com/overnote/over-golang/raw/master/images/go/go-develep.png" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/gin-gonic/gin" target="_blank" >gin-gonic&#x2F;gin</a></p><p><a href="https://golang.google.cn/doc/tutorial/web-service-gin" target="_blank" >Tutorial: Developing a RESTful API with Go and Gin</a></p><p><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949445" target="_blank" >gin_book</a></p><p><a href="https://shields.io/category/social" target="_blank" >GitHub Repo stars</a></p><h2 id="博客收录"><a href="#博客收录" class="headerlink" title="博客收录"></a>博客收录</h2><p><a href="https://liwenzhou.com/" target="_blank" >https://liwenzhou.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言 特殊语法</title>
      <link href="//post/2022-10-15go.html"/>
      <url>//post/2022-10-15go.html</url>
      
        <content type="html"><![CDATA[<h2 id="目前所遇到最好的教程"><a href="#目前所遇到最好的教程" class="headerlink" title="目前所遇到最好的教程"></a>目前所遇到最好的教程</h2><p><a href="https://www.topgoer.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E7%A8%8B%E5%BA%8F.html" target="_blank" >go 教程</a></p><p><a href="https://studygolang.com/pkgdoc" target="_blank" >https://studygolang.com/pkgdoc</a></p><h2 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h2><!-- <img src="http://t-blog-images.aijs.top/img/202210220808678.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222111407.jpg" /><h2 id="下载安装-go"><a href="#下载安装-go" class="headerlink" title="下载安装 go"></a>下载安装 go</h2><p><a href="https://golang.google.cn/doc/install" target="_blank" >官方安装包地址</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ go versiongo version go1.19.2 darwin&#x2F;amd64</code></pre><h2 id="Tour-教程"><a href="#Tour-教程" class="headerlink" title="Tour 教程"></a>Tour 教程</h2><p>之前没找到到这文档，看了菜鸟教程的 go，傻白白地以为没教程</p><p><a href="https://tour.go-zh.org/welcome/1" target="_blank" >https://tour.go-zh.org/welcome/1</a></p><img src="http://t-blog-images.aijs.top/img/202210180958616.webp" /> <h3 id="命名返回"><a href="#命名返回" class="headerlink" title="命名返回"></a>命名返回</h3><p><a href="https://tour.go-zh.org/basics/7" target="_blank" >见</a></p><p><strong>实现</strong></p><ul><li>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</li><li>没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。</li></ul><p><strong>功能</strong></p><ul><li>返回值的名称应当具有一定的意义，它可以作为文档使用。</li></ul><p><strong>优缺点：</strong><br>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><!-- <img src="http://t-blog-images.aijs.top/img/202210220851614.png" /> --><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;&#x2F;&#x2F; 返回多个返回值，有形参名称的func foo3(a string, b int) (r1 int, r2 int) &#123;fmt.Println(&quot;----foo3 ----&quot;)fmt.Println(&quot;a &#x3D;&quot;, a)fmt.Println(&quot;b &#x3D;&quot;, b)&#x2F;&#x2F; r1r2属于foo3的形参，初始化默认的值是0&#x2F;&#x2F; r1r2作用域空间是foo3整个函数体的&#123;&#125;空间fmt.Println(&quot;r1 &#x3D;&quot;, r1)fmt.Println(&quot;r2 &quot;, r2)&#x2F;&#x2F; 给有名称的返回值变量赋值r1 &#x3D; 1000r2 &#x3D; 2000return&#125;</code></pre><h2 id="If"><a href="#If" class="headerlink" title="If"></a>If</h2><p>if 的简短语句<br>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。</p><p>if 和 else<br>在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;fmt&quot;&quot;math&quot;)func pow(x, n, lim float64) float64 &#123;if v :&#x3D; math.Pow(x, n); v &lt; lim &#123;return v&#125; else &#123;fmt.Printf(&quot;%g &gt;&#x3D; %g\n&quot;, v, lim)&#125;&#x2F;&#x2F; 这里开始就不能使用 v 了return lim&#125;func main() &#123;fmt.Println(pow(3, 2, 10),pow(3, 3, 20),)&#125;</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">if initialization; condition &#123;    &#x2F;&#x2F; do something&#125;&#x2F;&#x2F; 例如:val :&#x3D; 10if val &gt; max &#123;    &#x2F;&#x2F; do something&#125;&#x2F;&#x2F; 你也可以这样写:if val :&#x3D; 10; val &gt; max &#123;    &#x2F;&#x2F; do something&#125;&#x2F;&#x2F; ————————————————&#x2F;&#x2F; 原文作者：Go 技术论坛文档：《Go 入门指南（）》&#x2F;&#x2F; 转自链接：https:&#x2F;&#x2F;learnku.com&#x2F;docs&#x2F;the-way-to-go&#x2F;if-else-structure&#x2F;3592&#x2F;&#x2F; 版权声明：翻译文档著作权归译者和 LearnKu 社区所有。转载请保留原文链接</code></pre><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p><h3 id="与众不同"><a href="#与众不同" class="headerlink" title="与众不同"></a>与众不同</h3><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。<br><em>实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。</em><br>除非以 <em>fallthrough 语句结束，否则分支会自动终止</em> Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p><h3 id="switch-的求值顺序"><a href="#switch-的求值顺序" class="headerlink" title="switch 的求值顺序"></a>switch 的求值顺序</h3><p>switch 的求值顺序<br>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; （例如，switch i &#123;case 0:case f():&#125;&#x2F;&#x2F; 在 i&#x3D;&#x3D;0 时 f 不会被调用。）</code></pre><h3 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a>没有条件的 switch</h3><p>没有条件的 switch 同 switch true 一样。</p><p>这种形式能将一长串 if-then-else 写得更加清晰。</p><img src="http://t-blog-images.aijs.top/img/202210201608273.webp" /><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><h3 id="推迟到外函数执行"><a href="#推迟到外函数执行" class="headerlink" title="推迟到外函数执行"></a>推迟到外函数执行</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; defer&#x2F;&#x2F; defer 语句会将函数推迟到外层函数返回之后执行。&#x2F;&#x2F; 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。package mainimport &quot;fmt&quot;func main() &#123;defer fmt.Println(&quot;world&quot;)fmt.Println(&quot;hello&quot;)&#125;&#x2F;&#x2F; hello&#x2F;&#x2F; world</code></pre><p>哦～原来如此，<code>defer db.Close()</code></p><h3 id="执行推迟时候，出栈"><a href="#执行推迟时候，出栈" class="headerlink" title="执行推迟时候，出栈"></a>执行推迟时候，出栈</h3><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是<code>具有相同唯一类型</code>的一组<code>已编号且长度固定</code>的数据项序列，这种类型可以是任意的<code>原始类型</code>例如整型、字符串或者<code>自定义类型</code></p><p>语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var variable_name [SIZE] variable_type</code></pre><p><strong>数组初始化</strong></p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; [] 被用于限定大小，&#123;&#125; 用于内容，与其他语言不同var balance &#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></pre><h3 id="x3D"><a href="#x3D" class="headerlink" title=":&#x3D;"></a>:&#x3D;</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 我们也可以通过字面量在声明数组的同时快速初始化数组：balance :&#x3D; [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; &#x2F;&#x2F; :&#x3D; 声明赋值运算符</code></pre><h3 id="长度不定"><a href="#长度不定" class="headerlink" title="长度不定"></a>长度不定</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 如果数组长度不确定，可以使用 ... 代替数组的长度，&#x2F;&#x2F; 编译器会根据元素个数自行推断数组的长度：var balance &#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;&#x2F;&#x2F; 或balance :&#x3D; [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;&#x2F;&#x2F; 如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</code></pre><h3 id="指定索引赋值"><a href="#指定索引赋值" class="headerlink" title="指定索引赋值"></a>指定索引赋值</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 将索引为 1 和 3 的元素初始化balance :&#x3D; [5]float32&#123;1:2.0,3:7.0&#125;&#x2F;&#x2F; 初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。</code></pre><h3 id="自动推断"><a href="#自动推断" class="headerlink" title="自动推断"></a>自动推断</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：balance[4] &#x3D; 50.0</code></pre><h3 id="多维数组语法"><a href="#多维数组语法" class="headerlink" title="多维数组语法"></a>多维数组语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;    &#x2F;&#x2F; Step 1: 创建数组    values :&#x3D; [][]int&#123;&#125; &#x2F;&#x2F; 这里要注意下，目前见到的例子都是空值初始化    &#x2F;&#x2F; Step 2: 使用 append() 函数向空的二维数组添加两行一维数组    row1 :&#x3D; []int&#123;1, 2, 3&#125;    row2 :&#x3D; []int&#123;4, 5, 6&#125;    values &#x3D; append(values, row1)    values &#x3D; append(values, row2)    &#x2F;&#x2F; Step 3: 显示两行数据    fmt.Println(&quot;Row 1&quot;)    fmt.Println(values[0])    fmt.Println(&quot;Row 2&quot;)    fmt.Println(values[1])    &#x2F;&#x2F; Step 4: 访问第一个元素    fmt.Println(&quot;第一个元素为：&quot;)    fmt.Println(values[0][0])&#125;</code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h3><p><strong>指向指针的指针</strong><br>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p><p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p><p>指向指针的指针变量声明格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var ptr **int;</code></pre><p><strong>例子：</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;   var a int   var ptr *int   var pptr **int   a &#x3D; 3000   &#x2F;* 指针 ptr 地址 *&#x2F;   ptr &#x3D; &amp;a   &#x2F;* 指向指针 ptr 地址 *&#x2F;   pptr &#x3D; &amp;ptr   &#x2F;* 获取 pptr 的值 *&#x2F;   fmt.Printf(&quot;变量 a &#x3D; %d\n&quot;, a )   fmt.Printf(&quot;指针变量 *ptr &#x3D; %d\n&quot;, *ptr )   fmt.Printf(&quot;指向指针的指针变量 **pptr &#x3D; %d\n&quot;, **pptr)&#125;</code></pre><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>其他语言对比：go 语言保留了，OC 中的结构体？可以理解为类的另一种写法</p></li><li><p>自身数组区别：Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p></li><li><p>构造函数有没有联系：我在想：结构体里的<code>构</code>是不是，构造函数的 <code>构</code></p></li></ul><p>函数传值：传值：直接结构体生成的变量，传引用：变量前<code>*</code> <code>*user</code></p><!-- <img src="http://t-blog-images.aijs.top/img/202210221329044.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222110201.jpg" /><!-- <img src="http://t-blog-images.aijs.top/img/202210221336286.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222124574.jpg" /><!-- <img src="http://t-blog-images.aijs.top/img/202210221336095.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222124989.jpg" /><h3 id="结构体继承"><a href="#结构体继承" class="headerlink" title="结构体继承"></a>结构体继承</h3><p><strong>子类实现</strong></p><!-- <img src="http://t-blog-images.aijs.top/img/202210221425432.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222124349.jpg" /><p><strong>实例化</strong></p><p>两种赋值方式， 第一种没见过吧，～～</p><!-- <img src="http://t-blog-images.aijs.top/img/202210221425435.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222125092.jpg" /><h2 id="万能类型-与-断言"><a href="#万能类型-与-断言" class="headerlink" title="万能类型 与 断言"></a>万能类型 与 断言</h2><!-- <img src="http://t-blog-images.aijs.top/img/202210221504291.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222125112.jpg" /><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><!-- <img src="http://t-blog-images.aijs.top/img/202210221335053.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222123797.jpg" /><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 结构体定义需要使用 type 和 struct 语句。&#x2F;&#x2F; struct 语句定义一个新的数据类型，结构体中有一个或多个成员。&#x2F;&#x2F; type 语句设定了结构体的名称。结构体的格式如下：type struct_variable_type struct &#123;   member definition   member definition   ...   member definition&#125;</code></pre><p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">variable_name :&#x3D; structure_variable_type &#123;value1, value2...valuen&#125;或variable_name :&#x3D; structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</code></pre><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;    &#x2F;&#x2F; 创建一个新的结构体    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;)    &#x2F;&#x2F; 也可以使用 key &#x3D;&gt; value 格式    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程&quot;, book_id: 6495407&#125;)    &#x2F;&#x2F; 忽略的字段为 0 或 空   fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.runoob.com&quot;&#125;)&#125;</code></pre><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>你可以定义<code>指向结构体的指针类似于其他指针变量</code>，格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">var struct_pointer *Books&#x2F;&#x2F; 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：struct_pointer &#x3D; &amp;Book1&#x2F;&#x2F; 使用结构体指针访问结构体成员，使用 &quot;.&quot; 操作符：struct_pointer.title</code></pre><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;   var Book1 Books        &#x2F;* 声明 Book1 为 Books 类型 *&#x2F;   var Book2 Books        &#x2F;* 声明 Book2 为 Books 类型 *&#x2F;   &#x2F;* book 1 描述 *&#x2F;   Book1.title &#x3D; &quot;Go 语言&quot;   Book1.author &#x3D; &quot;www.runoob.com&quot;   Book1.subject &#x3D; &quot;Go 语言教程&quot;   Book1.book_id &#x3D; 6495407   &#x2F;* book 2 描述 *&#x2F;   Book2.title &#x3D; &quot;Python 教程&quot;   Book2.author &#x3D; &quot;www.runoob.com&quot;   Book2.subject &#x3D; &quot;Python 语言教程&quot;   Book2.book_id &#x3D; 6495700   &#x2F;* 打印 Book1 信息 *&#x2F;   printBook(&amp;Book1)   &#x2F;* 打印 Book2 信息 *&#x2F;   printBook(&amp;Book2)&#125;func printBook( book *Books ) &#123;   fmt.Printf( &quot;Book title : %s\n&quot;, book.title)   fmt.Printf( &quot;Book author : %s\n&quot;, book.author)   fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject)   fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id)&#125;</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul><li>python 中也有切片，与 go 很像，又与 python 区别很大</li></ul><p>Go 语言切片是<code>对数组的抽象</code>。</p><p>切片出现的原因：go 数组长度固定，不够灵活</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，<br>Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，<code>可以追加元素，在追加时可能使切片的容量增大</code>。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 方式1var identifier []type&#x2F;&#x2F; 方式2 使用 make() 函数来创建切片var slice1 []type &#x3D; make([]type, len)&#x2F;&#x2F; 方式3 也可以简写为slice1 :&#x3D; make([]type, len)</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类 python</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 直接初始化切片，[] 表示是切片类型，&#123;1,2,3&#125; 初始化值依次是 1,2,3，其 cap&#x3D;len&#x3D;3。s :&#x3D;[] int &#123;1,2,3 &#125;&#x2F;&#x2F; 初始化切片 s，是数组 arr 的引用。s :&#x3D; arr[:]&#x2F;&#x2F; 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。s :&#x3D; arr[startIndex:endIndex] &#x2F;&#x2F; 左闭右开&#x2F;&#x2F; 默认 endIndex 时将表示一直到arr的最后一个元素。s :&#x3D; arr[startIndex:]&#x2F;&#x2F; 默认 startIndex 时将表示从 arr 的第一个元素开始。s :&#x3D; arr[:endIndex]&#x2F;&#x2F; 通过切片 s 初始化切片 s1。s1 :&#x3D; s[startIndex:endIndex]&#x2F;&#x2F; 通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片。s :&#x3D;make([]int,len,cap)</code></pre><h3 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h3><p><code>make([]T, length, capacity/*可选参数，容量*/)</code></p><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 以下为具体实例：&#x2F;&#x2F; 实例package mainimport &quot;fmt&quot;func main() &#123;   var numbers &#x3D; make([]int,3&#x2F;**长度 *&#x2F;,5&#x2F;**容量 *&#x2F;)   printSlice(numbers)&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\n&quot;,len(x),cap(x),x)&#125;&#x2F;&#x2F; 以上实例运行输出结果为:len&#x3D;3 cap&#x3D;5 slice&#x3D;[0 0 0]</code></pre><h3 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h3><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p><h3 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h3><p>注意点：切片声明时候赋值用<code>&#123;&#125;</code>，在切片赋值和打印时候都是数组<code>[item1,item2, ...]</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;   &#x2F;* 创建切片 *&#x2F;   numbers :&#x3D; []int&#123;0,1,2,3,4,5,6,7,8&#125;   printSlice(numbers) &#x2F;&#x2F; len&#x3D;9 cap&#x3D;9 slice&#x3D;[0 1 2 3 4 5 6 7 8]   &#x2F;* 打印原始切片 *&#x2F;   fmt.Println(&quot;numbers &#x3D;&#x3D;&quot;, numbers) &#x2F;&#x2F; numbers &#x3D;&#x3D; [0 1 2 3 4 5 6 7 8]   &#x2F;* 打印子切片从索引1(包含) 到索引4(不包含)*&#x2F;   fmt.Println(&quot;numbers[1:4] &#x3D;&#x3D;&quot;, numbers[1:4]) &#x2F;&#x2F; numbers[1:4] &#x3D;&#x3D; [1 2 3]   &#x2F;* 默认下限为 0*&#x2F;   fmt.Println(&quot;numbers[:3] &#x3D;&#x3D;&quot;, numbers[:3]) &#x2F;&#x2F; numbers[:3] &#x3D;&#x3D; [0 1 2]   &#x2F;* 默认上限为 len(s)*&#x2F;   fmt.Println(&quot;numbers[4:] &#x3D;&#x3D;&quot;, numbers[4:]) &#x2F;&#x2F; numbers[4:] &#x3D;&#x3D; [4 5 6 7 8]   numbers1 :&#x3D; make([]int,0,5)   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;5 slice&#x3D;[]   &#x2F;* 打印子切片从索引  0(包含) 到索引 2(不包含) *&#x2F;   number2 :&#x3D; numbers[:2]   printSlice(number2) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;9 slice&#x3D;[0 1]   &#x2F;* 打印子切片从索引 2(包含) 到索引 5(不包含) *&#x2F;   number3 :&#x3D; numbers[2:5]   printSlice(number3) &#x2F;&#x2F; len&#x3D;3 cap&#x3D;7 slice&#x3D;[2 3 4]&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\n&quot;,len(x),cap(x),x)&#125;</code></pre><h3 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h3><p><strong>这个又何 python</strong>很像，python 中，有些申请的变量是不能更改的，更改操作是对原来的拷贝再处理过程</p><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;   var numbers []int   printSlice(numbers) &#x2F;&#x2F; len&#x3D;0 cap&#x3D;0 slice&#x3D;[]   &#x2F;* 允许追加空切片 *&#x2F;   numbers &#x3D; append(numbers, 0)   printSlice(numbers) &#x2F;&#x2F; len&#x3D;1 cap&#x3D;1 slice&#x3D;[0]   &#x2F;* 向切片添加一个元素 *&#x2F;   numbers &#x3D; append(numbers, 1)   printSlice(numbers) &#x2F;&#x2F; len&#x3D;2 cap&#x3D;2 slice&#x3D;[0 1]   &#x2F;* 同时添加多个元素 *&#x2F;   numbers &#x3D; append(numbers, 2,3,4)   printSlice(numbers) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;6 slice&#x3D;[0 1 2 3 4]   &#x2F;* 创建切片 numbers1 是之前切片的两倍容量*&#x2F;   numbers1 :&#x3D; make([]int, len(numbers), (cap(numbers))*2)   &#x2F;* 拷贝 numbers 的内容到 numbers1 *&#x2F;   copy(numbers1,numbers)   printSlice(numbers1) &#x2F;&#x2F; len&#x3D;5 cap&#x3D;12 slice&#x3D;[0 1 2 3 4]&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len&#x3D;%d cap&#x3D;%d slice&#x3D;%v\n&quot;,len(x),cap(x),x)&#125;</code></pre><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>注意： 这玩意和 python 很不一样，这个是标识符， python 的 range 是个函数</p><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素</p><ul><li><code>数组</code>和<code>切片</code>中它返回元素的索引和索引对应的值</li><li>集合中返回 key-value 对</li></ul><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>for 循环的 range 格式可以对 <code>slice</code>、<code>map</code>、<code>数组</code>、<code>字符串</code>等进行迭代循环。格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 语法1for key, value :&#x3D; range oldMap &#123;    newMap[key] &#x3D; value&#125;&#x2F;&#x2F; 语法2for key :&#x3D; range oldMap&#x2F;&#x2F; 语法3for key, _ :&#x3D; range oldMap&#x2F;&#x2F; 语法4for _, value :&#x3D; range oldMap</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>go map 没有 javascript 那么多 api,简单来说就一个，那就是像对象一样赋值</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;* 声明变量，默认 map 是 nil *&#x2F;var map_variable map[key_data_type]value_data_type&#x2F;* 使用 make 函数 *&#x2F;map_variable :&#x3D; make(map[key_data_type]value_data_type)</code></pre><h3 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;    var countryCapitalMap map[string]string &#x2F;*创建集合 *&#x2F;    countryCapitalMap &#x3D; make(map[string]string)    &#x2F;* map插入key - value对,各个国家对应的首都 *&#x2F;    countryCapitalMap [ &quot;France&quot; ] &#x3D; &quot;巴黎&quot;    countryCapitalMap [ &quot;Italy&quot; ] &#x3D; &quot;罗马&quot;    countryCapitalMap [ &quot;Japan&quot; ] &#x3D; &quot;东京&quot;    countryCapitalMap [ &quot;India &quot; ] &#x3D; &quot;新德里&quot;    &#x2F;*使用键输出地图值 *&#x2F;    for country :&#x3D; range countryCapitalMap &#123;        fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])    &#125;    &#x2F;*查看元素在集合中是否存在 *&#x2F;    capital, ok :&#x3D; countryCapitalMap [ &quot;American&quot; ] &#x2F;*如果确定是真实的,则存在,否则不存在 *&#x2F;    &#x2F;*fmt.Println(capital) *&#x2F;    &#x2F;*fmt.Println(ok) *&#x2F;    if (ok) &#123;        fmt.Println(&quot;American 的首都是&quot;, capital)    &#125; else &#123;        fmt.Println(&quot;American 的首都不存在&quot;)    &#125;&#125;</code></pre><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>go map 删除元素用的是 delete 方法</p><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">delete(countryCapitalMap, &quot;France&quot;)</code></pre><h3 id="example-3"><a href="#example-3" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;        &#x2F;* 创建map *&#x2F;        countryCapitalMap :&#x3D; map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;        fmt.Println(&quot;原始地图&quot;)        &#x2F;* 打印地图 *&#x2F;        for country :&#x3D; range countryCapitalMap &#123;                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])        &#125;        &#x2F;*删除元素*&#x2F; delete(countryCapitalMap, &quot;France&quot;)        fmt.Println(&quot;法国条目被删除&quot;)        fmt.Println(&quot;删除元素后地图&quot;)        &#x2F;*打印地图*&#x2F;        for country :&#x3D; range countryCapitalMap &#123;                fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [ country ])        &#125;&#125;</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">type_name(expression) &#x2F;&#x2F; type_name 为类型，expression 为表达式。</code></pre><h3 id="example-4"><a href="#example-4" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;   var sum int &#x3D; 17   var count int &#x3D; 5   var mean float32   mean &#x3D; float32(sum)&#x2F;float32(count) &#x2F;&#x2F; 这里   fmt.Printf(&quot;mean 的值为: %f\n&quot;,mean)&#125;</code></pre><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><p>Go 语言提供了另外一种数据类型即接口，它<strong>把所有的具有共性的方法定义在一起</strong>，任何<strong>其他类型只要实现了这些方法就是实现了这个接口</strong>。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;* 定义接口 *&#x2F;type interface_name interface &#123;   method_name1 [return_type]   method_name2 [return_type]   method_name3 [return_type]   ...   method_namen [return_type]&#125;&#x2F;* 定义结构体 *&#x2F;type struct_name struct &#123;   &#x2F;* variables *&#x2F;&#125;&#x2F;* 实现接口方法 *&#x2F;func (struct_name_variable struct_name) method_name1() [return_type] &#123;   &#x2F;* 方法实现 *&#x2F;&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123;   &#x2F;* 方法实现*&#x2F;&#125;</code></pre><h3 id="example-5"><a href="#example-5" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;fmt&quot;)type Phone interface &#123;    call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) &#x2F;**前面这块 *&#x2F;call() &#123;    fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone)&#x2F;**前面这块 *&#x2F; call() &#123;    fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123;    var phone Phone &#x2F;&#x2F; interface 类型变量    &#x2F;&#x2F; 我本以为没有new 关键字，原来有啊    &#x2F;&#x2F; 不明白这里为什么 NokiaPhone的实例可以赋值给 phone，原因：**其他类型只要实现了这些方法就是实现了这个接口**    phone &#x3D; new(NokiaPhone)    phone.call()    phone &#x3D; new(IPhone)    phone.call()&#125;</code></pre><h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><h3 id="reflect-数据结构"><a href="#reflect-数据结构" class="headerlink" title="reflect 数据结构"></a>reflect 数据结构</h3><!-- <img src="http://t-blog-images.aijs.top/img/202210221536036.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222115379.jpg" /><h3 id="获取字段、类型、值"><a href="#获取字段、类型、值" class="headerlink" title="获取字段、类型、值"></a>获取字段、类型、值</h3><!-- <img src="http://t-blog-images.aijs.top/img/202210221536613.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222102153.png" /><!-- <img src="http://t-blog-images.aijs.top/img/202210221707726.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222125508.jpg" /><h3 id="结构体数据转-json"><a href="#结构体数据转-json" class="headerlink" title="结构体数据转 json"></a>结构体数据转 json</h3><!-- <img src="http://t-blog-images.aijs.top/img/202210221713548.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222106998.jpg" /><h3 id="json-转结构体数据"><a href="#json-转结构体数据" class="headerlink" title="json 转结构体数据"></a>json 转结构体数据</h3><img src="http://t-blog-images.aijs.top/img/202210221715593.png" /><h3 id="结构体标签"><a href="#结构体标签" class="headerlink" title="结构体标签"></a>结构体标签</h3><img src="http://t-blog-images.aijs.top/img/202210221724590.png" /><!-- <img src="http://t-blog-images.aijs.top/img/202210221726291.png" /> --><h2 id="Reflect-api-及作用"><a href="#Reflect-api-及作用" class="headerlink" title="Reflect api 及作用 ?"></a>Reflect api 及作用 ?</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; - 获取类型信息：reflect.TypeOf，是静态的 &#x2F;&#x2F; 结构体&#x2F;&#x2F; - 获取值信息：reflect.ValueOf，是动态的 &#x2F;&#x2F; &#123;1 zs 20&#125;&#x2F;&#x2F; - 遍历探测其 属性 &#x2F;&#x2F; NumField()&#x2F;&#x2F; - 遍历探测其 方法 &#x2F;&#x2F; NumMethod()   &#x2F;&#x2F;  &#123;&quot;Name&quot;: &quot;Hello&quot;, &quot;Type&quot;: func(main.User)&#125;&#x2F;&#x2F; reflect.Value提供了Elem()方法，可以获得指针向指向的value，设置的是指针所指向的内容 https:&#x2F;&#x2F;www.topgoer.cn&#x2F;docs&#x2F;gozhuanjia&#x2F;chapter066.1-reflect&#x2F;&#x2F; 其他api见文档 https:&#x2F;&#x2F;pkg.go.dev&#x2F;reflect</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (&quot;fmt&quot;&quot;reflect&quot;)&#x2F;&#x2F; 定义结构体type User struct &#123;Id   intName stringAge  int&#125;&#x2F;&#x2F; 绑方法func (u User) Hello() &#123;fmt.Println(&quot;Hello&quot;)&#125;&#x2F;&#x2F; 传入interface&#123;&#125;func Poni(o interface&#123;&#125;) &#123;t :&#x3D; reflect.TypeOf(o) &#x2F;&#x2F; 结构体fmt.Println(&quot;类型：&quot;, t)fmt.Println(&quot;字符串类型：&quot;, t.Name())&#x2F;&#x2F; 获取值v :&#x3D; reflect.ValueOf(o)fmt.Println(v)&#x2F;&#x2F; 可以获取所有属性&#x2F;&#x2F; 获取结构体字段个数：t.NumField()for i :&#x3D; 0; i &lt; t.NumField(); i++ &#123; &#x2F;&#x2F; 遍历探测其Filed&#x2F;&#x2F; 取每个字段f :&#x3D; t.Field(i)fmt.Printf(&quot;%s : %v&quot;, f.Name, f.Type) &#x2F;&#x2F; Id : int&#x2F;&#x2F; 获取字段的值信息&#x2F;&#x2F; Interface()：获取字段对应的值val :&#x3D; v.Field(i).Interface() &#x2F;&#x2F; 奇怪，Interface竟然能拿到值&#x2F;&#x2F; fmt.Println(&quot;  val :&quot;, val) &#x2F;&#x2F;   val : 1    &#x2F;&#x2F; fmt.Println(&quot;Name Type  val :&quot;, f.Name, f.Type, val)    &#x2F;&#x2F; Name Type  val : Id int 1    &#x2F;&#x2F; Name Type  val : Name string zs    &#x2F;&#x2F; Name Type  val : Age int 20&#125;fmt.Println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;)for i :&#x3D; 0; i &lt; t.NumMethod(); i++ &#123;m :&#x3D; t.Method(i)fmt.Println(m.Name)fmt.Println(m.Type)&#125;&#125;func main() &#123;u :&#x3D; User&#123;1, &quot;zs&quot;, 20&#125;Poni(u)&#125;&#x2F;&#x2F; 类型： main.User&#x2F;&#x2F; 字符串类型： User&#x2F;&#x2F; &#123;1 zs 20&#125;&#x2F;&#x2F; Id : int  val : 1&#x2F;&#x2F; Name : string  val : zs&#x2F;&#x2F; Age : int  val : 20&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F; Hello&#x2F;&#x2F; func(main.User)&#x2F;&#x2F; Program exited.</code></pre><p><a href="https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/%E5%8F%8D%E5%B0%84.html" target="_blank" >参考</a></p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p><a href="https://juejin.cn/post/6844903559335526407" target="_blank" >Golang 的反射 reflect 深入理解和示例</a></p><h2 id="Go-的-json-解析：Marshal-与-Unmarshal"><a href="#Go-的-json-解析：Marshal-与-Unmarshal" class="headerlink" title="Go 的 json 解析：Marshal 与 Unmarshal"></a>Go 的 json 解析：Marshal 与 Unmarshal</h2><ul><li>json.Marshal 结构体转 json</li><li>json.Unmarshal json 转结构体</li></ul><h3 id="json-Marshal"><a href="#json-Marshal" class="headerlink" title="json.Marshal"></a>json.Marshal</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">import (    &quot;encoding&#x2F;json&quot;    &quot;fmt&quot;)type User struct &#123;    Name  string &#96;json:&quot;user_name&quot;&#96;    Age   int    &#96;json:&quot;age&quot;&#96;    sex   string    Work1 *Work1    Work2 *Work2    Work3 Work3    Work4 interface&#123;&#125; &#96;json:&quot;work4&quot;&#96;&#125;type Work1 struct &#123;    Name   string &#96;json:&quot;work1_name&quot;&#96;    Salary float32&#125;type Work2 struct &#123;    Name   string &#96;json:&quot;work2_name&quot;&#96;    Salary float32&#125;type Work3 struct &#123;    Name   string &#96;json:&quot;work3_name&quot;&#96;    Salary float32&#125;type Work4 struct &#123;    Name    string &#96;json:&quot;work4_name&quot;&#96;    Salary  float32    Address string &#96;json:&quot;work4_add&quot;&#96;&#125;func main() &#123;    &#x2F;&#x2F; 实例化User    u1 :&#x3D; User&#123;        Name: &quot;ares&quot;,        Age:  18,        sex:  &quot;男&quot;,    &#125;    &#x2F;&#x2F; 指针    w1 :&#x3D; Work1&#123;        Name:   &quot;god1&quot;,        Salary: 100,    &#125;    u1.Work1 &#x3D; &amp;w1    &#x2F;&#x2F; 指针    w2 :&#x3D; new(Work2)    w2.Name &#x3D; &quot;god2&quot;    w2.Salary &#x3D; 200    u1.Work2 &#x3D; w2    &#x2F;&#x2F; 非指针    w3 :&#x3D; Work3&#123;        Name:   &quot;god3&quot;,        Salary: 300,    &#125;    u1.Work3 &#x3D; w3    &#x2F;&#x2F; 非指针    w4 :&#x3D; Work4&#123;        Name:    &quot;god4&quot;,        Salary:  400,        Address: &quot;cbd&quot;,    &#125;    u1.Work4 &#x3D; w4    &#x2F;&#x2F;Marshal失败时err!&#x3D;nil    jsonU, err :&#x3D; json.Marshal(u1)    if err !&#x3D; nil &#123;        fmt.Println(&quot;生成json字符串错误&quot;)    &#125;    &#x2F;&#x2F; jsonU是[]byte类型，转化成string类型便于查看    &#x2F;**    &#123;        &quot;user_name&quot;: &quot;ares&quot;,        &quot;age&quot;: 18,        &quot;Work1&quot;: &#123;            &quot;work1_name&quot;: &quot;god1&quot;,            &quot;Salary&quot;: 100        &#125;,        &quot;Work2&quot;: &#123;            &quot;work2_name&quot;: &quot;god2&quot;,            &quot;Salary&quot;: 200        &#125;,        &quot;Work3&quot;: &#123;            &quot;work3_name&quot;: &quot;god3&quot;,            &quot;Salary&quot;: 300        &#125;,        &quot;work4&quot;: &#123;            &quot;work4_name&quot;: &quot;god4&quot;,            &quot;Salary&quot;: 400,            &quot;work4_add&quot;: &quot;cbd&quot;        &#125;    &#125;    *&#x2F;    fmt.Println(string(jsonU))&#125;</code></pre><h3 id="Json-Unmarshal"><a href="#Json-Unmarshal" class="headerlink" title="Json Unmarshal"></a>Json Unmarshal</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;aresxin&#x2F;p&#x2F;go-json.html&quot; target&#x3D;&quot;_blank&quot; &gt;Go 的 json 解析:Marshal 与 Unmarshal&lt;&#x2F;a&gt;import (    &quot;encoding&#x2F;json&quot;    &quot;fmt&quot;    &quot;reflect&quot;)type User struct &#123;    Name  string &#96;json:&quot;user_name&quot;&#96;    Age   int    &#96;json:&quot;age&quot;&#96;    sex   string    Work1 *Work1    Work2 json.RawMessage    Work3 Work3    Work4 interface&#123;&#125; &#96;json:&quot;work4&quot;&#96;    Work5 interface&#123;&#125;&#125;type Work1 struct &#123;    Name   string &#96;json:&quot;work1_name&quot;&#96;    Salary float32&#125;type Work2 struct &#123;    Name   string &#96;json:&quot;work2_name&quot;&#96;    Salary float32&#125;type Work3 struct &#123;    Name   string &#96;json:&quot;work3_name&quot;&#96;    Salary float32&#125;type Work4 struct &#123;    Name    string &#96;json:&quot;work4_name&quot;&#96;    Salary  float32    Address string &#96;json:&quot;work4_add&quot;&#96;&#125;func main() &#123;    &#x2F;&#x2F;json字符中的&quot;引号，需用\进行转义，否则编译出错    data :&#x3D; &quot;&#123;\&quot;user_name\&quot;:\&quot;ares\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;,\&quot;age\&quot;:18,\&quot;Work1\&quot;:&#123;\&quot;work1_name\&quot;:\&quot;god1\&quot;,\&quot;Salary\&quot;:100&#125;,\&quot;Work2\&quot;:&#123;\&quot;work2_name\&quot;:\&quot;god2\&quot;,\&quot;Salary\&quot;:200&#125;,\&quot;Work3\&quot;:&#123;\&quot;work3_name\&quot;:\&quot;god3\&quot;,\&quot;Salary\&quot;:300&#125;,\&quot;work4\&quot;:&#123;\&quot;work4_name\&quot;:\&quot;god4\&quot;,\&quot;Salary\&quot;:400,\&quot;work4_add\&quot;:\&quot;cbd\&quot;&#125;&#125;&quot;    str :&#x3D; []byte(data)    u1 :&#x3D; User&#123;&#125;    &#x2F;&#x2F; Unmarshal的第一个参数是json字符串，第二个参数是接受json解析的数据结构.第二个参数必须是指针，否则无法接收解析的数据，    err :&#x3D; json.Unmarshal(str, &amp;u1)    if err !&#x3D; nil &#123;        fmt.Println(&quot;Unmarshal err,&quot;, err)    &#125;    &#x2F;&#x2F; &#123;ares 18  0xc0000a41c8 0xc0000a41e0 &#123;god3 300&#125; map[Salary:400 work4_add:cbd work4_name:god4]&#125;  Work2 为*Work2类型    &#x2F;&#x2F;  Work2 为json.RawMessage类型  &#123;ares 18  0xc0000a4198 [123 34 119 111 114 107 50 95 110 97 109 101 34 58 34 103 111 100 50 34 44 34 83 97 108 97 114 121 34 58 50 48 48 125] &#123;god3 300&#125; map[Salary:400 work4_add:cbd work4_name:god4] &lt;nil&gt;&#125;    fmt.Println(u1)    &#x2F;&#x2F; 查看类型    nameType :&#x3D; reflect.TypeOf(u1.Name)    ageType :&#x3D; reflect.TypeOf(u1.Age)    sexType :&#x3D; reflect.TypeOf(u1.sex)    work1Type :&#x3D; reflect.TypeOf(u1.Work1)    work2Type :&#x3D; reflect.TypeOf(u1.Work2)    work3Type :&#x3D; reflect.TypeOf(u1.Work3)    work4Type :&#x3D; reflect.TypeOf(u1.Work4)    work5Type :&#x3D; reflect.TypeOf(u1.Work5)    fmt.Println(nameType)  &#x2F;&#x2F; string    fmt.Println(ageType)   &#x2F;&#x2F; int    fmt.Println(sexType)   &#x2F;&#x2F; string    fmt.Println(work1Type) &#x2F;&#x2F; *main.Work1    fmt.Println(work2Type) &#x2F;&#x2F; json.RawMessage    fmt.Println(work3Type) &#x2F;&#x2F; main.Work3    fmt.Println(work4Type) &#x2F;&#x2F; map[string]interface &#123;&#125;    fmt.Println(work5Type) &#x2F;&#x2F; &lt;nil&gt;&#125;</code></pre><p>json 字符串解析时，需要一个“接收体”接受解析后的数据，且 Unmarshal 时接收体必须传递指针。<br>解析时，接收体可自行定义。json 串中的 key 自动在接收体中寻找匹配的项进行赋值。<br>匹配规则：</p><ul><li>先查找与 key 一样的 json 标签，找到则赋值给该标签对应的变量；</li><li>没有 json 标签的，就从上往下依次查找变量名与 key 一样的变量，或者变量名忽略大小写后与 key 一样的变量，第一个匹配的就赋值，后面就算有匹配的也忽略（变量可导出，首字母大写）。</li><li>当接收体中存在 json 串中匹配不了的项时，解析会自动忽略该项，该项仍保留原值。</li><li>如变量 Work5，保留空值 nil。</li><li>json 解析后，json 串中 value，只要是”简单数据”，都会按照默认的类型赋值。<ul><li>简单数据：是指不能再进行二次 json 解析的数据，例如 name</li><li>复合数据：是可进行二次甚至多次 json 解析的，因为它的 value 也是个可被解析的独立 json，例如 work1-5。</li></ul></li><li>对于”复合数据”，如果接收体中配的项被声明为 interface{}类型，go 都会默认解析成 map[string]interface{}类型。</li><li>如果想直接解析到 struct Class 对象中，可以将接受体对应的项定义为该 struct 类型。</li><li>如果不想指定 work 变量为具体的类型，仍想保留 interface{}类型，但又希望该变量可以解析到 struct work 对象中，可以将该变量定义为 json.RawMessage 类型。</li><li>被声明为 json.RawMessage 类型的变量在 json 解析时，变量值仍保留 json 的原值，即未被自动解析为 map[string]interface{}类型,可以对该变量进行二次 json 解析，因为其值仍是个独立且可解析的完整 json 串,只需再定义一个新的接受体即可。</li></ul><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><img src="http://t-blog-images.aijs.top/img/202210222040847.png" /><img src="http://t-blog-images.aijs.top/img/202210222041745.png" /><h2 id="goroutine-数据通信"><a href="#goroutine-数据通信" class="headerlink" title="goroutine 数据通信"></a>goroutine 数据通信</h2><img src="http://t-blog-images.aijs.top/img/202210222058287.png" /><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><img src="http://t-blog-images.aijs.top/img/202210222125508.jpg" /><h2 id="两个-channel-执行过程，及阻塞"><a href="#两个-channel-执行过程，及阻塞" class="headerlink" title="两个 channel 执行过程，及阻塞"></a>两个 channel 执行过程，及阻塞</h2><img src="http://t-blog-images.aijs.top/img/202210222145876.jpg" /><p><strong>无缓存</strong></p><img src="http://t-blog-images.aijs.top/img/202210222148949.jpg" /><p><strong>有缓存</strong><br><img src="http://t-blog-images.aijs.top/img/202210222148500.jpg" /></p><h3 id="关闭-特点"><a href="#关闭-特点" class="headerlink" title="关闭 特点"></a>关闭 特点</h3><img src="http://t-blog-images.aijs.top/img/202210222155221.png" /><p>当 channel 已经满，再向里面写数据，会阻塞<br>当 channel 为空，从里面取数据也会阻塞</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="读阻塞"><a href="#读阻塞" class="headerlink" title="读阻塞"></a>读阻塞</h4><img src="http://t-blog-images.aijs.top/img/202210222202688.png" /><img src="http://t-blog-images.aijs.top/img/202210222203039.png" /><h4 id="写阻塞"><a href="#写阻塞" class="headerlink" title="写阻塞"></a>写阻塞</h4><img src="http://t-blog-images.aijs.top/img/202210222204476.png" /><img src="http://t-blog-images.aijs.top/img/202210222332462.png" /><h3 id="channel-range"><a href="#channel-range" class="headerlink" title="channel range"></a>channel range</h3><img src="http://t-blog-images.aijs.top/img/202210222333136.png" /><h3 id="channel-select"><a href="#channel-select" class="headerlink" title="channel select"></a>channel select</h3><img src="http://t-blog-images.aijs.top/img/202210222334406.png" /><img src="http://t-blog-images.aijs.top/img/202210222338620.png" /><h2 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h2><img src="http://t-blog-images.aijs.top/img/202210222353689.png" /><img src="http://t-blog-images.aijs.top/img/202210222354251.png" /><img src="http://t-blog-images.aijs.top/img/202210222356816.png" /><img src="http://t-blog-images.aijs.top/img/202210231102618.png" /><img src="http://t-blog-images.aijs.top/img/202210231114931.png" /><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>通过内置的错误接口提供了非常简单的错误处理机制。</strong></p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>error 类型是一个接口类型，这是它的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">type error interface &#123;  Error() string&#125;</code></pre><p>我们可以在编码中<strong>通过实现 error 接口类型来生成错误信息</strong>。</p><p>函数通常在最后的返回值中返回错误信息。<strong>使用 errors.New 可返回一个错误信息</strong>：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">func Sqrt(f float64) (float64, error) &#123;    if f &lt; 0 &#123;        return 0, errors.New(&quot;math: square root of negative number&quot;)    &#125;    &#x2F;&#x2F; 实现&#125;</code></pre><h3 id="example-6"><a href="#example-6" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (    &quot;fmt&quot;)&#x2F;&#x2F; 定义一个 DivideError 结构&#x2F;&#x2F; 定义 xxx 结构体type DivideError struct &#123;    dividee int    divider int&#125;&#x2F;&#x2F; 实现 &#96;error&#96; 接口func (de *DivideError&#x2F;**指针 *&#x2F;) Error() string &#123;    strFormat :&#x3D; &#96;    Cannot proceed, the divider is zero.    dividee: %d    divider: 0&#96;&#x2F;&#x2F; fmt.Sprintf这个api, 有点面熟，先定义模版，再替换模版中的变量值    return fmt.Sprintf(strFormat, de.dividee)&#125;&#x2F;&#x2F; 定义 &#96;int&#96; 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;    if varDivider &#x3D;&#x3D; 0 &#123;        &#x2F;&#x2F; 结构体        dData :&#x3D; DivideError &#123;                dividee: varDividee,                divider: varDivider,        &#125;        &#x2F;&#x2F; 定义了一个结构体，直接调用结构体的方法，这也太直接了吧？        errorMsg &#x3D; dData.Error()        return    &#125; else &#123;        return varDividee &#x2F; varDivider, &quot;&quot;    &#125;&#125;func main() &#123;    &#x2F;&#x2F; 正常情况    &#x2F;** :&#x3D; 前面两个、后面两个，分别赋值 *&#x2F;    &#x2F;&#x2F; result 有值，执行if内容    if result, errorMsg :&#x3D; Divide(100, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;            fmt.Println(&quot;100&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 100&#x2F;10 &#x3D;  10    &#125;    &#x2F;&#x2F; result 为 0 ,执行if内容打印了    if result, errorMsg :&#x3D; Divide(0, 10); errorMsg &#x3D;&#x3D; &quot;&quot; &#123;      fmt.Println(&quot;0&#x2F;10 &#x3D; &quot;, result) &#x2F;&#x2F; 0&#x2F;10 &#x3D;  0    &#125;    &#x2F;&#x2F; 当除数为零的时候会返回错误信息    &#x2F;&#x2F; errorMsg 有值，执行if内容    if _, errorMsg :&#x3D; Divide(100, 0); errorMsg !&#x3D; &quot;&quot; &#123;            fmt.Println(&quot;errorMsg is: &quot;, errorMsg)    &#x2F;&#x2F; errorMsg is:    &#x2F;&#x2F;   Cannot proceed, the divider is zero.    &#x2F;&#x2F;   dividee: 100    &#x2F;&#x2F;   divider: 0    &#x2F;&#x2F; 这个返回有点意思，前面格式化错误打印，第一个变量是通过 &#96;&#96;运算得来的，和javascript 有点类似，原样的格式输出    &#125;&#125;</code></pre><!-- <img src="http://t-blog-images.aijs.top/img/202210151324359.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222122218.jpg" /><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>go 支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p><p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">go 函数名( 参数列表 )</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 例如：go f(x, y, z)&#x2F;&#x2F; 开启一个新的 goroutine:f(x, y, z)</code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，&#x2F;&#x2F; 以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。package mainimport (        &quot;fmt&quot;        &quot;time&quot;)func say(s string) &#123;        for i :&#x3D; 0; i &lt; 5; i++ &#123;                time.Sleep(100 * time.Millisecond)                fmt.Println(s)        &#125;&#125;func main() &#123;        go say(&quot;world&quot;)        say(&quot;hello&quot;)&#125;&#x2F;&#x2F; 执行以上代码，你会看到输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行：&#x2F;&#x2F; world&#x2F;&#x2F; hello&#x2F;&#x2F; hello&#x2F;&#x2F; world&#x2F;&#x2F; world&#x2F;&#x2F; hello&#x2F;&#x2F; hello&#x2F;&#x2F; world&#x2F;&#x2F; world&#x2F;&#x2F; hello</code></pre><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>用来：打通 goroutine，进行数据传输的</p><p>通道（channel）<strong>是用来传递数据的一个数据结构</strong>。</p><p>通道可用于<strong>两个 goroutine 之间</strong>通过传递一个指定类型的值来<strong>同步运行和通讯</strong>。操作符<code>&lt;-</code> 用于指定通道的方向，发送或接收。</p><p><strong>如果未指定方向，则为双向通道。</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 chv :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据           &#x2F;&#x2F; 并把值赋给 v&#x2F;&#x2F; 声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：ch :&#x3D; make(chan int)</code></pre><p>注意：默认情况下，<strong>通道是不带缓冲区的</strong>。发送端发送数据，同时<strong>必须有接收端</strong>相应的接收数据。</p><p>以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和：</p><h3 id="example-7"><a href="#example-7" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func sum(s []int, c chan int) &#123;        sum :&#x3D; 0        for _, v :&#x3D; range s &#123;                sum +&#x3D; v        &#125;        c &lt;- sum &#x2F;&#x2F; 把 sum 发送到通道 c&#125;func main() &#123;        s :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;        c :&#x3D; make(chan int)        go sum(s[:len(s)&#x2F;2], c) &#x2F;&#x2F; s[:len(s)&#x2F;2] [ -9, 4, 0]        go sum(s[len(s)&#x2F;2:], c) &#x2F;&#x2F; s[len(s)&#x2F;2:] [7, 2, 8]        x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收        fmt.Println(x, y, x+y)        &#x2F;&#x2F; -5 17 12&#125;</code></pre><!-- <img src="http://t-blog-images.aijs.top/img/202210151346664.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222122467.jpg" /><pre class="line-numbers language-go" data-language="go"><code class="language-go">&#x2F;&#x2F; 小改下func main() &#123;s :&#x3D; []int&#123;7, 2, 8, -9, 4, 0&#125;    c :&#x3D; make(chan int)    go sum(s[:len(s)&#x2F;2], c)    go sum(s[len(s)&#x2F;2:], c)    &#x2F;&#x2F; 下面这两个比goroutine先执行    fmt.Println(&quot;c&quot;)    fmt.Println(c)    x, y :&#x3D; &lt;-c, &lt;-c &#x2F;&#x2F; 从通道 c 中接收    a :&#x3D; &lt;-c &#x2F;&#x2F; 这里会报错    fmt.Println(a)    fmt.Println(x, y, x+y)&#125;&#x2F;&#x2F; c&#x2F;&#x2F; 0xc00006e060&#x2F;&#x2F; [-9 4 0]&#x2F;&#x2F; [7 2 8]&#x2F;&#x2F; fatal error: all goroutines are asleep - deadlock!&#x2F;&#x2F; goroutine 1 [chan receive]:&#x2F;&#x2F; main.main()&#x2F;&#x2F; &#x2F;tmp&#x2F;sandbox2040469662&#x2F;prog.go:26 +0x249&#x2F;&#x2F; Program exited.</code></pre><h3 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h3><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch :&#x3D; make(chan int, 100)</code></pre><p><strong>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态</strong>，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p><p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则<strong>缓冲区一满，数据发送端就无法再发送数据了</strong>。</p><p>注意：</p><ul><li>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。</li><li>如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；</li><li>如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport &quot;fmt&quot;func main() &#123;&#x2F;&#x2F; 这里我们定义了一个可以存储整数类型的带缓冲通道&#x2F;&#x2F; 缓冲区大小为2  ch :&#x3D; make(chan int, 2)  &#x2F;&#x2F; 因为 ch 是带缓冲的通道，我们可以同时发送两个数据  &#x2F;&#x2F; 而不用立刻需要去同步读取数据  ch &lt;- 1  ch &lt;- 2  &#x2F;&#x2F; 获取这两个数据  fmt.Println(&lt;-ch)  fmt.Println(&lt;-ch)&#x2F;&#x2F; 执行输出结果为：&#x2F;&#x2F; 1&#x2F;&#x2F; 2&#125;</code></pre><h2 id="Go-遍历通道与关闭通道"><a href="#Go-遍历通道与关闭通道" class="headerlink" title="Go 遍历通道与关闭通道"></a>Go 遍历通道与关闭通道</h2><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">v, ok :&#x3D; &lt;-ch</code></pre><h3 id="example-8"><a href="#example-8" class="headerlink" title="example"></a>example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport (        &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123;        x, y :&#x3D; 0, 1        for i :&#x3D; 0; i &lt; n; i++ &#123;                c &lt;- x                x, y &#x3D; y, x+y        &#125;        close(c)&#125;func main() &#123;        c :&#x3D; make(chan int, 10)        go fibonacci(cap(c), c)        &#x2F;&#x2F; range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个        &#x2F;&#x2F; 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据        &#x2F;&#x2F; 之后就结束了。        &#x2F;&#x2F; 如果上面的 c 通道不关闭，那么 range 函数就不会结束，从而在接收第 11 个数据的时候就阻塞了。        for i :&#x3D; range c &#123;                fmt.Println(i)        &#125;&#125;&#x2F;&#x2F; 执行输出结果为：&#x2F;&#x2F; 0&#x2F;&#x2F; 1&#x2F;&#x2F; 1&#x2F;&#x2F; 2&#x2F;&#x2F; 3&#x2F;&#x2F; 5&#x2F;&#x2F; 8&#x2F;&#x2F; 13&#x2F;&#x2F; 21&#x2F;&#x2F; 34</code></pre><p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p><h3 id="example-不关闭"><a href="#example-不关闭" class="headerlink" title="example 不关闭"></a>example 不关闭</h3><!-- <img src="http://t-blog-images.aijs.top/img/202210151355250.png" /> --><img src="http://t-blog-images.aijs.top/img/202210222123098.jpg" /><pre class="line-numbers language-none"><code class="language-none">fatal error: all goroutines are asleep - deadlock!</code></pre><h3 id="模块中大写"><a href="#模块中大写" class="headerlink" title="模块中大写"></a>模块中大写</h3><p><a href="https://go.dev/doc/code#:~:text=Because%20our%20ReverseRunes%20function%20begins%20with%20an%20upper%2Dcase%20letter%2C%20it%20is%20exported%2C%20and%20can%20be%20used%20in%20other%20packages%20that%20import%20our%20morestrings%20package." target="_blank" >见</a></p><p>模块中大些的函数是被导出。</p><ul><li>缓存，取代产生文件</li><li>绝对路径导入使用 <code>import ( &quot;packagepath&quot;)</code></li><li>安装<code>go install packagepath</code></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.runoob.com/go/go-ide.html" target="_blank" >runoob</a></p><p><a href="https://golang.google.cn/play/" target="_blank" >golang play</a></p><p><a href="https://github.com/gin-gonic/gin" target="_blank" >gin-gonic&#x2F;gin</a></p><p><a href="https://golang.google.cn/doc/tutorial/web-service-gin" target="_blank" >Tutorial: Developing a RESTful API with Go and Gin</a></p><h2 id="博客收录"><a href="#博客收录" class="headerlink" title="博客收录"></a>博客收录</h2><p><a href="https://learnku.com/docs/the-way-to-go/if-else-structure/3592" target="_blank" >这个文档比较好</a></p><p><a href="https://pkg.go.dev/" target="_blank" >https://pkg.go.dev/</a></p><h2 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h2><p><a href="https://www.bilibili.com/video/BV1ZJ411W7jG/" target="_blank" >见</a></p><p><a href="https://github.com/golang/go/wiki/NonEnglish" target="_blank" >NonEnglish 文档</a><br><a href="https://go-zh.org/doc/" target="_blank" >go 中文文档</a><br><a href="https://www.topgoer.com/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/fmt.html" target="_blank" >中文文档</a></p><p><a href="http://daohang.coder55.com/?F=top" target="_blank" >导航分类</a></p><p><a href="https://www.topgoer.com/" target="_blank" >https://www.topgoer.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextjs useSearchParams</title>
      <link href="//post/2022-10-14useSearchParams.html"/>
      <url>//post/2022-10-14useSearchParams.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>需求</strong></p><p>列表切换详情，返回列表，要求查询表单参数不丢失，</p><p><strong>思路</strong></p><ul><li>记录参数到 url 上，在记录的过程中，列表页面不刷新</li><li>返回时候列表页只作为一个 history 栈中的一个记录</li></ul><p><strong>MDN</strong></p><p>直接点：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API#replacestate_%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B" target="_blank" >history.replaceState</a></p><p><strong>history.replaceState</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">history.replaceState(stateObj, &quot;page 3&quot;, &quot;bar2.html&quot;);&#x2F;&#x2F; 注意点 history.replaceState, 会向url追加第三个参数，即使是相同的id,也会被追加。&#x2F;&#x2F; 例如：&#x2F;&#x2F; 初始 location.query 为 &#39;?time&#x3D;123456789&#39;&#x2F;&#x2F; history.replaceState(null, &quot;page 3&quot;, &quot;&amp;id&#x3D;1&quot;); &#x2F;&#x2F; 第一次调用&#x2F;&#x2F; location.query 为 &#39;?time&#x3D;123456789&amp;id&#x3D;1&#39;&#x2F;&#x2F; history.replaceState(null, &quot;page 3&quot;, &quot;&amp;id&#x3D;1&quot;); &#x2F;&#x2F; 第二次调用&#x2F;&#x2F; location.query 为 &#39;?time&#x3D;123456789&amp;id&#x3D;1&amp;id&#x3D;1&#39;&#x2F;&#x2F; history.replaceState(null, &quot;page 3&quot;, &quot;&amp;id&#x3D;1&quot;); &#x2F;&#x2F; 第三次调用&#x2F;&#x2F; location.query 为 &#39;?time&#x3D;123456789&amp;id&#x3D;1&amp;id&#x3D;1&amp;id&#x3D;1&#39;</code></pre><h2 id="nextjs"><a href="#nextjs" class="headerlink" title="nextjs"></a>nextjs</h2><p>在 nextjs 中没有提供类似 react-router-dom 中 <code>useSearchParams</code>这样的勾子</p><p><a href="https://reactrouter.com/en/main/hooks/use-search-params#usesearchparams" target="_blank" >useSearchParams</a></p><h2 id="假装我们不知道-replaceState"><a href="#假装我们不知道-replaceState" class="headerlink" title="假装我们不知道 replaceState"></a>假装我们不知道 replaceState</h2><p>如果要在 nextjs 中实现 <code>useSearchParams</code> 如何做呢？</p><p>会想到参考 <code>useSearchParams</code> 的源码实现</p><h2 id="下载源码搜下实现"><a href="#下载源码搜下实现" class="headerlink" title="下载源码搜下实现"></a>下载源码搜下实现</h2><h2 id="useSearchParams"><a href="#useSearchParams" class="headerlink" title="useSearchParams"></a>useSearchParams</h2><img src="http://t-blog-images.aijs.top/img/202210141716968.webp" /><!-- <img src="http://t-blog-images.aijs.top/img/202210141713394.webp" /> --><!-- <img src="http://t-blog-images.aijs.top/img/202210141714671.webp" /> --><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; packages&#x2F;react-router-dom&#x2F;index.tsx&#x2F;&#x2F; 调用 &#96;setSearchParams&#96; -&gt;  &#96;navigate&#96;-&gt;  &#96;let navigate &#x3D; useNavigate()&#96; -&gt; &#96;import &#123;  useNavigate&#125; from &quot;react-router&quot;;&#96;;</code></pre><p>到这里，要去找 <code>react-router 包中的 useNavigate</code>， 同一个代码仓库，不用切换项目</p><h2 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h2><p>同样方式，找到如下内容</p><img src="http://t-blog-images.aijs.top/img/202210141723899.webp" /><p>要去找下<code>NavigationContext</code>, React 的 context，我们了解到，是<code>NavigationContext.Provider</code>提供的数据</p><h2 id="NavigationContext-Provider"><a href="#NavigationContext-Provider" class="headerlink" title="NavigationContext.Provider"></a>NavigationContext.Provider</h2><p>同样方式，找到如下内容</p><img src="http://t-blog-images.aijs.top/img/202210141727222.webp" /><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; packages&#x2F;react-router&#x2F;lib&#x2F;components.tsx&#x2F;&#x2F; 这里要注意，这是一个组件，再找下去要找 &lt;Router了，由React-router-dom包暴露的组件，可知道暴露了几个组件：</code></pre><h2 id="react-router-dom-暴露的组件"><a href="#react-router-dom-暴露的组件" class="headerlink" title="react-router-dom 暴露的组件"></a>react-router-dom 暴露的组件</h2><img src="http://t-blog-images.aijs.top/img/202210141735213.webp" /><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; createBrowserHistory, createHashHistory &#125; from &quot;history&quot;; &#x2F;&#x2F; 这里 4&#x2F;&#x2F; ...export function BrowserRouter(&#123;  basename,  children,  window,&#125;: BrowserRouterProps) &#123;  let historyRef &#x3D; React.useRef&lt;BrowserHistory&gt;();  if (historyRef.current &#x3D;&#x3D; null) &#123;    historyRef.current &#x3D; createBrowserHistory(&#123; window &#125;); &#x2F;&#x2F; 这里 3  &#125;  let history &#x3D; historyRef.current; &#x2F;&#x2F; 这里 2  let [state, setState] &#x3D; React.useState(&#123;    action: history.action,    location: history.location,  &#125;);  React.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);  return (    &lt;Router      basename&#x3D;&#123;basename&#125;      children&#x3D;&#123;children&#125;      location&#x3D;&#123;state.location&#125;      navigationType&#x3D;&#123;state.action&#125;      navigator&#x3D;&#123;history&#125; &#x2F;&#x2F; 这里 1    &#x2F;&gt;  );&#125;</code></pre><p>最终发现到了 <code>history</code>库中</p><h2 id="createBrowserHistory"><a href="#createBrowserHistory" class="headerlink" title="createBrowserHistory"></a>createBrowserHistory</h2><p>同样方式，找到如下内容</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function createBrowserHistory(&#123; window &#x3D; document.defaultView &#125; &#x3D; &#123;&#125;) &#123;  let globalHistory &#x3D; window.history; &#x2F;&#x2F; &#x2F;&#x2F; 这里 4  &#x2F;&#x2F; 获取第几个，和 location 信息  &#x2F;&#x2F; ...  function replace(to, state) &#123;    &#x2F;&#x2F; 这里 2    let nextAction &#x3D; ReplaceAction;    let nextLocation &#x3D; getNextLocation(to, state);    function retry() &#123;      replace(to, state);    &#125;    if (allowTx(nextAction, nextLocation, retry)) &#123;      let [historyState, url] &#x3D; getHistoryStateAndUrl(nextLocation, index);      &#x2F;&#x2F; TODO: Support forced reloading      globalHistory.replaceState(historyState, null, url); &#x2F;&#x2F; 这里 3      applyTx(nextAction);    &#125;  &#125;  function go(n) &#123;    globalHistory.go(n);  &#125;  let history &#x3D; &#123;    get action() &#123;      return action;    &#125;,    get location() &#123;      return location;    &#125;,    createHref,    push,    replace, &#x2F;&#x2F; 这里 1    go,    back() &#123;      go(-1);    &#125;,    forward() &#123;      go(1);    &#125;,    listen(fn) &#123;      return listeners.push(fn);    &#125;,    block(fn) &#123;      let unblock &#x3D; blockers.push(fn);      if (blockers.length &#x3D;&#x3D;&#x3D; 1) &#123;        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);      &#125;      return function () &#123;        unblock();        &#x2F;&#x2F; Remove the beforeunload listener so the document may        &#x2F;&#x2F; still be salvageable in the pagehide event.        &#x2F;&#x2F; See https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;#unloading-documents        if (!blockers.length) &#123;          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);        &#125;      &#125;;    &#125;,  &#125;;  return history;&#125;</code></pre><p>最终发现调用的是 <code> window.history.replaceState(historyState, null, url)</code></p><h2 id="假装我们刚知道"><a href="#假装我们刚知道" class="headerlink" title="假装我们刚知道"></a>假装我们刚知道</h2><p>Oh~,原来如此呀</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>useNavigate</code></p><p>这个 hook 内部获取了 <code> let &#123; basename, navigator &#125; = React.useContext(NavigationContext);</code>,</p><p><code>NavigationContext.Provider</code>是最外层提供的，所以，在其他地方使用 <code>useNavigate</code> 直接能拿到 <code>navigator</code>,不需要通过<code>React.useContext(NavigationContext)</code>的方式获取</p><h2 id="最后，实现-nextjs-中该勾子"><a href="#最后，实现-nextjs-中该勾子" class="headerlink" title="最后，实现 nextjs 中该勾子"></a>最后，实现 nextjs 中该勾子</h2><h2 id="useSearchParams-1"><a href="#useSearchParams-1" class="headerlink" title="useSearchParams"></a>useSearchParams</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; hooks&#x2F;useSearchParams.tsximport &#123; useRouter &#125; from &quot;next&#x2F;router&quot;;import React from &quot;react&quot;;&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;blob&#x2F;main&#x2F;packages&#x2F;react-router-dom&#x2F;index.tsxexport type ParamKeyValuePair &#x3D; [string, string];export type URLSearchParamsInit &#x3D;  | string  | ParamKeyValuePair[]  | Record&lt;string, string | string[]&gt;  | URLSearchParams;type SetURLSearchParams &#x3D; (  nextInit?:    | URLSearchParamsInit    | ((prev: URLSearchParams) &#x3D;&gt; URLSearchParamsInit),  navigateOpts?: NavigateOptions) &#x3D;&gt; void;&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;blob&#x2F;d9d233c7fbb6f712915e8b0a7c916a69064bfdb9&#x2F;packages&#x2F;react-router&#x2F;lib&#x2F;context.ts#L92export interface NavigateOptions &#123;  replace?: boolean;  state?: any;  preventScrollReset?: boolean;  relative?: RelativeRoutingType;&#125;export type RelativeRoutingType &#x3D; &quot;route&quot; | &quot;path&quot;;&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;react-router&#x2F;blob&#x2F;main&#x2F;packages&#x2F;react-router-dom&#x2F;dom.ts&#x2F;** * Creates a URLSearchParams object using the given initializer. * * This is identical to &#96;new URLSearchParams(init)&#96; except it also * supports arrays as values in the object form of the initializer * instead of just strings. This is convenient when you need multiple * values for a given key, but don&#39;t want to use an array initializer. * * For example, instead of: * *   let searchParams &#x3D; new URLSearchParams([ *     [&#39;sort&#39;, &#39;name&#39;], *     [&#39;sort&#39;, &#39;price&#39;] *   ]); * * you can do: * *   let searchParams &#x3D; createSearchParams(&#123; *     sort: [&#39;name&#39;, &#39;price&#39;] *   &#125;); *&#x2F;export function createSearchParams(  init: URLSearchParamsInit &#x3D; &quot;&quot;): URLSearchParams &#123;  return new URLSearchParams(    typeof init &#x3D;&#x3D;&#x3D; &quot;string&quot; ||    Array.isArray(init) ||    init instanceof URLSearchParams      ? init      : Object.keys(init).reduce((memo, key) &#x3D;&gt; &#123;          const value &#x3D; init[key];          return memo.concat(            Array.isArray(value) ? value.map((v) &#x3D;&gt; [key, v]) : [[key, value]]          );        &#125;, [] as ParamKeyValuePair[])  );&#125;export function getSearchParamsForLocation(  locationSearch: string,  defaultSearchParams: URLSearchParams) &#123;  const searchParams &#x3D; createSearchParams(locationSearch);  &#x2F;&#x2F; @ts-ignore  for (const key of defaultSearchParams.keys()) &#123;    if (!searchParams.has(key)) &#123;      defaultSearchParams.getAll(key).forEach((value) &#x3D;&gt; &#123;        searchParams.append(key, value);      &#125;);    &#125;  &#125;  return searchParams;&#125;export function useSearchParams(  defaultInit?: URLSearchParamsInit): [URLSearchParams, SetURLSearchParams] &#123;  const defaultSearchParamsRef &#x3D; React.useRef(createSearchParams(defaultInit));  const router &#x3D; useRouter();  let searchParams &#x3D;    typeof window &#x3D;&#x3D;&#x3D; &quot;undefined&quot;      ? defaultSearchParamsRef.current      : getSearchParamsForLocation(          &#x2F;&#x2F; 参数          window?.location?.search || &quot;&quot;,          defaultSearchParamsRef.current        );  const setSearchParams &#x3D; React.useCallback&lt;SetURLSearchParams&gt;(    (nextInit, navigateOptions) &#x3D;&gt; &#123;      const newSearchParams &#x3D; createSearchParams(        typeof nextInit &#x3D;&#x3D;&#x3D; &quot;function&quot; ? nextInit(searchParams) : nextInit      );      window.history.replaceState(null, &quot;&quot;, &#96;?$&#123;newSearchParams&#125;&#96;);    &#125;,    [searchParams]  );  return [searchParams, setSearchParams];&#125;</code></pre><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; pages&#x2F;test&#x2F;replacestate.tsximport React, &#123; useCallback, useEffect, useState &#125; from &quot;react&quot;;import &#123; useSearchParams &#125; from &quot;..&#x2F;..&#x2F;hooks&#x2F;useSearchParams&quot;;interface IProps &#123;&#125;const TestReplaceState: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const [count, setCount] &#x3D; useState(0);  const [searchParams, setSearchParams] &#x3D; useSearchParams();  &#x2F;&#x2F; url数据放到state（数据恢复）  useEffect(() &#x3D;&gt; &#123;    setCount(Number(searchParams.get(&quot;id&quot;)));  &#125;, []);  &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;URLSearchParams  if (typeof window !&#x3D;&#x3D; &quot;undefined&quot;) &#123;    const searchParams &#x3D; new URLSearchParams(location.href);    &#x2F;&#x2F; @ts-ignore    for (let p of searchParams) &#123;      console.log(p);    &#125;  &#125;  &#x2F;&#x2F; 模拟查询表单提交  const handleSubmitQuery &#x3D; useCallback(() &#x3D;&gt; &#123;    const newValue &#x3D; count + 1;    &#x2F;&#x2F; 更新url数据，不刷新页面    setSearchParams(&#123; id: &#96;$&#123;newValue&#125;&#96; &#125;);    setCount(newValue);  &#125;, [count, setSearchParams]);  return (    &lt;div style&#x3D;&#123;&#123; padding: 50 &#125;&#125;&gt;      &lt;span        style&#x3D;&#123;&#123;          cursor: &quot;pointer&quot;,          background: &quot;#1980ff&quot;,          color: &quot;#fff&quot;,          padding: &quot;4px 6px&quot;,          borderRadius: 4,        &#125;&#125;        onClick&#x3D;&#123;handleSubmitQuery&#125;      &gt;        模拟查询表单提交数据 &#123;count&#125;      &lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;  );&#125;;export default TestReplaceState;</code></pre><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><img src="http://t-blog-images.aijs.top/img/202210141848635.gif" /><h2 id="详情-gt-列表-在-nextjs-上有时候不能被检测到"><a href="#详情-gt-列表-在-nextjs-上有时候不能被检测到" class="headerlink" title="详情-&gt;列表, 在 nextjs 上有时候不能被检测到"></a>详情-&gt;列表, 在 nextjs 上有时候不能被检测到</h2><p>url 切换成功，但是 nextjs 有时候检测不到 偶现</p><p>之后看下源码，到底是什么原因</p><h2 id="nextjs-提供了浅路由"><a href="#nextjs-提供了浅路由" class="headerlink" title="nextjs 提供了浅路由"></a>nextjs 提供了浅路由</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ....&#x2F;&#x2F; 需要有顺序的加载，否则 antd table pagination current当前页数存在问题，&#x2F;&#x2F; 原因是： pagination被封装到一个hook中，与table不在一个地方，table的，更新不及时useEffect(() &#x3D;&gt; &#123;  if (router.pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;my&#x2F;list&quot;) &#123;    setShowCreator(false);    refShowCreator.current &#x3D; false;  &#125; else &#123;    setShowCreator(true);    refShowCreator.current &#x3D; true;  &#125;  const urlparam &#x3D; router.query;  form.setFieldsValue(&#123;    ...urlparam,    states: (urlparam.states || [])?.map((item) &#x3D;&gt; Number(item)),  &#125;);  fetchCurrentData(+urlparam.pageIndex, +urlparam.limit);  &#x2F;&#x2F; eslint-disable-next-line react-hooks&#x2F;exhaustive-deps&#125;, [router.query.activeTab, pageOption, router.pathname, form]);&#x2F;&#x2F; ....&#x2F;&#x2F; 更新 queryparamsconst handleReplaceState &#x3D; (_params) &#x3D;&gt; &#123;  const urlparams &#x3D; qs.stringify(    filterEmptyVal(_params, &#123; cleanKeys: [], emptyString: true &#125;)  );  if (countref.current) &#123;    const _path &#x3D;      router.query.activeTab !&#x3D;&#x3D; undefined        ? &#96;$&#123;router.pathname&#125;?activeTab&#x3D;$&#123;router.query.activeTab&#125;&amp;$&#123;urlparams&#125;&#96;        : &#96;$&#123;router.pathname&#125;?$&#123;urlparams&#125;&#96;;    router?.push(_path, undefined, &#123; shallow: true &#125;);  &#125;  countref.current &#x3D; countref.current + 1;  return getProblems(_params);&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Cache</title>
      <link href="//post/2022-10-14react-cache.html"/>
      <url>//post/2022-10-14react-cache.html</url>
      
        <content type="html"><![CDATA[<h2 id="暂时没空看，先记录"><a href="#暂时没空看，先记录" class="headerlink" title="暂时没空看，先记录"></a>暂时没空看，先记录</h2><h2 id="react-router-saveScrollPosition"><a href="#react-router-saveScrollPosition" class="headerlink" title="react-router saveScrollPosition"></a>react-router saveScrollPosition</h2><p><a href="https://github.com/remix-run/react-router/blob/892238bee052177e78012167c088290b06400206/packages/router/router.ts#L814" target="_blank" >saveScrollPosition</a></p><h2 id="react-router-cache-route"><a href="#react-router-cache-route" class="headerlink" title="react-router-cache-route"></a>react-router-cache-route</h2><p><a href="https://github.com/CJY0208/react-router-cache-route" target="_blank" >https://github.com/CJY0208/react-router-cache-route</a></p><h2 id="react-activation"><a href="#react-activation" class="headerlink" title="react-activation"></a>react-activation</h2><p><code>&lt;KeepAlive /&gt;</code> only</p><p><a href="https://github.com/CJY0208/react-activation" target="_blank" >https://github.com/CJY0208/react-activation</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好记性不如“实时笔记”</title>
      <link href="//post/2022-10-13record.html"/>
      <url>//post/2022-10-13record.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>看视频、音频，再发散一点如会议、需求对接、老师授课课堂笔记等，很多场景我们可能遇到做笔记啊。</p><p><em>上学时候</em>，做课堂笔记是一件耗费心神的事情，既想要把内容听进去，又想之后能够很快的复习。真的很难。</p><p><em>现在，累了半辈子，这辈子是不可能再“那么记了”</em>，</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">程序员 !&#x3D; &quot;偷懒&quot; 程序员 &#x3D;&#x3D; &quot;高效率做事&quot; </code></pre><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>需要实时笔记，这样我就能快速复习了</li><li>不想手动记笔记，不想那么低效做事</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要在手机上&#x2F;电脑上，实现后台录音，之后把录音转化成文字，然后就可以整理笔记，把音频删除（节约存储空间）</p><h2 id="工具选取"><a href="#工具选取" class="headerlink" title="工具选取"></a>工具选取</h2><p><strong>大前提最最要免费</strong>（我没钱）</p><p><em>印象笔记</em></p><ul><li>收费，果断放弃</li><li>体验不好。之前也有试过印象笔记记东西，感觉体验不好，有Mac用备忘录就比印象笔记方便太多</li></ul><p><em>其他工具</em></p><p style="padding-left: 20px">其他的工具也了解了下，不能满足需要</p><p><em>飞书</em>：会议记录功能（飞书妙记）非常不错，</p><ul><li>最重要的事免费</li><li>满足手机上后台录音功能</li><li>可以实时录制，转化成文字笔记，</li><li>转化后的文字点击，自动切换到音频位置，非常不错</li></ul><p style="padding-left: 20px">题外话：飞书妙记功能不止于此</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><div style="display: flex;flex-direction: row;">  <video  controls src="http://t-blog-images.aijs.top/img/1665622922031613.mp4" style="width: 300px;max-width: 100%"></video>  <div style="width: 20px"></div>  <video controls src="http://t-blog-images.aijs.top/img/1665622922014178.mp4" style="width: 300px;max-width: 100%"></video></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>“好记性不如烂笔头”已经过时，把烂笔头省下来也是件不错的事情吧；</li><li>同时节约更多时间，即使聊聊天刷刷视频，也不会丢重点</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>“飞书妙记”，也是机器，转译的过程中难免也会有误，“修改”总比“完全写”要来</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 源码解析收录</title>
      <link href="//post/2022-10-10react-link.html"/>
      <url>//post/2022-10-10react-link.html</url>
      
        <content type="html"><![CDATA[<h2 id="收录链接-1"><a href="#收录链接-1" class="headerlink" title="收录链接 1"></a>收录链接 1</h2><p><a href="https://juejin.cn/post/7014775797596553230" target="_blank">React17 源码解析(开篇) —— 搭建 react 源码调试环境</a></p><p><a href="https://juejin.cn/post/7015853155367780383" target="_blank">React17 源码解析(1) —— 源码目录及 react 架构</a></p><p><a href="https://juejin.cn/post/7015855371847729166" target="_blank">React17 源码解析(2) —— jsx 转换及 React.createElement</a></p><p><a href="https://juejin.cn/post/7016512949330116645" target="_blank">React17 源码解析(3) —— 深入理解 fiber</a></p><p><a href="https://juejin.cn/post/7019254208830373902" target="_blank">React17 源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)</a></p><p><a href="https://juejin.cn/post/7020595059095666724" target="_blank">React17 源码解析(5) —— 全面理解 diff 算法</a></p><p><a href="https://juejin.cn/post/7022816775188250660" target="_blank">React17 源码解析(6) —— commit 阶段</a></p><p><a href="https://juejin.cn/post/7023568411963686920" target="_blank">React17 源码解析(7) —— 一文搞懂 hooks 原理</a></p><p><a href="https://juejin.cn/post/7030673003583111176" target="_blank">🚀 万字好文 —— 手把手教你实现史上功能最丰富的简易版 react</a></p><p>从上面了解到：</p><ol><li>几种数据类型之间的关系<code>Fiber</code>、 <code>Effect</code>、 <code>Hook</code>、 <code>Update</code>、 <code>UpdateQueue</code></li><li>“如何触发 React 调度更新”</li><li>“diff 算法”的大概是什么</li><li>“React Fiber 树如何被更新成 DOM 的”</li></ol><h2 id="收录链接-2"><a href="#收录链接-2" class="headerlink" title="收录链接 2"></a>收录链接 2</h2><p><strong>看完上面的文章，会有这个疑惑：</strong></p><p>我们的代码是如何进入 React 调度流程的（例如：写了一个组件，这个组件如何变成 workInProgressFiber 的一部分）</p><p><a href="https://juejin.cn/post/7016512949330116645" target="_blank">React17 源码解析(3) —— 深入理解 fiber</a>仅有一行描述：“每个节点开始创建时，执行 beginWork 流程，直至该节点的所有子孙节点都创建(更新)完成后，执行 completeWork 流程”。 因跳过了太多的细节，即使最后给了下面这么一幅图，也看的云里雾里</p><img src="http://t-blog-images.aijs.top/img/202210140926842.webp" /><p><strong>下面这两个链接详细阐述了整个过程</strong></p><p><a href="https://zhuanlan.zhihu.com/p/525244896" target="_blank" >React Fiber 架构原理：关于 Fiber 树的一切</a></p><p><a href="https://blog.51cto.com/u_15127625/3316937" target="_blank" >Fiber 树的构建</a></p><p><strong>爬取掘金专栏收录文章脚本</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var data &#x3D; &quot;&quot;;const list &#x3D; document.getElementsByClassName(&quot;title-row&quot;);Array.from(list)  &#x2F;&#x2F; .sort(() &#x3D;&gt; 1) &#x2F;*反向排序 *&#x2F;  .forEach((item) &#x3D;&gt; &#123;    const linkdom &#x3D; item.children[0];    const lk &#x3D; &#96;&lt;a href&#x3D;&quot;$&#123;linkdom.href&#125;&quot; target&#x3D;&quot;_blank&quot; &gt;$&#123;linkdom.title&#125;&lt;&#x2F;a&gt;\n&#96;;    data +&#x3D; lk;  &#125;);copy(data);</code></pre><img src="http://t-blog-images.aijs.top/img/202210101827397.webp" style="max-width:100%; width: 500px" /><h2 id="收录链接-3"><a href="#收录链接-3" class="headerlink" title="收录链接 3"></a>收录链接 3</h2><p><a href="https://react.jokcy.me/book/api/react-structure.html" target="_blank" >react-structure</a></p><p><a href="https://lilixikun.github.io/blog/" target="_blank" >lilixikun</a></p><h2 id="updateQueue-环形链表"><a href="#updateQueue-环形链表" class="headerlink" title="updateQueue 环形链表"></a>updateQueue 环形链表</h2><p><strong>为什么使用环形链表：</strong></p><p><strong>普通链表</strong></p><ul><li>如果只保存首节点的指针，则每次插入时需要先进行一次遍历找到尾节点，再进行插入。</li><li>要么就需要保存首尾节点的指针。</li><li><strong>环形链表</strong></li></ul><p>而<em>环形链表的尾节点的下一个节点就是首节点</em>，因此只需要保存一个尾节点就<em>可以做到既方便插入、又方便访问首节点</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">UpdateQueue&lt;State&gt; &#x3D; &#123;  &#x2F;&#x2F; 这三个baseState是有更新被跳过时候才产生  baseState: State, &#x2F;&#x2F; baseState 指向被跳过的首个元素之前的所有 update 计算出的最终状态  firstBaseUpdate: Update&lt;State&gt;, &#x2F;&#x2F; firstBaseUpdate 指向被跳过的首个 update  lastBaseUpdate: Update&lt;State&gt;, &#x2F;&#x2F; lastBaseUpdate，只要有 update 被跳过，那么它一定指向本次更新的 update 中的最后一个  shared: SharedQueue&lt;State&gt;, &#x2F;&#x2F; 单环链表 真正存放 update 的链表的属性  effects: Array&lt;Update&lt;State&gt;&gt;,&#125;;type SharedQueue&lt;State&gt; &#x3D; &#123;  pending: Update&lt;State&gt; | null;&#125;;</code></pre><h2 id="firstBaseUpdate-以及-lastBaseUpdate-形成的单链表"><a href="#firstBaseUpdate-以及-lastBaseUpdate-形成的单链表" class="headerlink" title="firstBaseUpdate 以及 lastBaseUpdate 形成的单链表"></a>firstBaseUpdate 以及 lastBaseUpdate 形成的单链表</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let pendingQueue &#x3D; queue.shared.pending; &#x2F;&#x2F;  (取一个节点)&#x2F;&#x2F; 将 pending 设为空，表示这些 pending 已经处理过queue.shared.pending &#x3D; null;const lastPendingUpdate &#x3D; pendingQueue; &#x2F;&#x2F; pending 的最后一个 udpdateconst firstPendingUpdate &#x3D; lastPendingUpdate.next; &#x2F;&#x2F; pending 的第一个 update&#x2F;&#x2F; 剪开环，使最后一个 update 不再指向第一个 updatelastPendingUpdate.next &#x3D; null;if (lastBaseUpdate &#x3D;&#x3D;&#x3D; null) &#123;  &#x2F;&#x2F;  firstBaseUpdate &#x3D; firstPendingUpdate;&#125; else &#123;  &#x2F;&#x2F; 如果上一次有跳过的 update，那么 baseUpdate 链表不为空  &#x2F;&#x2F; 需要将 pending 的第一个 update 接上 baseUpdate  lastBaseUpdate.next &#x3D; firstPendingUpdate;&#125;&#x2F;&#x2F; 将 lastBaseUpdate 赋值为 lastPendingUpdate&#x2F;&#x2F; 此时已经形成了 以 firstBaseUpdate 为头以 lastBaseUpdate 为尾的新链表&#x2F;&#x2F; 也即为本次需要处理的 update 链表lastBaseUpdate &#x3D; lastPendingUpdate;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7093082885363597349" target="_blank" >React Fiber - updateQueue 原理分析</a></p><p><a href="https://juejin.cn/post/7019254208830373902" target="_blank" >React17 源码解析(4) —— 详解 render 阶段(scheduler 和 reconciler)</a><br><a href="https://blog.csdn.net/qq_39583550/article/details/125905341" target="_blank" >见</a></p><h2 id="待学习源码"><a href="#待学习源码" class="headerlink" title="待学习源码"></a>待学习源码</h2><p><a href="https://github.com/baozouai/react-source-study" target="_blank" >react-source-study, 这老铁掘金文章写跑题了，蹭热度，不晓得，代码如何～，先收着</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Antd Tree drag</title>
      <link href="//post/2022-10-10antd-tree-drag.html"/>
      <url>//post/2022-10-10antd-tree-drag.html</url>
      
        <content type="html"><![CDATA[<h2 id="属性解释"><a href="#属性解释" class="headerlink" title="属性解释"></a>属性解释</h2><p><strong>dropToGap</strong>：boolean类型，true代表拖拽到节点之间的缝隙中，false代表拖拽到节点上，即节点的内容区。<br><strong>dropPosition</strong>：拖拽的时候，针对一个节点有三种情况，即拖拽到节点之上，拖拽到节点上，拖拽到节点之下。</p><p>三种情况其值有所不同。antd 依赖了 rc-tree，</p><p><strong>rc-tree</strong> </p><p>在 rc-tree 里 dropPosition 是一个相对地址。<br>如果拖到了目标节点的上面则当前元素 -1，下面则是 1（* rc-tree这块不确定具体情况*）。</p><p><strong>antd</strong></p><p> antd里则是相对于目标节点的 index针对拖动情况计算出来。</p><ul><li>拖拽到节点之上(<strong>节点上边缘间隙位置</strong>)： 该节点的 index-1</li><li>拖拽到节点上面(<strong>上边缘与下边缘之间的区域</strong>)：dropPosition 就是该节点的 index。</li><li>拖拽到节点之下(<strong>节点下边缘间隙位置</strong>)：该节点的 index+1</li></ul><p>如下图所示：</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><img src="http://t-blog-images.aijs.top/img/202210101025107.webp" /><h2 id="官方代码"><a href="#官方代码" class="headerlink" title="官方代码"></a>官方代码</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> onDrop &#x3D; info &#x3D;&gt; &#123;    console.log(info);    const dropKey &#x3D; info.node.props.eventKey;    const dragKey &#x3D; info.dragNode.props.eventKey;    const dropPos &#x3D; info.node.props.pos.split(&#39;-&#39;);   &#x2F;&#x2F; 这里计算的差值 上面分析了info.dropPosition的含义   dropPosition有3种情况    &#x2F;&#x2F; &#x3D;0 表示拖拽到元素上  &#x2F;&#x2F; &#x3D;1 表示拖拽到元素下面   那么放置元素的时候  应该放到这个位置+1的位置上  &#x2F;&#x2F; &#x3D;-1 表示拖拽到元素上面   那么放置元素的时候 直接放到这个位置即可    const dropPosition &#x3D; info.dropPosition - Number(dropPos[dropPos.length - 1]);&#x2F;&#x2F; 递归查到元素所在树中的位置    const loop &#x3D; (data, key, callback) &#x3D;&gt; &#123;      data.forEach((item, index, arr) &#x3D;&gt; &#123;        if (item.key &#x3D;&#x3D;&#x3D; key) &#123;          &#x2F;&#x2F;在回调函数中将此元素，位置，以及元数组都返回          return callback(item, index, arr);        &#125;        if (item.children) &#123;          return loop(item.children, key, callback);        &#125;      &#125;);    &#125;;    &#x2F;&#x2F; 浅拷贝整个树 此处有疑问  不过不影响功能  因为怕操作data 我觉得应该深拷贝     const data &#x3D; [...this.state.gData];    &#x2F;&#x2F; Find dragObject 查找获取到拖拽开始的元素对象    let dragObj;    loop(data, dragKey, (item, index, arr) &#x3D;&gt; &#123;      &#x2F;&#x2F; 查找到后删除此元素  这里相当于直接操作了data 所以我认为应该深拷贝      arr.splice(index, 1);      dragObj &#x3D; item;    &#125;);    if (!info.dropToGap) &#123;      &#x2F;&#x2F; Drop on the content  拖拽到内容上       loop(data, dropKey, item &#x3D;&gt; &#123;        item.children &#x3D; item.children || [];        &#x2F;&#x2F; where to insert 示例添加到尾部，可以是随意位置        item.children.push(dragObj);      &#125;);    &#125;    &#x2F;&#x2F; 拖拽到元素之下的缝隙中，元素有子节点，并且当前元素子节点展开。此时元素放到了子节点的第一位。（当然可以根据具体情况随意位置）     else if (      (info.node.props.children || []).length &gt; 0 &amp;&amp; &#x2F;&#x2F; Has children      info.node.props.expanded &amp;&amp; &#x2F;&#x2F; Is expanded      dropPosition &#x3D;&#x3D;&#x3D; 1 &#x2F;&#x2F; On the bottom gap    ) &#123;      loop(data, dropKey, item &#x3D;&gt; &#123;        item.children &#x3D; item.children || [];        &#x2F;&#x2F; where to insert 示例添加到头部，可以是随意位置        item.children.unshift(dragObj);      &#125;);    &#125; else &#123;      let ar;      let i;      loop(data, dropKey, (item, index, arr) &#x3D;&gt; &#123;        ar &#x3D; arr;        i &#x3D; index;      &#125;);      if (dropPosition &#x3D;&#x3D;&#x3D; -1) &#123;        ar.splice(i, 0, dragObj);      &#125; else &#123;        ar.splice(i + 1, 0, dragObj);      &#125;    &#125;    this.setState(&#123;      gData: data,    &#125;);  &#125;;</code></pre><p>作者：黎明的叶子<br>链接：<a href="https://www.jianshu.com/p/0e8bf11cd2dc">https://www.jianshu.com/p/0e8bf11cd2dc</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/0e8bf11cd2dc" target="_blank" >ant-design拖动属性dropToGap,dropPosition</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tailwindcss</title>
      <link href="//post/2022-10-09tailwindcss.html"/>
      <url>//post/2022-10-09tailwindcss.html</url>
      
        <content type="html"><![CDATA[<div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/tailwindlabs/tailwindcss">https://github.com/tailwindlabs/tailwindcss</a><img src="https://img.shields.io/github/stars/tailwindlabs/tailwindcss?style=social" /></div><h2 id="CSS-发展"><a href="#CSS-发展" class="headerlink" title="CSS 发展"></a>CSS 发展</h2><p><strong>第一个阶段，原生写法</strong></p><p>是类似于编程中面向过程的写法，需要什么样式，自己在 css 中写什么样式。对代码有洁癖的程序员会进行简单的 css 复用。但是也只是简单的复用，大多数时候还是需要什么写什么，想怎么写怎么写。</p><p><strong>第二个阶段，CSS 组件化。</strong></p><p>类似于编程中面向对象的写法，将相同视觉的 UI 封装成一个组件。比如一个按钮，整个项目中，这个按钮被多次使用，并且样式一致。那么就可以封装成一个按钮类。使用的时候直接使用这个类名称就 OK。</p><p>这也是的做法。</p><p>这种框架的优势在于，。比如你需要一个表单，，需要一个导航，需要一个弹窗，Card 卡片。有现成的 class。直接拿过来用，就可以快速的完成效果。完全不需要动手写 css。</p><p>这也是目前比较流行的方法。这几年几乎很少有项目是自己一点一点手写样式的了，多多少少都会使用到一些 css 框架。</p><p>对于一些需要快速交付的项目，非常适合使用这种组件化 css 框架。</p><p><strong>第三个阶段，CSS 零件化。</strong></p><p>也叫做。和上面第一个阶段第二个阶段都有类似的地方。依旧是组件，只是每个组件都是一个单一功能的 css 属性。</p><p>上面第一个阶段的时候，我们讲了有些有对代码有追求的人，会开始复用 css。<br>比如页面中大量的用到 float:left。那么就可以封装一个类，比如是这样</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.left &#123;  float: left;&#125;</code></pre><p>然后需要使用 float:left 的时候，直接使用.left 就可以。</p><p>但是我们自己写 css 的时候，仅仅是封装一些常用的简单的类，绝大多数的 css，都需要动手去写 css。比如你要写个宽度 12 像素。你就得老老实实的去写 width:12px，逃避不了，不过估计也没人想过逃避。</p><p>Tailwind CSS 就是第三个阶段的产物，它做了什么呢？<br>它将所有的 css 属性全部封装成语义化的类，比如你想要一个 float:left，它已经帮你封装好了，你直接使用一个 float-left 就可以。<br>需要一个宽度为 12 像素，只需要写 w-3 就可以。</p><h2 id="tailwindcss-是什么"><a href="#tailwindcss-是什么" class="headerlink" title="tailwindcss 是什么"></a>tailwindcss 是什么</h2><p>像是 CSS 行内样式的另一种实现，有自己的语法，又和 CSS 有些关联【如 修饰符速查表、伪类速查表】</p><p>实现了 CSS 行内样式不支持的一些 CSS 属性</p><h2 id="tailwindcss-工作原理是什么"><a href="#tailwindcss-工作原理是什么" class="headerlink" title="tailwindcss 工作原理是什么"></a>tailwindcss 工作原理是什么</h2><p>Tailwind CSS 的工作原理是扫描所有 HTML 文件、JavaScript 组件和任何其他模板以查找类名，生成相应的样式，然后将其写入静态 CSS 文件。</p><p>它快速、灵活、可靠，运行时间为零。</p><h2 id="tailwindcss-解决了什么问题"><a href="#tailwindcss-解决了什么问题" class="headerlink" title="tailwindcss 解决了什么问题"></a>tailwindcss 解决了什么问题</h2><p><a href="https://tailwindcss.com/docs/utility-first#:~:text=some%20really%20important-,benefits,-%3A" target="_blank" >见</a></p><p><a href="https://tailwindcss.com/docs/utility-first#:~:text=But%20using%20utility%20classes%20has%20a%20few%20important%20advantages%20over%20inline%20styles%3A" target="_blank" >见</a></p><h2 id="tailwindcss-好乱啊"><a href="#tailwindcss-好乱啊" class="headerlink" title="tailwindcss 好乱啊"></a>tailwindcss 好乱啊</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>“this is an atrocity, what a horrible mess!”</p></blockquote><p>现在我知道你在想什么了，“这是一场暴行，多么可怕的混乱！”你说得对，它有点丑。事实上，当你第一次看到它时，几乎不可能认为这是一个好主意——你必须真正尝试一下。<br>但一旦你真的以这种方式构建了一些东西，你会很快发现一些真正重要的好处：</p><ul><li><strong>您没有为了给类命名而浪费精力。</strong> 不需要仅仅为了设置一些样式而额外添加一些像 sidebar-inner-wrapper 这样愚蠢的类名，不必再为了一个 flex 容器的完美抽象命名而倍受折磨。</li><li><strong>您的 CSS 停止增长。</strong> 使用传统方法，每次添加新功能时 CSS 文件都会变大。使用功能类，所有内容都是可重用的，因此您几乎不需要编写新的 CSS。</li><li><strong>更改会更安全。</strong> CSS 是全局性的，您永远不知道当您进行更改时会破坏掉什么。您 HTML 中的类是本地的，因此您可以更改它们而不必担心其他问题。</li></ul><h2 id="tailwindcss-打包后会不会太大"><a href="#tailwindcss-打包后会不会太大" class="headerlink" title="tailwindcss 打包后会不会太大"></a>tailwindcss 打包后会不会太大</h2><p><a href="https://tailwindcss.com/docs/optimizing-for-production" target="_blank" >见</a></p><p>Tailwind CSS 非常注重性能，旨在通过只生成项目中实际使用的 CSS 来生成尽可能小的 CSS 文件。</p><p>再加上缩小和网络压缩，这通常会导致 CSS 文件小于 10kB，即使对于大型项目也是如此。例如，Netflix 将 Tailwind 用于 Netflix Top 10，而整个网站仅通过网络提供 6.5kB 的 CSS。</p><p>有了这么小的 CSS 文件，您就不必担心复杂的解决方案，比如代码分割每个页面的 CSS，而只需发送一个小 CSS 文件即可下载并缓存，直到您重新部署站点。</p><p>对于最小的生产版本，我们建议使用 cssnano 之类的工具缩小 CSS，并使用 Brotli 压缩 CSS。</p><h2 id="tailwindcss-看起来像是行内，为什么不用行内样式"><a href="#tailwindcss-看起来像是行内，为什么不用行内样式" class="headerlink" title="tailwindcss 看起来像是行内，为什么不用行内样式"></a>tailwindcss 看起来像是行内，为什么不用行内样式</h2><p>对这种方式的一个普遍反应是, “这不就是内联样式吗？” 在某些方面是 — 您是将样式直接应用于元素，而不是为元素分配一个类，然后在这个类中设置样式。</p><p>但是使用功能类比内联样式具有一些重要的优点：</p><ul><li><strong>基于约束的设计</strong>. 使用内联样式, 每个值都是一个魔术数字。 使用功能类, 您是从预定义的设计系统中选择样式，这使得构建统一的 UI 变得更加容易。</li><li><strong>响应式的设计</strong>. 在内联样式中您不能使用媒体查询, 但您可以使用 Tailwind 的响应式功能类非常容易的构建完全响应式的界面。</li><li><strong>Hover, focus, 以及其它状态</strong>. 内联样式无法设置 hover 或者 focus 这样的状态, 但 Tailwind 的状态变体使用功能类可以非常容易的为这些状态设置样式。</li></ul><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>在使用功能优先的方式时，最大的可维护性问题是管理通用的可重复使用的功能类组合。</p><p>通过提取组件（通常做为模板片断或者组件），可以轻松解决此问题。</p><p>如果您想了解其他人使用此方法的经验，请查看以下资源：</p><p><a href="https://tailwindcss.com/docs/utility-first#:~:text=If%20you%E2%80%99d%20like%20to%20hear%20about%20others%E2%80%99%20experiences%20with%20this%20approach%2C%20check%20out%20the%20following%20resources%3A" target="_blank" >见</a></p><h2 id="tailwindcss-修饰速查表"><a href="#tailwindcss-修饰速查表" class="headerlink" title="tailwindcss 修饰速查表"></a>tailwindcss 修饰速查表</h2><p>默认情况下，Tailwind 中包含的每个修改器的快速 <a href="https://tailwindcss.com/docs/hover-focus-and-other-states#quick-reference" target="_blank" >参考表</a>。</p><h2 id="tailwindcss-伪类速查表"><a href="#tailwindcss-伪类速查表" class="headerlink" title="tailwindcss 伪类速查表"></a>tailwindcss 伪类速查表</h2><p><a href="https://tailwindcss.com/docs/hover-focus-and-other-states#pseudo-class-reference" target="_blank" >Pseudo-class reference</a></p><h2 id="额-主要使用-antd-库，tailwindcss-能混着用？"><a href="#额-主要使用-antd-库，tailwindcss-能混着用？" class="headerlink" title="额 主要使用 antd 库，tailwindcss 能混着用？"></a>额 主要使用 antd 库，tailwindcss 能混着用？</h2><p>可以混着用，而且还可能有问题 😓</p><p><a href="https://www.jianshu.com/p/2162daf865d9" target="_blank" >见</a></p><h2 id="tailwindcss-可能更适合业务不复杂，展示要求高的场景"><a href="#tailwindcss-可能更适合业务不复杂，展示要求高的场景" class="headerlink" title="tailwindcss 可能更适合业务不复杂，展示要求高的场景"></a>tailwindcss 可能更适合业务不复杂，展示要求高的场景</h2><ul><li><p>如果 B 端系统，不用 antd , 使用 tailwindcss 来开发，要自定义多少组件 😓</p></li><li><p>官网之类偏展示性的到非常适合（移动优先）</p></li><li><p>一些模版引擎需要借助一些插件，如 Django（django-tailwind）<a href="https://qa.1r1g.com/sf/ask/4437469851/" target="_blank" >见</a></p></li><li><p>设计软件支持 tailwindcss 语法的代码吗？</p></li></ul><h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p><strong>Responsive Design</strong></p><p>这种方法最让人惊讶的地方是，要为移动设备设计样式，您需要使用未经修改的实用程序版本，而不是 sm:前缀版本。不要把 sm 看作是“在小屏幕上”的意思，而要把它看作“在小断点上”。<br><a href="https://tailwindcss.com/docs/responsive-design#targeting-mobile-screens:~:text=Don%E2%80%99t%20think%20of%20sm%3A%20as%20meaning%20%E2%80%9Con%20small%20screens%E2%80%9D%2C%20think%20of%20it%20as%20%E2%80%9Cat%20the%20small%20breakpoint%E2%80%9C." target="_blank" >见</a></p><p>请注意，我们不必为 sm 断点或 xl 断点指定背景色-您只需要指定实用程序何时开始生效，而不是何时停止。<br><a href="https://tailwindcss.com/docs/responsive-design#:~:text=Notice%20that%20we%20did%20not" target="_blank" >见</a></p><hr/><p>Note that if you’re using Sass&#x2F;SCSS, you’ll need to use Sass’ interpolation feature to get this to work:</p><p><a href="https://tailwindcss.com/docs/functions-and-directives#:~:text=important%3B%0A%7D-,Note%20that,-if%20you%E2%80%99re%20using" target="_blank" >见</a></p><hr/><p>在每个组件 CSS 中使用@apply 不生效，要用插件的形式，作者说了，你不要搞这些奇葩的操作 <a href="https://tailwindcss.com/docs/functions-and-directives#using-apply-with-per-component-css:~:text=best%20solution%20is%20to%20just%20not%20do%20weird%20stuff%20like%20this%20at%20all" target="_blank" >见</a></p><p><a href="https://tailwindcss.com/docs/functions-and-directives#using-apply-with-per-component-css" target="_blank" >见</a></p><hr/><p>由于 Tailwind 使用嵌套对象语法来定义其默认调色板，因此请确保使用点符号来访问嵌套颜色。</p><p><a href="https://tailwindcss.com/docs/functions-and-directives#using-apply-with-per-component-css:~:text=)%3B%0A%7D-,Since,-Tailwind%20uses%20a" target="_blank" >见</a></p><p><strong>Using with Preprocessors</strong></p><p><a href="https://tailwindcss.com/docs/using-with-preprocessors#using-post-css-as-your-preprocessor" target="_blank" >见</a></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><strong>Reusing Styles</strong></p><p>利用编辑器和语言的特点 <a href="https://tailwindcss.com/docs/reusing-styles#using-editor-and-language-features" target="_blank" >见</a></p><p>利用循环，进行组件复用 <a href="https://tailwindcss.com/docs/reusing-styles#loops" target="_blank" >见</a></p><p>提取组件和部分组件 <a href="https://tailwindcss.com/docs/reusing-styles#extracting-components-and-partials" target="_blank" >见</a></p><p>不要依赖 CSS 类来提取复杂组件，使用 js 来处理 <a href="https://tailwindcss.com/docs/reusing-styles#compared-to-css-abstractions" target="_blank" >见</a></p><p>使用@apply 提取类 <a href="https://tailwindcss.com/docs/reusing-styles#extracting-classes-with-apply" target="_blank" >见</a></p><p>避免过早抽象 <a href="https://tailwindcss.com/docs/reusing-styles#avoiding-premature-abstraction" target="_blank" >见</a> 无论你做什么，不要仅仅为了让事情看起来“干净”而使用@apply。是的，充斥着 Tailwind 类的 HTML 模板有点难看。在拥有大量定制 CSS 的项目中进行更改会更糟糕。</p><p>如果您开始使用@apply 来处理所有事情，那么您基本上只是再次编写 CSS，并抛弃了 Tailwind 为您提供的所有工作流和可维护性优势，例如：</p><ul><li><strong>你必须时时刻刻想出类名</strong>——没有什么比为不值得命名的东西想出类名更能让你慢下来或耗尽你的精力。</li><li><strong>您必须在多个文件之间跳转以进行更改</strong>-这是一个比您在将所有内容放在一起之前想象的更大的工作流杀手。</li><li><strong>改变样式更可怕</strong>——CSS 是全球性的，你确定你可以在不破坏网站其他部分的情况下改变该类的最小宽度值吗？</li><li><strong>你的 CSS 包会更大</strong>。</li></ul><p>如果您打算使用@apply，请将其用于非常小的、高度可重用的东西，如按钮和表单控件，没用组件框架时候，你可以这么搞，甚至只有在您没有使用像 React(组件才是更好的选择)这样的框架时。</p><p>总之@apply 非常不建议用， 少用</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="工具-最基础"><a href="#工具-最基础" class="headerlink" title="工具 -最基础"></a>工具 -最基础</h3><h3 id="伪类伪元素"><a href="#伪类伪元素" class="headerlink" title="伪类伪元素"></a>伪类伪元素</h3><h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><h3 id="Dark-Mode"><a href="#Dark-Mode" class="headerlink" title="Dark Mode"></a>Dark Mode</h3><h3 id="复用样式"><a href="#复用样式" class="headerlink" title="复用样式"></a>复用样式</h3><h3 id="增加自定义样式"><a href="#增加自定义样式" class="headerlink" title="增加自定义样式"></a>增加自定义样式</h3><h3 id="函数和指令"><a href="#函数和指令" class="headerlink" title="函数和指令"></a>函数和指令</h3><h2 id="看看视频巩固下"><a href="#看看视频巩固下" class="headerlink" title="看看视频巩固下"></a>看看视频巩固下</h2><p>有时间在继续学吧～，现在也用不到</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.tailwindcss.cn/docs/functions-and-directives" target="_blank" >tailwindcss 中文文档， 内容不全</a></p><p><a href="https://tailwindcss.com/" target="_blank" >tailwindcss</a></p><p><a href="https://blog.csdn.net/qq_43456781/article/details/120269565" target="_blank" >见</a></p><p><a href="http://www.3dwindy.com/article/299521" target="_blank" >Tailwind CSS v3——核心思想（三）自定义样式</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome Extension</title>
      <link href="//post/2022-09-27chrome-extension.html"/>
      <url>//post/2022-09-27chrome-extension.html</url>
      
        <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>ModHeader，交互丑也就罢了，用Cookie还要收费,多大点事～ 还跟我要钱</p><img src="http://t-blog-images.aijs.top/img/202209271028841.webp" style="width:500px;max-width: 100%" /><h2 id="chrome-extension官网"><a href="#chrome-extension官网" class="headerlink" title="chrome extension官网"></a>chrome extension官网</h2><p><a href="https://developer.chrome.com/docs/extensions/mv3/getstarted/" target="_blank" >chrome extension官网</a></p><h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><ul><li>原生</li><li>vite + vue3</li><li>vite + react</li><li>create-react-app <a href="https://blog.logrocket.com/creating-chrome-extension-react-typescript/" target="_blank" >见</a></li></ul><p>原生的优点：是容易调试</p><p>框架的优点：写pupup交互方便， chrome相关api不能像开发网页一样直接调用，需要打包出dist</p><p>原生&#x2F;框架产物 </p><img src="http://t-blog-images.aijs.top/img/202209271040946.webp" style="width:500px;max-width: 100%" /><h2 id="chrome插件调试技巧"><a href="#chrome插件调试技巧" class="headerlink" title="chrome插件调试技巧"></a>chrome插件调试技巧</h2><p><a href="https://blog.spoock.com/2016/04/03/chrome-extension-debugging/" target="_blank" >chrome插件调试技巧</a></p><h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p><a href="https://developer.chrome.com/docs/extensions/mv3/manifest/" target="_blank" >见</a></p><h2 id="成为chrome商店开发者"><a href="#成为chrome商店开发者" class="headerlink" title="成为chrome商店开发者"></a>成为chrome商店开发者</h2><p>虽然，现在不是为了赚钱，可以后就说不定了～，先备着</p><p><a href="https://blog.csdn.net/iteye_13003/article/details/82643913" target="_blank" >Google Chrome商店开发者认证支付$5【图解认证支付成功】</a></p><p>如何支付：可以去淘宝搜搜～</p><h2 id="报错记录"><a href="#报错记录" class="headerlink" title="报错记录"></a>报错记录</h2><h3 id="报错1"><a href="#报错1" class="headerlink" title="报错1"></a>报错1</h3><p>Cannot find module ‘react&#x2F;jsx-runtime’ or its corresponding type declarations</p><p><a href="https://bobbyhadz.com/blog/react-cannot-find-module-react-jsx-runtime">https://bobbyhadz.com/blog/react-cannot-find-module-react-jsx-runtime</a></p><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p>For a Chrome Extension, you should be using a hash or memory history. You’ll run into problems otherwise.</p><p><a href="https://github.com/remix-run/react-router/issues/4309" target="_blank" >in Chrome Extension #4309 </a></p><h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2><img src="http://t-blog-images.aijs.top/img/202209282111429.png"  style="width:500px;max-width: 100%"/><img src="http://t-blog-images.aijs.top/img/202209282112634.png"  style="width:500px;max-width: 100%"/><img src="http://t-blog-images.aijs.top/img/202209282128437.png"  style="width:500px;max-width: 100%"/><h2 id="半成品"><a href="#半成品" class="headerlink" title="半成品"></a>半成品</h2><img src="http://t-blog-images.aijs.top/img/202210081428563.webp" style="width:500px;max-width: 100%" />]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 页面传参数</title>
      <link href="//post/2022-09-26react-params.html"/>
      <url>//post/2022-09-26react-params.html</url>
      
        <content type="html"><![CDATA[<h1 id="刷新不丢失"><a href="#刷新不丢失" class="headerlink" title="刷新不丢失"></a>刷新不丢失</h1><h2 id="更改浏览器url"><a href="#更改浏览器url" class="headerlink" title="更改浏览器url"></a>更改浏览器url</h2><ul><li>方案1: input type&#x3D;”search”</li><li>方案2: 直接操作location.href </li><li>方案3:</li></ul><h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><h1 id="刷新丢失，不刷新保留"><a href="#刷新丢失，不刷新保留" class="headerlink" title="刷新丢失，不刷新保留"></a>刷新丢失，不刷新保留</h1><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React TS 范型组件</title>
      <link href="//post/2022-09-25react%E8%8C%83%E5%9E%8B.html"/>
      <url>//post/2022-09-25react%E8%8C%83%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>TypeScript 中，类型（interface, type）是可以声明成泛型的，这很常见。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Props&lt;T&gt; &#123;  content: T;&#125;</code></pre><p>这表明 Props 接口定义了这么一种类型：</p><p>它是包含一个 content 字段的对象, 该 content 字段的类型由使用时的泛型 T 决定</p><p><strong>使用时候ts自动推断</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type StringProps &#x3D; Props&lt;string&gt;;let props: StringProps;props &#x3D; &#123;  &#x2F;&#x2F;   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322)  content: 42&#125;;props &#x3D; &#123;  &#x2F;&#x2F; ✅  content: &quot;hello&quot;&#125;;</code></pre><p>TypeScript 能够跟使用时候提供的值自动推断出类型 T，无需显式指定：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Props&lt;T&gt; &#123;  content: T;&#125;function Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;  console.log(props);&#125;&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;number&gt;(props: Props&lt;number&gt;): void *&#x2F;Foo(&#123; content: 42 &#125;);&#x2F;** 此时 Foo 的完整签名为： function Foo&lt;string&gt;(props: Props&lt;string&gt;): void *&#x2F;Foo(&#123; content: &quot;hello&quot; &#125;);</code></pre><p>上面因为 Foo 函数接收 <code>Props&lt;T&gt;</code> 作为入参，<br>意味着我们在调用 Foo 的时候需要传递类型 T 以确定<code> Props&lt;T&gt;</code>，所以 Foo 函数也变成了泛型。</p><p>当调用 <code>Foo(&#123; content: 42 &#125;)</code> 的时候，TypeScript 自动解析出 T 为 number，此时对应的函数签名为：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function Foo&lt;number&gt;(props: Props&lt;number&gt;): void;</code></pre><p>而我们并没有显式地指定其中的类型 T，像这样 <code>Foo&lt;number&gt;(&#123; content: 42 &#125;)</code>;。</p><h2 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a>泛型组件</h2><p>将上面的 Foo 函数返回 JSX 元素，就成了一个 React 组件。因为它是泛型函数，它所形成的组件也就成了 泛型组件&#x2F;Generic Components。</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function Foo&lt;T&gt;(props: Props&lt;T&gt;) &#123;  return &lt;div&gt; &#123;props.content&#125;&lt;&#x2F;div&gt;;&#125;const App &#x3D; () &#x3D;&gt; &#123;  return (    &lt;div className&#x3D;&quot;App&quot;&gt;      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;      &lt;Foo&lt;string&gt;&#x2F;**真的有点奇葩，理却是这个理 *&#x2F; content&#x3D;&#123;&quot;hello&quot;&#125;&gt;&lt;&#x2F;Foo&gt;    &lt;&#x2F;div&gt;  );&#125;;</code></pre><p>因为 TypeScript 可根据传入的实际值解析泛型类型，所以 <code>&lt;Foo&lt;string&gt; content=&#123;&quot;hello&quot;&#125;&gt;&lt;/Foo&gt;</code> 中 string 是可选的，这里只为展示，让你看到其实 React 组件还可以这么玩。</p><p>为了进一步理解泛型组件，再看下非泛型情况下上面的组件是长怎样的。</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface Props &#123;  content: string;&#125;function Foo(props: Props) &#123;  return &lt;div&gt;&#123;props.content&#125;&lt;&#x2F;div&gt;;&#125;const App &#x3D; () &#x3D;&gt; &#123;  return (    &lt;div className&#x3D;&quot;App&quot;&gt;      &#123;&#x2F;*   Type &#39;number&#39; is not assignable to type &#39;string&#39;.ts(2322) *&#x2F;&#125;      &lt;Foo content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Foo&gt;      &lt;Foo content&#x3D;&#123;&quot;hello&quot;&#125;&gt;&lt;&#x2F;Foo&gt;    &lt;&#x2F;div&gt;  );&#125;;</code></pre><p>以上，便是一个 React 组件常规的写法。它定义的入参 Props 只接收 string 类型。由此也看出泛型的优势，即大部分代码可复用的情况下，将参数变成泛型后，不同类型的入参可复用同一组件，不用为新类型新写一个组件。</p><p>除了函数组件，对于类类型的组件来说，也是一样可泛型化的。</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface Props&lt;T&gt; &#123;  content: T;&#125;class Bar&lt;T&gt; extends React.Component&lt;Props&lt;T&gt;&gt; &#123;  render() &#123;    return &lt;div&gt;&#123;this.props.content&#125;&lt;&#x2F;div&gt;;  &#125;&#125;const App &#x3D; () &#x3D;&gt; &#123;  return (    &lt;div className&#x3D;&quot;App&quot;&gt;      &lt;Bar content&#x3D;&#123;42&#125;&gt;&lt;&#x2F;Bar&gt;      &lt;Bar&lt;string&gt; content&#x3D;&#123;&quot;hello&quot;&#125;&gt;&lt;&#x2F;Bar&gt;    &lt;&#x2F;div&gt;  );&#125;;</code></pre><p>一个更加真实的示例<br>一个更加实用的示例是列表组件。列表中的分页加载，滚动刷新逻辑等，对于所有列表数据都是通用的，将这个列表组件书写成泛型便可和任意类型列表数据结合，而无须通过其他方式来达到复用的目的，将列表元素声明成 any 或 Record&lt;string,any&gt; 等类型。</p><p>先看不使用泛型情况下，如何实现这么一个列表组件。此处只看列表元素的展示以阐述泛型的作用，其他逻辑比如数据加载等先忽略。</p><p>列表组件 List.tsx</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface Item &#123;  [prop: string]: any;&#125;interface Props &#123;  list: Item[];  children: (item: Item, index: number) &#x3D;&gt; React.ReactNode;&#125;function List(&#123; list, children &#125;: Props) &#123;  &#x2F;&#x2F; 列表中其他逻辑...  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;&#125;</code></pre><p>上面，为了尽可能满足大部分数据类型，将列表的元素类型定义成了 <code>[prop: string]: any;</code> 的形式，其实和 <code>Record&lt;string,any&gt; </code>没差。在这里已经可以看到类型的丢失了，因为出现了 <code>any</code>，而我们使用 TypeScript 的首要准则是<code>尽量避免 any</code>。</p><p>然后是使用上面所定义的列表组件：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface User &#123;  id: number;  name: string;&#125;const data: User[] &#x3D; [  &#123;    id: 1,    name: &quot;wayou&quot;  &#125;,  &#123;    id: 1,    name: &quot;niuwayong&quot;  &#125;];const App &#x3D; () &#x3D;&gt; &#123;  return (    &lt;div className&#x3D;&quot;App&quot;&gt;      &lt;List list&#x3D;&#123;data&#125;&gt;        &#123;item &#x3D;&gt; &#123;          &#x2F;&#x2F;   此处 &#96;item.name&#96; 类型为 &#96;any&#96;          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;        &#125;&#125;      &lt;&#x2F;List&gt;    &lt;&#x2F;div&gt;  );&#125;;</code></pre><p>这里使用时，item.name 的类型已经成了 any。对于简单数据来说，还可以接收这样类型的丢失，但对于复杂类型，类型的丢失就完全享受不到 TypeScript 所带来的类型便利了。</p><p>上面的实现还有个问题是它规定了列表元素必需是对象，理所应当地就不能处理元始类型数组了，比如无法渲染 [‘wayou’,’niuwayong’] 这样的输入。</p><p>下面使用泛型改造上面的列表组件，让它支持外部传入类型。</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface Props&lt;T&gt; &#123;  list: T[];  children: (item: T, index: number) &#x3D;&gt; React.ReactNode;&#125;function List&lt;T&gt;(&#123; list, children &#125;: Props&lt;T&gt;) &#123;  &#x2F;&#x2F; 列表中其他逻辑...  return &lt;div&gt;&#123;list.map(children)&#125;&lt;&#x2F;div&gt;;&#125;</code></pre><p>改造后，列表元素的类型完全由使用的地方决定，作为列表组件，内部它无须关心，同时对于外部传递的 children 回调中 item 入参，类型也没有丢失。</p><p>使用改造后的泛型列表：</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface User &#123;  id: number;  name: string;&#125;const data: User[] &#x3D; [  &#123;    id: 1,    name: &quot;wayou&quot;  &#125;,  &#123;    id: 1,    name: &quot;niuwayong&quot;  &#125;];const App &#x3D; () &#x3D;&gt; &#123;  return (    &lt;div className&#x3D;&quot;App&quot;&gt;      &lt;List list&#x3D;&#123;data&#125;&gt;        &#123;item &#x3D;&gt; &#123;          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;User&#96;          return &lt;div key&#x3D;&#123;item.name&#125;&gt;&#123;item.name&#125;&lt;&#x2F;div&gt;;        &#125;&#125;      &lt;&#x2F;List&gt;      &lt;List list&#x3D;&#123;[&quot;wayou&quot;, &quot;niuwayong&quot;]&#125;&gt;        &#123;item &#x3D;&gt; &#123;          &#x2F;&#x2F;   此处 &#96;item&#96; 类型为 &#96;string&#96;          return &lt;div key&#x3D;&#123;item&#125;&gt;&#123;item&#125;&lt;&#x2F;div&gt;;        &#125;&#125;      &lt;&#x2F;List&gt;    &lt;&#x2F;div&gt;  );&#125;;</code></pre><h2 id="antd-Table"><a href="#antd-Table" class="headerlink" title="antd Table"></a>antd Table</h2><p>有人说：“表格那个真心体会到泛型组件”</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; &#x2F;code&#x2F;源码&#x2F;ant-design&#x2F;components&#x2F;table&#x2F;Table.tsx...export &#123; ColumnsType, TablePaginationConfig &#125;;...export interface TableProps&lt;RecordType&gt;extends Omit&lt;    RcTableProps&lt;RecordType&gt;,    | &#39;transformColumns&#39;    | &#39;internalHooks&#39;    | &#39;internalRefs&#39;    | &#39;data&#39;    | &#39;columns&#39;    | &#39;scroll&#39;    | &#39;emptyText&#39;  &gt; &#123;  ...  columns?: ColumnsType&lt;RecordType&gt;;  ...  &#125;function Table&lt;RecordType extends object &#x3D; any&gt;(props: TableProps&lt;RecordType&gt;) &#123;  ...  const &#123;    ...    columns,    ...  &#125; &#x3D; props;  &#x2F;&#x2F; 转化后的，之后直接用于 RcTable  const mergedColumns &#x3D; React.useMemo(() &#x3D;&gt; &#123;    const matched &#x3D; new Set(Object.keys(screens).filter((m: Breakpoint) &#x3D;&gt; screens[m]));    return (columns || convertChildrenToColumns(children)).filter(      (c: ColumnType&lt;RecordType&gt;) &#x3D;&gt;        !c.responsive || c.responsive.some((r: Breakpoint) &#x3D;&gt; matched.has(r)),    );  &#125;, [children, columns, screens]);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="//post/2022-09-24python.html"/>
      <url>//post/2022-09-24python.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python3-升级"><a href="#Python3-升级" class="headerlink" title="Python3 升级"></a>Python3 升级</h1><p><a href="https://www.python.org/" target="_blank" >官网</a></p><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/python/cpython">https://github.com/python/cpython</a><img src="https://img.shields.io/github/stars/python/cpython?style=social" /></div><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/golang/go">https://github.com/golang/go</a><img src="https://img.shields.io/github/stars/golang/go?style=social" /></div><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">$ python --versionPython 2.7.15$ python3 --versionPython 3.7.2$ brew upgrade python@3.10</code></pre><p>大概是 2019 年安装的 python 3.7.2 版本，看了下文档，有少数内容是需要 3.8 版本才可以使用，所以升级下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 尝试的方案就不提了，最后是使用brew更新的，我印象中也是使用brew进行安装的 Python 3.7.2&#x2F;&#x2F;  1. brew升级问题$ brew updateError:  homebrew-core is a shallow clone.  homebrew-cask is a shallow clone.To &#96;brew update&#96;, first run:&#x2F;&#x2F; 提示更新 homebrew-core 、 homebrew-cask  git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core fetch --unshallow  git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask fetch --unshallowThese commands may take a few minutes to run due to the large size of the repositories.This restriction has been made on GitHub&#39;s request because updating shallowclones is an extremely expensive operation due to the tree layout and traffic ofHomebrew&#x2F;homebrew-core and Homebrew&#x2F;homebrew-cask. We don&#39;t do this for youautomatically to avoid repeatedly performing an expensive unshallow operation inCI systems (which should instead be fixed to not use shallow clones). Sorry forthe inconvenience!$  git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core fetch --unshallowremote: Enumerating objects: 554589, done.remote: Counting objects: 100% (554579&#x2F;554579), done.remote: Compressing objects: 100% (203589&#x2F;203589), done.remote: Total 545216 (delta 349940), reused 533974 (delta 338772), pack-reused 0Receiving objects: 100% (545216&#x2F;545216), 185.96 MiB | 3.35 MiB&#x2F;s, done.Resolving deltas: 100% (349940&#x2F;349940), completed with 7224 local objects.From https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core   ec1cfdae42e..44f9ecb1cc9  master     -&gt; origin&#x2F;master$ git -C &#x2F;usr&#x2F;local&#x2F;Homebrew&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-cask fetch --unshallowremote: Enumerating objects: 183139, done.remote: Counting objects: 100% (170633&#x2F;170633), done.remote: Compressing objects: 100% (52991&#x2F;52991), done.remote: Total 157830 (delta 118189), reused 144193 (delta 104700), pack-reused 0Receiving objects: 100% (157830&#x2F;157830), 74.85 MiB | 3.34 MiB&#x2F;s, done.Resolving deltas: 100% (118189&#x2F;118189), completed with 6886 local objects.From https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-cask   372fbf30e9..91f5fb626d  master     -&gt; origin&#x2F;master&#x2F;&#x2F; python3.10安装$ brew upgrade python@3.10Running &#96;brew update --preinstall&#96;...&#x3D;&#x3D;&gt; Upgrading 1 outdated package:python@3.10 3.10.2 -&gt; 3.10.6_2Error: python@3.10: the bottle needs the Apple Command Line Tools to be installed.  You can install them, if desired, with:    xcode-select --installYou can try to install from source with:  brew install --build-from-source python@3.10Please note building from source is unsupported. You will encounter buildfailures with some formulae. If you experience any issues please create pullrequests instead of asking for help on Homebrew&#39;s GitHub, Twitter or any otherofficial channels.&#x2F;&#x2F; 失败提示$ xcode-select --installxcode-select: note: install requested for command line developer tools&#x2F;&#x2F; 从source安装$  brew install --build-from-source python@3.10...&#x2F;&#x2F; 安装 98.4% 失败######################################################################    98.4%curl: (56) LibreSSL SSL_read: error:02FFF03C:system library:func(4095):Operation timed out, errno 60Error: python@3.10: Failed to download resource &quot;python@3.10&quot;Download failed: https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.10.6&#x2F;Python-3.10.6.tgz&#x2F;&#x2F; 重新执行命令再次安装$  brew install --build-from-source python@3.10Running &#96;brew update --auto-update&#96;...python@3.10 3.7.2_2 is already installed but outdated (so it will be upgraded).&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.10.6&#x2F;Python-3.10.6.tgz######################################################################## 100.0%&#x3D;&#x3D;&gt; Upgrading python@3.10  3.10.2 -&gt; 3.10.6_2&#x2F;&#x2F; 整个过程很长，还需要vpn加持Last login: Sat Sep 24 17:31:07 on ttys008 $ python3 --versionPython 3.10.6 $ pythonzsh: command not found: python &#x2F;&#x2F; 是真的狗啊 $&#x2F;&#x2F; 发现又在下载了，我确认了下安装日志，之前是有2.7.15的&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.15&#x2F;Python-2.7.15.tar.xz######                                                                     8.6%$ brew install --build-from-source python@2.7.15Warning: No available formula with the name &quot;python@2.7.15&quot;. Did you mean python@3.7?&#x3D;&#x3D;&gt; Searching for similarly named formulae...This similarly named formula was found:python@3.7To install it, run:  brew install python@3.7&#x3D;&#x3D;&gt; Searching for a previously deleted formula (in the last month)...Error: No previously deleted formula found.&#x3D;&#x3D;&gt; Searching taps on GitHub...Error: No formulae found in taps.$ brew install --build-from-source python@2.7Warning: No available formula with the name &quot;python@2.7&quot;. Did you mean python@3.7, python@3.9, python@3.8, python@3.10 or python-yq?&#x3D;&#x3D;&gt; Searching for similarly named formulae...These similarly named formulae were found:python@3.7                   python@3.9                   python@3.8                   python@3.10 ✔                python-yqTo install one of them, run (for example):  brew install python@3.7&#x3D;&#x3D;&gt; Searching for a previously deleted formula (in the last month)...Error: No previously deleted formula found.&#x3D;&#x3D;&gt; Searching taps on GitHub...Error: No formulae found in taps.$ brew link --overwrite python@2Linking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15... 33 symlinks created.$ brew link --overwrite python@2Warning: Already linked: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15To relink, run:  brew unlink python@2 &amp;&amp; brew link python@2&#x2F;&#x2F; unlink、link$ brew unlink python@2 &amp;&amp; brew link python@2Unlinking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15... 33 symlinks removed.Linking &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@2&#x2F;2.7.15... 33 symlinks created.&#x2F;&#x2F; 终于好了$ python --versionPython 2.7.15$ python3 --versionPython 3.10.6$</code></pre><h1 id="python-官网"><a href="#python-官网" class="headerlink" title="python 官网"></a>python 官网</h1><p>对于 python 官网，我特意和 java、go、rust、nodejs 做了下比较，虽然 python 的官网也显得老旧，我甚至一度怀疑我看的是不是 python 文档。没 go 官网看的那么舒服。可毕竟人家是编程语言排名第一。嗯～，就这一点，都可以忍。学～</p><p><a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" >见 python</a></p><p><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" >见 runoob</a></p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>对于菜鸟教程上的例子，可以选择更改页面样式<code>img &#123;display: none&#125;</code>来查看，gif 文件跳来跳去，看的眼花，而且每个图占据那么大的空间，文章结构感被破坏了</p></div><h1 id="python-web-框架选择"><a href="#python-web-框架选择" class="headerlink" title="python web 框架选择"></a>python web 框架选择</h1><p>去 boss 搜了下，主要是 django 和 Flask</p><p><a href="https://zhuanlan.zhihu.com/p/359280800" target="_blank" >Django vs Flask: 到底应该选哪个?</a></p><p>我选了 django ,原因</p><ul><li>django star 多一点</li><li>Django vs Flask: 到底应该选哪个? 让我觉得，django 更稳</li><li>Django 官网比 Flask 看着舒服</li></ul><p><a href="https://pythondjango.cn/django/basic-tutorials" target="_blank" >见 pythondjango</a><br><a href="https://zhuanlan.zhihu.com/p/110479564" target="_blank" >Django 的由来及名字如何发音如何读</a><br><a href="https://zhuanlan.zhihu.com/p/110479564" target="_blank" >Django 由来</a></p><h1 id="我的感受"><a href="#我的感受" class="headerlink" title="我的感受"></a>我的感受</h1><p>在感受了 python， django 和 Flask。 我觉得，这比 java 简单多了，和 js 比较，python api 也更多，虽然，一开始有点抵触语法，习惯就好～</p><p>java 这玩意，生态再好，我都不想下手（虽然之前也有学过 😓，迷途小书童）</p><h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><p>Last login: Sat Sep 24 18:45:11 on ttys009<br>$ pip install Django&#x3D;&#x3D;4.1.1<br>zsh: command not found: pip<br>$ brew install pip<br>Running <code>brew update --auto-update</code>…<br>&#x3D;&#x3D;&gt; Auto-updated Homebrew!<br>Updated 1 tap (homebrew&#x2F;core).</p><p>You have 22 outdated formulae installed.<br>You can upgrade them with brew upgrade<br>or list them with brew outdated.</p><p>Warning: No available formula with the name “pip”. Did you mean pipx, pig, pit, php, pcp, pup, zip, sip or vip?<br>&#x3D;&#x3D;&gt; Searching for similarly named formulae…<br>These similarly named formulae were found:<br>aespipe libpipeline pipe-rename pipes-sh pyenv-pip-migrate pit zip<br>brew-pip pip-audit pipebench pipeviewer spiped php sip<br>grepip pip-completion pipemeter pipgrip xpipe pcp vip<br>lesspipe pip-tools pipenv pipx pig pup<br>To install one of them, run (for example):<br>brew install aespipe<br>pip is part of the python formula:<br>brew install python</p><h1 id="安装-Django"><a href="#安装-Django" class="headerlink" title="安装 Django"></a>安装 Django</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ python3 -m pip install DjangoCollecting Django  Downloading Django-4.1.1-python-none-any.whl (8.1 MB)     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 8.1&#x2F;8.1 MB 2.0 MB&#x2F;s eta 0:00:00Collecting sqlparse&gt;&#x3D;0.2.2  Downloading sqlparse-0.4.3-python-none-any.whl (42 kB)     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 42.8&#x2F;42.8 kB 238.6 kB&#x2F;s eta 0:00:00Collecting asgiref&lt;4,&gt;&#x3D;3.5.2  Downloading asgiref-3.5.2-python-none-any.whl (22 kB)Installing collected packages: sqlparse, asgiref, DjangoSuccessfully installed Django-4.1.1 asgiref-3.5.2 sqlparse-0.4.3</code></pre><p><a href="https://www.runoob.com/django/django-intro.html" target="_blank" >runoob</a></p><h1 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h1><h1 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h1><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><ul><li>正反向区别</li><li>一对一、一对多、多对多区别</li><li>单划线、双划线区别</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Book(models.Model):    title &#x3D; models.CharField(max_length&#x3D;32)    price &#x3D; models.DecimalField(max_digits&#x3D;5, decimal_places&#x3D;2)    pub_date &#x3D; models.DateField()    # 暂且理解 关联    publish &#x3D; models.ForeignKey(&quot;Publish&quot;, on_delete&#x3D;models.CASCADE)    # 多对多，    # 从Book往Author看，为正向，    # 从Author往Book看，为反向    authors &#x3D; models.ManyToManyField(&quot;Author&quot;)class Publish(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    city &#x3D; models.CharField(max_length&#x3D;64)    email &#x3D; models.EmailField()class Author(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.SmallIntegerField()    # 一对一    au_detail &#x3D; models.OneToOneField(&quot;AuthorDetail&quot;, on_delete&#x3D;models.CASCADE)class AuthorDetail(models.Model):    gender_choices &#x3D; (        (0, &quot;女&quot;),        (1, &quot;男&quot;),        (2, &quot;保密&quot;),    )    gender &#x3D; models.SmallIntegerField(choices&#x3D;gender_choices)    tel &#x3D; models.CharField(max_length&#x3D;32)    addr &#x3D; models.CharField(max_length&#x3D;64)    birthday &#x3D; models.DateField()</code></pre><p>说明：</p><p>1、EmailField 数据类型是邮箱格式，底层继承 CharField，进行了封装，相当于 MySQL 中的 varchar。</p><p>2、Django1.1 版本不需要联级删除：on_delete&#x3D;models.CASCADE，Django2.2 需要。</p><p>3、一般不需要设置联级更新.</p><p>4、外键在一对多的多中设置：models.ForeignKey(“关联类名”, on_delete&#x3D;models.CASCADE)。</p><p>5、OneToOneField &#x3D; ForeignKey(…，unique&#x3D;True)设置一对一。</p><p>6、若有模型类存在外键，创建数据时，要先创建外键关联的模型类的数据，不然创建包含外键的模型类的数据时，外键的关联模型类的数据会找不到。</p><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p><strong>书籍表 Book</strong>：title 、 price 、 pub_date 、 publish（外键，多对一） 、 authors（多对多）</p><p><strong>出版社表 Publish</strong>：name 、 city 、 email</p><p><strong>作者表 Author</strong>：name 、 age 、 au_detail（一对一）</p><p><strong>作者详情表 AuthorDetail</strong>：gender 、 tel 、 addr 、 birthday</p><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><img src="http://t-blog-images.aijs.top/img/202209251553634.png" /><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO app01_publish ( name, city, email )VALUES ( &quot;华山出版社&quot;, &quot;华山&quot;, &quot;hs@163.com&quot; ), ( &quot;明教出版社&quot;, &quot;黑木崖&quot;, &quot;mj@163.com&quot; )# 先插入 authordetail 表中多数据INSERT INTO app01_authordetail ( gender, tel, addr, birthday )VALUES ( 1, 13432335433, &quot;华山&quot;, &quot;1994-5-23&quot; ), ( 1, 13943454554, &quot;黑木崖&quot;, &quot;1961-8-13&quot; ), ( 0, 13878934322, &quot;黑木崖&quot;, &quot;1996-5-20&quot; )# 再将数据插入 author，这样 author 才能找到 authordetailINSERT INTO app01_author ( name, age, au_detail_id )VALUES ( &quot;令狐冲&quot;, 25, 1 ), ( &quot;任我行&quot;, 58, 2 ), ( &quot;任盈盈&quot;, 23, 3 )</code></pre><p>在 MySQL 中执行以下 SQL 插入操作：</p><h2 id="ORM-添加数据"><a href="#ORM-添加数据" class="headerlink" title="ORM - 添加数据"></a>ORM - 添加数据</h2><h3 id="一对多-外键-ForeignKey"><a href="#一对多-外键-ForeignKey" class="headerlink" title="一对多(外键 ForeignKey)"></a>一对多(外键 ForeignKey)</h3><p><strong>方式一:</strong> 传对象的形式，返回值的数据类型是对象，书籍对象。</p><p>步骤：</p><p>a. 获取出版社对象<br>b. 给书籍的出版社属性 pulish 传出版社对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01&#x2F;views.py 文件代码：def add_book(request):    #  获取出版社对象    pub_obj &#x3D; models.Publish.objects.filter(pk&#x3D;1).first() # pk 缩写 primary key    #  给书籍的出版社属性publish传出版社对象    book &#x3D; models.Book.objects.create(title&#x3D;&quot;菜鸟教程&quot;, price&#x3D;200, pub_date&#x3D;&quot;2010-10-10&quot;, publish&#x3D;pub_obj)    print(book, type(book))    return HttpResponse(book)</code></pre><p><strong>方式二:</strong> 传对象 ID 的形式（传对象 id 常用）</p><p>一对多中，设置外键属性的类(多的表)中，MySQL 中显示的字段名是:外键属性名_id。</p><p>返回值的数据类型是对象，书籍对象。</p><p>步骤：</p><p>a. 获取出版社对象的 id<br>b. 给书籍的关联出版社字段 pulish_id 传出版社对象的 id</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01&#x2F;views.py 文件代码：def add_book(request):    #  获取出版社对象    pub_obj &#x3D; models.Publish.objects.filter(pk&#x3D;1).first()    #  获取出版社对象的id    pk &#x3D; pub_obj.pk    #  给书籍的关联出版社字段 publish_id 传出版社对象的id    book &#x3D; models.Book.objects.create(title&#x3D;&quot;冲灵剑法&quot;, price&#x3D;100, pub_date&#x3D;&quot;2004-04-04&quot;, publish_id&#x3D;pk)    print(book, type(book))    return HttpResponse(book)</code></pre><h3 id="多对多-ManyToManyField-：在第三张关系表中新增数据"><a href="#多对多-ManyToManyField-：在第三张关系表中新增数据" class="headerlink" title="多对多(ManyToManyField)：在第三张关系表中新增数据"></a>多对多(ManyToManyField)：在第三张关系表中新增数据</h3><p><strong>方式一:</strong> 传对象形式，无返回值。</p><p>步骤：</p><p>a. 获取作者对象<br>b. 获取书籍对象<br>c. 给书籍对象的 authors 属性用 add 方法传作者对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01&#x2F;views.py 文件代码：def add_book(request):    #  获取作者对象    chong &#x3D; models.Author.objects.filter(name&#x3D;&quot;令狐冲&quot;).first()    ying &#x3D; models.Author.objects.filter(name&#x3D;&quot;任盈盈&quot;).first()    #  获取书籍对象    book &#x3D; models.Book.objects.filter(title&#x3D;&quot;菜鸟教程&quot;).first()    #  给书籍对象的 authors 属性用 add 方法传作者对象    book.authors.add(chong, ying)    return HttpResponse(book)</code></pre><p><strong>方式二:</strong> 传对象 id 形式，无返回值。</p><p>步骤：</p><p>a. 获取作者对象的 id<br>b. 获取书籍对象<br>c. 给书籍对象的 authors 属性用 add 方法传作者对象的 id</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># app01&#x2F;views.py 文件代码：def add_book(request):    #  获取作者对象    chong &#x3D; models.Author.objects.filter(name&#x3D;&quot;令狐冲&quot;).first()    #  获取作者对象的id    pk &#x3D; chong.pk    #  获取书籍对象    book &#x3D; models.Book.objects.filter(title&#x3D;&quot;冲灵剑法&quot;).first()    #  给书籍对象的 authors 属性用 add 方法传作者对象的id    book.authors.add(pk) # 这个不能理解了，authors这个字段接受了pk</code></pre><h2 id="关联管理器-对象调用"><a href="#关联管理器-对象调用" class="headerlink" title="关联管理器(对象调用)"></a>关联管理器(对象调用)</h2><p>前提：</p><h3 id="多对多（双向均有关联管理器）"><a href="#多对多（双向均有关联管理器）" class="headerlink" title="多对多（双向均有关联管理器）"></a>多对多（双向均有关联管理器）</h3><h3 id="一对多（只有多的那个类的对象有关联管理器，即反向才有）"><a href="#一对多（只有多的那个类的对象有关联管理器，即反向才有）" class="headerlink" title="一对多（只有多的那个类的对象有关联管理器，即反向才有）"></a>一对多（只有多的那个类的对象有关联管理器，即反向才有）</h3><p>语法格式：</p><p>正向：属性名<br>反向：小写类名加 _set</p><p><strong>注意：一对多只能反向</strong></p><p>常用方法：</p><p>add()：用于多对多，把指定的模型对象添加到关联对象集（关系表）中。</p><p>注意：add() 在一对多(即外键)中，只能传对象（ <em>QuerySet 数据类型），不能传 id（</em>[id 表]）。</p><p>*[ ] 的使用:</p><h3 id="方式一：传对象"><a href="#方式一：传对象" class="headerlink" title="方式一：传对象"></a>方式一：传对象</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">book_obj &#x3D; models.Book.objects.get(id&#x3D;10)author_list &#x3D; models.Author.objects.filter(id__gt&#x3D;2)book_obj.authors.add(*author_list)  # 将 id 大于2的作者对象添加到这本书的作者集合中</code></pre><h3 id="方式二：传对象-id"><a href="#方式二：传对象-id" class="headerlink" title="方式二：传对象 id"></a>方式二：传对象 id</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">book_obj.authors.add(*[1,3]) # 将 id&#x3D;1 和 id&#x3D;3 的作者对象添加到这本书的作者集合中return HttpResponse(&quot;ok&quot;)</code></pre><p>反向：小写表名_set</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ying &#x3D; models.Author.objects.filter(name&#x3D;&quot;任盈盈&quot;).first()book &#x3D; models.Book.objects.filter(title&#x3D;&quot;冲灵剑法&quot;).first()ying.book_set.add(book)return HttpResponse(&quot;ok&quot;)</code></pre><p>create()：创建一个新的对象，并同时将它添加到关联对象集之中。</p><p>返回新创建的对象。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pub &#x3D; models.Publish.objects.filter(name&#x3D;&quot;明教出版社&quot;).first()wo &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).first()book &#x3D; wo.book_set.create(title&#x3D;&quot;吸星大法&quot;, price&#x3D;300, pub_date&#x3D;&quot;1999-9-19&quot;, publish&#x3D;pub)print(book, type(book))return HttpResponse(&quot;ok&quot;)</code></pre><p>remove()：从关联对象集中移除执行的模型对象。</p><p>对于 ForeignKey 对象，这个方法仅在 null&#x3D;True（可以为空）时存在，无返回值。</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">author_obj &#x3D;models.Author.objects.get(id&#x3D;1)book_obj &#x3D; models.Book.objects.get(id&#x3D;11)author_obj.book_set.remove(book_obj)return HttpResponse(&quot;ok&quot;)</code></pre><p>clear()：从关联对象集中移除一切对象，删除关联，不会删除对象。</p><p>对于 ForeignKey 对象，这个方法仅在 null&#x3D;True（可以为空）时存在。</p><p>无返回值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 清空独孤九剑关联的所有作者book &#x3D; models.Book.objects.filter(title&#x3D;&quot;菜鸟教程&quot;).first()book.authors.clear()</code></pre><h2 id="ORM-查询-set-语法"><a href="#ORM-查询-set-语法" class="headerlink" title="ORM 查询 _set 语法"></a>ORM 查询 _set 语法</h2><p>基于对象的跨表查询。</p><p>正向：属性名称<br>反向：小写类名_set</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><h4 id="正向"><a href="#正向" class="headerlink" title="正向"></a>正向</h4><p>查询主键为 1 的书籍的出版社所在的城市（正向）。</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">book &#x3D; models.Book.objects.filter(pk&#x3D;1).first()res &#x3D; book.publish.cityprint(res, type(res))return HttpResponse(&quot;ok&quot;)</code></pre><h4 id="反向"><a href="#反向" class="headerlink" title="反向"></a>反向</h4><p>查询明教出版社出版的书籍名（反向）。</p><p>反向：对象.小写类名_set(pub.book_set) 可以跳转到关联的表(书籍表)。</p><p>pub.book_set.all()：取出书籍表的所有书籍对象，在一个 QuerySet 里，遍历取出一个个书籍对象。</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pub &#x3D; models.Publish.objects.filter(name&#x3D;&quot;明教出版社&quot;).first()res &#x3D; pub.book_set.all()for i in res:    print(i.title)return HttpResponse(&quot;ok&quot;)</code></pre><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>查询令狐冲的电话（正向）</p><h4 id="正向-1"><a href="#正向-1" class="headerlink" title="正向"></a>正向</h4><p>正向：对象.属性 (author.au_detail) 可以跳转到关联的表(作者详情表)</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">author &#x3D; models.Author.objects.filter(name&#x3D;&quot;令狐冲&quot;).first()res &#x3D; author.au_detail.telprint(res, type(res))return HttpResponse(&quot;ok&quot;)</code></pre><h4 id="反向-1"><a href="#反向-1" class="headerlink" title="反向"></a>反向</h4><p>查询所有住址在黑木崖的作者的姓名（反向）。</p><p>一对一的反向，用 对象.小写类名 即可，不用加 _set。（这个比较特别）</p><p>反向：对象.小写类名(addr.author)可以跳转到关联的表(作者表)。</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">addr &#x3D; models.AuthorDetail.objects.filter(addr&#x3D;&quot;黑木崖&quot;).first()res &#x3D; addr.author.nameprint(res, type(res))return HttpResponse(&quot;ok&quot;)</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>菜鸟教程所有作者的名字以及手机号（正向）。</p><h4 id="正向-2"><a href="#正向-2" class="headerlink" title="正向"></a>正向</h4><p>正向：对象.属性(book.authors)可以跳转到关联的表(作者表)。</p><p>作者表里没有作者电话，因此再次通过对象.属性(i.au_detail)跳转到关联的表（作者详情表）。</p><p><strong>实例</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">book &#x3D; models.Book.objects.filter(title&#x3D;&quot;菜鸟教程&quot;).first()res &#x3D; book.authors.all()for i in res:    print(i.name, i.au_detail.tel) # au_detail 为author类的一个字段return HttpResponse(&quot;ok&quot;)</code></pre><h4 id="反向-2"><a href="#反向-2" class="headerlink" title="反向"></a>反向</h4><p>查询任我行出过的所有书籍的名字（反向）。</p><p><strong>实例</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">author &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).first()res &#x3D; author.book_set.all()for i in res:    print(i.title)return HttpResponse(&quot;ok&quot;)</code></pre><h2 id="ORM-查询-基于双下划线的跨表查询-语法"><a href="#ORM-查询-基于双下划线的跨表查询-语法" class="headerlink" title="ORM 查询 基于双下划线的跨表查询 语法"></a>ORM 查询 基于双下划线的跨表查询 语法</h2><p><strong>正向：</strong>属性名称<strong>跨表的属性名称<br><strong>反向：</strong>小写类名</strong>跨表的属性名称（有个问题，如果类名和属性名一样，呃呃呃～～～？）</p><h3 id="一对多-1"><a href="#一对多-1" class="headerlink" title="一对多"></a>一对多</h3><p>查询菜鸟出版社出版过的所有书籍的名字与价格。</p><h4 id="正向-3"><a href="#正向-3" class="headerlink" title="正向"></a>正向</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(publish__name&#x3D;&quot;菜鸟出版社&quot;).values_list(&quot;title&quot;, &quot;price&quot;)</code></pre><h4 id="反向-3"><a href="#反向-3" class="headerlink" title="反向"></a>反向</h4><p>反向：通过 小写类名<strong>跨表的属性名称（book</strong>title，book__price） 跨表获取数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Publish.objects.filter(name&#x3D;&quot;菜鸟出版社&quot;).# Book 中有publish，从Publish 找Book为反向查找values_list(&quot;book__title&quot;,&quot;book__price&quot;) # 模型与表：只要存在模型关系，就可以获取相关表中数据return HttpResponse(&quot;ok&quot;)</code></pre><h3 id="多对多-1"><a href="#多对多-1" class="headerlink" title="多对多"></a>多对多</h3><p>查询任我行出过的所有书籍的名字。</p><h4 id="正向-4"><a href="#正向-4" class="headerlink" title="正向"></a>正向</h4><p>正向：通过 属性名称<strong>跨表的属性名称(authors</strong>name) 跨表获取数据：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(authors__name&#x3D;&quot;任我行&quot;).values_list(&quot;title&quot;)</code></pre><h4 id="反向-4"><a href="#反向-4" class="headerlink" title="反向"></a>反向</h4><p><strong>反向：</strong>通过 小写类名<strong>跨表的属性名称（book</strong>title） 跨表获取数据：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).values_list(&quot;book__title&quot;)</code></pre><h3 id="一对一-1"><a href="#一对一-1" class="headerlink" title="一对一"></a>一对一</h3><p>查询任我行的手机号。</p><h4 id="正向-5"><a href="#正向-5" class="headerlink" title="正向"></a>正向</h4><p><strong>正向：</strong>通过 属性名称<strong>跨表的属性名称(au_detail</strong>tel) 跨表获取数据。（Author 中 au_detail 字段）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Author.objects.filter(name&#x3D;&quot;任我行&quot;).values_list(&quot;au_detail__tel&quot;)</code></pre><h4 id="反向-5"><a href="#反向-5" class="headerlink" title="反向"></a>反向</h4><p><strong>反向：</strong>通过 小写类名<strong>跨表的属性名称（author</strong>name） 跨表获取数据。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.AuthorDetail.objects.filter(author__name&#x3D;&quot;任我行&quot;).values_list(&quot;tel&quot;)</code></pre><h2 id="ORM-–-多表实例（聚合与分组查询）"><a href="#ORM-–-多表实例（聚合与分组查询）" class="headerlink" title="ORM – 多表实例（聚合与分组查询）"></a>ORM – 多表实例（聚合与分组查询）</h2><h3 id="聚合查询（aggregate）"><a href="#聚合查询（aggregate）" class="headerlink" title="聚合查询（aggregate）"></a>聚合查询（aggregate）</h3><p>聚合查询函数是对一组值执行计算，并返回单个值。</p><p>Django 使用聚合查询前要先从 django.db.models 引入 Avg、Max、Min、Count、Sum（首字母大写）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Avg,Max,Min,Count,Sum  #   引入函数</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><ul><li><p>聚合查询返回值的数据类型是字典。</p></li><li><p>聚合函数 aggregate() 是 QuerySet 的一个终止子句， 生成的一个汇总值，相当于 count()。</p></li><li><p>使用 aggregate() 后，数据类型就变为字典，不能再使用 QuerySet 数据类型的一些 API 了。</p></li><li><p>日期数据类型(DateField)可以用 Max 和 Min。</p></li><li><p>返回的字典中：键的名称默认是（属性名称加上__聚合函数名），值是计算出来的聚合值。</p></li><li><p>如果要自定义返回字典的键的名称，可以起别名：</p></li><li><p>aggregate(别名 &#x3D; 聚合函数名(“属性名称”))</div></li></ul><p>计算所有图书的平均价格:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import Avg,Max,Min,Count,Sum  #   引入函数...res &#x3D; models.Book.objects.aggregate(Avg(&quot;price&quot;))print(res, type(res))...</code></pre><p>计算所有图书的数量、最贵价格和最便宜价格:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res&#x3D;models.Book.objects.aggregate(c&#x3D;Count(&quot;id&quot;),max&#x3D;Max(&quot;price&quot;),min&#x3D;Min(&quot;price&quot;))print(res,type(res)</code></pre><h3 id="分组查询（annotate）"><a href="#分组查询（annotate）" class="headerlink" title="分组查询（annotate）"></a>分组查询（annotate）</h3><p>分组查询一般会用到聚合函数，所以使用前要先从 django.db.models 引入 Avg,Max,Min,Count,Sum（首字母大写）。</p><p>from django.db.models import Avg,Max,Min,Count,Sum # 引入函数</p><p>返回值：</p><p>分组后，用 values 取值，则返回值是 QuerySet 数据类型里面为一个个字典；<br>分组后，用 values_list 取值，则返回值是 QuerySet 数据类型里面为一个个元组。<br>MySQL 中的 limit 相当于 ORM 中的 QuerySet 数据类型的切片。</p><p>注意：</p><p>annotate 里面放聚合函数。</p><p>values 或者 values_list 放在 annotate 前面：values 或者 values_list 是声明以什么字段分组，annotate 执行分组。</p><p>values 或者 values_list 放在 annotate 后面： annotate 表示直接以当前表的 pk 执行分组，values 或者 values_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values_list 里写其别名。</p><p>准备数据和创建模型</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># models.pyclass Emp(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    # 外键    salary &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)    dep &#x3D; models.CharField(max_length&#x3D;32)    province &#x3D; models.CharField(max_length&#x3D;32)class Emps(models.Model):    name &#x3D; models.CharField(max_length&#x3D;32)    age &#x3D; models.IntegerField()    salary &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)    # 外键    dep &#x3D; models.ForeignKey(&quot;Dep&quot;, on_delete&#x3D;models.CASCADE)    province &#x3D; models.CharField(max_length&#x3D;32)class Dep(models.Model):    title &#x3D; models.CharField(max_length&#x3D;32)</code></pre><p>数据:</p><p>在 MySQL 命令行中执行：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- app01_emp数据INSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;1&#39;, &#39;令狐冲&#39;, &#39;24&#39;, &#39;6000.00&#39;, &#39;销售部&#39; , &#39;河南&#39;);INSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;2&#39;, &#39;任盈盈&#39;, &#39;18&#39;, &#39;8000.00&#39;, &#39;关公部&#39; , &#39;广东&#39;);INSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;3&#39;, &#39;任我行&#39;, &#39;56&#39;, &#39;10000.00&#39;, &#39;销售部&#39; , &#39;广东&#39;);INSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;4&#39;, &#39;岳灵珊&#39;, &#39;19&#39;, &#39;6000.00&#39;, &#39;关公部&#39; , &#39;河南&#39;);INSERT INTO &#96; app01_emp &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; dep &#96; , &#96; province &#96;) VALUES (&#39;5&#39;, &#39;小龙女&#39;, &#39;20&#39;, &#39;8000.00&#39;, &#39;关公部&#39; , &#39;河北&#39;);-- app01_dep数据INSERT INTO &#96; app01_dep &#96; (&#96; id &#96;, &#96; title &#96;) VALUES (&#39;1&#39;, &#39;销售部&#39;);INSERT INTO &#96; app01_dep &#96; (&#96; id &#96;, &#96; title &#96;) VALUES (&#39;2&#39;, &#39;关公部&#39;);-- app01_emps 数据INSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;2&#39;, &#39;令狐冲&#39;, &#39;24&#39;, &#39;8000.00&#39;, &#39;河南&#39; , &#39;1&#39;);INSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;3&#39;, &#39;任盈盈&#39;, &#39;18&#39;, &#39;9000.00&#39;, &#39;广东&#39; , &#39;2&#39;);INSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;4&#39;, &#39;任我行&#39;, &#39;57&#39;, &#39;10000.00&#39;, &#39;广东&#39; , &#39;1&#39;);INSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;5&#39;, &#39;岳灵珊&#39;, &#39;19&#39;, &#39;6000.00&#39;, &#39;河南&#39; , &#39;2&#39;);INSERT INTO &#96; app01_emps &#96; (&#96; id &#96;, &#96; name &#96;, &#96; age &#96;, &#96; salary &#96;, &#96; province &#96; , &#96; dep_id &#96;) VALUES (&#39;6&#39;, &#39;小龙女&#39;, &#39;20&#39;, &#39;8000.00&#39;, &#39;河北&#39; , &#39;2&#39;);</code></pre><p>统计每一个出版社的最便宜的书的价格：</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Publish.objects.values(&quot;name&quot;).annotate(in_price &#x3D; Min(&quot;book__price&quot;))print(res)</code></pre><p>命令行中可以看到以下输出：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;QuerySet [&#123;&#39;name&#39;: &#39;菜鸟出版社&#39;, &#39;in_price&#39;: Decimal(&#39;100.00&#39;)&#125;, &#123;&#39;name&#39;: &#39;明教出版社&#39;, &#39;in_price&#39;: Decimal(&#39;300.00&#39;)&#125;]&gt;</code></pre><p>统计每一本书的作者个数：</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.annotate(c &#x3D; Count(&quot;authors__name&quot;)).values(&quot;title&quot;,&quot;c&quot;)print(res)</code></pre><p>命令行中可以看到以下输出：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;QuerySet [&#123;&#39;title&#39;: &#39;菜鸟教程&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;吸星大法&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;冲灵剑法&#39;, &#39;c&#39;: 1&#125;]&gt;</code></pre><p>统计每一本以”菜”开头的书籍的作者个数：</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(title__startswith&#x3D;&quot;菜&quot;).annotate(c &#x3D; Count(&quot;authors__name&quot;)).values(&quot;title&quot;,&quot;c&quot;)print(res)</code></pre><p>统计不止一个作者的图书名称：</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.annotate(c &#x3D; Count(&quot;authors__name&quot;)).filter(c__gt&#x3D;0).values(&quot;title&quot;,&quot;c&quot;)print(res)</code></pre><p>命令行中可以看到以下输出：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&lt;QuerySet [&#123;&#39;title&#39;: &#39;菜鸟教程&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;吸星大法&#39;, &#39;c&#39;: 1&#125;, &#123;&#39;title&#39;: &#39;冲灵剑法&#39;, &#39;c&#39;: 1&#125;]&gt;</code></pre><p>根据一本图书作者数量的多少对查询集 QuerySet 进行降序排序:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.annotate(c &#x3D; Count(&quot;authors__name&quot;)).order_by(&quot;-c&quot;).values(&quot;title&quot;,&quot;c&quot;)print(res)</code></pre><p>查询各个作者出的书的总价格:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Author.objects.annotate(all &#x3D; Sum(&quot;book__price&quot;)).values(&quot;name&quot;,&quot;all&quot;)print(res)</code></pre><h3 id="F-查询"><a href="#F-查询" class="headerlink" title="F() 查询"></a>F() 查询</h3><p>F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。</p><p>之前构造的过滤器都只是将字段值与某个常量做比较，如果想要对两个字段的值做比较，就需要用到 F()。</p><p>使用前要先从 django.db.models 引入 F:</p><p>from django.db.models import F<br>用法：</p><p>F(“字段名称”)<br>F 动态获取对象字段的值，可以进行运算。</p><p>Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取余的操作。</p><p>修改操作（update）也可以使用 F() 函数。</p><p>查询工资大于年龄的人：</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.db.models import F...book&#x3D;models.Emp.objects.filter(salary__gt&#x3D;F(&quot;age&quot;)).values(&quot;name&quot;,&quot;age&quot;)...</code></pre><p>将每一本书的价格提高 100 元:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.update(price&#x3D;F(&quot;price&quot;)+100)print(res)</code></pre><h3 id="Q-查询-（与-或-非）操作符"><a href="#Q-查询-（与-或-非）操作符" class="headerlink" title="Q() 查询 （与 或 非）操作符"></a>Q() 查询 （与 或 非）操作符</h3><p>使用前要先从 django.db.models 引入 Q:<br>from django.db.models import Q<br>用法：</p><p>Q(条件判断)</p><p>例如：</p><p>Q(title__startswith&#x3D;”菜”)<br>之前构造的过滤器里的多个条件的关系都是 and，如果需要执行更复杂的查询（例如 or 语句），就可以使用 Q 。</p><p>Q 对象可以使用 &amp; | ~ （与 或 非）操作符进行组合。</p><p>优先级从高到低：~ &amp; |。</p><p>可以混合使用 Q 对象和关键字参数，Q 对象和关键字参数是用”and”拼在一起的（即将逗号看成 and ），但是 Q 对象必须位于所有关键字参数的前面。</p><p>查询价格大于 350 或者名称以菜开头的书籍的名称和价格。</p><p>from django.db.models import Q<br>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">...res&#x3D;models.Book.objects.filter(Q(price__gt&#x3D;350)|Q(title__startswith&#x3D;&quot;菜&quot;)).values(&quot;title&quot;,&quot;price&quot;)print(res)...</code></pre><p>查询以”菜”结尾或者不是 2010 年 10 月份的书籍:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(Q(title__endswith&#x3D;&quot;菜&quot;) | ~Q(Q(pub_date__year&#x3D;2010) &amp; Q(pub_date__month&#x3D;10)))print(res)</code></pre><p>查询出版日期是 2004 或者 1999 年，并且书名中包含有”菜”的书籍。</p><p>Q 对象和关键字混合使用，Q 对象要在所有关键字的前面:</p><p>实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res &#x3D; models.Book.objects.filter(Q(pub_date__year&#x3D;2004) | Q(pub_date__year&#x3D;1999), title__contains&#x3D;&quot;菜&quot;)print(res)</code></pre><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p><a href="https://blog.csdn.net/weixin_34049948/article/details/92688433#:~:text=%E9%83%BD%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5-,%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E5%88%86%E9%A1%B5,-%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1" target="_blank" >见 django 中 orm 分页功能（内置分页）</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from django.core.paginator import Paginator,Page#导入模块def custom(request):  #获取当前页  current_page &#x3D; request.GET.get(&#39;page&#39;)  current_page &#x3D; int(current_page)  #每页显示10条  per_page &#x3D; 10  #1,0-10  #2，10-20  #3,20-30  start_page &#x3D; (current_page -1) * per_page  end_page &#x3D; current_page * per_page  user_list &#x3D; models.Uinfo.objects.all()[start_page:end_page]  return render(request,&#39;custom.html&#39;,&#123;&#39;user_list&#39;:user_list&#125;)</code></pre><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li>不支持 knif4j</li><li>swagger 不维护了</li><li>drf-yasg 不好用，而且还有 bug（仅仅点了几下就发现 bug,不能忍～）</li></ul><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>生态不全：经过两天学习，觉得 python 生态没想象中的那么优秀，Django 也没有想象中的那么好，生态最起码比不上 java 和 nodejs</p><p>语言简化：java 强语言，nodejs 有 typescipt 夹持，看起来 Django 优点弱鸡，python 更像是脚本语言</p><p>不好理解：Django ORM 用起来没有 Typeorm 或者 mybatis 那么好理解，有些单划线&#x2F;双划线的东西，为了简化而简化，失去语义话</p><p><em>有个问题：怎么就语言排行榜排到第一了，费解～</em></p><h2 id="我又安装了一遍-python"><a href="#我又安装了一遍-python" class="headerlink" title="我又安装了一遍 python"></a>我又安装了一遍 python</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">WARNING: Python 2.7 is not recommended.This version is included in macOS for compatibility with legacy software.&#x2F;&#x2F; macOS 以后默认是 python3Future versions of macOS will not include Python 2.7.Instead, it is recommended that you transition to using &#39;python3&#39; from within Terminal.👑 ~ $ python --versionPython 2.7.18👑 ~ $👑 ~ $👑 ~ $👑 ~ $👑 ~ $ brew updateUpdated 2 taps (homebrew&#x2F;core and homebrew&#x2F;cask).&#x3D;&#x3D;&gt; New Formulaeadamstark-audiofile           gaze                          lunar-date                    rdbage-plugin-yubikey            gcc@11                        mabel                         redis@6.2agg                           gcem                          maclaunch                     release-itantidote                      gdrive-downloader             mailsy                        reqapophenia                     gebug                         manifest-tool                 ripsecretsarxiv_latex_cleaner           ghc@8.10                      mariadb@10.7                  romeastro                         ghorg                         markdown-toc                  rush-parallelautocorrect                   git-codereview                mbt                           sambambaaws-nuke                      git-delete-merged-branches    mbw                           scala@2.13aws2-wrap                     git-machete                   mcap                          schemathesisaztfy                         git-sync                      meek                          sdl2_soundbazarr                        git-workspace                 mesheryctl                    sftpgobdftopcf                      glibc@2.13                    metalang99                    sgnberkeley-db@5                 glider                        metview                       sgrbfgminer                      gnustep-base                  micro_inetd                   shadercbore-cli                      go-camo                       minimap2                      slither-analyzerburst                         go@1.18                       mkfontscale                   smapc                             goctl                         mkp224o                       snapcastc2rust                        gokart                        mle                           snowballcamlp-streams                 got                           monika                        snowflakecargo-bundle                  groestlcoin                   mprocs                        solc-selectcargo-crev                    gum                           mqttui                        spirv-headerscargo-depgraph                has                           mxnet                         sprcargo-nextest                 hatch                         mycorrhiza                    sqlcmdcargo-udeps                   helix                         mypaint-brushes               sse2neoncargo-zigbuild                helmify                       nali                          stanc3cbindgen                      highway                       naml                          stencilcensys                        hof                           nb                            svt-av1cfonts                        hpp-fcl                       neovide                       swiftdrawchain-bench                   hwatch                        netcdf-cxx                    swtpmcircumflex                    hyx                           netcdf-fortran                synergy-corecommitlint                    iir1                          nftables                      taplocpi                           ijq                           nmrpflash                     tblscpp-httplib                   install-peerdeps              nuraft                        teacql-proxy                     interface99                   oak                           tellercreate-api                    iptables                      objconv                       terecrytic-compile                jackett                       ocl-icd                       terramatecurlcpp                       jaq                           octosql                       textractcxgo                          jj                            ohdear-cli                    tfelczg                           json2tsv                      onlykey-agent                 tinysearchdart-sdk                      jupp                          open62541                     tlsxdatatype99                    kalign                        opencl-headers                toml-testdbml-cli                      kics                          opencl-icd-loader             toxcoredistrobox                     ksh93                         opentelemetry-cpp             tradcppdocker-buildx                 kt-connect                    openvi                        treefmtdoggo                         kubesess                      ouch                          tremor-runtimedooit                         leapp-cli                     pacmc                         trezor-bridgedotdrop                       levant                        page                          trzsz-godronedb                       lexicon                       pax                           ttdldsda-doom                     lgeneral                      pg_cron                       ttmathdtrx                          libabw                        pg_partman                    tucdump1090-mutability           libapplewm                    pget                          tuntoxdumpling                      libbpf                        phrase-cli                    tygodunamai                       libeatmydata                  pint                          typewrittendura                          libff                         pipe-rename                   unisonlangdynein                        liblbfgs                      pixie                         uthashechidna                       libnetfilter_conntrack        pixiewps                      vectorscanedencommon                    libnftnl                      pkcs11-tools                  verapdfeditorconfig-checker          libnl                         poac                          verovioeget                          libobjc2                      pocl                          vileenex2notion                   libplacebo                    podman-compose                vineyarderlang@24                     libpython-tabulate            popeye                        virt-managerevernote-backup               libtpms                       primecount                    vscefastfetch                     liburing                      protobuf@3                    vulkan-loaderfastnetmon                    libvatek                      prql-compiler                 wasm-micro-runtimefclones                       libxcvt                       prr                           wb32-dfu-updater_clifelinks                       libxfont2                     purescript-language-server    weasyprintfend                          licenseplist                  pymol                         webkitgtkferium                        licensor                      pymupdf                       x86_64-linux-gnu-binutilsflix                          linux-headers@5.15            python-build                  xcode-kotlinflock                         livekit                       python-typing-extensions      xctesthtmlreportfonts-encodings               livekit-cli                   pyyaml                        xdg-ninjafortls                        llvm@13                       qbe                           xkbcompfred                          llvm@14                       qsv                           xpipefreebayes                     lmfit                         quilt-installer               xwinfuego-firestore               lndir                         quran                         yorkiegator                         lucky-commit                  railway                       zx&#x3D;&#x3D;&gt; New Casksaethersx2                                                   mbcordakiflow                                                     medisaliwangwang                                                 megaamazon-luna                                                 metadaticsapifox                                                      miaoyanapipost                                                     micromambaapp-fair                                                    mighty-mikeaptakube                                                    miln-movie-splitterarchy                                                       miniwolarduino-ide                                                 mintsastrofox                                                    moderndeckavifquicklook                                               mp3tagbattery                                                     mx-power-gadgetbeast2                                                      nanoembetterandbetter                                             nitro-pdf-probetterdisplay                                               notesnookbike                                                        opencore-patcherbili-downloader                                             orangedrangon-android-messagesbing-wallpaper                                              orionblack-light                                                 orka-vm-toolsblack-light-pro                                             oso-cloudbluebubbles                                                 osubookwright                                                  oxwubridge                                                      phpwebstudycalhash                                                     pictureviewcardinal                                                    playcover-communitycardpresso                                                  plex-htpcchromium-gost                                               plugdatacider                                                       plus42-binarycisdem-duplicate-finder                                     plus42-decimalcleaneronepro                                               podman-desktopcloud189                                                    polypadcontour                                                     postman-clicro-mag-rally                                               protokoldcp-o-matic-combiner                                        psstdcp-o-matic-disk-writer                                     qspace-prodcp-o-matic-editor                                          qwerty-frdcp-o-matic-playlist-editor                                 random-mouse-clickerdecentr                                                     readdle-sparkdetail                                                      reflectdevcleaner                                                  reversodiffusionbee                                                rnnoisedixa                                                        roam-researchdmg-canvas                                                  rockboxutilitydoll                                                        rustdeskdouyin                                                      sanesidebuttonsdrawpile                                                    shop-differentduckduckgo                                                  snapmaker-lubanecamm-live                                                  solelectrum-grs                                                sonixdelephicon                                                   splineferdium                                                     squashfertigt-slate                                               swiftcordfilen                                                       tailscalefly-key                                                     tdr-kotelnikovfresh                                                       tdr-novagama                                                        tdr-vos-slickeqgama-jdk                                                    tempboxgamemaker                                                   texifiergamma-control                                               ti-smartview-ce-for-the-ti-84-plus-familygittyup                                                     tl-legacyglance-chamburr                                             tmpdiskgoxel                                                       tomatobargroestlcoin-core                                            tqslgyroflow                                                    trivialhdfview                                                     trunk-ioheadlamp                                                    twitch-studiohttpie                                                      typcn-bilibiliimhex                                                       uiinput-source-pro                                            ukrainian-typographic-keyboardiqmol                                                       universal-android-debloaterjpc-qlcolorcode                                             v2ray-unofficialjquake                                                      vedjuice                                                       viebkeet                                                        virtualbuddylaconvolver                                                 weektodolanguagetool                                                whist-browserlectrote                                                    wirecastlemonlime                                                   workmanlivebook                                                    wowlocalxpose                                                  xiv-on-maclookingglassbridge                                          xprochecklookingglassstudio                                          yandex-music-unofficiallunacy                                                      yatteemacforge                                                    yousicianmanila                                                      yubihsm2-sdk&#x3D;&#x3D;&gt; Outdated Formulaeboost               gdbm                jpeg                ncurses             redis               zsh-completionsca-certificates     gettext             libidn2             nginx               sqlite              zstdcocoapods           git                 libpng              openssl@1.1         treedouble-conversion   glog                libtiff             pcre2               watchmanfmt                 graphicsmagick      libtool             python@3.10         webpfolly               icu4c               little-cms2         python@3.9          xzfreetype            jasper              lz4                 readline            zshYou have 37 outdated formulae installed.You can upgrade them with brew upgradeor list them with brew outdated.👑 ~ $ brew upgrade python@3.10&#x3D;&#x3D;&gt; Upgrading 1 outdated package:python@3.10 3.10.0_2 -&gt; 3.10.7&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;gdbm&#x2F;manifests&#x2F;1.23######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;gdbm&#x2F;blobs&#x2F;sha256:0d0aeea95f9e7b4ccfa1e8d7f3a83b3b4d604eac1178e4f88ad&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:0d0aeea95f9e7b4ccfa1e8d7f3a83b3b4######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;ca-certificates&#x2F;manifests&#x2F;2022-10-11######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;ca-certificates&#x2F;blobs&#x2F;sha256:1b264e579e31b3041a87ff91f09d5f7cc0d51fea&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:1b264e579e31b3041a87ff91f09d5f7cc######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;openssl&#x2F;1.1&#x2F;manifests&#x2F;1.1.1r######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;openssl&#x2F;1.1&#x2F;blobs&#x2F;sha256:7b4469b13c9dccfaf9a239b8fad644e3bd31d1bba474&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:7b4469b13c9dccfaf9a239b8fad644e3b######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;readline&#x2F;manifests&#x2F;8.2.1######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;readline&#x2F;blobs&#x2F;sha256:19e6b02f577010a1a33c6ae6f09e40772d6ab22d94b6cf3&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:19e6b02f577010a1a33c6ae6f09e40772######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;sqlite&#x2F;manifests&#x2F;3.39.4######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;sqlite&#x2F;blobs&#x2F;sha256:43b72d87a55f57496284e1028986373e918f382b8381e6b29&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:43b72d87a55f57496284e1028986373e9######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;xz&#x2F;manifests&#x2F;5.2.7######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;xz&#x2F;blobs&#x2F;sha256:02ed422191f81ca5c476f82264b6662a1ebcf95b90fb3ee10b524&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:02ed422191f81ca5c476f82264b6662a1######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.10&#x2F;manifests&#x2F;3.10.7######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.10&#x2F;blobs&#x2F;sha256:710e2e28077bf203fd50929bb094cb142e26f6ffd666&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:710e2e28077bf203fd50929bb094cb142######################################################################## 100.0%&#x3D;&#x3D;&gt; Upgrading python@3.10  3.10.0_2 -&gt; 3.10.7&#x3D;&#x3D;&gt; Installing dependencies for python@3.10: gdbm, ca-certificates, openssl@1.1, readline, sqlite and xz&#x3D;&#x3D;&gt; Installing python@3.10 dependency: gdbm&#x3D;&#x3D;&gt; Pouring gdbm--1.23.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;gdbm&#x2F;1.23: 24 files, 956.7KB&#x3D;&#x3D;&gt; Installing python@3.10 dependency: ca-certificates&#x3D;&#x3D;&gt; Pouring ca-certificates--2022-10-11.all.bottle.tar.gz&#x3D;&#x3D;&gt; Regenerating CA certificate bundle from keychain, this may take a while...🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;ca-certificates&#x2F;2022-10-11: 3 files, 225.5KB&#x3D;&#x3D;&gt; Installing python@3.10 dependency: openssl@1.1&#x3D;&#x3D;&gt; Pouring openssl@1.1--1.1.1r.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openssl@1.1&#x2F;1.1.1r: 8,097 files, 18.5MB&#x3D;&#x3D;&gt; Installing python@3.10 dependency: readline&#x3D;&#x3D;&gt; Pouring readline--8.2.1.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;readline&#x2F;8.2.1: 50 files, 1.7MB&#x3D;&#x3D;&gt; Installing python@3.10 dependency: sqlite&#x3D;&#x3D;&gt; Pouring sqlite--3.39.4.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;sqlite&#x2F;3.39.4: 11 files, 4.4MB&#x3D;&#x3D;&gt; Installing python@3.10 dependency: xz&#x3D;&#x3D;&gt; Pouring xz--5.2.7.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;xz&#x2F;5.2.7: 95 files, 1.4MB&#x3D;&#x3D;&gt; Installing python@3.10&#x3D;&#x3D;&gt; Pouring python@3.10--3.10.7.monterey.bottle.tar.gzError: The &#96;brew link&#96; step did not complete successfullyThe formula built, but is not symlinked into &#x2F;usr&#x2F;localCould not symlink bin&#x2F;2to3Target &#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3already exists. You may want to remove it:  rm &#39;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3&#39;To force the link and overwrite all conflicting files:  brew link --overwrite python@3.10To list all files that would be deleted:  brew link --overwrite --dry-run python@3.10Possible conflicting files are:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;2to3&#x2F;usr&#x2F;local&#x2F;bin&#x2F;2to3-3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;2to3-3.10&#x2F;usr&#x2F;local&#x2F;bin&#x2F;idle3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;idle3&#x2F;usr&#x2F;local&#x2F;bin&#x2F;idle3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;idle3.10&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pydoc3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;pydoc3&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pydoc3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;pydoc3.10&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3-config -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3-config&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10 -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3.10&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.10-config -&gt; &#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#x2F;python3.10-config&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7&#x2F;bin&#x2F;python3.10 -m ensurepip&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7&#x2F;bin&#x2F;python3.10 -m pip install -v --no-deps --no-index --upgrade --isolated --target&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.10&#x2F;site-packages &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7&#x2F;Fr&#x3D;&#x3D;&gt; Summary🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.7: 3,112 files, 56.5MB&#x3D;&#x3D;&gt; Running &#96;brew cleanup python@3.10&#96;...Disable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.Hide these hints with HOMEBREW_NO_ENV_HINTS (see &#96;man brew&#96;).Removing: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.10&#x2F;3.10.0_2... (3,134 files, 55.8MB)&#x3D;&#x3D;&gt; Upgrading 5 dependents of upgraded formulae:Disable this behaviour by setting HOMEBREW_NO_INSTALLED_DEPENDENTS_CHECK.Hide these hints with HOMEBREW_NO_ENV_HINTS (see &#96;man brew&#96;).folly 2021.10.18.00 -&gt; 2022.10.03.00, nginx 1.21.5 -&gt; 1.23.1, python@3.9 3.9.7_1 -&gt; 3.9.15, redis 6.2.6 -&gt; 7.0.5, watchman 2021.10.18.00 -&gt; 2022.10.03.00&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;icu4c&#x2F;manifests&#x2F;71.1######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;icu4c&#x2F;blobs&#x2F;sha256:87617a04333c53236f5174f5a3fa70458d61d735024ed477c0&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:87617a04333c53236f5174f5a3fa70458######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;lz4&#x2F;manifests&#x2F;1.9.4######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;lz4&#x2F;blobs&#x2F;sha256:88b369cea90a0a119c24aa96a614fe7d77de58d18cb1803023dc&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:88b369cea90a0a119c24aa96a614fe7d7######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;zstd&#x2F;manifests&#x2F;1.5.2-3######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;zstd&#x2F;blobs&#x2F;sha256:b0eabfa556c5aed039a5b22cd7e2e3dd52c7d2416c1141e4a8e&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:b0eabfa556c5aed039a5b22cd7e2e3dd5######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;boost&#x2F;manifests&#x2F;1.80.0######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;boost&#x2F;blobs&#x2F;sha256:cc487497f5beaa3726ed3e8772e8066e968ad494917b35c58c&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:cc487497f5beaa3726ed3e8772e8066e9######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;double-conversion&#x2F;manifests&#x2F;3.2.1######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;double-conversion&#x2F;blobs&#x2F;sha256:ab33e3194744d91e611c402d1f5ed5243ffa7b&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:ab33e3194744d91e611c402d1f5ed5243######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fmt&#x2F;manifests&#x2F;9.1.0######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fmt&#x2F;blobs&#x2F;sha256:324344e5048ea4bf92352dcdfae63832d447c0d27cc01d45eecc&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:324344e5048ea4bf92352dcdfae63832d######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;glog&#x2F;manifests&#x2F;0.6.0######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;glog&#x2F;blobs&#x2F;sha256:04b418eda3d8089e64ab902d265dd935245c815b19933173f67&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:04b418eda3d8089e64ab902d265dd9352######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;folly&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;folly&#x2F;blobs&#x2F;sha256:98bfca5e3fb0a99e08f7bd7336ae3984eb4ca5cee7a716885a&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:98bfca5e3fb0a99e08f7bd7336ae3984e######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;pcre2&#x2F;manifests&#x2F;10.40######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;pcre2&#x2F;blobs&#x2F;sha256:3d2707e8d5a80e1a28875e3b9c7b47cebaf5fd420049d6f1a7&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:3d2707e8d5a80e1a28875e3b9c7b47ceb######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;nginx&#x2F;manifests&#x2F;1.23.1######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;nginx&#x2F;blobs&#x2F;sha256:7e05d8658f1e2c264028530fc70ba4c87e6c152b85b3f014f2&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:7e05d8658f1e2c264028530fc70ba4c87######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.9&#x2F;manifests&#x2F;3.9.15######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;python&#x2F;3.9&#x2F;blobs&#x2F;sha256:15e10e163d4e24b12ba288b00bc9a7d4c4369a42dbbec&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:15e10e163d4e24b12ba288b00bc9a7d4c######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;redis&#x2F;manifests&#x2F;7.0.5######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;redis&#x2F;blobs&#x2F;sha256:34957c1e8e932793ff3d356fe5ae0e1bb36d9f0b6418ef25f0&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:34957c1e8e932793ff3d356fe5ae0e1bb######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;edencommon&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;edencommon&#x2F;blobs&#x2F;sha256:9d84be36d7c4ac1ae077fa732233e86fc2e11ef3511c0&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:9d84be36d7c4ac1ae077fa732233e86fc######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;libsodium&#x2F;manifests&#x2F;1.0.18_1######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;libsodium&#x2F;blobs&#x2F;sha256:522ac3f26c646f3d276b0c997e1a2771559d4766362d28&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:522ac3f26c646f3d276b0c997e1a27715######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fizz&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fizz&#x2F;blobs&#x2F;sha256:8c0a984b2701acfe0d03f5b8c6e407367fef65f9a55540681ea&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:8c0a984b2701acfe0d03f5b8c6e407367######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;wangle&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;wangle&#x2F;blobs&#x2F;sha256:eabcfc7dd5dbf84488847e008559e5259ce11a534726f2f7f&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:eabcfc7dd5dbf84488847e008559e5259######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fbthrift&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fbthrift&#x2F;blobs&#x2F;sha256:32977a7a9420533f6de58dd1734e9e42a5aba22d624bff5&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:32977a7a9420533f6de58dd1734e9e42a######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fb303&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;fb303&#x2F;blobs&#x2F;sha256:ade782f9844e6f1a96a5a8bec6f582b6aaae0a39b01bbdd3e5&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:ade782f9844e6f1a96a5a8bec6f582b6a######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;watchman&#x2F;manifests&#x2F;2022.10.03.00######################################################################## 100.0%&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;ghcr.io&#x2F;v2&#x2F;homebrew&#x2F;core&#x2F;watchman&#x2F;blobs&#x2F;sha256:a5974893885c994eb31772fa0eeccd016cfa9b1e31c7f7a&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;pkg-containers.githubusercontent.com&#x2F;ghcr1&#x2F;blobs&#x2F;sha256:a5974893885c994eb31772fa0eeccd016######################################################################## 100.0%&#x3D;&#x3D;&gt; Upgrading folly  2021.10.18.00 -&gt; 2022.10.03.00&#x3D;&#x3D;&gt; Installing dependencies for folly: icu4c, lz4, zstd, boost, double-conversion, fmt and glog&#x3D;&#x3D;&gt; Installing folly dependency: icu4c&#x3D;&#x3D;&gt; Pouring icu4c--71.1.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;icu4c&#x2F;71.1: 262 files, 76.2MB&#x3D;&#x3D;&gt; Installing folly dependency: lz4&#x3D;&#x3D;&gt; Pouring lz4--1.9.4.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;lz4&#x2F;1.9.4: 22 files, 685.2KB&#x3D;&#x3D;&gt; Installing folly dependency: zstd&#x3D;&#x3D;&gt; Pouring zstd--1.5.2.monterey.bottle.3.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zstd&#x2F;1.5.2: 31 files, 2.4MB&#x3D;&#x3D;&gt; Installing folly dependency: boost&#x3D;&#x3D;&gt; Pouring boost--1.80.0.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;boost&#x2F;1.80.0: 15,568 files, 472MB&#x3D;&#x3D;&gt; Installing folly dependency: double-conversion&#x3D;&#x3D;&gt; Pouring double-conversion--3.2.1.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;double-conversion&#x2F;3.2.1: 26 files, 242.3KB&#x3D;&#x3D;&gt; Installing folly dependency: fmt&#x3D;&#x3D;&gt; Pouring fmt--9.1.0.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fmt&#x2F;9.1.0: 27 files, 1MB&#x3D;&#x3D;&gt; Installing folly dependency: glog&#x3D;&#x3D;&gt; Pouring glog--0.6.0.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;glog&#x2F;0.6.0: 22 files, 315.7KB&#x3D;&#x3D;&gt; Installing folly&#x3D;&#x3D;&gt; Pouring folly--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;folly&#x2F;2022.10.03.00: 839 files, 24.5MB&#x3D;&#x3D;&gt; Running &#96;brew cleanup folly&#96;...Removing: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;folly&#x2F;2021.10.18.00... (795 files, 23.6MB)&#x3D;&#x3D;&gt; Upgrading nginx  1.21.5 -&gt; 1.23.1&#x3D;&#x3D;&gt; Installing dependencies for nginx: pcre2&#x3D;&#x3D;&gt; Installing nginx dependency: pcre2&#x3D;&#x3D;&gt; Pouring pcre2--10.40.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;pcre2&#x2F;10.40: 230 files, 6.4MB&#x3D;&#x3D;&gt; Installing nginx&#x3D;&#x3D;&gt; Pouring nginx--1.23.1.monterey.bottle.tar.gz&#x3D;&#x3D;&gt; CaveatsDocroot is: &#x2F;usr&#x2F;local&#x2F;var&#x2F;wwwThe default port has been set in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;.To restart nginx after an upgrade:  brew services restart nginxOr, if you don&#39;t want&#x2F;need a background service you can just run:  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;&#x3D;&#x3D;&gt; Summary🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.23.1: 26 files, 2.2MB&#x3D;&#x3D;&gt; Running &#96;brew cleanup nginx&#96;...Removing: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.21.5... (26 files, 2.2MB)&#x3D;&#x3D;&gt; Upgrading python@3.9  3.9.7_1 -&gt; 3.9.15&#x3D;&#x3D;&gt; Pouring python@3.9--3.9.15.monterey.bottle.tar.gz&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15&#x2F;bin&#x2F;python3.9 -m ensurepip&#x3D;&#x3D;&gt; &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15&#x2F;bin&#x2F;python3.9 -m pip install -v --no-deps --no-index --upgrade --isolated --target&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.9&#x2F;site-packages &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15&#x2F;Framew🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.15: 3,069 files, 55.5MB&#x3D;&#x3D;&gt; Running &#96;brew cleanup python@3.9&#96;...Removing: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;python@3.9&#x2F;3.9.7_1... (3,080 files, 54.6MB)&#x3D;&#x3D;&gt; Upgrading redis  6.2.6 -&gt; 7.0.5&#x3D;&#x3D;&gt; Pouring redis--7.0.5.monterey.bottle.tar.gz&#x3D;&#x3D;&gt; CaveatsTo restart redis after an upgrade:  brew services restart redisOr, if you don&#39;t want&#x2F;need a background service you can just run:  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis.conf&#x3D;&#x3D;&gt; Summary🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;redis&#x2F;7.0.5: 14 files, 2.6MB&#x3D;&#x3D;&gt; Running &#96;brew cleanup redis&#96;...Removing: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;redis&#x2F;6.2.6... (14 files, 2.0MB)&#x3D;&#x3D;&gt; Upgrading watchman  2021.10.18.00 -&gt; 2022.10.03.00&#x3D;&#x3D;&gt; Installing dependencies for watchman: edencommon, libsodium, fizz, wangle, fbthrift and fb303&#x3D;&#x3D;&gt; Installing watchman dependency: edencommon&#x3D;&#x3D;&gt; Pouring edencommon--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;edencommon&#x2F;2022.10.03.00: 15 files, 294.7KB&#x3D;&#x3D;&gt; Installing watchman dependency: libsodium&#x3D;&#x3D;&gt; Pouring libsodium--1.0.18_1.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;libsodium&#x2F;1.0.18_1: 73 files, 1MB&#x3D;&#x3D;&gt; Installing watchman dependency: fizz&#x3D;&#x3D;&gt; Pouring fizz--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fizz&#x2F;2022.10.03.00: 184 files, 3.8MB&#x3D;&#x3D;&gt; Installing watchman dependency: wangle&#x3D;&#x3D;&gt; Pouring wangle--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;wangle&#x2F;2022.10.03.00: 117 files, 3.3MB&#x3D;&#x3D;&gt; Installing watchman dependency: fbthrift&#x3D;&#x3D;&gt; Pouring fbthrift--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fbthrift&#x2F;2022.10.03.00: 755 files, 20.9MB&#x3D;&#x3D;&gt; Installing watchman dependency: fb303&#x3D;&#x3D;&gt; Pouring fb303--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;fb303&#x2F;2022.10.03.00: 56 files, 3.6MB&#x3D;&#x3D;&gt; Installing watchman&#x3D;&#x3D;&gt; Pouring watchman--2022.10.03.00.monterey.bottle.tar.gz🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;watchman&#x2F;2022.10.03.00: 22 files, 13.6MB&#x3D;&#x3D;&gt; Running &#96;brew cleanup watchman&#96;...Removing: &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;watchman&#x2F;2021.10.18.00... (23 files, 5.4MB)&#x3D;&#x3D;&gt; Checking for dependents of upgraded formulae...&#x3D;&#x3D;&gt; No broken dependents found!&#x3D;&#x3D;&gt; Caveats&#x3D;&#x3D;&gt; nginxDocroot is: &#x2F;usr&#x2F;local&#x2F;var&#x2F;wwwThe default port has been set in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;.To restart nginx after an upgrade:  brew services restart nginxOr, if you don&#39;t want&#x2F;need a background service you can just run:  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;&#x3D;&#x3D;&gt; redisTo restart redis after an upgrade:  brew services restart redisOr, if you don&#39;t want&#x2F;need a background service you can just run:  &#x2F;usr&#x2F;local&#x2F;opt&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis.conf👑 ~ $ python3 -VPython 3.10.0👑 ~ $</code></pre><h2 id="命令行-python-换行"><a href="#命令行-python-换行" class="headerlink" title="命令行 python 换行"></a>命令行 python 换行</h2><p>在命令行中“&gt;&gt;&gt;”是 python 的输入提示符，按回车键则表示输入结束。那么如何在命令行中换行呢？</p><p>换行方法：\</p><p>如：<br><strong>变量换行 <code>需要;\</code></strong></p><pre class="line-numbers language-python3" data-language="python3"><code class="language-python3">&gt;&gt;&gt; print &#39;aaa&#39;; \... print &#39;bbb&#39;; \... print &#39;ccc&#39;</code></pre><p>注意“;”的使用。python 本身语句结束和间隔都是不需要“;”的，但是在换行时要使用“;”，最后一行不要求必须有“;”，加上也不会出错。</p><p><strong>函数不需要;\换行</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; def fun(params):...   print(params); &#x2F;&#x2F; 注意前面有两个空格...&gt;&gt;&gt; fun(&#39;hello wolrd&#39;)hello wolrd</code></pre><p><strong>查看数据类型</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; type(a)&lt;class &#39;list&#39;&gt;</code></pre><h2 id="pip-1"><a href="#pip-1" class="headerlink" title="pip"></a>pip</h2><p><a href="https://pip.pypa.io/en/stable/installation/" target="_blank" >官网</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">👑 ~ $ curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py | python3  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100 2500k  100 2500k    0     0   278k      0  0:00:08  0:00:08 --:--:--  297kCollecting pip  Downloading pip-22.2.2-py3-none-any.whl (2.0 MB)     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 2.0&#x2F;2.0 MB 3.1 MB&#x2F;s eta 0:00:00Collecting wheel  Downloading wheel-0.37.1-py2.py3-none-any.whl (35 kB)Installing collected packages: wheel, pip  WARNING: The script wheel is installed in &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#39; which is not on PATH.  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.  Attempting uninstall: pip    Found existing installation: pip 21.2.3    Uninstalling pip-21.2.3:      Successfully uninstalled pip-21.2.3  WARNING: The scripts pip, pip3 and pip3.10 are installed in &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.10&#x2F;bin&#39; which is not on PATH.  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.Successfully installed pip-22.2.2 wheel-0.37.1</code></pre><h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h2><pre class="line-numbers language-none"><code class="language-none">brew install ffmpegffmpeg -version</code></pre><h2 id="视频推荐"><a href="#视频推荐" class="headerlink" title="视频推荐"></a>视频推荐</h2><p><em>B 站：小甲鱼（鱼 C）的 python 视频，视频质量不错。</em></p><p>即使是学习 js 的盆友，看这个视频也会有一定的收获，毕竟“语言”与“语言”在创作的过程中，多少都有些互相借鉴的味道</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React warning</title>
      <link href="//post/2022-09-21react.html"/>
      <url>//post/2022-09-21react.html</url>
      
        <content type="html"><![CDATA[<h2 id="没有意义属性"><a href="#没有意义属性" class="headerlink" title="没有意义属性"></a>没有意义属性</h2><p>非 html 没有意义的属性向下传递,会被 react 检测到</p><img src="http://t-blog-images.aijs.top/img/202209211458714.webp" /><h2 id="移除属性"><a href="#移除属性" class="headerlink" title="移除属性"></a>移除属性</h2><p>移除属性，避免向下传递<br><img src="http://t-blog-images.aijs.top/img/202209211455001.webp" /></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中的术语</title>
      <link href="//post/2022-09-19react.html"/>
      <url>//post/2022-09-19react.html</url>
      
        <content type="html"><![CDATA[<h2 id="浅合并"><a href="#浅合并" class="headerlink" title="浅合并"></a>浅合并</h2><p><a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#:~:text=)%3B%0A%20%20%7D-,%E8%BF%99%E9%87%8C%E7%9A%84%E5%90%88%E5%B9%B6%E6%98%AF%E6%B5%85%E5%90%88%E5%B9%B6,-%EF%BC%8C%E6%89%80%E4%BB%A5%20this.setState" target="_blank" >this.setState 会进行浅合并</a></p><h2 id="falsy"><a href="#falsy" class="headerlink" title="falsy"></a>falsy</h2><p><a href="https://zh-hans.reactjs.org/docs/conditional-rendering.html#:~:text=%E8%B7%B3%E8%BF%87%E5%AE%83%E3%80%82-,%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8Cfalsy%20%E8%A1%A8%E8%BE%BE%E5%BC%8F,-%E4%BC%9A%E4%BD%BF%20%26%26" target="_blank" >falsy 表达式 </a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy" target="_blank" >MDN 8 个 falsy 值</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; | 值        | 说明                                                                                                      |&#x2F;&#x2F; | :-------- | :-------------------------------------------------------------------------------------------------------- |&#x2F;&#x2F; | 0         | 数值 zero                                                                                                 |&#x2F;&#x2F; | -0        | 数值 负 zero                                                                                              |&#x2F;&#x2F; | 0n        | 当 BigInt 作为布尔值使用时，遵从其作为数值的规则. 0n 是 falsy 值。                                        |&#x2F;&#x2F; | false     | false 关键字                                                                                              |&#x2F;&#x2F; | undefined | undefined - 原始值                                                                                        |&#x2F;&#x2F; | null      | null - 缺少值                                                                                             |&#x2F;&#x2F; | &quot;&quot;, &#39;&#39;, &#96; | 这是一个空字符串 (字符串的长度为零). JavaScript 中的字符串可用双引号 &quot;&quot;, 单引号 &#39;&#39;, 或 模板字面量&#96; 定义。 |&#x2F;&#x2F; | NaN       | NaN - 非数值 |</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>rn 中 尽量先转 boolean 类型，否则 falsy 很有可能渲染到 View 组件中，引起崩溃</div><h2 id="key-会传递信息给-React-，但不会传递给你的组件"><a href="#key-会传递信息给-React-，但不会传递给你的组件" class="headerlink" title="key 会传递信息给 React ，但不会传递给你的组件"></a>key 会传递信息给 React ，但不会传递给你的组件</h2><p><a href="https://zh-hans.reactjs.org/docs/lists-and-keys.html#:~:text=key%20%E4%BC%9A%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E7%BB%99%20React%20%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E4%BC%A0%E9%80%92%E7%BB%99%E4%BD%A0%E7%9A%84%E7%BB%84%E4%BB%B6" target="_blank" >key 会传递信息给 React ，但不会传递给你的组件</a></p><h2 id="ES6-计算属性名称"><a href="#ES6-计算属性名称" class="headerlink" title="ES6 计算属性名称"></a>ES6 计算属性名称</h2><p><a href="https://zh-hans.reactjs.org/docs/forms.html#:~:text=%E8%BF%99%E9%87%8C%E4%BD%BF%E7%94%A8%E4%BA%86-,ES6%20%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0,-%E7%9A%84%E8%AF%AD%E6%B3%95%E6%9B%B4%E6%96%B0" target="_blank" >计算属性名称</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">this.setState(&#123;  [name]: value,&#125;);</code></pre><h2 id="formik"><a href="#formik" class="headerlink" title="formik"></a>formik</h2><p><a href="https://formik.org/" target="_blank" >formik</a></p><pre class="line-numbers language-none"><code class="language-none">Build forms in React, without the tearsFormik is the world&#39;s most popular open source form library for React and React Native.</code></pre><h2 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h2><p>这个玩意在实现 React 的 “diffing” 算法过程中所作出的设计决策，</p><ul><li>以保证组件更新可预测，</li><li>且在繁杂业务场景下依然保持应用的高性能</li></ul><p>动机：</p><p>在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。<br>在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。<br>React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p><p>此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。<br>然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。</p><p>如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。<br>于是 React 在以下两个假设的基础之上提出了一套 O(n) 的<em>启发式算法</em>：</p><ul><li>两个不同类型的元素会产生出不同的树；</li><li>开发者可以使用 key 属性标识哪些子元素，在不同的渲染中可能是不变的。</li></ul><p>在实践中，我们发现以上假设在几乎所有实用的场景下都成立。</p><h2 id="diffing-算法"><a href="#diffing-算法" class="headerlink" title="diffing 算法"></a>diffing 算法</h2><ul><li>对比不同类型的元素</li><li>对比同一类型的元素 ， React 会保留 DOM 节点，仅比对及更新有改变的属性。</li><li>对比同类型的组件元素， 当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致</li><li>对子节点进行递归，默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</li><li>Keys ， 为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-qa</title>
      <link href="//post/2022-09-19qa.html"/>
      <url>//post/2022-09-19qa.html</url>
      
        <content type="html"><![CDATA[<h2 id="var-let-const-区别："><a href="#var-let-const-区别：" class="headerlink" title="var let const 区别："></a>var let const 区别：</h2><ol><li>版本： var 是 es6 之前， const、let es6 之后，</li><li>分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域</li><li>提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使用会报错</li><li>重复：var 可以重复声明、重复赋值，let 不可以重复声明，但可重复赋值，const 不可重复声明和赋值</li><li>存储：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li><li>默认： 默认情况下是 var 声明</li><li>函数：函数声明提升优先于 var</li></ol><p>补充说明： const 和不变性。</p><p>const 创建一个变量名绑定，该绑定在创建后不能重新分配。<br>const 不创建不可变对象。不能更改绑定所引用的对象，但仍然可以更改对象的属性，这意味着使用 const 创建的绑定是可变的，而不是不可变的。</p><h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>当 js 引擎执行到一段可执行代码时，就会为之创建对应的执行上下文(Execution Context)。<br>分为三种：全局执行上下文，函数执行上下文，eval 执行上下文。</p><p><code>全局上下文：</code>默认&#x2F;基础的上下文，任何不在函数内部的代码都在全局上下文中，一个程序中只有一个全局执行上下文</p><p><code>函数执行上下文</code>：一个函数被调用时，会为该函数创建一个上下文，每个函数都有自己的函数上下文，函数上下文可以有任意多个</p><p><code>eval上下文</code>：执行在 eval 函数内部的代码也会有属于它自己的执行上下文</p><h2 id="javascript-的执行顺序"><a href="#javascript-的执行顺序" class="headerlink" title="javascript 的执行顺序"></a>javascript 的执行顺序</h2><ol><li><code>JavaScript 代码在执行的过程中</code>，需要先做变量提升，之所以如此，是因为 JavaScript 代码在执行前需要进行<code>编译</code>；</li><li>在编译阶段，<ul><li>变量和函数会被存放到<code>变量环境</code>中，变量的默认值为 undefined；</li><li>块级作用域会被存放到<code>词法环境</code>中；</li><li>存在两个相同的函数，后面的会<code>覆盖</code>前面的函数；</li></ul></li><li>调用函数时，JavaScript 引擎维护了一个栈的数据结构（<code>调用栈</code>），每次调用函数都会将函数的执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码；</li><li>当函数执行完毕后，JavaScript 引擎会将该函数的执行上下文<code>弹出栈</code>；</li><li>当分配的栈空间被占满时，会引发<code>栈溢出</code>的情况；</li></ol><p>作者：chicABoo<br>链接：<a href="https://juejin.cn/post/6965786039185047559">https://juejin.cn/post/6965786039185047559</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是可访问变量的集合。</p><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><p>JavaScript 变量生命周期</p><ul><li>局部变量在函数执行完毕后销毁。</li><li>全局变量在页面关闭后销毁。</li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当执行一段代码时，JavaScript 引擎首先在当前执行上下文中查找变量，<br>如果找不到，会根据外部引用 outer 去对应的外部执行上下文查找变量，直到查找到最外层的全局执行上下文，<br>从当前执行上下文到全局执行上下文，形成了一个链条，我们称为<code>作用域链</code></p><p>简单来说：由于函数嵌套，一个变量在当前函数作用域找不到，会往上找，直到全局作用域，这种作用域嵌套的现象；由内向外，一层一层往上的链式规则，这就是作用域链</p><p><a href="https://juejin.cn/post/7023259995219165214" target="_blank" >JavaScript 执行机制二（深入之闭包）</a></p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><ul><li>词法作用域是由代码声明的位置决定的，所以词法作用域是静态作用域，通过它能预测代码在执行过程中如何查找标识。</li><li>对于代码中存在块级作用域的情况，作用域链首先在词法环境中查找，没找到才会到变量环境中查找</li></ul><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfb6a6ffe2147be9ce8dbcc60eb0de5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" /><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在 JavaScript 中，根据词法作用域的规则，内部函数总能访问外部函数声明的变量，当通过调用外部函数返回内部函数时，即使外部函数执行完毕，内部函数引用外部函数的变量仍存在内存中，我们就把这些变量的集合称为闭包</p><h3 id="那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？"><a href="#那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？" class="headerlink" title="那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？"></a>那么闭包在内存中是如何存储的呢？为什么外部函数执行完成，销毁了，变量仍然存在内存中？</h3><ol><li>如果一个函数内有闭包，javascript 在执行这个函数时候，会预扫描内部函数是否有使用的 foo 函数中声明的变量；</li><li>预扫描过程中，在内层函数 showName 中找到了外部函数 foo 中声明的变量 name，因此在 JavaScript 中判断这是一个闭包，</li><li>此时会在堆中开辟一个空间创建 closure(foo)对象，将 name 值存到里面。</li><li>而执行栈中的 foo 执行上下文中的 name 存的值是 closure(foo)的地址，因此当 foo 函数执行完成并销毁，name 值仍然存在堆的 closure(foo)的对象中，具体如下图所示：</li><li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b437d4602e45379d9c9b4139817a24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?" /></li></ol><p>作者：chicABoo<br>链接：<a href="https://juejin.cn/post/7023259995219165214">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="闭包是如何回收的"><a href="#闭包是如何回收的" class="headerlink" title="闭包是如何回收的"></a>闭包是如何回收的</h3><ul><li>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭。但如果这个变量之后不在使用，就会造成内存泄露</li><li>如果引用闭包的函数是一个局部变量，等函数销毁后，在下一次执行垃圾回收时，判断闭包这块内容不再使用，那么 JavaScript 引擎的垃圾回收器就会回收这块内容</li></ul><h3 id="闭包使用原则"><a href="#闭包使用原则" class="headerlink" title="闭包使用原则"></a>闭包使用原则</h3><ul><li>如果该闭包会一直使用，那么它可以作为全局变量而存在；</li><li>但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>作用域链：</code>每个执行上下文都有一个指向外部的 outer，这个指向外部的引用 outer 在编译时就决定了，也就是说，根据声明的位置就能确定外部引用 outer，这就是词法作用域（静态作用域），它能预测代码执行过程中如何查找标识。通过它就能确定作用域链。</li><li><code>闭包：</code>外部函数声明的变量，在内部函数中调用，当调用外部函数返回内部函数时，外部函数中声明的变量并不会随着外部函数执行完成而销毁，这些变量构成的集合就是外部函数的闭包。</li><li><code>栈和堆空间：</code>基本数据类型是存在栈空间中的，引用数据类型是存在堆空间中的。<code>当形成闭包时，外部函数声明的变量存放在调用栈中，对于外部函数中的变量被内部函数所使用，在堆中就会创建一个 closure(函数名)的对象，用于存放闭包的变量集合，而外部函数中存的只是堆中的地址。所以说，当外部函数执行完成销毁时，JavaScript 引擎并不会回收堆中的地址。</code></li><li><code>正确使用闭包：</code>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，占用内存又大，那么尽量让它作为局部变量使用。</li></ul><p>作者：chicABoo<br>链接：<a href="https://juejin.cn/post/7023259995219165214">https://juejin.cn/post/7023259995219165214</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>通俗点来讲就是：指变量的可使用范围</p><p>一般有三种作用域：全局作用域、函数作用域、块级作用域</p><p>全局作用域：声明的变量，全局可见<br>函数作用域：声明的变量在当前函数内部可见<br>块级作用域：{},条件语句，循环语句中</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>js 面向对象编程的实现</p><p>在 JavaScript 中原型是一个 prototype 对象，用于表示类型之间的关系。</p><p>每一个对象都与另一个对象相关联，那个关联的对象就称为原型</p><h3 id="为什么使用原型"><a href="#为什么使用原型" class="headerlink" title="为什么使用原型"></a>为什么使用原型</h3><p>原型对象的用途： 是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已。</p><p>所有的实例是共享同一个原型对象，因此有别于实例方法或属性，原型对象仅有一份。</p><h3 id="原型分类"><a href="#原型分类" class="headerlink" title="原型分类"></a>原型分类</h3><p>显示原型和隐式原型</p><p>显示原型： prototype 关键字标识<br>隐式原型： <code>__proto__</code>表示<br>一个构造函数显示原型 &#x3D;&#x3D;&#x3D; 该构造函数一个实例的隐式原型 即： （构造函数.<code>prototype</code> &#x3D;&#x3D;&#x3D; 构造函数实例.<code>__proto__</code>）</p><h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><ol><li>每个实例对象的<code>__proto__</code>​ 属性, 指向它的构造函数的原型对象（<code>prototype</code>）。</li><li>该原型对象也有一个自己的原型对象（<code>__proto__</code>​），层层向上直到一个对象的原型对象为 <code>null</code>​。</li><li>根据定义，<code>null</code>​ 没有原型，并作为这个原型链中的最后一个环节</li></ol><p>简单来说，原型链是： 一个对象 找原型对象 的依据</p><p><a href="https://www.51cto.com/article/718086.html" target="_blank" >见</a></p><h3 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h3><ul><li>对象字面量</li><li>构造函数</li><li>new 关键字</li><li>Object.create</li><li>class</li></ul><h3 id="Number、Boolean-包装类型的原型链是怎样的？"><a href="#Number、Boolean-包装类型的原型链是怎样的？" class="headerlink" title="Number、Boolean 包装类型的原型链是怎样的？"></a>Number、Boolean 包装类型的原型链是怎样的？</h3><h3 id="简单数据类型，为什么可以调用方法"><a href="#简单数据类型，为什么可以调用方法" class="headerlink" title="简单数据类型，为什么可以调用方法"></a>简单数据类型，为什么可以调用方法</h3><p><a href="https://www.cnblogs.com/venoral/p/5243189.html" target="_blank" >见</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var s1 &#x3D; &quot;some text&quot;;var s2 &#x3D; s1.substring(2); &#x2F;&#x2F;&#39;me text&#39;</code></pre><p>基本类型不是对象，因而从逻辑上讲他们不该有方法，其实为了让我们实现这种操作，后台已经完成了一系列的处理。</p><p>第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台会完成如下处理：</p><p><strong>创建</strong> <code>String/Boolean/Number</code> 类的一个实例。<code>var s1=new String(&#39;some text&#39;);</code><br><strong>调用</strong>在实例上调用指定的方法。<code>var s2=s1.substring(2);//&#39;me text&#39;</code><br><strong>销毁</strong>这个实例<code>。s1=null</code></p><p><strong>引用类型与基本包装类型的主要区别就是对象的生存期：</strong></p><ul><li>_使用 new 操作符创建的引用类型的实例_，在执行流离开当前作用域之前都一直保存在内存中。</li><li>_自动创建的基本包装类型的对象_，只存在于代码执行的一瞬间，然后被立即销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</li></ul><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><h3 id="实例与构造函数之间的关系"><a href="#实例与构造函数之间的关系" class="headerlink" title="实例与构造函数之间的关系"></a>实例与构造函数之间的关系</h3><p>实例.<code>__proto__</code> &#x3D;&#x3D;&#x3D; 该实例的构造函数.<code>prototype</code></p><h3 id="ES6-语法中的-class、extends-与-super-的原理"><a href="#ES6-语法中的-class、extends-与-super-的原理" class="headerlink" title="ES6 语法中的 class、extends 与 super 的原理"></a>ES6 语法中的 class、extends 与 super 的原理</h3><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="聊下-this-指向问题"><a href="#聊下-this-指向问题" class="headerlink" title="聊下 this 指向问题"></a>聊下 this 指向问题</h3><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p><h3 id="为什要有-this"><a href="#为什要有-this" class="headerlink" title="为什要有 this"></a>为什要有 this</h3><p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p><p>简单来说：this,被放到作用域中， 为了简化代码</p><h3 id="this-是如何定义的"><a href="#this-是如何定义的" class="headerlink" title="this 是如何定义的"></a>this 是如何定义的</h3><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p><p>我们简单总结一下 this 的特点：</p><ul><li>this 是在运行时绑定的，不是在编写时绑定</li><li>this 的绑定与函数的声明和位置没有任何关系</li><li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。</li></ul><p>所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</p><p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h3 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h3><p>判断函数调用时是否使用了 new，如果使用了 new 绑定，则 this 绑定的是新创建的对象。<br>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。<br>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。<br>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，</p><ul><li>在严格模式下，默认绑定的 this 是 undefined，</li><li>非严格模式下绑定到全局对象。</li></ul><p><em>类声明和类表达式的主体都执行在严格模式下</em></p><p><a href="/posts/2022-10-21js-class" target="_blank" >前端基础-class</a></p><p>作者：小猪课堂<br>链接：<a href="https://juejin.cn/post/7115390077353590792">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="this-绑定的优先级"><a href="#this-绑定的优先级" class="headerlink" title="this 绑定的优先级"></a>this 绑定的优先级</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new 绑定</code></pre><h2 id="new-做了哪些事情"><a href="#new-做了哪些事情" class="headerlink" title="new 做了哪些事情"></a>new 做了哪些事情</h2><p>1、创建一个空对象；</p><p>2、将空对象的原型，指向于构造函数的原型；</p><p>3、将空对象作为构造函数的上下文（改变 this 指向）；</p><p>4、对有返回值的构造函数做判断处理</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;定义构造函数function Fun(age, name) &#123;  this.age &#x3D; age;  this.name &#x3D; name;  return 1;&#125;function myNew(fn, ...args) &#123;  &#x2F;&#x2F;1、先创造空对象  &#x2F;&#x2F;其实等于var obj &#x3D; Object.create(&#123;&#125;)  var obj &#x3D; &#123;&#125;;  &#x2F;&#x2F;2、obj的__proto__指向原型  Object.setPrototypeOf(obj, fn.prototype);  &#x2F;&#x2F;3、改变this指向，执行构造函数内部函数  var result &#x3D; fn.apply(obj, args);  &#x2F;&#x2F;4、判断return  return result instanceof Object ? result : obj;&#125;</code></pre><p><a href="cnblogs.com/jacky02/p/16048701.html" target="_blank" >见</a></p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function myCreate(obj) &#123;  let F &#x3D; function () &#123;&#125;;  F.prototype &#x3D; obj;  return new F();&#125;</code></pre><h3 id="Object-create-与-new-的区别"><a href="#Object-create-与-new-的区别" class="headerlink" title="Object.create 与 new 的区别"></a>Object.create 与 new 的区别</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; new Object() 方式创建var obj &#x3D; &#123; name: &quot;jack&quot; &#125;;var b &#x3D; new Object(obj);console.log(b.name);console.log(b.__proto__.name); &#x2F;&#x2F;undefined&#x2F;&#x2F; Object.create() 方式创建var obj2 &#x3D; &#123; name: &quot;apple&quot; &#125;;var c &#x3D; Object.create(obj2);console.log(c.name);console.log(c.__proto__.name); &#x2F;&#x2F;apple</code></pre><p>new 出来的 b 对象，通过原型链无法访问到 name 属性，而 Object.create 出来的 c 却可以</p><h2 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="headerlink" title="箭头函数与普通函数区别"></a>箭头函数与普通函数区别</h2><ol><li><p><strong>使用</strong>简单：箭头函数使用起来简单，更适合匿名函数，比较特殊的对象方法，可以简写(){},这个不是箭头函数</p></li><li><p><strong>声明</strong>具名箭头函数可以用 var let const , 普通函数除这些之外还可用 function 关键字</p></li><li><p><strong>立即执行</strong> 普通函数可以声明立即执行函数，箭头函数也可<code>void (()=&gt; &#123;console.log(1)&#125;)()</code></p></li><li><p><strong>运算上</strong> 在使用短路运算符的时候，箭头函数要用()括起来，否则因解析顺序导致错误</p></li><li><p><strong>拥有</strong> 箭头函数没有自己的 this, prototype，arguments, super, new.target,</p></li><li><p>基于此：箭头函数不适用于构造函数、new、yeild 等场合</p></li><li><p>在 apply,call,bind 中第一个参数会被忽略</p></li><li><p>箭头函数没有 arguments，可以使用…rest, （这里有个注意的点：普通函数 arguments，<strong>在非严格模式下</strong>，有默认参数、剩余参数和结构赋值的情况会出现： arguments 与形参不一致的情况）</p></li></ol><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><code>背景</code>：js 是单线程的，同一时间 dom 的操作不允许并行</p><p><code>出现的原因</code>：单线程，如果出现耗时的情况会一直等待，以浏览器为例： 浏览器分为 5 大线程，定时器线程和网络线程</p><p><code>解决了什么问题</code>：在单线程中，可以跳过一些耗时的操作，先去做其他的事情，待到需要执行的时候，再执行，而这一策略被称为 事件循环</p><p><code>执行过程：</code> <code>宿主环境</code>：以浏览器环境来说</p><ol><li>在 javascript 中，将任务放到执行栈中执行，执行完成的会出栈；未执行的会依次压入栈底，</li><li>先执行同步任务（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部），直至同步任务都被执行完</li><li>然后执行微任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）直至微任务队列都被执行完</li><li>然后执行宏任务队列，（1. 遇到同步的任务直接执行，执行完出栈，2.遇到微任务放到微任务队列尾部，3.遇到宏任务放到宏任务队列尾部）</li><li>会再去检测微任务队列，之后，再以相同的方式去执行宏任务队列</li></ol><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><h2 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="通过构造函数"><a href="#通过构造函数" class="headerlink" title="通过构造函数"></a>通过构造函数</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Singleton &#123;  constructor() &#123;    console.log(&quot;this&quot;, this);    if (!Singleton.instance) &#123;      &#x2F;&#x2F; 将 this 挂载到单例上      Singleton.instance &#x3D; this;    &#125;    return Singleton.instance;  &#125;&#125;const a &#x3D; new Singleton();const b &#x3D; new Singleton();console.log(a &#x3D;&#x3D;&#x3D; b);</code></pre><h3 id="通过静态方法"><a href="#通过静态方法" class="headerlink" title="通过静态方法"></a>通过静态方法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Singleton &#123;  static instance &#x3D; null;  static getInstance() &#123;    if (!Singleton.instance) &#123;      Singleton.instance &#x3D; new Singleton();    &#125;    return Singleton.instance;  &#125;&#125;const a &#x3D; Singleton.getInstance();const b &#x3D; Singleton.getInstance();console.log(a &#x3D;&#x3D;&#x3D; b);</code></pre><h2 id="编程方法论"><a href="#编程方法论" class="headerlink" title="编程方法论"></a>编程方法论</h2><h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><p>函数式编程（通常缩写为 FP）是通过组合纯函数，避免状态共享、可变数据和副作用来构建软件的过程。</p><p>函数式编程是声明式的，而不是命令式的，应用程序状态通过纯函数流动。</p><p>与面向对象编程不同，在面向对象编程中，应用程序状态通常与对象中的方法共享和协作。</p><p>与命令式或面向对象的代码相比，函数式代码往往更简洁、更可预测、更易于测试</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>函数式编程有些重要的概念：</p><ul><li>纯函数： 给定相同的输入，总是得到相同的输出，没有副作用</li><li>函数组合：将两个或两个以上的函数组合起来以产生一个新函数或进行某种计算的过程</li><li>避免状态共享：共享作用域中存在的任何变量、对象或内存空间，或者是在作用域之间传递的对象的属性。共享作用域可以包括全局作用域或闭包作用域。通常，在面向对象编程中，通过向其他对象添加属性，在作用域之间共享对象。</li><li>避免可变数据： 不可变对象是指创建后不能修改的对象。相反，可变对象是在创建后可以修改的对象， 可以通过：Object.freeze 进行冻结</li><li>避免副作用：副作用是指：除了返回值之外，任何应用程序状态的改变都是可以在被调用函数之外观察到的</li></ul><p><a href="https://juejin.cn/post/6844904130796847111" target="_blank" >见</a></p><h3 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h3><h3 id="什么是面向过程编程"><a href="#什么是面向过程编程" class="headerlink" title="什么是面向过程编程"></a>什么是面向过程编程</h3><h2 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h2><h3 id="type-与-interface-的区别"><a href="#type-与-interface-的区别" class="headerlink" title="type 与 interface 的区别"></a>type 与 interface 的区别</h3><p><a href="https://www.51cto.com/article/705857.html" target="_blank" >见</a><br><a href="https://juejin.cn/post/6844903749501059085" target="_blank" >见</a></p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都可以描述一个对象或者函数</li><li>都允许拓展（extends） interface 继承使用 <code>extends关键字</code> ， type 继承使用 <code>&amp;</code>关键字</li></ol><ul><li><code>interface extends interface</code></li><li><code>interface extends type</code></li><li><code>type extends interface</code></li><li><code>type extends type</code></li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</li><li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</li><li>interface 能够声明合并 (type 不可以)</li></ul><h4 id="描述上：1-都可以描述一个对象或者函数"><a href="#描述上：1-都可以描述一个对象或者函数" class="headerlink" title="描述上：1. 都可以描述一个对象或者函数"></a>描述上：1. 都可以描述一个对象或者函数</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; interfaceinterface User &#123;  name: string  age: number&#125;interface SetUser &#123;  (name: string, age: number): void;&#125;&#x2F;&#x2F; typetype User &#x3D; &#123;  name: string  age: number&#125;;type SetUser &#x3D; (name: string, age: number)&#x3D;&gt; void;</code></pre><h4 id="扩展上：-2-都允许拓展（extends"><a href="#扩展上：-2-都允许拓展（extends" class="headerlink" title="扩展上： 2. 都允许拓展（extends"></a>扩展上： 2. 都允许拓展（extends</h4><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; interface extends interfaceinterface Name &#123;  name: string;&#125;interface User extends Name &#123;  age: number;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; type extends typetype Name &#x3D; &#123;  name: string;&#125;;type User &#x3D; Name &amp; &#123; age: number &#125;;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; interface extends typetype Name &#x3D; &#123;  name: string;&#125;;interface User extends Name &#123;  age: number;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; type extends interfaceinterface Name &#123;  name: string;&#125;type User &#x3D; Name &amp; &#123;  age: number;&#125;;</code></pre><h3 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h3><h4 id="1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以"><a href="#1-type-可以声明基本类型别名，联合类型，元组等类型-interface-不可以" class="headerlink" title="1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)"></a>1. type 可以声明基本类型别名，联合类型，元组等类型(interface 不可以)</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 基本类型别名type Name &#x3D; string;&#x2F;&#x2F; 联合类型interface Dog &#123;  wong();&#125;interface Cat &#123;  miao();&#125;type Pet &#x3D; Dog | Cat;&#x2F;&#x2F; 具体定义数组每个位置的类型type PetList &#x3D; [Dog, Pet];</code></pre><h4 id="2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以"><a href="#2-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-不可以" class="headerlink" title="2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)"></a>2. type 语句中还可以使用 typeof 获取实例的 类型进行赋值(interface 不可以)</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 当你想获取一个变量的类型时，使用 typeoflet div &#x3D; document.createElement(&quot;div&quot;);type B &#x3D; typeof div;</code></pre><p>其他骚操作</p><pre class="line-numbers language-none"><code class="language-none">type StringOrNumber &#x3D; string | number;type Text &#x3D; string | &#123; text: string &#125;;type NameLookup &#x3D; Dictionary&lt;string, Person&gt;;type Callback&lt;T&gt; &#x3D; (data: T) &#x3D;&gt; void;type Pair&lt;T&gt; &#x3D; [T, T];type Coordinates &#x3D; Pair&lt;number&gt;;type Tree&lt;T&gt; &#x3D; T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</code></pre><h4 id="interface-能够声明合并-type-不行"><a href="#interface-能够声明合并-type-不行" class="headerlink" title="interface 能够声明合并(type 不行)"></a>interface 能够声明合并(type 不行)</h4><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface User &#123;  name: string;  age: number;&#125;interface User &#123;  sex: string;&#125;&#x2F;*User 接口为 &#123;  name: string  age: number  sex: string&#125;*&#x2F;</code></pre><h2 id="Typescript-中-extends-的作用"><a href="#Typescript-中-extends-的作用" class="headerlink" title="Typescript 中 extends 的作用"></a>Typescript 中 extends 的作用</h2><h3 id="1、接口继承"><a href="#1、接口继承" class="headerlink" title="1、接口继承"></a>1、接口继承</h3><p>可以继承父类接口的方法和属性</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  name: string;&#125;interface Dog extends Animal &#123;  sayHello: () &#x3D;&gt; void;&#125;&#x2F;&#x2F; dog 具有 Animal 的 name 属性。const dog: Dog &#x3D; &#123;  name: &quot;tom&quot;,  sayHello: function () &#123;&#125;,&#125;;</code></pre><h3 id="2、普通条件判断"><a href="#2、普通条件判断" class="headerlink" title="2、普通条件判断"></a>2、普通条件判断</h3><p>用来判断一个类型是否可以分配给另外一个类型</p><p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  name: string;&#125;interface Dog extends Animal &#123;  sayHello: () &#x3D;&gt; void;&#125;const dog: Dog &#x3D; &#123;  name: &quot;tom&quot;,  sayHello: function () &#123;&#125;,&#125;;type bool &#x3D; Animal extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;type bool1 &#x3D; Dog extends Animal ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre><h3 id="3、泛型条件判断"><a href="#3、泛型条件判断" class="headerlink" title="3、泛型条件判断"></a>3、泛型条件判断</h3><p>对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</p><p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p><p>满足两个要点即可适用分配律：</p><p>参数是泛型类型，</p><p>代入参数的是联合类型<br>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Animal&lt;T&gt; &#x3D; T;type Animal1&lt;T&gt; &#x3D; [T];type Dog &#x3D; Animal&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;type Dog1 &#x3D; Animal1&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]type A &#x3D; &quot;x&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;type B &#x3D; &quot;x&quot; extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;type C &#x3D; [&quot;x&quot; | &quot;y&quot;] extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;type D &#x3D; &quot;x&quot; | &quot;y&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; D &#x3D; &#39;yse&#39;</code></pre><h3 id="4、泛型约束"><a href="#4、泛型约束" class="headerlink" title="4、泛型约束"></a>4、泛型约束</h3><p>在书写泛型时，往往需要对类型参数作一定对限制。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;  return obj[key];&#125;const obj &#x3D; &#123;  name: &quot;tom&quot;,  age: 12,&#125;;getInfo(obj, &quot;age&quot;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="聊下-key"><a href="#聊下-key" class="headerlink" title="聊下 key"></a>聊下 key</h3><h3 id="为什么引入-key"><a href="#为什么引入-key" class="headerlink" title="为什么引入 key"></a>为什么引入 key</h3><p><strong>key 帮助 React 识别出被修改、添加或删除的 item</strong></p><p>在对子节点进行递归时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。在子元素列表末尾新增元素时，更新开销比较小。</p><p>React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。</p><p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。</p><p>React 并不会意识到应该保留 <li>Duke</li> 和 <li>Villanova</li>，而是会重建每一个子元素。这种情况会带来性能问题。</p><p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。使得树的转换效率得以提高：</p><p>现在 React 知道只有带着 ‘2014’ key 的元素是新元素，带着 ‘2015’ 以及 ‘2016’ key 的元素仅仅移动了。</p><p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p><h3 id="key-有什么要求"><a href="#key-有什么要求" class="headerlink" title="key 有什么要求"></a>key 有什么要求</h3><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。这个 key 不需要全局唯一，但在列表中需要保持唯一。</p><h3 id="通常情况-key-不会用-index"><a href="#通常情况-key-不会用-index" class="headerlink" title="通常情况 key 不会用 index"></a>通常情况 key 不会用 index</h3><p>原因：</p><ol><li><p>使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</p></li><li><p>由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，</p></li></ol><h3 id="什么时候使用-key"><a href="#什么时候使用-key" class="headerlink" title="什么时候使用 key"></a>什么时候使用 key</h3><ol><li>子元素列表时候需要用 key</li><li>同级元素比如两个按钮，在使用三目运算符进行条件处理时候，也需要加 key，不加会出现，按钮事件被错误触发的现象，（这是由于 React 可中断渲染和合成事件共同作用引起的）</li></ol><h3 id="key-在源码单节点、多节点中的"><a href="#key-在源码单节点、多节点中的" class="headerlink" title="key 在源码单节点、多节点中的"></a>key 在源码单节点、多节点中的</h3><h3 id="diff-单节点、多节点"><a href="#diff-单节点、多节点" class="headerlink" title="diff [单节点、多节点]"></a>diff [单节点、多节点]</h3><h3 id="hooks-产生的原因"><a href="#hooks-产生的原因" class="headerlink" title="hooks 产生的原因"></a>hooks 产生的原因</h3><p>Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题</p><h3 id="在组件之间复用状态逻辑很难"><a href="#在组件之间复用状态逻辑很难" class="headerlink" title="在组件之间复用状态逻辑很难"></a><code>在组件之间复用状态逻辑很难</code></h3><h3 id="复杂组件变得难以理解"><a href="#复杂组件变得难以理解" class="headerlink" title="复杂组件变得难以理解"></a><code>复杂组件变得难以理解</code></h3><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。）</p><h3 id="难以理解的-class"><a href="#难以理解的-class" class="headerlink" title="难以理解的 class"></a><code>难以理解的 class</code></h3><p>(除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。)</p><h3 id="useEffect-执行特点"><a href="#useEffect-执行特点" class="headerlink" title="useEffect 执行特点"></a>useEffect 执行特点</h3><h4 id="1-useEffect-做了什么？"><a href="#1-useEffect-做了什么？" class="headerlink" title="1. useEffect 做了什么？"></a>1. useEffect 做了什么？</h4><p>(<br>通过使用这个 Hook，你可以告诉 React 组件需要在渲染后执行某些操作。React 会保存你传递的函数（我们将它称之为 “effect”），并且在执行 DOM 更新之后调用它。<br>)</p><h4 id="2-为什么在组件内部调用-useEffect？"><a href="#2-为什么在组件内部调用-useEffect？" class="headerlink" title="2. 为什么在组件内部调用 useEffect？"></a>2. 为什么在组件内部调用 useEffect？</h4><p>(<br>将 useEffect 放在组件内部,让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。<br>)</p><h4 id="3-useEffect-会在每次渲染后都执行吗？"><a href="#3-useEffect-会在每次渲染后都执行吗？" class="headerlink" title="3. useEffect 会在每次渲染后都执行吗？"></a>3. useEffect 会在每次渲染后都执行吗？</h4><p>(<br>是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕。<br>)</p><h4 id="4-传递给-useEffect-的函数在每次渲染中都会有所不同"><a href="#4-传递给-useEffect-的函数在每次渲染中都会有所不同" class="headerlink" title="4. 传递给 useEffect 的函数在每次渲染中都会有所不同"></a>4. 传递给 useEffect 的函数在每次渲染中都会有所不同</h4><p>(<br>经验丰富的 JavaScript 开发人员可能会注意到，传递给 useEffect 的函数在每次渲染中都会有所不同，这是刻意为之的。事实上这正是我们可以在 effect 中获取最新的 count 的值，而不用担心其过期的原因。每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。<br>)</p><h4 id="5-effect-异步执行"><a href="#5-effect-异步执行" class="headerlink" title="5. effect 异步执行"></a>5. effect 异步执行</h4><p>不需要同步地执行, 如果需要同步用 <code>useLayoutEffect</code></p><h4 id="6-为什么要在-effect-中返回一个函数？"><a href="#6-为什么要在-effect-中返回一个函数？" class="headerlink" title="6. 为什么要在 effect 中返回一个函数？"></a>6. 为什么要在 effect 中返回一个函数？</h4><p>(<br>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。<br>)</p><h4 id="7-React-何时清除-effect？"><a href="#7-React-何时清除-effect？" class="headerlink" title="7. React 何时清除 effect？"></a>7. React 何时清除 effect？</h4><p>(<br>React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。<br>)</p><h3 id="useEffect-使用特点上？"><a href="#useEffect-使用特点上？" class="headerlink" title="useEffect 使用特点上？"></a>useEffect 使用特点上？</h3><ul><li><p>提示: 使用多个 Effect 实现关注点分离</p></li><li><p>解释：为什么每次更新的时候都要运行 Effect(此默认行为保证了一致性，避免了在 class 组件中因为没有处理更新逻辑而导致常见的 bug。)</p></li><li><p>提示: 通过跳过 Effect 进行性能优化（使用第二参数，未来版本，可能会在构建时自动添加第二个参数。）</p></li></ul><h3 id="useEffect-实现原理"><a href="#useEffect-实现原理" class="headerlink" title="useEffect 实现原理"></a>useEffect 实现原理</h3><h3 id="Hook-使用规则"><a href="#Hook-使用规则" class="headerlink" title="Hook 使用规则"></a>Hook 使用规则</h3><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p><p>只能<code>在函数最外层调用 Hook</code>。<code>不要在循环</code>、<code>条件判断</code>或者<code>子函数中调用</code>。</p><p><code>只能在 React 的函数组件中调用 Hook</code>。不要在其他 JavaScript 函数中调用。（还有一个地方可以调用 Hook —— 就是自定义的 Hook 中，我们稍后会学习到。）</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="父子组件生命周期函数执行顺序："><a href="#父子组件生命周期函数执行顺序：" class="headerlink" title="父子组件生命周期函数执行顺序："></a>父子组件生命周期函数执行顺序：</h3><p>父子组件生命周期函数执行顺序：</p><p><strong>类组件</strong></p><p>进入页面：parent-constructor -&gt; parent-getDerivedStateFromProps -&gt; parent-render -&gt; child-constructor -&gt; child-getDerivedStateFromProps -&gt; child-render -&gt; child-componentDidMount -&gt; parent-componentDidMount<br>（子组件先挂载，父组件后挂载）</p><p>更新页面：parent-getDerivedStateFromProps -&gt; parent-shouldComponentUpdate -&gt; parent-render -&gt; child-getDerivedStateFromProps -&gt; child-shouldComponentUpdate -&gt; child-render -&gt; child-componentDidUpdate -&gt; parent-componentDidUpdate<br>（子组件先更新，父组件后更新）<br>销毁页面：parent-componentWillUnmount -&gt; child-componentWillUnmount<br>（父组件先 willUnmount，子组件后 willlUnmount）</p><p><a href="https://www.cnblogs.com/foreveronlymiss/p/15387022.html" target="_blank" >见</a></p><p><strong>函数组件</strong></p><p>子组件先于父组件</p><p><a href="https://blog.csdn.net/qq_35770417/article/details/120706178" target="_blank" >见</a></p><h3 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h3><p>用来突出显示应用程序中潜在问题的工具,不会渲染任何可见的 UI,它为其后代元素触发额外的检查和警告(<span style="color: red">严格模式检查仅在开发模式下运行；它们不会影响生产构建。</span>)</p><p>作用：</p><ul><li>识别不安全的生命周期（使用了第三方库，很难确保它们不使用这些生命周期方法）</li><li>使用过时字符串 ref API 的警告</li><li>检测过时的 context API</li><li>使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>确保可复用状态（在未来，我们希望增加一个功能，允许 React 在保留 state 的同时对 UI 进行增删）</li></ul><h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h3><p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p><h3 id="合成事件的捕获和冒泡如何实现"><a href="#合成事件的捕获和冒泡如何实现" class="headerlink" title="合成事件的捕获和冒泡如何实现"></a>合成事件的捕获和冒泡如何实现</h3><p>数组正反序遍历</p><h3 id="父子组件合成事件的捕获和冒泡执行顺序"><a href="#父子组件合成事件的捕获和冒泡执行顺序" class="headerlink" title="父子组件合成事件的捕获和冒泡执行顺序"></a>父子组件合成事件的捕获和冒泡执行顺序</h3><p>V17 之前，合成事件和原生事件的执行顺序与冒泡&#x2F;捕获模式无关，原生事件恒早于合成事件；</p><p>V17 后，合成事件和原生事件的执行顺序与冒泡&#x2F;捕获模式相关，冒泡模式，原生事件早于合成事件，捕获模式，合成事件早于原生事件。</p><p>&#x2F;&#x2F; V17.0.2 document 原生事件 &gt; 合成事件（父 -&gt; 子） &gt; 原生事件（父 -&gt; 子）<br>&#x2F;&#x2F; 原生事件：document DOM 事件监听！<br>&#x2F;&#x2F; React 事件：父元素事件监听！<br>&#x2F;&#x2F; React 事件：子元素事件监听！<br>&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！</p><p>&#x2F;&#x2F; V16.14.0 document 原生事件 &gt; 原生事件（父 -&gt; 子）&gt; 合成事件（父 -&gt; 子）<br>&#x2F;&#x2F; 原生事件：document DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：父元素 DOM 事件监听！<br>&#x2F;&#x2F; 原生事件：子元素 DOM 事件监听！<br>&#x2F;&#x2F; React 事件：父元素事件监听！<br>&#x2F;&#x2F; React 事件：子元素事件监听！</p><p>作者：活抓一只小机灵<br>链接：<a href="https://juejin.cn/post/7005129812981317668">https://juejin.cn/post/7005129812981317668</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口。</p><h3 id="要使用浏览器的底层事件？"><a href="#要使用浏览器的底层事件？" class="headerlink" title="要使用浏览器的底层事件？"></a>要使用浏览器的底层事件？</h3><p>需要使用 nativeEvent 属性来获取</p><h3 id="变化？"><a href="#变化？" class="headerlink" title="变化？"></a>变化？</h3><p>从 v17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中。</p><h3 id="在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？"><a href="#在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？" class="headerlink" title="在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？"></a>在冒泡阶段被触发事件处理函数，如何在捕获阶段触发？</h3><p>如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。</p><h3 id="事件委托的变更"><a href="#事件委托的变更" class="headerlink" title="事件委托的变更"></a>事件委托的变更</h3><p>React v17 中，React 不会再将事件处理添加到 document 上，而是将事件处理添加到渲染 React 树的根 DOM 容器中<br>经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，其中大多与将 React 与非 React 代码集成有关。</p><h3 id="全新的-JSX-转换"><a href="#全新的-JSX-转换" class="headerlink" title="全新的 JSX 转换"></a>全新的 JSX 转换</h3><p>此时源代码无需引入 React 即可使用 JSX 了！（但仍需引入 React，以便使用 React 提供的 Hook 或其他导出。）</p><p>此变化与所有现有 JSX 代码兼容，所以你无需修改组件。如果你对此感兴趣，你可以查看 RFC 了解全新转换工作的具体细节。</p><p>特点：</p><ul><li>新的 JSX 转换不依赖 React 环境</li></ul><p>优点：</p><ul><li>不需要引入 Ract 使用全新的转换，你可以单独使用 JSX 而无需引入 React。</li><li>改善 bundle 根据你的配置，JSX 的编译输出可能会略微改善 bundle 的大小。</li><li>以备未来之需 它将减少你需要学习 React 概念的数量，以备未来之需。</li></ul><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="git-rebase-与-git-merge"><a href="#git-rebase-与-git-merge" class="headerlink" title="git rebase 与 git merge"></a>git rebase 与 git merge</h3><p>merge(合并): 会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）<br>rebase（变基）: 变基使得提交历史更加整洁, 尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉，</p><p>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p><h3 id="副作用清理时间"><a href="#副作用清理时间" class="headerlink" title="副作用清理时间"></a>副作用清理时间</h3><ul><li>React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。</li><li>React 16 只对组件内的 effect 保证这种顺序。</li></ul><h3 id="React17-重大更改"><a href="#React17-重大更改" class="headerlink" title="React17 重大更改"></a>React17 重大更改</h3><ul><li>更改事件委托</li><li>对标浏览器，对事件系统进行小改</li><li>去除事件池 不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水 （因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。）</li><li>副作用清理时间 （- React 17 将在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）。，- React 16 只对组件内的 effect 保证这种顺序。）</li><li>返回一致的 undefined 错误，（算是改 bug 了，forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致。在返回 undefined 时会报错）</li><li>原生组件栈 （生产环境提示更友好。在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。_React 实现这一点的方式有点非常规_。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。因此，_当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息_）</li><li>移除私有导出（与 react 关联不是很大的部分被移出）</li></ul><h3 id="变基原理："><a href="#变基原理：" class="headerlink" title="变基原理："></a>变基原理：</h3><ol><li>是首先找到这两个分支的最近共同祖先 C2</li><li>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3</li><li>最后以此将之前另存为临时文件的修改依序应用</li></ol><h3 id="什么时候用哪个？"><a href="#什么时候用哪个？" class="headerlink" title="什么时候用哪个？"></a>什么时候用哪个？</h3><p>这本身存在分歧，主要看团队需要，如果团队需要历史记录保留，便于追踪，可以使用 merge ,如果不希望保留过多的过程，只关注结果那么可以用 rebase.无论用哪个，为了避免 rebase 的坑， 需要遵循以下原则：</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p><pre class="line-numbers language-none"><code class="language-none">$ git rebase --onto master server client</code></pre><p>你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#:~:text=Figure%2039.%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E9%87%8C%E5%86%8D%E5%88%86%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E5%88%86%E6%94%AF%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" >见</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git rebase -i HEAD~4# s 命令压缩</code></pre><img src="http://t-blog-images.aijs.top/img/202209171547417.png" /><img src="http://t-blog-images.aijs.top/img/202209171551269.png" /><p><a href="https://www.cnblogs.com/lookphp/p/5799533.html" target="_blank" >见</a></p><p><a href="https://backlog.com/git-tutorial/cn/stepup/stepup7_7.html" target="_blank" >见</a></p><h3 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h3><img src="http://t-blog-images.aijs.top/img/202209181100864.png" /><img src="http://t-blog-images.aijs.top/img/202209181059249.png" /><pre class="line-numbers language-none"><code class="language-none">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~3The previous cherry-pick is now empty, possibly due to conflict resolution.If you wish to commit it anyway, use:    git commit --allow-emptyOtherwise, please use &#39;git reset&#39;interactive rebase in progress; onto e1a52d3Last commands done (2 commands done):   pick 78c1fd9 应对github bug s 压缩   pick 8935665 应对github bugNext commands to do (4 remaining commands):   pick 421821a update   pick 4eff6a3 updateYou are currently rebasing branch &#39;main&#39; on &#39;e1a52d3&#39;.nothing to commit, working tree cleanCould not apply 8935665... 应对github bug♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git rebase -i HEAD~2It seems that there is already a rebase-merge directory, andI wonder if you are in the middle of another rebase.  If that is thecase, please try        git rebase (--continue | --abort | --skip)If that is not the case, please        rm -fr &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;.git&#x2F;rebase-merge&quot;and run me again.  I am stopping in case you still have somethingvaluable there.$ git rebase --abort</code></pre><h2 id="掘金小猪课堂"><a href="#掘金小猪课堂" class="headerlink" title="掘金小猪课堂"></a>掘金小猪课堂</h2><h3 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别"></a>for…in 和 for…of 的区别</h3><p>for…in 可以遍历对象和数组，for…of 不能遍历对象<br>for…in <strong>循环不仅遍历数字键名，还会遍历手动添加的其它键，甚至包括原型链上的键</strong><br>for…in 遍历的索引为字符串类型<br>for..of 适用遍历数&#x2F;数组对象&#x2F;字符串&#x2F;map&#x2F;set 等拥有迭代器对象的集合，但是不能遍历对象<br>for…of 与 forEach()不同的是，它可以正确响应 break、continue 和 return 语句<br>具有迭代器对象才可以使用 for…of</p><p>作者：小猪课堂<br>链接：<a href="https://juejin.cn/post/7002484014414037000">https://juejin.cn/post/7002484014414037000</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="JavaScript-中可迭代对象"><a href="#JavaScript-中可迭代对象" class="headerlink" title="JavaScript 中可迭代对象"></a>JavaScript 中可迭代对象</h3><p>Set<br>Map</p><p>String<br>Array</p><p>Arguments<br>NodeList</p><h3 id="几种获取-URL-参数"><a href="#几种获取-URL-参数" class="headerlink" title="几种获取 URL 参数"></a><a href="https://juejin.cn/post/7075305529903415304" target="_blank" >几种获取 URL 参数</a></h3><ul><li>通过正则匹配的方式</li><li>利用 a 标签内置方法</li><li>利用 split 方法分割法</li><li>使用 URLSearchParams 方法</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; - 通过正则匹配的方式&lt;script&gt;  &#x2F;&#x2F; 利用正则表达式  let url &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&quot;  &#x2F;&#x2F; &#x2F;&#x2F; 返回参数对象  function queryURLParams(url) &#123;    let pattern &#x3D; &#x2F;(\w+)&#x3D;(\w+)&#x2F;ig; &#x2F;&#x2F;定义正则表达式    let parames &#x3D; &#123;&#125;; &#x2F;&#x2F; 定义参数对象    url.replace(pattern, ($, $1, $2) &#x3D;&gt; &#123;      parames[$1] &#x3D; $2;    &#125;);    return parames;  &#125;  console.log(queryURLParams(url))&lt;&#x2F;script&gt;&#x2F;&#x2F; - 使用 URLSearchParams 方法&lt;script&gt;  let URL &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com?name&#x3D;elephant&amp;age&#x3D;25&amp;sex&#x3D;male&amp;num&#x3D;100&quot;  function queryURLParams(URL) &#123;    let url &#x3D; URL.split(&quot;?&quot;)[1];    const urlSearchParams &#x3D; new URLSearchParams(url);    const params &#x3D; Object.fromEntries(urlSearchParams.entries());    return params  &#125;  console.log(queryURLParams(URL))&lt;&#x2F;script&gt;&#x2F;&#x2F; 作者：小猪课堂&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7075305529903415304&#x2F;&#x2F; 来源：稀土掘金&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h3 id="offsetHeight、scrollHeight、clientHeight-的区别"><a href="#offsetHeight、scrollHeight、clientHeight-的区别" class="headerlink" title="offsetHeight、scrollHeight、clientHeight 的区别"></a>offsetHeight、scrollHeight、clientHeight 的区别</h3><p>三个属性虽然都很类似，但是每一个又有一些不一样的地方，总结起来就下面三点：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;*占据空间*&#x2F; offsetHeight &#x3D; 内容高度 + padding + border;&#x2F;*内容*&#x2F; clientheight &#x3D; 内容高度 + padding;&#x2F;*滚动*&#x2F; scrollHeight &#x3D; 内容实际尺寸 + padding;&#x2F;&#x2F; 作者：小猪课堂&#x2F;&#x2F; 链接：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;7085317886046126087&#x2F;&#x2F; 来源：稀土掘金&#x2F;&#x2F; 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><h3 id="childNodes-和-children-有什么区别？"><a href="#childNodes-和-children-有什么区别？" class="headerlink" title="childNodes 和 children 有什么区别？"></a>childNodes 和 children 有什么区别？</h3><p><strong>Node -&gt; childNodes</strong></p><p>在 DOM 树中，所有的节点都是 Node，包括 Element，也就是说 Node 包含了 <code>HTML 元素标签</code>、<code>text</code>、<code>以及注释</code>等等内容，它是所有 DOM 的基类。</p><p><strong>Element -&gt; HTMLCollection</strong></p><p>在 DOM 树中，Element 只包含 HTML 元素标签。</p><p><strong>关系</strong></p><p>childNodes 属于 NodeList 集合，它会返回所有的子节点，包括文本、标签、注释等等。</p><p>children 数据 HTMLCollection 集合，它会返回所有 HTML 元素节点。</p><p>childNodes 包含 children。</p><h3 id="Ajax、Fetch、Axios-三者的区别"><a href="#Ajax、Fetch、Axios-三者的区别" class="headerlink" title="Ajax、Fetch、Axios 三者的区别"></a>Ajax、Fetch、Axios 三者的区别</h3><p><strong>Ajax</strong></p><p><em>全称：</em> Asynchronous JavaScript And XML，翻译过来就是“异步的 Javascript 和 XML”。<br><em>特点</em> 局部刷新页面，无需重载整个页面。<br><em>简单来说</em> Ajax 是一种思想，XMLHttpRequest 只是实现 Ajax 的一种方式。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;  function ajax(url) &#123;    &#x2F;&#x2F; 实例    const xhr &#x3D; new XMLHttpRequest();    &#x2F;&#x2F; 方法    xhr.open(&quot;get&quot;, url, false);    &#x2F;&#x2F; 监听    xhr.onreadystatechange &#x3D; function () &#123;      &#x2F;&#x2F; 异步回调函数      if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;        if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;          console.info(&quot;响应结果&quot;, xhr.response)        &#125;      &#125;    &#125;    &#x2F;&#x2F; 发送    xhr.send(null);  &#125;  ajax(&#39;https:&#x2F;&#x2F;smallpig.site&#x2F;api&#x2F;category&#x2F;getCategory&#39;)&lt;&#x2F;script&gt;</code></pre><p><strong>Fetch</strong></p><p><em>注意：</em>不应该和 Ajax 做比较, 应该和 <code>XMLHttpRequest</code>做比较， Ajax 一个是思想，Fetch 一个是真实存在的 API</p><p><em>特点</em></p><ul><li>Fetch 是在 ES6 出现的，它使用了 ES6 提出的 promise 对象</li><li>内置的 API</li><li>使用上更简单</li><li>使用 promise, 不使用回调</li><li>数据流对象处理数据<code>常用res.json()转化成json数据</code></li></ul><p><strong>Axios</strong></p><p><em>Axios</em>是一个基于 promise 和 XHR 封装的网络请求库</p><p><em>特点：</em></p><ul><li>从浏览器中创建 XMLHttpRequests，从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><img src="http://t-blog-images.aijs.top/img/202210171747226.webp" /><h3 id="判断两个对象是否相等"><a href="#判断两个对象是否相等" class="headerlink" title="判断两个对象是否相等"></a>判断两个对象是否相等</h3><h3 id="实现浏览器多标签页之间通信"><a href="#实现浏览器多标签页之间通信" class="headerlink" title="实现浏览器多标签页之间通信"></a>实现浏览器多标签页之间通信</h3><p><strong>浏览器自身解决方案</strong></p><p>localStorage(不跨域)、cookie(不跨域)、indexDB(不跨域)、sharedWorker(不跨域)</p><p><strong>服务端协同</strong></p><p>websocket</p><p><strong>sessionStorage,webworker</strong></p><p>属于页面会话级别</p><h3 id="将类数组转为数组"><a href="#将类数组转为数组" class="headerlink" title="将类数组转为数组"></a>将类数组转为数组</h3><p><em>类数组：</em></p><ul><li>类数组是一个对象， 带有 length 属性</li><li>没有数组方法，即不可调用数组的原型方法</li></ul><p><em>类数组：</em></p><ul><li>arguments</li><li>HTMLCollection</li><li>NodeList</li></ul><p><em>实现方案</em></p><ul><li>Array.from ES6 提供的方法，只能实现浅拷贝</li><li>扩展运算符 不能使用在非迭代对象上</li><li>数组 slice 方法 在不改变原数组的情况下返回数组中的某些元素并形成新的数组。</li></ul><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><p>typeof 能判断基本数据类型，不能判断引用数据类型<br>instanceof 可以判断引用数据类型, 不能判断基本数据类型</p><p>虽然上面两个结合可以处理，但是过于复杂</p><p>每个对象都有一个  toString()  方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()  方法被每个  Object  对象继承。如果此方法在自定义对象中未被覆盖，toString()  返回  “[object type]”，其中  type  是对象的类型</p><p>作者：小猪课堂<br>链接：<a href="https://juejin.cn/post/7089322067677413412">https://juejin.cn/post/7089322067677413412</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;  function getType(data) &#123;    let originType &#x3D; Object.prototype.toString.call(data); &#x2F;&#x2F; 获取内部属性值    let index &#x3D; originType.indexOf(&#39; &#39;); &#x2F;&#x2F; 以空格分割    let type &#x3D; originType.slice(index + 1, -1); &#x2F;&#x2F; 截取 [object Number]    return type.toLowerCase();  &#125;  console.info(getType(&quot;小猪课堂&quot;)); &#x2F;&#x2F; string  console.info(getType(123)); &#x2F;&#x2F; number  console.info(getType(true)); &#x2F;&#x2F; boolean  console.info(getType(null)); &#x2F;&#x2F; null  console.info(getType(undefined)); &#x2F;&#x2F; undefined  console.info(getType(&#123; name: &quot;小猪课堂&quot; &#125;)); &#x2F;&#x2F; object  console.info(getType([1,3,2])); &#x2F;&#x2F; array  console.info(getType(Promise.resolve())); &#x2F;&#x2F; promise  console.info(getType(new Set())); &#x2F;&#x2F; set  console.info(getType(new WeakMap())); &#x2F;&#x2F; weakmap  console.info(getType(new Date())); &#x2F;&#x2F; date  console.info(getType(() &#x3D;&gt; &#123;&#125;)); &#x2F;&#x2F; function  console.info(getType(new Map)); &#x2F;&#x2F; map  console.info(getType(BigInt(100))); &#x2F;&#x2F; bigint  console.info(getType(new RegExp(&#39;&#39;))); &#x2F;&#x2F; regexp  console.info(getType((Symbol()))); &#x2F;&#x2F; symbol&lt;&#x2F;script&gt;</code></pre><h3 id="session、cookie、token-的区别？"><a href="#session、cookie、token-的区别？" class="headerlink" title="session、cookie、token 的区别？"></a>session、cookie、token 的区别？</h3><p>1.为什么会有它们？</p><p><strong>无状态</strong><br>我们都知道 HTTP 协议是无状态的，所谓的无状态就是客户端每次想要与服务端通信，都必须重新与服务端链接，意味着请求一次客户端和服务端就连接一次，下一次请求与上一次请求是没有关系的。</p><p><strong>区分用户</strong><br>这种无状态的方式就会存在一个问题：如何判断两次请求的是同一个人？就好比用户在页面 A 发起请求获取个人信息，然后在另一个页面同样发起请求获取个人信息，我们如何确定这俩个请求是同一个人发的呢？</p><p>为了解决这种问题，我们就迫切需要一种方式知道发起请求的客户端是谁？此时，cookie、token、session 就出现了，它们就可以解决客户端标识的问题，在扩大一点就是解决权限问题。</p><p>它们就好比让每个客户端或者说登录用户有了自己的身份证，我们可以通过这个身份证确定发请求的是谁！</p><p>作者：小猪课堂<br>链接：<a href="https://juejin.cn/post/7090503270447185951">https://juejin.cn/post/7090503270447185951</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>cookie 的缺点：</p><ul><li>增加请求体积，浪费性能，因为每次请求都会携带 cookie。</li><li>增加服务端资源消耗，因为每个客户端连接进来都需要生成 session，会占用服务端资源的。</li><li>容易遭受 CSRF 攻击，即跨站域请求伪造。</li></ul><h3 id="new-做了哪些操作？手写一个-new-方法！"><a href="#new-做了哪些操作？手写一个-new-方法！" class="headerlink" title="new 做了哪些操作？手写一个 new 方法！"></a>new 做了哪些操作？手写一个 new 方法！</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;  &#x2F;&#x2F; 定义构造函数  function Person(name, age) &#123;    this.name &#x3D; name;    this.age &#x3D; age;    return this.name + &#39;:&#39; + this.age  &#125;  &#x2F;&#x2F; 定义原型方法  Person.prototype.say &#x3D; function () &#123;    console.log(&quot;你好：&quot;, this.name)  &#125;  &#x2F;&#x2F; 手动实现new方法  function myNew(constructor) &#123;    if (typeof constructor !&#x3D;&#x3D; &quot;function&quot;) &#123;      throw &quot;myNew方法的第一个参数必须是一个方法&quot;;    &#125;    &#x2F;&#x2F; 基于constructor的原型创建一个全新的对象    let newObj &#x3D; Object.create(constructor.prototype);    &#x2F;&#x2F; 获取传入的参数    let args &#x3D; Array.from(arguments).slice(1);    &#x2F;&#x2F; 执行constructor函数，获取结果，并将属性添加到新对象newObj上    let result &#x3D; constructor.apply(newObj, args); &#x2F;&#x2F; 将this指向newObj    &#x2F;&#x2F; 判断result类型，如果是object或者function类型，则直接返回结果    let originType &#x3D; Object.prototype.toString.call(result); &#x2F;&#x2F; 获取内部属性值    let isObject &#x3D; originType &#x3D;&#x3D;&#x3D; &#39;[object Object]&#39;;    let isFunction &#x3D; originType &#x3D;&#x3D;&#x3D; &#39;[object Function]&#39;;    if (isObject || isFunction) &#123;      return result;    &#125; else &#123;      &#x2F;&#x2F; 返回新对象      return newObj;    &#125;  &#125;  let obj &#x3D; myNew(Person, &#39;小猪课堂&#39;, 26);  console.log(obj);  obj.say();&lt;&#x2F;script&gt;</code></pre><h2 id="跨标签页的通讯方式有哪些"><a href="#跨标签页的通讯方式有哪些" class="headerlink" title="跨标签页的通讯方式有哪些"></a>跨标签页的通讯方式有哪些</h2><h3 id="为什么需要跨标签页通信"><a href="#为什么需要跨标签页通信" class="headerlink" title="为什么需要跨标签页通信"></a>为什么需要跨标签页通信</h3><p>一个标签页的数据，要同步给另一个标签页</p><h3 id="列举"><a href="#列举" class="headerlink" title="列举"></a>列举</h3><ul><li><code>广播模式：</code>Broadcast Channe &#x2F; Service Worker &#x2F; LocalStorage + StorageEvent</li><li><code>共享存储模式：</code>Shared Worker &#x2F; IndexedDB &#x2F; cookie</li><li><code>口口相传模式：</code>window.open + window.opener</li><li><code>基于服务端：</code>Websocket &#x2F; Comet &#x2F; SSE 等</li></ul><p>作者：AlienZHOU<br>链接：<a href="https://juejin.cn/post/6844903811232825357">https://juejin.cn/post/6844903811232825357</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>除了轮询还可以通过监听 tab 切换来实现数据同步<br>过了一会我们从 Tab B 切换回 Tab A 时，希望将之前在 Tab B 中的操作的信息同步回来。这时候，其实只用在 Tab A 中监听 visibilitychange 这样的事件，来做一次信息同步即可</p><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Broadcast_Channel_API" target="_blank" >Broadcast_Channel_API</a><br><a href="https://juejin.cn/post/6844903811232825357" target="_blank" >面试官：前端跨页面通信，你知道哪些方法？</a></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;iframe  src&#x3D;&quot;https:&#x2F;&#x2F;alienzhou.github.io&#x2F;cross-tab-communication&#x2F;&quot;  style&#x3D;&quot;width: 100%; height: 800px&quot;&gt;&lt;&#x2F;iframe&gt;</code></pre><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/alienzhou/alienzhou.github.io/blob/master/cross-tab-communication/index.html" target="_blank" >见</a></p><h3 id="非同源"><a href="#非同源" class="headerlink" title="非同源"></a>非同源</h3><p><a href="https://juejin.cn/post/6869686782942773255" target="_blank" >见</a></p><p>实现原理：<br><a href="http://localhost:3000/bbb.html%EF%BC%88%E7%AE%80%E7%A7%B0">http://localhost:3000/bbb.html（简称</a> bbb 页面）嵌入 iframe 页面 <a href="http://localhost:3001/a.html%EF%BC%88%E7%AE%80%E7%A7%B0">http://localhost:3001/a.html（简称</a> iframe 页面）<br>iframe 能够接受父级页面 bbb.html 发送过来的数据<br>与此同时 iframe 与实际需要接受数据的 <a href="http://localhost:3001/b.html">http://localhost:3001/b.html</a>(简称 b 页面)同源，所以可以通过同源通信的 Broadcast Channel 方式将 iframe 接受到的数据发送给 b 页面实现 bbb 页面与 b 页面之间的数据发送</p><p>作者：Tsuki_<br>链接：<a href="https://juejin.cn/post/6869686782942773255">https://juejin.cn/post/6869686782942773255</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 父传子iframe.contentWindow.postMessage(&quot;父页面传送的数据&quot;, &quot;*&quot;);&#x2F;&#x2F; 父接子window.addEventListener(&quot;message&quot;, function (data) &#123;  console.log(data);&#125;);&#x2F;&#x2F; 子接父window.addEventListener(&quot;message&quot;, function (obj) &#123;  console.log(&quot;子页面&quot;);  console.log(obj);  let parentWindow &#x3D; obj.source;  parentWindow.postMessage(&quot;子页面传送的数据&quot;, &quot;*&quot;);&#125;);&#x2F;&#x2F; 子传父function sendMesg() &#123;  window.parent.window.postMessage(&quot;子页面传送的数据&quot;, &quot;*&quot;);&#125;</code></pre><p><a href="https://blog.csdn.net/wangliuqi123/article/details/109577991" target="_blank" >见</a></p><h2 id="CSS3-中-transition-和-animation-的属性分别有哪些"><a href="#CSS3-中-transition-和-animation-的属性分别有哪些" class="headerlink" title="CSS3 中 transition 和 animation 的属性分别有哪些"></a>CSS3 中 transition 和 animation 的属性分别有哪些</h2><h2 id="CSS3-font"><a href="#CSS3-font" class="headerlink" title="CSS3 font"></a>CSS3 font</h2><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的技术。</p><p><em>函数柯里化，是可以用来慢慢凑齐参数，延迟函数的执行。（先分期交钱，后交货！）</em></p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>函数有记忆功能（多次接受参数，记忆历史参数信息），累积接受参数个数函数小于定义参数个数时返回一个函数，继续接受参数，<code>典型的闭包 + 递归</code></p><h3 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h3><h3 id="柯里化-1"><a href="#柯里化-1" class="headerlink" title="柯里化"></a>柯里化</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const curry &#x3D; (fn, ...rest) &#x3D;&gt; &#123;  return (...args) &#x3D;&gt; &#123;    &#x2F;&#x2F;判断参数总数是否和fn参数个数相等    if ([...rest, ...args].length &#x3D;&#x3D;&#x3D; fn.length) &#123;      return fn(...rest, ...args); &#x2F;&#x2F;拓展参数，调用fn    &#125; else &#123;      return curry(fn, [...rest, ...args]); &#x2F;&#x2F;迭代，传入现有的所有参数    &#125;  &#125;;&#125;;&#x2F;&#x2F; const curry &#x3D; (fn, ...args1) &#x3D;&gt; (...args2) &#x3D;&gt; ((arg) &#x3D;&gt; (arg.length &#x3D;&#x3D;&#x3D; fn.length ? fn(...arg) : curry(fn, ...arg)))([&#x2F;&#x2F;       ...args1,&#x2F;&#x2F;       ...args2,&#x2F;&#x2F;     ]);&#x2F;&#x2F; 调用const foo &#x3D; (a, b, c) &#x3D;&gt; a * b * c;curry(foo)(2, 3, 4); &#x2F;&#x2F; -&gt; 24curry(foo, 2)(3, 4); &#x2F;&#x2F; -&gt; 24curry(foo, 2, 3)(4); &#x2F;&#x2F; -&gt; 24curry(foo, 2, 3, 4)(); &#x2F;&#x2F; -&gt; 24</code></pre><p><a href="https://www.jianshu.com/p/c87242cd2f6c" target="_blank" >见</a></p><h2 id="promise-与-async-的区别"><a href="#promise-与-async-的区别" class="headerlink" title="promise 与 async 的区别"></a>promise 与 async 的区别</h2><h3 id="async-特点"><a href="#async-特点" class="headerlink" title="async 特点"></a>async 特点</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>async 解决了什么问题 promise 链式调用的烦恼<br>async 和 await 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 promise</p><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ul><li>async 函数是 AsyncFunction 构造函数的实例 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function#:~:text=async%20%E5%87%BD%E6%95%B0%E6%98%AF%20AsyncFunction%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E4%BE%8B" target="_blank" >见</a></li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>async 函数可能包含 0 个或者多个 await 表达式。</li><li>await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。</li><li>promise 的解决值会被当作该 await 表达式的返回值</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。这样的话，一个不含 await 表达式的 async 函数是会同步运行的。</li><li>如果函数体内有一个 await 表达式，async 函数就<code>一定</code>会异步执行。</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>async 返回值<code>一定</code>为 promise, 如果返回值不是 promise，将会被隐式包装在一个 promise 中</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function foo() &#123;  return 1;&#125;&#x2F;&#x2F; 等价于function foo() &#123;  return Promise.resolve(1);&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(1);async function foo() &#123;  console.log(2);  await 1;  console.log(3);&#125;foo();console.log(4);&#x2F;&#x2F; 结果：1243</code></pre><h4 id="两个-await-执行说明"><a href="#两个-await-执行说明" class="headerlink" title="两个 await, 执行说明"></a>两个 await, 执行说明</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">async function foo() &#123;  const result1 &#x3D; await new Promise((resolve) &#x3D;&gt;    setTimeout(() &#x3D;&gt; resolve(&quot;1&quot;))  );  const result2 &#x3D; await new Promise((resolve) &#x3D;&gt;    setTimeout(() &#x3D;&gt; resolve(&quot;2&quot;))  );&#125;foo();</code></pre><ol><li>foo 函数的第一行将会同步执行，await 将会等待 promise 的结束。然后暂停通过 foo 的进程，并将控制权交还给调用 foo 的函数。(控制权转出)</li><li>一段时间后，当第一个 promise 完结的时候，控制权将重新回到 foo 函数内。示例中将会将 1（promise 状态为 fulfilled）作为结果返回给 await 表达式的左边即 result1。 (控制权转入)</li><li>接下来函数会继续进行，到达第二个 await 区域，此时 foo 函数的进程将再次被暂停。(控制权转出)</li><li>一段时间后，同样当第二个 promise 完结的时候，result2 将被赋值为 2，之后函数将会正常同步执行，将默认返回 undefined (控制权转入)</li></ol><p><em>注意： promise 链不是一次就构建好的，相反，promise 链是分阶段构造的，因此在处理异步函数时必须注意对错误函数的处理。</em></p><h4 id="async-x2F-await-和-Promise-x2F-then-对比以及错误处理"><a href="#async-x2F-await-和-Promise-x2F-then-对比以及错误处理" class="headerlink" title="async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理"></a>async&#x2F;await 和 Promise&#x2F;then 对比以及错误处理</h4><ul><li>大多数 async 函数也可以使用 Promises 编写。但是，<code>在错误处理方面，async 函数更容易捕获异常错误</code></li><li>如果任一 <code>awaited 调用失败</code>，它将<code>自动捕获异常</code>，async 函数<code>执行中断</code>，并通过<code>隐式返回 Promise </code>将错误传递给调用者</li><li>async 函数仍有可能然可能错误地忽略错误.在 async 中， 没有等待 await 返回，则不会传播任何错误</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>promise 链式调用繁杂，async&#x2F;await 相对来说，更简单</li><li>promise api 能够实现并发， async&#x2F;await 只会顺序执行</li><li>async&#x2F;await 的返回值，一定是一个 promise，会进行隐式的包装（如果在发生错误时候进行，捕获处理然后返回一个值，之后真正返回并不是这个值，而是被 promise 包装了）</li><li>async&#x2F;await 在处理错误方面更容易（任意一个 await 出错，会自动捕获异常，执行中断，隐式返回 promise 错误，这几个环环相扣）</li><li>如果没有等待返回的情况下，async 可能错误的忽略错误，不进行传播错误</li><li>因 async&#x2F;await 一定返回的是 promise,所以 async&#x2F;await 既可以用<code>try catch</code>， 也可以用<code>.catch</code> (<code>try catch</code>是 js 语法，<code>.catch</code>是<code>promise.catch</code>语法)</li></ol><h2 id="包装对象-x2F-原型与原型链"><a href="#包装对象-x2F-原型与原型链" class="headerlink" title="包装对象&#x2F;原型与原型链"></a>包装对象&#x2F;原型与原型链</h2><h3 id="包装对象的含义"><a href="#包装对象的含义" class="headerlink" title="包装对象的含义"></a>包装对象的含义</h3><p>（Number&#x2F;String）经过封装，能够处理（number&#x2F;string）的对象</p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><div style="display:flex;flex-direction:row; flex-wrap:wrap;align-items: flex-start;"><img src="http://t-blog-images.aijs.top/img/202210261711923.webp" style="width: 550px;max-width:100%" /><div style="width:10px"></div><img src="http://t-blog-images.aijs.top/img/202210261734112.webp" style="width: 360px;max-width:100%"/></div><p>细品 原型与原型链关系图：</p><p>竖着看分为三栏：左侧为实例对象，中间为构造函数，右侧为原型对象</p><table><thead><tr><th align="left">序号</th><th align="left">实例</th><th align="left">构造函数 <span style="color: red">created by Function</span></th><th align="left">实例原型</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">new Foo&#x2F;Number&#x2F;String</td><td align="left">function Foo&#x2F;Number&#x2F;String()</td><td align="left">Foo&#x2F;Number&#x2F;String.prototype</td></tr><tr><td align="left">2</td><td align="left">new Object</td><td align="left">function Object()</td><td align="left">Object.prototype</td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">function Function()</td><td align="left">Function.prototype</td></tr></tbody></table><p><strong>注意：序号 1</strong><br>从 MDN Number 包装对象的目录接口也可以看出：Number 的原型链： <code>Function.prototype -&gt; Object.prototype -&gt; null</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; .__proto__ 表示：隐式原型&#x2F;&#x2F; .prototype 表示：显示原型实例.__proto__ &#x3D;&#x3D; 实例的原型对象构造函数的.__proto__ &#x3D;&#x3D; Function 的原型对象原型对象的.constructor &#x3D;&#x3D; 对应的构造函数构造函数的.prototype &#x3D;&#x3D; 对应的原型对象非(Object 和 null)的.__proto__ &#x3D;&#x3D; Object.prototypeObject.__proto__ &#x3D;&#x3D; null&#x2F;&#x2F; 有意思的是 FunctionFunction.__proto__ &#x3D;&#x3D; Function.prototype</code></pre><h2 id="Object-freeze-vs-Object-seal-vs-Object-preventExtensions"><a href="#Object-freeze-vs-Object-seal-vs-Object-preventExtensions" class="headerlink" title="Object.freeze() vs Object.seal() vs Object.preventExtensions()"></a>Object.freeze() vs Object.seal() vs Object.preventExtensions()</h2><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><ul><li>不增加新属性</li><li>不删除已有属性</li><li>不赋值</li><li>子属性对象可编辑</li></ul><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><ul><li>不增加新属性</li><li>不删除已有属性</li><li>可赋值</li></ul><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><ul><li>不增加新属性</li><li>可改已有属性</li></ul><h3 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h3><table><thead><tr><th align="left">特性</th><th align="left">默认</th><th align="left">preventExtensions</th><th align="left">seal</th><th align="left">freeze</th></tr></thead><tbody><tr><td align="left">增加新属性</td><td align="left">可</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">移除属性</td><td align="left">可</td><td align="left">可</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">更改属性</td><td align="left">可</td><td align="left">可</td><td align="left">可</td><td align="left"></td></tr><tr><td align="left">子对象属性操作</td><td align="left">可</td><td align="left">可</td><td align="left">可</td><td align="left">可</td></tr></tbody></table><p><a href="https://javascript.plainenglish.io/object-freeze-vs-object-seal-vs-object-preventextensions-e78ef3a24201" target="_blank" >见</a></p><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>最早的前端开发就是实现页面，及交互的特效。<br>但是随着需求的增加，前端也变成大前端，还要做 App、小程序以及各种端。在这种需求日增的情况下，必须得考虑一种新的方式，优化前端的开发工作，<br>例如，解决代码冗余，项目可维护性，提升版本迭代速度等等一系列的问题。前端工程化的概念也就是在这中情况下被提出了。</p><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>前端工程化的主要目标就是解放生产力、提高生产效率。通过制定一系列的规范，借<br>助工具和框架解决前端开发以及前后端协作过程中的痛点和难度问题。</p><h3 id="如何实施前端工程化"><a href="#如何实施前端工程化" class="headerlink" title="如何实施前端工程化"></a>如何实施前端工程化</h3><ul><li>前端后分离</li><li>使用 webpack 实现项目构建</li><li>使用 babel 完成 javascript 编译</li><li>CSS 预编译</li><li>模块化开发</li><li>组件化</li><li>本地开发环境&#x2F;模拟数据</li><li>规范化约束</li><li>项目部署</li></ul><h2 id="npm-run-做了什么"><a href="#npm-run-做了什么" class="headerlink" title="npm run 做了什么"></a>npm run 做了什么</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; package.json; -&gt; node_modules&#x2F;.bin&#x2F; -&gt;对应的可执行文件执行&#x2F;&#x2F; 在安装依赖的时候，是通过npm install xxx来执行的，例如npm install @vue&#x2F;cli-service,npm在安装这个依赖的时候，就会在node_modules&#x2F;.bin&#x2F;目录中创建好vue-cli-service为名的几个可执行文件了【不同系统对应不同的可执行文件】&#x2F;&#x2F; .bin目录下的文件不是任何一个npm包。目录下的文件，表示这是一个个软连接，打开文件可以看到文件顶部写着#!&#x2F;bin&#x2F;sh,表示这是一个脚本&#x2F;&#x2F; 当使用 npm run serve 执行 vue-cli-service serve时，虽然没有安装 vue-cli-service的全局命令，但是npm 会到 .&#x2F;node_modules&#x2F;.bin中找到 vue-cli-service 文件作为 脚本来执行，则相当于执行了 .&#x2F;node_modules&#x2F;.bin&#x2F;vue-cli-service serve（最后的 serve 作为参数传入）</code></pre><h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><p><strong>1. 检查配置</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">项目级别的.npmrc文件 &gt;  用户级别的.npmrc文件 &gt;  全局的.npmrc文件 &gt;  npm内置的.npmrc文件;</code></pre><p><strong>2、没有 lock 文件</strong><br>2.1、分析依赖关系，这是因为我们包会依赖其他的包，并且会多个包之间产生相同的依赖的关系。<br>2.2、从 registry 仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）。<br>2.3、 获取到压缩包后会对压缩包进行缓存（从 npm5 开始有的）。<br>2.4、将压缩包解压到项目的 node_modules 文件夹中（前面我们讲过，require 的查找顺序会在该包下面查找）。<br><strong>3、有 lock 文件</strong><br>3.1、检测 lock 中包的版本是否和 package.json 中一致（会按照 semver 版本规范检测）。<br>3.2、不一致，那么会重新构建依赖关系，直接会走顶层的流程。<br>3.3、一致的情况下，会去优先查找缓存。<br>3.4、没有找到，会从 registry 仓库下载，直接走顶层流程。<br>3.5、查找到，会获取缓存中的压缩文件，并且将压缩文件解压到 node_modules 文件夹中。</p><h2 id="实现-jsonp，传入-URL，callback-和-callbackName-三个参数"><a href="#实现-jsonp，传入-URL，callback-和-callbackName-三个参数" class="headerlink" title="实现 jsonp，传入 URL，callback 和 callbackName 三个参数"></a>实现 jsonp，传入 URL，callback 和 callbackName 三个参数</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;  function jsonp(url, callbackName, callback) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;      try &#123;        let str &#x3D; &#96;$&#123;url&#125;?callback&#x3D;$&#123;callbackName&#125;&#96;        let scriptEle &#x3D; document.createElement(&#39;script&#39;)        scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;        scriptEle.src &#x3D; str        scriptEle.addEventListener(&#39;load&#39;, callback)        window[callbackName] &#x3D; function (data) &#123;          resolve(data)          document.body.removeChild(scriptEle)        &#125;        document.body.appendChild(scriptEle)      &#125; catch (err) &#123;        reject(err)      &#125;    &#125;)  &#125;  jsonp(&#39;http:&#x2F;&#x2F;127.0.0.1:3000&#x2F;home&#39;, &#39;fun1&#39;, () &#x3D;&gt; &#123;console.log(&#39;加载成功&#39;)&#125;).then(res &#x3D;&gt; &#123;    console.log(res)  &#125;)&lt;&#x2F;script&gt;</code></pre><h2 id="原生-js-实现动态加载-js-文件"><a href="#原生-js-实现动态加载-js-文件" class="headerlink" title="原生 js 实现动态加载 js 文件?"></a>原生 js 实现动态加载 js 文件?</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;    function loadScript(src, attrs) &#123;      return new Promise((resolve, reject) &#x3D;&gt; &#123;        try &#123;          &#x2F;&#x2F; 创建标签          let scriptEle &#x3D; document.createElement(&#39;script&#39;)          &#x2F;&#x2F; 类型          scriptEle.type &#x3D; &#39;text&#x2F;javascript&#39;          &#x2F;&#x2F; src          scriptEle.src &#x3D; src          &#x2F;&#x2F; 增加属性          for (let key in attrs) &#123;            scriptEle.setAttribute(key, attrs[key])          &#125;          &#x2F;&#x2F; 监听完成          scriptEle.addEventListener(&#39;load&#39;, function () &#123;            resolve(&#39;成功&#39;)          &#125;)          &#x2F;&#x2F; 挂载后加载          document.body.appendChild(scriptEle)        &#125; catch (err) &#123;          reject(err)        &#125;      &#125;)    &#125;    loadScript(&#39;http:&#x2F;&#x2F;cdn.staticfile.org&#x2F;jquery&#x2F;1.6.2&#x2F;jquery.min.js&#39;, &#123;async: true&#125;).then(res &#x3D;&gt; &#123;      console.log(res)    &#125;)  &lt;&#x2F;script&gt;</code></pre><h2 id="js-中的-for-循环注意点？"><a href="#js-中的-for-循环注意点？" class="headerlink" title="js 中的 for 循环注意点？"></a>js 中的 for 循环注意点？</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 多个判断条件以最后一个为准&#x2F;&#x2F; 最后一个是 j &lt; 9for (var i &#x3D; 0, j &#x3D; 0; i &lt; 5, j &lt; 9; i++, j++) &#123;  console.log(i, j);&#125;&#x2F;&#x2F; 0 0&#x2F;&#x2F; 1 1&#x2F;&#x2F; 2 2&#x2F;&#x2F; 3 3&#x2F;&#x2F; 4 4&#x2F;&#x2F; 5 5&#x2F;&#x2F; 6 6&#x2F;&#x2F; 7 7&#x2F;&#x2F; 8 8&#x2F;&#x2F; 最后一个是  i &lt; 5for (var i &#x3D; 0, j &#x3D; 0; j &lt; 9, i &lt; 5; i++, j++) &#123;  console.log(i, j);&#125;&#x2F;&#x2F; 0 0&#x2F;&#x2F; 1 1&#x2F;&#x2F; 2 2&#x2F;&#x2F; 3 3&#x2F;&#x2F; 4 4</code></pre><h2 id="new-操作符和点运算符的优先级"><a href="#new-操作符和点运算符的优先级" class="headerlink" title="new 操作符和点运算符的优先级"></a>new 操作符和点运算符的优先级</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Foo() &#123;  getName &#x3D; function () &#123;    console.log(1);  &#125;; &#x2F;&#x2F;会修改全局的下的getName  return this; &#x2F;&#x2F; 构造函数的返回值值得注意，如果是引用类型，则得到引用数据，null除外&#125;Foo.getName &#x3D; function () &#123;  console.log(2);&#125;;Foo.prototype.getName &#x3D; function () &#123;  console.log(3);&#125;;var getName &#x3D; function () &#123;  console.log(4);&#125;;function getName() &#123;  console.log(5);&#125;&#x2F;&#x2F;请写出以下输出结果：Foo.getName(); &#x2F;&#x2F;2getName(); &#x2F;&#x2F; 4Foo().getName(); &#x2F;&#x2F; 1getName(); &#x2F;&#x2F; 1new Foo.getName(); &#x2F;&#x2F; 2 这里是new了一个Foo.getName函数，并没有先执行Foo.getName()在去执行new操作new Foo().getName(); &#x2F;&#x2F; 3 (new Foo()).getName() 此时的getName是找到Foo构造函数的原型对象上的getName属性new new Foo().getName(); &#x2F;&#x2F; 3  new ((new Foo()).getName)();&#x2F;*******************升级版********************&#x2F;&#x2F;&#x2F; function Foo() &#123;&#x2F;&#x2F; this.getName &#x3D; function() &#123;&#x2F;&#x2F; console.log(3);&#x2F;&#x2F; return &#123;&#x2F;&#x2F; getName: getName&#x2F;&#x2F;这个就是第六问中涉及的构造函数的返回值问题&#x2F;&#x2F; &#125;&#x2F;&#x2F; &#125;;&#x2F;&#x2F;这个就是第六问中涉及到的， JS 构造函数公有方法和原型链方法的优先级&#x2F;&#x2F; getName &#x3D; function() &#123;&#x2F;&#x2F; console.log(1);&#x2F;&#x2F; &#125;;&#x2F;&#x2F; return this&#x2F;&#x2F; &#125;&#x2F;&#x2F; Foo.getName &#x3D; function() &#123;&#x2F;&#x2F; console.log(2);&#x2F;&#x2F; &#125;;&#x2F;&#x2F; Foo.prototype.getName &#x3D; function() &#123;&#x2F;&#x2F; console.log(6);&#x2F;&#x2F; &#125;;&#x2F;&#x2F; var getName &#x3D; function() &#123;&#x2F;&#x2F; console.log(4);&#x2F;&#x2F; &#125;;&#x2F;&#x2F; function getName() &#123;&#x2F;&#x2F; console.log(5);&#x2F;&#x2F; &#125; &#x2F;&#x2F;答案：&#x2F;&#x2F; Foo.getName(); &#x2F;&#x2F;2&#x2F;&#x2F; getName(); &#x2F;&#x2F;4&#x2F;&#x2F; console.log(Foo())&#x2F;&#x2F; Foo().getName(); &#x2F;&#x2F;1&#x2F;&#x2F; getName(); &#x2F;&#x2F;1&#x2F;&#x2F; new Foo.getName(); &#x2F;&#x2F;2&#x2F;&#x2F; new Foo().getName(); &#x2F;&#x2F;3&#x2F;&#x2F;             &#x2F;&#x2F;多了一问&#x2F;&#x2F; new Foo().getName().getName(); &#x2F;&#x2F;3 1&#x2F;&#x2F; new new Foo().getName(); &#x2F;&#x2F;3&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_34146986&#x2F;article&#x2F;details&#x2F;92386841</code></pre><h2 id="new-一个构造函数，如果函数返回不同类型的值，结果会如何"><a href="#new-一个构造函数，如果函数返回不同类型的值，结果会如何" class="headerlink" title="new 一个构造函数，如果函数返回不同类型的值，结果会如何?"></a>new 一个构造函数，如果函数返回不同类型的值，结果会如何?</h2><p>new 的原理： 最后要判断构造函数返回值是不是个对象，不是对象是对象返回这个值，不是对象，返回构造函数的实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">null instanceof Object; &#x2F;&#x2F; falseObject instanceof null; &#x2F;&#x2F; 报错，instanceof 的右侧必须是一个对象&#x2F;&#x2F; Uncaught TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></pre><h3 id="什么都不返回"><a href="#什么都不返回" class="headerlink" title="什么都不返回"></a>什么都不返回</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() &#123;&#125;let p1 &#x3D; new Person();console.log(p1); &#x2F;&#x2F;Person &#123;&#125;</code></pre><h3 id="返回一个新的对象"><a href="#返回一个新的对象" class="headerlink" title="返回一个新的对象"></a>返回一个新的对象</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() &#123;  return &#123;    name: &quot;1234&quot;,  &#125;;&#125;let p1 &#x3D; new Person();console.log(p1); &#x2F;&#x2F;&#123;name: &#39;1234&#39;&#125;</code></pre><h3 id="返回一个原始值"><a href="#返回一个原始值" class="headerlink" title="返回一个原始值"></a>返回一个原始值</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() &#123;  return 111;&#125;let p1 &#x3D; new Person();console.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre><h3 id="返回-null"><a href="#返回-null" class="headerlink" title="返回 null"></a>返回 null</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() &#123;  return null;&#125;let p1 &#x3D; new Person();console.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre><h3 id="返回-true"><a href="#返回-true" class="headerlink" title="返回 true"></a>返回 true</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() &#123;  return true;&#125;let p1 &#x3D; new Person();console.log(p1); &#x2F;&#x2F; Person &#123;&#125;</code></pre><h3 id="返回-this"><a href="#返回-this" class="headerlink" title="返回 this"></a>返回 this</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Person() &#123;  &#x2F;&#x2F; 构造函数this指的是对象实例  return this;&#125;let p1 &#x3D; new Person();console.log(p1);&#x2F;&#x2F; Person &#123;&#125;&#x2F;&#x2F; 但是 this instanceof Object true, 这里涉及到this指向问题</code></pre><h2 id="为什么要用-apply-x2F-call-这两个函数"><a href="#为什么要用-apply-x2F-call-这两个函数" class="headerlink" title="为什么要用 apply&#x2F;call 这两个函数"></a>为什么要用 apply&#x2F;call 这两个函数</h2><ul><li>说白了就是“拿来主义”、“借刀杀人”的功效，</li><li>比如我想做什么事，我不会不要紧，只要有人会就可以实现。</li><li>在程序里面就是，现在假如你想用什么方法，但是当前对象没有，你可以选择拓展，自己造一个这样的方法，但是你也可以直接拿来用</li></ul><p>有时候这样使用更方便，我们只需要对象和回调方法即可，按照一般的说法就是：call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。</p><p><a href="https://segmentfault.com/q/1010000006732812" target="_blank" >讲真，为什么要用 apply 和 call 这两个函数？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-this</title>
      <link href="//post/2022-09-18this.html"/>
      <url>//post/2022-09-18this.html</url>
      
        <content type="html"><![CDATA[<h2 id="注意啦，注意啦"><a href="#注意啦，注意啦" class="headerlink" title="注意啦，注意啦"></a>注意啦，注意啦</h2><p>以下皆对普通函数而言，箭头函数可不是这么玩的</p><h2 id="为什要有-this"><a href="#为什要有-this" class="headerlink" title="为什要有 this"></a>为什要有 this</h2><p>this 被自动定义在所有函数的作用域中，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 API 设计或者函数变得更加简洁，而且还更容易复用。</p><p>简单来说：this，被放到作用域中， 为了简化代码</p><h2 id="this-是如何定义的"><a href="#this-是如何定义的" class="headerlink" title="this 是如何定义的"></a>this 是如何定义的</h2><p>简单来说： this 就是一个执行上下文中的一个属性，可以简单的把 this 当作一个对象，只不过该对象指向哪儿是在函数调用的时候确定的</p><p>我们简单总结一下 this 的特点：</p><ul><li>this 是在运行时绑定的，不是在编写时绑定</li><li>this 的绑定与函数的声明和位置没有任何关系</li><li>函数在调用时，会创建一个执行上下文，this 就是这个执行上下文中的一个属性，在函数执行的时候可以用到 this。所以 this 是在函数调用的时候确定绑定关系的，也就是运行时。</li></ul><p>简单来说：this 就是一个对象，this 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h2 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h2><ul><li>判断函数调用时是否使用了 new，即 new 绑定，如果使用了，则 this 绑定的是新创建的对象。</li><li>函数调用是否使用了 call、apply 等显式绑定，或者硬绑定（bind），如果是的话，this 指向指定的对象。</li><li>函数是否在某个上下文对象中调用，即隐式绑定，如 obj1.foo，如果是的话，this 指向绑定的那个上下文对象。</li><li>以上 3 点都不涉及的话，则采用默认绑定，但是需要注意的是，在<code>严格模式下</code>，默认绑定的 this 是 undefined，<code>非严格模式</code>下绑定到全局对象。</li></ul><p>作者：小猪课堂<br>链接：<a href="https://juejin.cn/post/7115390077353590792">https://juejin.cn/post/7115390077353590792</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="this-绑定的优先级"><a href="#this-绑定的优先级" class="headerlink" title="this 绑定的优先级"></a>this 绑定的优先级</h2><p>默认绑定 &lt; 隐式绑定 &lt; 显式绑定 &lt; new(牛) 绑定</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 常用快捷键（持续更新...）</title>
      <link href="//post/2022-09-17vscode-shortcuts.html"/>
      <url>//post/2022-09-17vscode-shortcuts.html</url>
      
        <content type="html"><![CDATA[<h2 id="直接换行"><a href="#直接换行" class="headerlink" title="直接换行"></a>直接换行</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + enter;</code></pre><h2 id="选中多个相同的元素"><a href="#选中多个相同的元素" class="headerlink" title="选中多个相同的元素"></a>选中多个相同的元素</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + d; &#x2F;&#x2F; 每次向后多选一个相同的</code></pre><h2 id="选中相同内容"><a href="#选中相同内容" class="headerlink" title="选中相同内容"></a>选中相同内容</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + shift + L; &#x2F;&#x2F; 全文，选相同内容</code></pre><h2 id="多位置同时编辑"><a href="#多位置同时编辑" class="headerlink" title="多位置同时编辑"></a>多位置同时编辑</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + 点击;</code></pre><h2 id="选择一块内容"><a href="#选择一块内容" class="headerlink" title="选择一块内容"></a>选择一块内容</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + shift + 上; &#x2F;&#x2F; 当前行光标 左侧至顶部 全部内容cmd + shift + 下; &#x2F;&#x2F; 当前行光标 右侧至顶部 全部内容cmd + shift + 左; &#x2F;&#x2F; 当前行光标 左侧 全部内容cmd + shift + 右; &#x2F;&#x2F; 当前行光标 右侧 全部内容</code></pre><h2 id="选择一段内容"><a href="#选择一段内容" class="headerlink" title="选择一段内容"></a>选择一段内容</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">alt + shift + 左; &#x2F;&#x2F; 当前行光标 左侧 一段内容alt + shift + 右; &#x2F;&#x2F; 当前行光标 右侧 一段内容</code></pre><h2 id="复制当前行到"><a href="#复制当前行到" class="headerlink" title="复制当前行到"></a>复制当前行到</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">alt + shift + 上; &#x2F;&#x2F; 向上复制一行alt + shift + 下; &#x2F;&#x2F; 向下复制一行</code></pre><h2 id="向上插入空行"><a href="#向上插入空行" class="headerlink" title="向上插入空行"></a>向上插入空行</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + shift + enter;</code></pre><h2 id="向下插入空行"><a href="#向下插入空行" class="headerlink" title="向下插入空行"></a>向下插入空行</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + enter;</code></pre><h2 id="底部窗口显示隐藏"><a href="#底部窗口显示隐藏" class="headerlink" title="底部窗口显示隐藏"></a>底部窗口显示隐藏</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + j;</code></pre><h2 id="左侧窗口显示隐藏"><a href="#左侧窗口显示隐藏" class="headerlink" title="左侧窗口显示隐藏"></a>左侧窗口显示隐藏</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + B;</code></pre><h2 id="切换顶部-tab-文件"><a href="#切换顶部-tab-文件" class="headerlink" title="切换顶部 tab 文件"></a>切换顶部 tab 文件</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + alt + 左; &#x2F;&#x2F; 打开向左面一个cmd + alt + 右; &#x2F;&#x2F; 打开右面一个</code></pre><h2 id="文件内容切换到左侧导航"><a href="#文件内容切换到左侧导航" class="headerlink" title="文件内容切换到左侧导航"></a>文件内容切换到左侧导航</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + shift + E;cmd + down; &#x2F;&#x2F; 进入文件，光标定位到顶部</code></pre><h2 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + up; &#x2F;&#x2F; 向上滚动cmd + down; &#x2F;&#x2F; 进入文件，光标定位到顶部</code></pre><h2 id="切换-outline"><a href="#切换-outline" class="headerlink" title="切换 outline"></a>切换 outline</h2><p>可以快速地浏览代码，在代码中跳转，在长代码、长文档中还可以充当目录的功能</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">shift + cmd + . &#x2F;&#x2F; 快速地浏览代码</code></pre><img src="http://t-blog-images.aijs.top/img/202209172219341.png" /><h2 id="最近打开的文件"><a href="#最近打开的文件" class="headerlink" title="最近打开的文件"></a>最近打开的文件</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + p; &#x2F;&#x2F; 最近打开的文件</code></pre><h2 id="最近打开的项目"><a href="#最近打开的项目" class="headerlink" title="最近打开的项目"></a>最近打开的项目</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ctrl + R; &#x2F;&#x2F; 最近打开的项目</code></pre><h2 id="跳转到代码实现位置"><a href="#跳转到代码实现位置" class="headerlink" title="跳转到代码实现位置"></a>跳转到代码实现位置</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + fn + f12; &#x2F;&#x2F; 跳转到代码实现位置</code></pre><h2 id="跳回上次光标位置"><a href="#跳回上次光标位置" class="headerlink" title="跳回上次光标位置"></a>跳回上次光标位置</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ctrl + - &#x2F;&#x2F;跳回上次光标位置</code></pre><h2 id="关闭当前-tab"><a href="#关闭当前-tab" class="headerlink" title="关闭当前 tab"></a>关闭当前 tab</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + W; &#x2F;&#x2F; 关闭当前tab</code></pre><h3 id="文件内容替换"><a href="#文件内容替换" class="headerlink" title="文件内容替换"></a>文件内容替换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + F;</code></pre><h3 id="全局内容替换"><a href="#全局内容替换" class="headerlink" title="全局内容替换"></a>全局内容替换</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + shift + F;</code></pre><h3 id="跳转到下一个相同内容"><a href="#跳转到下一个相同内容" class="headerlink" title="跳转到下一个相同内容"></a>跳转到下一个相同内容</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + F; &#x2F;&#x2F; 先搜索该内容enter &#x2F; cmd + G; &#x2F;&#x2F; 下翻查找enter + shift; &#x2F;&#x2F; 上翻查找</code></pre><h3 id="快速删除行"><a href="#快速删除行" class="headerlink" title="快速删除行"></a>快速删除行</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + shift + K; &#x2F;&#x2F; 快速删除行&#x2F;&#x2F; orctrl + e; &#x2F;&#x2F; 跳到行未cmd + DELETE; &#x2F;&#x2F; 删除当前行光标前的内容</code></pre><h2 id="上行插入内容"><a href="#上行插入内容" class="headerlink" title="上行插入内容"></a>上行插入内容</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">shift + cmd + enter; &#x2F;&#x2F; 上行插入内容</code></pre><h2 id="下行插入内容"><a href="#下行插入内容" class="headerlink" title="下行插入内容"></a>下行插入内容</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + enter; &#x2F;&#x2F; 下行插入内容</code></pre><h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">f12; &#x2F;&#x2F; 代码重构 重命名</code></pre><h3 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h3><pre class="line-numbers language-none"><code class="language-none">cmd + ] &#x2F;&#x2F;代码向右缩进cmd + [ &#x2F;&#x2F;代码向左缩进</code></pre><h2 id="自定义打开-outline"><a href="#自定义打开-outline" class="headerlink" title="自定义打开 outline"></a>自定义打开 outline</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">shift + cmd + 2; &#x2F;&#x2F; 打开outline</code></pre><img src="http://t-blog-images.aijs.top/img/202209182009209.png" /><h2 id="多文件保存"><a href="#多文件保存" class="headerlink" title="多文件保存"></a>多文件保存</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cmd + S; &#x2F;&#x2F;但文件保存option + cmd + S; &#x2F;&#x2F; 批量文件保存</code></pre><h2 id="终端显示-x2F-隐藏"><a href="#终端显示-x2F-隐藏" class="headerlink" title="终端显示&#x2F;隐藏"></a>终端显示&#x2F;隐藏</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ctrl + &#96; &#x2F;&#x2F; 注意 不要听网上瞎扯说配置“mac隐私安全&#x2F;开发工具&#x2F;vscode” 打勾，如果打不开vscode terminal 可以查看是否被打勾了 （一定不要打勾！！！）</code></pre><h2 id="光标行选中"><a href="#光标行选中" class="headerlink" title="光标行选中"></a>光标行选中</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">1. 光标位置选到行首 &#x2F;&#x2F; ctrl + shift + A2. 光标位置跳到行首 &#x2F;&#x2F; ctrl + A3. 光标位置选到行尾 &#x2F;&#x2F; ctrl + shift + E4. 光标位置跳到行尾 &#x2F;&#x2F; ctrl + E5. 选择附近一段内容 &#x2F;&#x2F; ctrl + shift + right</code></pre><h2 id="扩展链接（非参考链接）"><a href="#扩展链接（非参考链接）" class="headerlink" title="扩展链接（非参考链接）"></a>扩展链接（非参考链接）</h2><p><a href="https://www.w3cschool.cn/vscode/vscode-file-jump.html" target="_blank" >见</a><br><a href="https://wenku.baidu.com/view/ccdc1ac6132de2bd960590c69ec3d5bbfc0ada45.html" target="_blank" >见</a></p><h2 id="待研究"><a href="#待研究" class="headerlink" title="待研究"></a>待研究</h2><p><a href="https://segmentfault.com/a/1190000008079848" target="_blank" >见</a></p>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 源码</title>
      <link href="//post/2022-09-16hexo%E6%BA%90%E7%A0%81.html"/>
      <url>//post/2022-09-16hexo%E6%BA%90%E7%A0%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><img src="http://t-blog-images.aijs.top/img/202209160918655.webp" /><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#  tree -L 2 -I .pnpm.├── hexo -&gt; .pnpm&#x2F;hexo@6.2.0&#x2F;node_modules&#x2F;hexo├── hexo-browsersync -&gt; .pnpm&#x2F;hexo-browsersync@0.3.0&#x2F;node_modules&#x2F;hexo-browsersync├── hexo-deployer-git -&gt; .pnpm&#x2F;hexo-deployer-git@3.0.0&#x2F;node_modules&#x2F;hexo-deployer-git├── hexo-generator-archive -&gt; .pnpm&#x2F;hexo-generator-archive@1.0.0&#x2F;node_modules&#x2F;hexo-generator-archive├── hexo-generator-category -&gt; .pnpm&#x2F;hexo-generator-category@1.0.0&#x2F;node_modules&#x2F;hexo-generator-category├── hexo-generator-index -&gt; .pnpm&#x2F;hexo-generator-index@2.0.0&#x2F;node_modules&#x2F;hexo-generator-index├── hexo-generator-search -&gt; .pnpm&#x2F;hexo-generator-search@2.4.3&#x2F;node_modules&#x2F;hexo-generator-search├── hexo-generator-tag -&gt; .pnpm&#x2F;hexo-generator-tag@1.0.0&#x2F;node_modules&#x2F;hexo-generator-tag├── hexo-renderer-ejs -&gt; .pnpm&#x2F;hexo-renderer-ejs@2.0.0&#x2F;node_modules&#x2F;hexo-renderer-ejs├── hexo-renderer-marked -&gt; .pnpm&#x2F;hexo-renderer-marked@5.0.0&#x2F;node_modules&#x2F;hexo-renderer-marked├── hexo-renderer-stylus -&gt; .pnpm&#x2F;hexo-renderer-stylus@2.1.0&#x2F;node_modules&#x2F;hexo-renderer-stylus├── hexo-server -&gt; .pnpm&#x2F;hexo-server@3.0.0&#x2F;node_modules&#x2F;hexo-server├── hexo-theme-aurora -&gt; .pnpm&#x2F;hexo-theme-aurora@1.5.5&#x2F;node_modules&#x2F;hexo-theme-aurora├── hexo-theme-landscape -&gt; .pnpm&#x2F;hexo-theme-landscape@0.0.3&#x2F;node_modules&#x2F;hexo-theme-landscape└── patch-package -&gt; .pnpm&#x2F;patch-package@6.4.7&#x2F;node_modules&#x2F;patch-package</code></pre><img src="http://t-blog-images.aijs.top/img/202209160915807.webp" />]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbortController 取消请求</title>
      <link href="//post/2022-09-14cancel.html"/>
      <url>//post/2022-09-14cancel.html</url>
      
        <content type="html"><![CDATA[<h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><p>在网上胡乱翻翻，无意中又翻到 MDN 看到了</p><h2 id="AbortController"><a href="#AbortController" class="headerlink" title="AbortController"></a>AbortController</h2><p>AbortController 接口表示一个控制器对象，允许你根据需要中止一个或多个 Web 请求。</p><p><strong>构造函数</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">AbortController.AbortController();&#x2F;&#x2F; 创建一个新的 AbortController 对象实例。</code></pre><p><strong>属性</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">AbortController.signal; &#x2F;&#x2F; 只读&#x2F;&#x2F; 返回一个 AbortSignal 对象实例，它可以用来 with&#x2F;abort 一个 Web（网络）请求。</code></pre><p><strong>方法</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">AbortController.abort();&#x2F;&#x2F; 中止一个尚未完成的 Web（网络）请求。这能够中止 fetch 请求及任何响应体的消费和流。</code></pre><p>对于取消请求，我之前理解的优点偏差，我之前理解的是：promise 提前返回就把请求取消掉了，类似 race,然而并非如此</p><img src="http://t-blog-images.aijs.top/img/202209142113959.png" /><p>当一个 fetch request 初始化，我们把 AbortSignal 作为一个选项传递到到请求对象（如下 { signal }）。这将 signal 和 controller 与这个 fetch request 相关联，然后允许我们通过调用 AbortController.abort() 中止请求，如下第二个事件监听函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let controller;const url &#x3D; &quot;video.mp4&quot;;const downloadBtn &#x3D; document.querySelector(&quot;.download&quot;);const abortBtn &#x3D; document.querySelector(&quot;.abort&quot;);downloadBtn.addEventListener(&quot;click&quot;, fetchVideo);abortBtn.addEventListener(&quot;click&quot;, () &#x3D;&gt; &#123;  if (controller) &#123;    controller.abort();    console.log(&quot;中止下载&quot;);  &#125;&#125;);function fetchVideo() &#123;  controller &#x3D; new AbortController();  const signal &#x3D; controller.signal;  fetch(url, &#123; signal &#125;)    .then((response) &#x3D;&gt; &#123;      console.log(&quot;下载完成&quot;, response);    &#125;)    .catch((err) &#x3D;&gt; &#123;      console.error(&#96;下载错误：$&#123;err.message&#125;&#96;);    &#125;);&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>备注： 当 abort() 被调用时，这个 fetch() promise 将 reject 一个名为 AbortError 的 DOMException。</p></div><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><img src="http://t-blog-images.aijs.top/img/202209142107002.png" /><img src="http://t-blog-images.aijs.top/img/202209142106275.png" /><p><a href="https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/adapters/xhr.js#L217" target="_blank" >axios adapters xhr</a></p><img src="http://t-blog-images.aijs.top/img/202209142118467.png" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController" target="_blank" >AbortController</a></p><p><a href="https://axios-http.com/zh/docs/cancellation" target="_blank" >axios-http.com</a></p><p><a href="https://github.com/axios/axios#abortcontroller" target="_blank" >github axios</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webview应用</title>
      <link href="//post/2022-09-13webview.html"/>
      <url>//post/2022-09-13webview.html</url>
      
        <content type="html"><![CDATA[<h2 id="h5-webview"><a href="#h5-webview" class="headerlink" title="h5 webview"></a>h5 webview</h2><p>应用很广啊，平时还真没感觉到是 h5 页面渲染的内容，报错了才知道</p><h2 id="支付宝会员"><a href="#支付宝会员" class="headerlink" title="支付宝会员"></a>支付宝会员</h2><img src="http://t-blog-images.aijs.top/img/202209132212194.png" style="width: 300px; max-width: 100%" /><h2 id="B-站-直播"><a href="#B-站-直播" class="headerlink" title="B 站 直播"></a>B 站 直播</h2><img src="http://t-blog-images.aijs.top/img/202209132212876.png" style="width: 300px; max-width: 100%"/><h2 id="掘金文章详情"><a href="#掘金文章详情" class="headerlink" title="掘金文章详情"></a>掘金文章详情</h2><img src="http://t-blog-images.aijs.top/img/202209132212267.png" style="width: 300px; max-width: 100%"/>]]></content>
      
      
      <categories>
          
          <category> h5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> h5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-i18next 实战</title>
      <link href="//post/2022-09-11react-i18next.html"/>
      <url>//post/2022-09-11react-i18next.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于常量的数据，当 i18n 语言改变时候，顶部菜单，和侧边栏菜单没有发生改变</p><p>有问题代码</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; 仅仅是为了使用 useTranslation 而进行组件封装import React from &quot;react&quot;;import &#123; useTranslation &#125; from &quot;react-i18next&quot;;interface IProps &#123;  children: string;&#125;const Trans: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const &#123; t &#125; &#x3D; useTranslation();  return t(props.children);&#125;;export default Trans;</code></pre><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; 语言变化，不可有效更新例子&#x2F;&#x2F; Trans 为了翻译写的react组件export const topRoutes: MenuConfig[] &#x3D; [  &#123;    name: &lt;Trans&gt;tconfig&lt;&#x2F;Trans&gt;,    path: &quot;&#x2F;tconfig&quot;,    redirect: &quot;&#x2F;tconfig&#x2F;products&quot;,    routes: [      &#123;        name: &lt;Trans&gt;products&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tconfig&#x2F;products&quot;,        component: &lt;TargetConfProducts &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,      &#123;        name: &lt;Trans&gt;devices&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tconfig&#x2F;devices&quot;,        component: &lt;TargetConfDevices &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,      &#123;        name: &lt;Trans&gt;category&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tconfig&#x2F;category&quot;,        component: &lt;TargetConfCategory &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,    ],  &#125;,  &#123;    name: &lt;Trans&gt;mconfig&lt;&#x2F;Trans&gt;,    path: &quot;&#x2F;mconfig&quot;,    redirect: &quot;&#x2F;mconfig&#x2F;list&quot;,    routes: [      &#123;        name: &lt;Trans&gt;config&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;mconfig&#x2F;list&quot;,        component: &lt;ModConfPage &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,    ],  &#125;,  &#123;    name: &lt;Trans&gt;tmonitor&lt;&#x2F;Trans&gt;,    path: &quot;&#x2F;tmonitor&quot;,    redirect: &quot;&#x2F;tmonitor&#x2F;overview&quot;,    routes: [      &#123;        name: &lt;Trans&gt;tmonitor-overview&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tmonitor&#x2F;overview&quot;,        component: &lt;MonitorOverview &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,      &#123;        name: &lt;Trans&gt;tmonitor-product&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tmonitor&#x2F;product&quot;,        component: &lt;MonitorProduct &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,      &#123;        name: &lt;Trans&gt;tmonitor-device&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tmonitor&#x2F;device&quot;,        component: &lt;MonitorDevice &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,      &#123;        name: &lt;Trans&gt;tmonitor-cere&lt;&#x2F;Trans&gt;,        path: &quot;&#x2F;tmonitor&#x2F;cere&quot;,        component: &lt;MonitorCere &#x2F;&gt;,        icon: &lt;LoginOutlined &#x2F;&gt;,      &#125;,    ],  &#125;,];</code></pre><img src="http://t-blog-images.aijs.top/img/202209111755182.gif" /><img src="http://t-blog-images.aijs.top/img/202209111756612.gif" /><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p><strong>原因分析</strong>：数据并没有重新计算 topRoutes 数据仍然是旧的数据</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>方案</strong></p><p>刷新浏览器的方案不考虑，用户体验极差，以下仅考虑不刷新方案</p><p><strong>方案 1：</strong> 强制渲染（顶层 <code>key</code> 方案，这个方案利用 <code>react diff</code> 首先比较 key，key 不同不复用的规则），缺点：1. 部分页面可能会触发重新请求， 2. Trans 组件有割裂感 3. 有性能损耗</p><p><strong>方案 2：</strong> <code>i18n.language</code> 变化时候进行重新计算（<code>useMemo/useCallback</code>），缺点: 1. 比较分散,难以维护， 2. Trans 组件有割裂感</p><p><strong>方案 3：</strong> 将 t 传入，不使用组件，利用函数，计算返回的是一个新的数组的特点， 并且直接用 <code>t(&quot;tconfig&quot;)</code>形式, 优点： 直观，没有割裂感</p><p>需要随语言变化的数据，可以不使用常量的数据， 换成函数</p><h2 id="方案-3"><a href="#方案-3" class="headerlink" title="方案 3"></a>方案 3</h2><p>修改后</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">export const topRoutesFun &#x3D; (t: Function) &#x3D;&gt; &#123;  return [    &#123;      name: t(&quot;tconfig&quot;),      path: &quot;&#x2F;tconfig&quot;,      redirect: &quot;&#x2F;tconfig&#x2F;products&quot;,      routes: [        &#123;          name: t(&quot;products&quot;),          path: &quot;&#x2F;tconfig&#x2F;products&quot;,          component: &lt;TargetConfProducts &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,        &#123;          name: t(&quot;devices&quot;),          path: &quot;&#x2F;tconfig&#x2F;devices&quot;,          component: &lt;TargetConfDevices &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,        &#123;          name: t(&quot;category&quot;),          path: &quot;&#x2F;tconfig&#x2F;category&quot;,          component: &lt;TargetConfCategory &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,      ],    &#125;,    &#123;      name: t(&quot;mconfig&quot;),      path: &quot;&#x2F;mconfig&quot;,      redirect: &quot;&#x2F;mconfig&#x2F;list&quot;,      routes: [        &#123;          name: t(&quot;config&quot;),          path: &quot;&#x2F;mconfig&#x2F;list&quot;,          component: &lt;ModConfPage &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,      ],    &#125;,    &#123;      name: t(&quot;tmonitor&quot;),      path: &quot;&#x2F;tmonitor&quot;,      redirect: &quot;&#x2F;tmonitor&#x2F;overview&quot;,      routes: [        &#123;          name: t(&quot;tmonitor-overview&quot;),          path: &quot;&#x2F;tmonitor&#x2F;overview&quot;,          component: &lt;MonitorOverview &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,        &#123;          name: t(&quot;tmonitor-product&quot;),          path: &quot;&#x2F;tmonitor&#x2F;product&quot;,          component: &lt;MonitorProduct &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,        &#123;          name: t(&quot;tmonitor-device&quot;),          path: &quot;&#x2F;tmonitor&#x2F;device&quot;,          component: &lt;MonitorDevice &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,        &#123;          name: t(&quot;tmonitor-cere&quot;),          path: &quot;&#x2F;tmonitor&#x2F;cere&quot;,          component: &lt;MonitorCere &#x2F;&gt;,          icon: &lt;LoginOutlined &#x2F;&gt;,        &#125;,      ],    &#125;,  ];&#125;;</code></pre><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><img src="http://t-blog-images.aijs.top/img/202209112002362.gif" /><h2 id="生活～"><a href="#生活～" class="headerlink" title="生活～"></a>生活～</h2><p>去刷鲍鱼，还有六只，好像死翘翘了</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vite react antd</title>
      <link href="//post/2022-09-07vite-react.html"/>
      <url>//post/2022-09-07vite-react.html</url>
      
        <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p><strong>方案 1: nextjs + sun (antd)</strong></p><p>之前部门用的公司（前端基建二次封装）的这套组合，被现在的部门嫌弃</p><p><strong>方案 2: @umijs&#x2F;max</strong></p><p>试用了 umijs&#x2F;max MFSU, 在开发更新体验上还是觉得慢</p><p><strong>方案 3: vite + react + antd + ahooks + axios + antv + canvas(svg) + ts + i18next</strong></p><ul><li>react 读 hook 部分源码</li><li>ahooks 读过源码</li><li>axios 读过源码</li><li>canvas(svg) 部分可视化定制要求高，antv 无法实现</li><li>i18next 对外系统需要多语言，没有使用公司多语言平台的原因，项目不大，没必要，更何况，当前部门希望创新</li></ul><p>最终选择了这套方案</p><p>没用 redux 原因：全局使用 context，局部使用 hooks 组合的方式</p><h3 id="ts-全局声明配置"><a href="#ts-全局声明配置" class="headerlink" title="ts 全局声明配置"></a>ts 全局声明配置</h3><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ESNext&quot;,    &quot;useDefineForClassFields&quot;: true,    &quot;lib&quot;: [&quot;DOM&quot;, &quot;DOM.Iterable&quot;, &quot;ESNext&quot;],    &quot;allowJs&quot;: false,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: false,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;strict&quot;: true,    &quot;forceConsistentCasingInFileNames&quot;: true,    &quot;module&quot;: &quot;ESNext&quot;,    &quot;moduleResolution&quot;: &quot;Node&quot;,    &quot;resolveJsonModule&quot;: true,    &quot;isolatedModules&quot;: true,    &quot;noEmit&quot;: true,    &quot;jsx&quot;: &quot;react-jsx&quot;,    &quot;paths&quot;: &#123;      &quot;@&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;*&quot;],      &quot;@&#x2F;components&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;components&#x2F;*&quot;]    &#125;  &#125;,  &quot;include&quot;: [&quot;src&quot;],  &quot;references&quot;: [&#123; &quot;path&quot;: &quot;.&#x2F;tsconfig.node.json&quot; &#125;]&#125;</code></pre><p>配置完成仍然提示</p><pre class="line-numbers language-none"><code class="language-none">Cannot find module &#39;@&#x2F;components&#x2F;test&#39; or its corresponding type declarations.</code></pre><p>解决： vscode 重新启动</p><p><a href="https://blog.csdn.net/q95548854/article/details/121899607" target="_blank" >终极解决 TS 或者 Vetur 报错，Cannot find module ‘@&#x2F;xx&#x2F;xxx‘，找不到*.vue 等编译问题</a></p><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><img src="http://t-blog-images.aijs.top/img/202209071639635.webp" /><img src="http://t-blog-images.aijs.top/img/202209071640618.webp" /><p><strong>见完整配置</strong></p><ul><li>移除日志</li><li>移除 debuger</li><li>集成 lodash 测试下打包优化</li><li>antd 按需加载</li><li>antd 定制主题</li><li>请求工具封装</li></ul><h3 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">open .&#x2F;stats.html -a Google\ Chrome</code></pre><img src="http://t-blog-images.aijs.top/img/202209081109070.webp" /><p>考虑到项目中仅用到图表</p><p>所以将 <code>@ant-design/charts</code> 替换为 <code>@ant-design/plots</code> 子包试用</p><p>包大小降低了一丢丢，感觉不对</p><h3 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h3><p>这是一个问题，之前我看有同事，用 vite 开发，用 webpack 打包部署</p><p>打包问题，最终变成<code>vite 产物</code> <code>dist</code> 部署问题。</p><p>我也尝试了多次使用 next 部署方案，进行部署，由于不晓得运维内部是如何写 dockerfile 的，所以是各种报错</p><img src="http://t-blog-images.aijs.top/img/202209131956944.png" /><img src="http://t-blog-images.aijs.top/img/202209131955989.png" /><p>Dockerfile</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM nginx:1.15.0ADD .docker&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.confADD .docker &#x2F;COPY  .&#x2F;dist &#x2F;www&#x2F;RUN chmod -R 755 &#x2F;wwwCMD [ &quot;sh&quot;, &quot;&#x2F;start.sh&quot; ]</code></pre><p><strong>start.sh</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 注入环境变量sed -i &quot;s&#x2F;\(&lt;head&gt;\)&#x2F;\1&lt;script&gt;window.ENV&#x3D;&#39;$TYA_ENV&#39;;window.REGION&#x3D;&#39;$TYA_REGION&#39;&lt;\&#x2F;script&gt;&#x2F;&quot; &quot;&#x2F;www&#x2F;index.html&quot;nginx -g &quot;daemon off;&quot;</code></pre><p><strong>nginx</strong></p><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">server &#123;    listen       80;    server_name  localhost;    location &#x3D;&#x2F;health &#123;        return 200 ok;    &#125;    # 这个路径是业务方自己要加的，在上传组件的时候，他们希望直接使用脚本上传组件，通过这个接口获取 token数据    location &#x2F;_&#x2F;token &#123;         add_header Content-Type &#39;text&#x2F;html&#39;;         add_header Cache-Control &#39;no-store&#39;; &#x2F;&#x2F; 缓存         return 200 $cookie_SSO_USER_TOKEN;    &#125;    location &#x2F; &#123;        add_header Cache-Control &#39;no-store&#39;; &#x2F;&#x2F; 缓存        if_modified_since off; &#x2F;&#x2F; 缓存        etag off; &#x2F;&#x2F; 缓存        expires -1; &#x2F;&#x2F; 缓存        root &#x2F;www&#x2F;;        index          index.html;        try_files $uri &#x2F;index.html;    &#125;    gzip on;    gzip_min_length 1k;    gzip_buffers 4 16k;    gzip_comp_level 2;    gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png;    gzip_vary off;    gzip_disable &quot;MSIE [1-6]\.&quot;;    error_page   500 502 503 504  &#x2F;50x.html;&#125;</code></pre><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><img src="http://t-blog-images.aijs.top/img/202209091405085.webp" /><h2 id="打包预览-404"><a href="#打包预览-404" class="headerlink" title="打包预览 404"></a>打包预览 404</h2><p>预览默认启动 index.html,肯定没有这个 react-router-dom 的路径 ，会走到 404</p><p>修改 index.html 代码</p><details class="custom-details"><summary>index.html</summary><p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;meta name&#x3D;&quot;Keywords&quot; content&#x3D;&quot;项目&quot; &#x2F;&gt;    &lt;meta name&#x3D;&quot;Description&quot; content&#x3D;&quot;项目&quot; &#x2F;&gt;    &lt;!-- &lt;link rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;svg+xml&quot; href&#x3D;&quot;&#x2F;vite.svg&quot; &#x2F;&gt; --&gt;    &lt;link      rel&#x3D;&quot;shortcut icon&quot;      href&#x3D;&quot;https:&#x2F;&#x2F;images.com&#x2F;rms-static&#x2F;4d08a150-2f4a-11ed-acd5-2f6ea556a3fd-1662623168485.ico&quot;      type&#x3D;&quot;image&#x2F;x-icon&quot;    &#x2F;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;    &lt;title&gt;碳项目&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.tsx&quot;&gt;&lt;&#x2F;script&gt;    &lt;!-- fix代码，将&#x2F;index.html 改为 &#x2F; --&gt;    &lt;script&gt;      if (window.location.pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;index.html&quot;) &#123;        window.location.pathname &#x3D; &quot;&#x2F;&quot;;      &#125;    &lt;&#x2F;script&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></p></details><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><details class="custom-details"><summary>tree -L 2 -I node_modules</summary><p><pre class="line-numbers language-none"><code class="language-none">.├── dist│   ├── index.html│   ├── static│   └── vite.svg├── index.html├── package.json├── pnpm-lock.yaml├── public│   └── vite.svg├── src│   ├── @types &#x2F;&#x2F; ts全局类型│   ├── App.css│   ├── App.tsx &#x2F;&#x2F; 入口│   ├── assets &#x2F;&#x2F; 资源│   ├── components &#x2F;&#x2F; 组件│   ├── consts &#x2F;&#x2F; 常量│   ├── context &#x2F;&#x2F; react context│   ├── hooks &#x2F;&#x2F; react hooks│   ├── i18n &#x2F;&#x2F; 多语言 i18n│   ├── index.css│   ├── layout &#x2F;&#x2F; 布局│   ├── main.tsx│   ├── pages &#x2F;&#x2F; 页面│   ├── router &#x2F;&#x2F; 路由│   ├── services &#x2F;&#x2F; 接口│   ├── temp &#x2F;&#x2F; 临时测试│   ├── utils &#x2F;&#x2F; 工具函数│   └── vite-env.d.ts├── stats.html &#x2F;&#x2F; 打包分析产物├── tsconfig.json &#x2F;&#x2F; ts 配置├── tsconfig.node.json└── vite.config.ts &#x2F;&#x2F; vite 配置17 directories, 15 files</code></pre></p></details><details class="custom-details"><summary>tree -L 2 src</summary><p><pre class="line-numbers language-none"><code class="language-none">src├── @types│   ├── index.d.ts│   └── react-i18next├── App.css├── App.tsx├── assets│   ├── favicon.ico│   └── react.svg├── components│   ├── auth│   ├── bar.tsx│   ├── condition│   ├── error│   ├── iconfont│   ├── loading│   ├── login│   ├── pageContainer│   ├── test.module.less│   ├── test.tsx│   └── trans├── consts├── context│   └── global-context.ts├── hooks├── i18n│   ├── config.ts│   ├── en│   └── zh├── index.css├── layout│   ├── base-layout│   └── bread├── main.tsx├── pages│   ├── home│   ├── mod-conf│   ├── switchlogin│   ├── target-conf│   └── target-monitor├── router│   ├── index.tsx│   └── routerGuard.tsx├── services├── temp│   └── App\ copy.tsx├── utils│   └── request.ts└── vite-env.d.ts31 directories, 17 files</code></pre></p></details><h2 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h2><details class="custom-details"><summary>package.json</summary><p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;smart-carbon&quot;,  &quot;private&quot;: true,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;,    &quot;build&quot;: &quot;tsc &amp;&amp; vite build&quot;,    &quot;preview&quot;: &quot;vite preview&quot; &#x2F;&#x2F; 注意避坑 404  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@ant-design&#x2F;icons&quot;: &quot;^4.7.0&quot;,    &quot;@ant-design&#x2F;plots&quot;: &quot;^1.2.2&quot;, &#x2F;&#x2F; @ant-design&#x2F;charts的一个子包，还是有点大； 之后可以学习下svg、canvas绘图，这样打出的内容非常小    &quot;ahooks&quot;: &quot;^3.7.0&quot;,    &quot;antd&quot;: &quot;^4.23.0&quot;,    &quot;axios&quot;: &quot;^0.27.2&quot;,    &quot;classnames&quot;: &quot;^2.3.1&quot;,    &quot;i18next&quot;: &quot;^21.9.1&quot;,    &quot;lodash&quot;: &quot;^4.17.21&quot;, &#x2F;&#x2F; 这个依赖完全是为了测试vite lodash 打成bundle    &quot;moment&quot;: &quot;^2.29.4&quot;,    &quot;react&quot;: &quot;^18.2.0&quot;,    &quot;react-dom&quot;: &quot;^18.2.0&quot;,    &quot;react-i18next&quot;: &quot;^11.18.6&quot;,    &quot;react-router-dom&quot;: &quot;^6.3.0&quot;,    &quot;rollup-plugin-external-globals&quot;: &quot;^0.6.1&quot;,    &quot;vite-plugin-imp&quot;: &quot;^2.3.0&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@types&#x2F;lodash&quot;: &quot;^4.14.184&quot;,    &quot;@types&#x2F;node&quot;: &quot;^18.7.15&quot;,    &quot;@types&#x2F;react&quot;: &quot;^18.0.17&quot;,    &quot;@types&#x2F;react-dom&quot;: &quot;^18.0.6&quot;,    &quot;@vitejs&#x2F;plugin-react&quot;: &quot;^2.1.0&quot;,    &quot;less&quot;: &quot;^4.1.3&quot;,    &quot;rollup&quot;: &quot;^2.79.0&quot;,    &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot;,    &quot;rollup-plugin-visualizer&quot;: &quot;^5.8.1&quot;,    &quot;typescript&quot;: &quot;^4.6.4&quot;,    &quot;vite&quot;: &quot;^3.1.0&quot;,    &quot;vite-plugin-compression&quot;: &quot;^0.5.1&quot;  &#125;&#125;</code></pre></p></details><details class="custom-details"><summary>vite.config.ts</summary><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; vite.config.tsimport &#123; defineConfig &#125; from &quot;vite&quot;;import react from &quot;@vitejs&#x2F;plugin-react&quot;;&#x2F;&#x2F;@ts-ignoreimport path from &quot;path&quot;;import vitePluginImp from &quot;vite-plugin-imp&quot;;import externalGlobals from &quot;rollup-plugin-external-globals&quot;;import viteCompression from &quot;vite-plugin-compression&quot;;import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;import &#123; visualizer &#125; from &quot;rollup-plugin-visualizer&quot;;const __dirname &#x3D; path.resolve();&#x2F;&#x2F; 一些需要单独打成bundle的文件const chunk1 &#x3D; [&quot;react&quot;, &quot;react-router-dom&quot;, &quot;react-dom&quot;];const chunk2 &#x3D; [&quot;moment&quot;, &quot;@ant-design&#x2F;icons&quot;, &quot;ahooks&quot;];const chunk3 &#x3D; [&quot;lodash&quot;];const chunk4 &#x3D; [&quot;axios&quot;];const antdChunk &#x3D; [&quot;antd&quot;];const plotsChunk &#x3D; [&quot;@ant-design&#x2F;plots&quot;];const build &#x3D; &#123;  rollupOptions: &#123;    output: &#123;      &#x2F;&#x2F; 文件指纹      chunkFileNames: &quot;static&#x2F;js&#x2F;[name].[hash].js&quot;,      entryFileNames: &quot;static&#x2F;js&#x2F;[name].[hash].js&quot;,      &#x2F;&#x2F; 分类输出      assetFileNames: &quot;static&#x2F;[ext]&#x2F;[name].[hash].[ext]&quot;,      &#x2F;&#x2F; 手动chunk      manualChunks: &#123;        vendor: chunk1,        vendor2: chunk2,        vendor3: chunk3,        vendor4: chunk4,        plots: plotsChunk,        antd: antdChunk,      &#125;,    &#125;,  &#125;,  chunkSizeWarningLimit: 1024,&#125;;const server &#x3D; &#123;  port: 3006,  open: &quot;&#x2F;index.html&quot;,  proxy: &#123;    &quot;&#x2F;api&quot;: &#123;      target: &quot;http:&#x2F;&#x2F;localhost:3032&quot;,      changeOrigin: true,      &#x2F;&#x2F; rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^\&#x2F;api&#x2F;, &#39;&#39;)    &#125;,  &#125;,&#125;;const plugins &#x3D; [  react(),  vitePluginImp(&#123;    libList: [      &#x2F;&#x2F; antd 按需引入      &#123;        libName: &quot;antd&quot;,        style: (name) &#x3D;&gt; &#96;antd&#x2F;es&#x2F;$&#123;name&#125;&#x2F;style&#96;,      &#125;,    ],  &#125;),  externalGlobals(&#123;    &#x2F;&#x2F; &quot;@ant-design&#x2F;charts&quot;: &quot;window.charts&quot;  &#125;),  &#x2F;&#x2F; vite打包优化 - 压缩  viteCompression(&#123;    verbose: true,    disable: false,    threshold: 10240,    algorithm: &quot;gzip&quot;,    ext: &quot;.gz&quot;,  &#125;),  &#x2F;&#x2F; vite 打包优化 - 移除 日志&#x2F;debugger  terser(&#123;    compress: &#123;      defaults: false,      &#x2F;&#x2F; drop_console: true,    &#125;,    mangle: &#123;      eval: true,      module: true,      toplevel: true,      safari10: true,      properties: false,    &#125;,    &#x2F;&#x2F; 不输出注释    output: &#123;      comments: false,    &#125;,  &#125;),  &#x2F;&#x2F; vite 打包分析  visualizer(),];&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;export default defineConfig(&#123;  plugins,  css: &#123;    &#x2F;&#x2F; 配置antd主题    preprocessorOptions: &#123;      less: &#123;        javascriptEnabled: true,        modifyVars: &#123;          &#x2F;&#x2F; 在这里自定义主题色等样式          &quot;@primary-color&quot;: &quot;#646cff&quot;, &#x2F;&#x2F;设置antd主题色        &#125;,      &#125;,    &#125;,    &#x2F;&#x2F; 模块化样式，启用小驼峰    modules: &#123;      localsConvention: &quot;camelCase&quot;,    &#125;,  &#125;,  &#x2F;&#x2F; 路径别名，简化长路径引入，看着不舒服  resolve: &#123;    alias: &#123;      &quot;~&quot;: path.resolve(__dirname, &quot;.&#x2F;&quot;), &#x2F;&#x2F; 根路径      &quot;@&quot;: path.resolve(__dirname, &quot;src&quot;), &#x2F;&#x2F; src 路径    &#125;,  &#125;,  server,  build,&#125;);</code></pre></p></details><details class="custom-details"><summary>ts 全局声明配置</summary><p>优点：必要的全局声明，可以极大减少 typescipt 类型的引入</p><p>&#x2F;src&#x2F;@types</p><pre class="line-numbers language-none"><code class="language-none">.├── index.d.ts└── react-i18next    └── index.d.ts1 directory, 2 files</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; react-i18next&#x2F;&#x2F;     └── index.d.tsimport &quot;react-i18next&quot;;import &#123; resources &#125; from &quot;..&#x2F;..&#x2F;src&#x2F;i18n&#x2F;config&quot;;declare module &quot;react-i18next&quot; &#123;  type DefaultResources &#x3D; typeof resources[&quot;en&quot;];  interface Resources extends DefaultResources &#123;&#125;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; index.d.tsdeclare interface MenuConfig &#123;  name: string | React.ReactNode;  icon?: React.ReactNode;  path?: string;  asPath?: string;  pattern?: RegExp;  isMenu?: boolean;  hidden?: boolean;  routes?: MenuConfig[];  onClick?: () &#x3D;&gt; void;  layout?: React.ReactNode;  component?: React.ReactNode;  icon?: React.ReactNode;  isShow?: boolean;  pageName?: string;  redirect?: string;&#125;declare interface IResultData&lt;T&gt; &#123;  code: string; &#x2F;&#x2F; 响应码  result?: T; &#x2F;&#x2F; 数据  data?: T;  success: boolean; &#x2F;&#x2F; 是否成功(true：成功，false：失败)  msg?: string; &#x2F;&#x2F; 错误信息(请求成功时无该字段)  errorMsg?: string;  message?: string;&#125;</code></pre></details><h2 id="i18n-ally-插件"><a href="#i18n-ally-插件" class="headerlink" title="i18n-ally 插件"></a>i18n-ally 插件</h2><p>插件之前安装好的，大概在几个月前，使用还是正常的，经历过几次 vscode 升级，嗝屁了</p><p>试着重新安装了几次，确定不行，断定是配置出的问题，可视化配置，直接搜 <code>i18n</code></p><img src="http://t-blog-images.aijs.top/img/202209131951465.png" /><p>以下为<code>setting.json</code>统一配置（不在每个项目中建立啥的配置文件，麻烦）， 直接在<code>setting.json</code>中配置如下</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;i18n-ally.extract.autoDetect&quot;: true,&quot;i18n-ally.extract.keyMaxLength&quot;: 1,&quot;i18n-ally.theme.annotation&quot;: &quot;rgba(153, 153, 153, .8)&quot;,&quot;i18n-ally.theme.annotationBorder&quot;: &quot;rgba(153, 153, 153, .8)&quot;,&quot;i18n-ally.theme.annotationMissing&quot;: &quot;#d37070&quot;,&quot;i18n-ally.theme.annotationMissingBorder&quot;: &quot;#d37070&quot;,&quot;i18n-ally.extract.parsers.html&quot;: &#123;&#125;,&quot;i18n-ally.displayLanguage&quot;: &quot;zh&quot;,&quot;i18n-ally.enabledFrameworks&quot;: [  &quot;react&quot;,  &quot;vue&quot;],&quot;i18n-ally.extract.ignoredByFiles&quot;: &#123;&#125;</code></pre><h2 id="eslint-primtter"><a href="#eslint-primtter" class="headerlink" title="eslint + primtter"></a>eslint + primtter</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.38.0&quot;,&quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.0.1&quot;,&quot;eslint&quot;: &quot;^8.7.0&quot;,&quot;eslint-config-prettier&quot;: &quot;^8.5.0&quot;,&quot;eslint-plugin-import&quot;: &quot;^2.26.0&quot;,&quot;eslint-plugin-prettier&quot;: &quot;^4.2.1&quot;,&quot;eslint-plugin-react&quot;: &quot;^7.31.8&quot;,&quot;eslint-plugin-react-hooks&quot;: &quot;^4.6.0&quot;,&quot;eslint-plugin-simple-import-sort&quot;: &quot;^8.0.0&quot;,&quot;prettier&quot;: &quot;^2.5.1&quot;,</code></pre><img src="http://t-blog-images.aijs.top/img/202209232044597.png" /><h3 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a>.eslintignore</h3><h3 id="eslintrc-cjs"><a href="#eslintrc-cjs" class="headerlink" title=".eslintrc.cjs"></a>.eslintrc.cjs</h3><p>这个要注意下，<code>.eslintrc.js</code>会报错，vscode eslint 插件会有异常抛出，配的时候如果没有生效，可以查下原因</p><ul><li>vscode项目重启</li><li>vscode eslint插件报错</li><li>.eslintrc.cjs内容 有误</li></ul><h3 id="prettierignore"><a href="#prettierignore" class="headerlink" title=".prettierignore"></a>.prettierignore</h3><h3 id="prettierrc"><a href="#prettierrc" class="headerlink" title=".prettierrc"></a>.prettierrc</h3><p>这个找文档配配就行</p><h3 id="editor不用配置"><a href="#editor不用配置" class="headerlink" title=".editor不用配置"></a>.editor不用配置</h3><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><img src="http://t-blog-images.aijs.top/img/202209232048164.png" /><img src="http://t-blog-images.aijs.top/img/202209232048659.png" /><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><img src="http://t-blog-images.aijs.top/img/202209232054086.gif" /><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/841660202/vite-react-template" target="_blank" >github 私有仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nest 413</title>
      <link href="//post/2022-09-06nestjs.html"/>
      <url>//post/2022-09-06nestjs.html</url>
      
        <content type="html"><![CDATA[<h2 id="有问题的项目"><a href="#有问题的项目" class="headerlink" title="有问题的项目"></a>有问题的项目</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; NestFactory &#125; from &quot;@nestjs&#x2F;core&quot;;import &#123; NestExpressApplication &#125; from &quot;@nestjs&#x2F;platform-express&quot;;import &#123; AppModule &#125; from &quot;.&#x2F;app.module&quot;;import &#123; join &#125; from &quot;path&quot;;import &#123; rootDir &#125; from &quot;.&#x2F;utils&#x2F;path&quot;;import &#123; config &#125; from &quot;.&#x2F;config&quot;;import * as bodyParser from &quot;body-parser&quot;;async function bootstrap() &#123;  &#x2F;&#x2F; const app &#x3D; await NestFactory.create(AppModule);  const app &#x3D; await NestFactory.create&lt;NestExpressApplication&gt;(AppModule, &#123;    cors: true,  &#125;);  app.setGlobalPrefix(&quot;api&quot;);  app.useStaticAssets(join(rootDir, &quot;public&quot;), &#123;    prefix: config.static, &#x2F;&#x2F;设置虚拟路径  &#125;);  &#x2F;&#x2F; limit  app.use(bodyParser.urlencoded(&#123; extended: true, limit: &quot;8mb&quot; &#125;));  app.use(bodyParser.json(&#123; limit: &quot;8mb&quot; &#125;));  app.enableCors();  await app.listen(config.port);&#125;bootstrap();</code></pre><h2 id="新构建的项目-413"><a href="#新构建的项目-413" class="headerlink" title="新构建的项目 413"></a>新构建的项目 413</h2><p>在一个项目中试了 n 遍都报同样的错误</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; NestFactory &#125; from &quot;@nestjs&#x2F;core&quot;;import &#123; AppModule &#125; from &quot;.&#x2F;app.module&quot;;async function bootstrap() &#123;  const app &#x3D; await NestFactory.create(AppModule);  await app.listen(8000);&#125;bootstrap();&#x2F;&#x2F;</code></pre><img src="http://t-blog-images.aijs.top/img/202209062047875.png" /><h2 id="新构建的项目-200"><a href="#新构建的项目-200" class="headerlink" title="新构建的项目 200"></a>新构建的项目 200</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; it&#39;s okimport &#123; NestFactory &#125; from &quot;@nestjs&#x2F;core&quot;;import &#123; AppModule &#125; from &quot;.&#x2F;app.module&quot;;import * as bodyParser from &quot;body-parser&quot;;async function bootstrap() &#123;  const app &#x3D; await NestFactory.create(AppModule);  &#x2F;&#x2F; 配置limit  app.use(bodyParser.json(&#123; limit: &quot;50mb&quot; &#125;));  app.use(bodyParser.urlencoded(&#123; limit: &quot;50mb&quot;, extended: true &#125;));  await app.listen(8000);&#125;bootstrap();</code></pre><img src="http://t-blog-images.aijs.top/img/202209062043913.png" /><h2 id="新构建的项目-使用-NestExpressApplication"><a href="#新构建的项目-使用-NestExpressApplication" class="headerlink" title="新构建的项目 使用 NestExpressApplication"></a>新构建的项目 使用 NestExpressApplication</h2><p>配置如下，src 相关代码完全一致</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#123;  &quot;name&quot;: &quot;nest-413&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;author&quot;: &quot;&quot;,  &quot;private&quot;: true,  &quot;license&quot;: &quot;UNLICENSED&quot;,  &quot;scripts&quot;: &#123;    &quot;prebuild&quot;: &quot;rimraf dist&quot;,    &quot;build&quot;: &quot;nest build&quot;,    &quot;format&quot;: &quot;prettier --write \&quot;src&#x2F;**&#x2F;*.ts\&quot; \&quot;test&#x2F;**&#x2F;*.ts\&quot;&quot;,    &quot;start&quot;: &quot;nest start&quot;,    &quot;start:dev&quot;: &quot;nest start --watch&quot;,    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,    &quot;start:prod&quot;: &quot;node dist&#x2F;main&quot;,    &quot;lint&quot;: &quot;eslint \&quot;&#123;src,apps,libs,test&#125;&#x2F;**&#x2F;*.ts\&quot; --fix&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;test:watch&quot;: &quot;jest --watch&quot;,    &quot;test:cov&quot;: &quot;jest --coverage&quot;,    &quot;test:debug&quot;: &quot;node --inspect-brk -r tsconfig-paths&#x2F;register -r ts-node&#x2F;register node_modules&#x2F;.bin&#x2F;jest --runInBand&quot;,    &quot;test:e2e&quot;: &quot;jest --config .&#x2F;test&#x2F;jest-e2e.json&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@nestjs&#x2F;common&quot;: &quot;^9.0.0&quot;,    &quot;@nestjs&#x2F;core&quot;: &quot;^9.0.0&quot;,    &quot;@nestjs&#x2F;platform-express&quot;: &quot;^9.0.11&quot;,    &quot;@nestjs&#x2F;typeorm&quot;: &quot;^9.0.1&quot;,    &quot;body-parser&quot;: &quot;^1.20.0&quot;,    &quot;mysql2&quot;: &quot;^2.3.3&quot;,    &quot;reflect-metadata&quot;: &quot;^0.1.13&quot;,    &quot;request&quot;: &quot;^2.88.2&quot;,    &quot;rimraf&quot;: &quot;^3.0.2&quot;,    &quot;rxjs&quot;: &quot;^7.2.0&quot;,    &quot;typeorm&quot;: &quot;^0.3.9&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@nestjs&#x2F;cli&quot;: &quot;^9.0.0&quot;,    &quot;@nestjs&#x2F;schematics&quot;: &quot;^9.0.0&quot;,    &quot;@nestjs&#x2F;testing&quot;: &quot;^9.0.0&quot;,    &quot;@types&#x2F;express&quot;: &quot;^4.17.13&quot;,    &quot;@types&#x2F;jest&quot;: &quot;28.1.8&quot;,    &quot;@types&#x2F;node&quot;: &quot;^16.0.0&quot;,    &quot;@types&#x2F;supertest&quot;: &quot;^2.0.11&quot;,    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.0.0&quot;,    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.0.0&quot;,    &quot;eslint&quot;: &quot;^8.0.1&quot;,    &quot;eslint-config-prettier&quot;: &quot;^8.3.0&quot;,    &quot;eslint-plugin-prettier&quot;: &quot;^4.0.0&quot;,    &quot;jest&quot;: &quot;28.1.3&quot;,    &quot;prettier&quot;: &quot;^2.3.2&quot;,    &quot;source-map-support&quot;: &quot;^0.5.20&quot;,    &quot;supertest&quot;: &quot;^6.1.3&quot;,    &quot;ts-jest&quot;: &quot;28.0.8&quot;,    &quot;ts-loader&quot;: &quot;^9.2.3&quot;,    &quot;ts-node&quot;: &quot;^10.0.0&quot;,    &quot;tsconfig-paths&quot;: &quot;4.1.0&quot;,    &quot;typescript&quot;: &quot;^4.7.4&quot;  &#125;,  &quot;jest&quot;: &#123;    &quot;moduleFileExtensions&quot;: [      &quot;js&quot;,      &quot;json&quot;,      &quot;ts&quot;    ],    &quot;rootDir&quot;: &quot;src&quot;,    &quot;testRegex&quot;: &quot;.*\\.spec\\.ts$&quot;,    &quot;transform&quot;: &#123;      &quot;^.+\\.(t|j)s$&quot;: &quot;ts-jest&quot;    &#125;,    &quot;collectCoverageFrom&quot;: [      &quot;**&#x2F;*.(t|j)s&quot;    ],    &quot;coverageDirectory&quot;: &quot;..&#x2F;coverage&quot;,    &quot;testEnvironment&quot;: &quot;node&quot;  &#125;&#125;</code></pre><h2 id="有问题项目配置"><a href="#有问题项目配置" class="headerlink" title="有问题项目配置"></a>有问题项目配置</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#123;  &quot;name&quot;: &quot;mitm-cache&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;author&quot;: &quot;&quot;,  &quot;private&quot;: true,  &quot;license&quot;: &quot;UNLICENSED&quot;,  &quot;scripts&quot;: &#123;    &quot;prebuild&quot;: &quot;rimraf dist&quot;,    &quot;build&quot;: &quot;nest build&quot;,    &quot;format&quot;: &quot;prettier --write \&quot;src&#x2F;**&#x2F;*.ts\&quot; \&quot;test&#x2F;**&#x2F;*.ts\&quot;&quot;,    &quot;start&quot;: &quot;nest start&quot;,    &quot;start:dev&quot;: &quot;nest start --watch&quot;,    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,    &quot;start:prod&quot;: &quot;node dist&#x2F;main&quot;,    &quot;lint&quot;: &quot;eslint \&quot;&#123;src,apps,libs,test&#125;&#x2F;**&#x2F;*.ts\&quot; --fix&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;test:watch&quot;: &quot;jest --watch&quot;,    &quot;test:cov&quot;: &quot;jest --coverage&quot;,    &quot;test:debug&quot;: &quot;node --inspect-brk -r tsconfig-paths&#x2F;register -r ts-node&#x2F;register node_modules&#x2F;.bin&#x2F;jest --runInBand&quot;,    &quot;test:e2e&quot;: &quot;jest --config .&#x2F;test&#x2F;jest-e2e.json&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@nestjs&#x2F;common&quot;: &quot;^8.0.0&quot;,    &quot;@nestjs&#x2F;core&quot;: &quot;^8.0.0&quot;,    &quot;@nestjs&#x2F;platform-express&quot;: &quot;^8.4.7&quot;,    &quot;@nestjs&#x2F;typeorm&quot;: &quot;^8.1.4&quot;,    &quot;mysql2&quot;: &quot;^2.3.3&quot;,    &quot;reflect-metadata&quot;: &quot;^0.1.13&quot;,    &quot;request&quot;: &quot;^2.88.2&quot;,    &quot;rimraf&quot;: &quot;^3.0.2&quot;,    &quot;rxjs&quot;: &quot;^7.2.0&quot;,    &quot;typeorm&quot;: &quot;^0.3.6&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@nestjs&#x2F;cli&quot;: &quot;^8.0.0&quot;,    &quot;@nestjs&#x2F;schematics&quot;: &quot;^8.0.0&quot;,    &quot;@nestjs&#x2F;testing&quot;: &quot;^8.0.0&quot;,    &quot;@types&#x2F;express&quot;: &quot;^4.17.13&quot;,    &quot;@types&#x2F;jest&quot;: &quot;27.5.0&quot;,    &quot;@types&#x2F;node&quot;: &quot;^16.0.0&quot;,    &quot;@types&#x2F;supertest&quot;: &quot;^2.0.11&quot;,    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^5.0.0&quot;,    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^5.0.0&quot;,    &quot;eslint&quot;: &quot;^8.0.1&quot;,    &quot;eslint-config-prettier&quot;: &quot;^8.3.0&quot;,    &quot;eslint-plugin-prettier&quot;: &quot;^4.0.0&quot;,    &quot;jest&quot;: &quot;28.0.3&quot;,    &quot;prettier&quot;: &quot;^2.3.2&quot;,    &quot;source-map-support&quot;: &quot;^0.5.20&quot;,    &quot;supertest&quot;: &quot;^6.1.3&quot;,    &quot;ts-jest&quot;: &quot;28.0.1&quot;,    &quot;ts-loader&quot;: &quot;^9.2.3&quot;,    &quot;ts-node&quot;: &quot;^10.0.0&quot;,    &quot;tsconfig-paths&quot;: &quot;4.0.0&quot;,    &quot;typescript&quot;: &quot;^4.3.5&quot;  &#125;,  &quot;jest&quot;: &#123;    &quot;moduleFileExtensions&quot;: [      &quot;js&quot;,      &quot;json&quot;,      &quot;ts&quot;    ],    &quot;rootDir&quot;: &quot;src&quot;,    &quot;testRegex&quot;: &quot;.*\\.spec\\.ts$&quot;,    &quot;transform&quot;: &#123;      &quot;^.+\\.(t|j)s$&quot;: &quot;ts-jest&quot;    &#125;,    &quot;collectCoverageFrom&quot;: [      &quot;**&#x2F;*.(t|j)s&quot;    ],    &quot;coverageDirectory&quot;: &quot;..&#x2F;coverage&quot;,    &quot;testEnvironment&quot;: &quot;node&quot;  &#125;&#125;</code></pre><h2 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h2><p>在 src 代码一致的情况下，nest 相关版本使用最新的，可以断定 nest v8 有问题</p><h2 id="公司电脑验证"><a href="#公司电脑验证" class="headerlink" title="公司电脑验证"></a>公司电脑验证</h2><p>启动的端口一直是修改前的端口，执行 项目中 <code>yarn prebuild</code> 会清理 dist 目录，清理完成后重启可以了</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;scripts&quot;: &#123;    &quot;prebuild&quot;: &quot;rimraf dist&quot;, &#x2F;&#x2F; 这个    &quot;build&quot;: &quot;nest build&quot;,    &quot;format&quot;: &quot;prettier --write \&quot;src&#x2F;**&#x2F;*.ts\&quot; \&quot;test&#x2F;**&#x2F;*.ts\&quot;&quot;,    &quot;start&quot;: &quot;nest start&quot;,    &quot;start:dev&quot;: &quot;nest start --watch&quot;,    &quot;start:debug&quot;: &quot;nest start --debug --watch&quot;,    &quot;start:prod&quot;: &quot;node dist&#x2F;main&quot;,    &quot;lint&quot;: &quot;eslint \&quot;&#123;src,apps,libs,test&#125;&#x2F;**&#x2F;*.ts\&quot; --fix&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;test:watch&quot;: &quot;jest --watch&quot;,    &quot;test:cov&quot;: &quot;jest --coverage&quot;,    &quot;test:debug&quot;: &quot;node --inspect-brk -r tsconfig-paths&#x2F;register -r ts-node&#x2F;register node_modules&#x2F;.bin&#x2F;jest --runInBand&quot;,    &quot;test:e2e&quot;: &quot;jest --config .&#x2F;test&#x2F;jest-e2e.json&quot;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> nest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React useImperativeHandle</title>
      <link href="//post/2022-09-06useImperativeHandle.html"/>
      <url>//post/2022-09-06useImperativeHandle.html</url>
      
        <content type="html"><![CDATA[<h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>vscode 把 js 代码做做了 ts 校验</p><img src="http://t-blog-images.aijs.top/img/202209061141505.webp" /><p>问题处理</p><img src="http://t-blog-images.aijs.top/img/202209061143356.webp" /><h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>use Imperative Handle 使用命令句柄</p><p><code>useImperativeHandle(ref, createHandle, [deps])</code></p><p><code>useImperativeHandle </code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。</p><p>在大多数情况下，应当避免使用 <code>ref </code>这样的命令式代码。<code>useImperativeHandle </code> 应当与 <code>forwardRef</code> 一起使用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function FancyInput(props, ref) &#123;  const inputRef &#x3D; useRef();  useImperativeHandle(ref, () &#x3D;&gt; (&#123;    focus: () &#x3D;&gt; &#123;      inputRef.current.focus();    &#125;,  &#125;));  return &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;*...*&#x2F; &#x2F;&gt;;&#125;FancyInput &#x3D; forwardRef(FancyInput);</code></pre><p>在本例中，渲染  <code>&lt;FancyInput ref=&#123;inputRef&#125; /&gt;</code>  的父组件可以调用  <code>inputRef.current.focus()</code>。</p><h2 id="antd-form"><a href="#antd-form" class="headerlink" title="antd form"></a>antd form</h2><p>看下组件中是如何使用的</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; ...const [wrapForm] &#x3D; useForm(form);&#x2F;&#x2F; ...React.useImperativeHandle(ref, () &#x3D;&gt; wrapForm);</code></pre><h2 id="useImperativeHandle-源码"><a href="#useImperativeHandle-源码" class="headerlink" title="useImperativeHandle 源码"></a>useImperativeHandle 源码</h2><h2 id="Type-‘MutableRefObject-lt-IOrgStaffSelectRef-undefined-gt-’-is-not-assignable-to-type-‘Ref-undefined’"><a href="#Type-‘MutableRefObject-lt-IOrgStaffSelectRef-undefined-gt-’-is-not-assignable-to-type-‘Ref-undefined’" class="headerlink" title="Type ‘MutableRefObject&lt;IOrgStaffSelectRef | undefined&gt;’ is not assignable to type ‘Ref | undefined’."></a>Type ‘MutableRefObject&lt;IOrgStaffSelectRef | undefined&gt;’ is not assignable to type ‘Ref<IOrgStaffSelectRef> | undefined’.</h2><p><a href="https://atomizedobjects.com/blog/react/how-to-use-useref-with-typescript/#:~:text=However%20if%20you%20then%20change%20this%20to%20allow%20strings%20as%20well%20we%20no%20longer%20will%20get%20that%20error%3A" target="_blank" >How to use useRef with TypeScript</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/1b31b54ab7c0" target="_blank" >vscode 中对 JS 文件使用了 typeScript 检测</a></p><p><a href="https://github.com/yaofly2012/note/issues/219" target="_blank" >useImperativeHandle 笔记</a></p><p><a href="https://segmentfault.com/q/1010000023311358" target="_blank" >为什么 React 源码中有 new.js 和 old.js ？</a></p><p><a href="https://juejin.cn/post/6932763604492140557" target="_blank" >useEffect 和 useLayoutEffect 源码浅析</a></p><p><a href="https://segmentfault.com/a/1190000040758640" target="_blank" >最陌生的 hooks: useImperativeHandle</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode react-javascript-snippets源码</title>
      <link href="//post/2022-09-05vscode.html"/>
      <url>//post/2022-09-05vscode.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>要分享自己开发的代码片段工具 <a href="/#/post/2022-05-11vscode" target="_blank" ><code>vs-snippets</code></a>，正所谓：<code>没有对比，就没有伤害</code>,了解下别人是如何开发代码片段插件的思路，做个对比</p><p>不得不说，<code>react-javascript-snippets</code> 无论从源代码组织还是支持的代码片段来讲都非常优秀，对于大众化来讲非常 nice。 然而项目开发总有那么多定制化，作为一款代码片段插件来讲，私有定制化却并不是那么灵活</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>.json 文件不能增加注释</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;es7-react-js-snippets&quot;,  &quot;displayName&quot;: &quot;ES7+ React&#x2F;Redux&#x2F;React-Native snippets&quot;,  &quot;description&quot;: &quot;Extensions for React, React-Native and Redux in JS&#x2F;TS with ES7+ syntax. Customizable. Built-in integration with prettier.&quot;,  &quot;version&quot;: &quot;4.4.3&quot;,  &quot;publisher&quot;: &quot;dsznajder&quot;,  &quot;icon&quot;: &quot;images&#x2F;logo.png&quot;,  &quot;browser&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;,  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;,  &quot;keywords&quot;: [    &quot;snippets&quot;,    &quot;react&quot;,    &quot;redux&quot;,    &quot;react-native&quot;,    &quot;customizable&quot;,    &quot;javascript&quot;,    &quot;typescript&quot;,    &quot;prettier&quot;  ],  &quot;license&quot;: &quot;MIT&quot;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;dsznajder&#x2F;vscode-es7-javascript-react-snippets&quot;  &#125;,  &quot;engines&quot;: &#123;    &quot;vscode&quot;: &quot;^1.60.0&quot;  &#125;,  &#x2F;&#x2F; https:&#x2F;&#x2F;code.visualstudio.com&#x2F;api&#x2F;references&#x2F;extension-manifest#combining-extension-contributions  &quot;categories&quot;: [&quot;Snippets&quot;],  &quot;extensionKind&quot;: [&quot;ui&quot;, &quot;workspace&quot;],  &quot;capabilities&quot;: &#123;    &quot;virtualWorkspaces&quot;: true,    &quot;untrustedWorkspaces&quot;: &#123;      &quot;supported&quot;: true    &#125;  &#125;,  &#x2F;&#x2F; https:&#x2F;&#x2F;code.visualstudio.com&#x2F;api&#x2F;references&#x2F;extension-manifest  &quot;activationEvents&quot;: [    &quot;onLanguage:typescript&quot;,    &quot;onLanguage:typescriptReact&quot;,    &quot;onLanguage:javascript&quot;,    &quot;onLanguage:javascriptReact&quot;,    &quot;onCommand:reactSnippets.search&quot;,    &quot;onStartupFinished&quot;  ],  &quot;contributes&quot;: &#123;    &#x2F;&#x2F; 查询命令    &quot;commands&quot;: [      &#123;        &quot;command&quot;: &quot;reactSnippets.search&quot;,        &quot;title&quot;: &quot;Snippet search&quot;      &#125;    ],    &#x2F;&#x2F; 绑定快捷键    &quot;keybindings&quot;: [      &#123;        &quot;command&quot;: &quot;reactSnippets.search&quot;,        &quot;key&quot;: &quot;ctrl+alt+r&quot;,        &quot;mac&quot;: &quot;shift+cmd+r&quot;,        &quot;when&quot;: &quot;editorTextFocus&quot;      &#125;    ],    &#x2F;&#x2F; 配置信息    &quot;configuration&quot;: &#123;      &quot;title&quot;: &quot;ES React&#x2F;React-Native&#x2F;Redux snippets&quot;,      &quot;properties&quot;: &#123;        &#x2F;&#x2F; 是否启用prettier格式代码        &quot;reactSnippets.settings.prettierEnabled&quot;: &#123;          &quot;type&quot;: &quot;boolean&quot;,          &quot;markdownDescription&quot;: &quot;[EXPERIMENTAL: MIGHT NOT WORK]: Integrate prettier settings with code generated from snippets.&quot;,          &quot;default&quot;: false        &#125;,        &#x2F;&#x2F; 是否在顶部引入 react importReactOnTop        &quot;reactSnippets.settings.importReactOnTop&quot;: &#123;          &quot;type&quot;: &quot;boolean&quot;,          &quot;markdownDescription&quot;: &quot;Controls if snippets should add &#96;import React from &#39;react&#39;;&#96; at the top of components.\nUse if you have React +17 and use jsx transform.&quot;,          &quot;default&quot;: true        &#125;,        &#x2F;&#x2F; 是否使用typescript        &quot;reactSnippets.settings.typescript&quot;: &#123;          &quot;type&quot;: &quot;boolean&quot;,          &quot;markdownDescription&quot;: &quot;Controls if React components have typescript Props typing.&quot;,          &quot;default&quot;: true        &#125;,        &#x2F;&#x2F; 语言范围        &quot;reactSnippets.settings.languageScopes&quot;: &#123;          &quot;type&quot;: &quot;string&quot;,          &quot;markdownDescription&quot;: &quot;defines the language scopes for which the snippets will be available.\nUse comma separated values.\nFor example: &#96;typescript,typescriptreact,javascript,javascriptreact&#96;&quot;,          &quot;default&quot;: &quot;typescript,typescriptreact,javascript,javascriptreact&quot;        &#125;,        &#x2F;&#x2F; props&#x2F;state. 使用type还是interface        &quot;reactSnippets.settings.typescriptPropsStatePrefix&quot;: &#123;          &quot;type&quot;: &quot;string&quot;,          &quot;markdownDescription&quot;: &quot;Controls which prefix for typescript snippets should use for props&#x2F;state.&quot;,          &quot;default&quot;: &quot;type&quot;,          &quot;enum&quot;: [&quot;type&quot;, &quot;interface&quot;]        &#125;      &#125;    &#125;,    &quot;snippets&quot;: [      &#x2F;&#x2F; js语言      &#123;        &quot;language&quot;: &quot;javascript&quot;,        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;      &#125;,      &#x2F;&#x2F; jsx语言      &#123;        &quot;language&quot;: &quot;javascriptreact&quot;,        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;      &#125;,      &#x2F;&#x2F; ts语言      &#123;        &quot;language&quot;: &quot;typescript&quot;,        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;      &#125;,      &#x2F;&#x2F; tsx语言      &#123;        &quot;language&quot;: &quot;typescriptreact&quot;,        &quot;path&quot;: &quot;.&#x2F;lib&#x2F;snippets&#x2F;generated.json&quot;      &#125;    ]  &#125;,  &quot;scripts&quot;: &#123;    &quot;vscode:prepublish&quot;: &quot;yarn compile&quot;,    &quot;compile&quot;: &quot;rm -rf lib; tsc -p .&#x2F; --noEmit false --module commonjs --outDir lib&quot;,    &quot;compile:dev&quot;: &quot;rm -rf lib; tsc -p .&#x2F; --noEmit false --module commonjs --outDir lib&quot;,    &quot;lint&quot;: &quot;eslint --ext .js,.ts,.tsx .&#x2F;src&#x2F;&quot;,    &quot;watch&quot;: &quot;tsc -watch -p .&#x2F;&quot;,    &quot;typescript&quot;: &quot;tsc --noEmit&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;prettier&quot;: &quot;2.5.1&quot;  &#125;,  &quot;peerDependencies&quot;: &#123;    &quot;prettier&quot;: &quot;^2&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;prettier&quot;: &quot;2.5.1&quot;,    &quot;typescript&quot;: &quot;4.5.5&quot;  &#125;,  &#x2F;&#x2F; prettier  配置  &quot;prettier&quot;: &#123;    &quot;bracketSameLine&quot;: false,    &quot;bracketSpacing&quot;: true,    &quot;printWidth&quot;: 80,    &quot;semi&quot;: true,    &quot;singleQuote&quot;: true,    &quot;tabWidth&quot;: 2,    &quot;trailingComma&quot;: &quot;all&quot;,    &quot;useTabs&quot;: false,    &quot;endOfLine&quot;: &quot;auto&quot;  &#125;&#125;</code></pre><h2 id="tsrcredux-命令举例"><a href="#tsrcredux-命令举例" class="headerlink" title="tsrcredux 命令举例"></a>tsrcredux 命令举例</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123;  exportDefault,  innerComponent,  innerComponentReturn,  propsStateInterface,  propsTypeInterface,  react,  reactComponent,  reactPureComponent,  reduxComponentExport,&#125; from &quot;.&#x2F;sharedSnippets&quot;;&#x2F;&#x2F; src&#x2F;sourceSnippets&#x2F;typescript.ts&#x2F;&#x2F; 源码链接：https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;typescript.ts#L175const typescriptReactClassComponentRedux: TypescriptSnippet &#x3D; &#123;  key: &quot;typescriptReactClassComponentRedux&quot;,  prefix: &quot;tsrcredux&quot;,  body: [    &quot;import &#123; connect &#125; from &#39;react-redux&#39;&quot;,    ...reactComponent, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L18 &#x2F;&#x2F; 复用 import React, &#123; Component &#125; from &#39;react&#39;    &quot;&quot;,    ...propsStateInterface, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L52 type Props &#x3D; &#123;&#125; type State &#x3D; &#123;&#125;    &#96;export class $&#123;Placeholders.FileName&#125; extends Component&lt;Props, State&gt; &#123;&#96;,    &quot;  state &#x3D; &#123;&#125;&quot;,    &quot;&quot;,    ...innerComponentReturn, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L40    &quot;&#125;&quot;,    ...reduxComponentExport, &#x2F;&#x2F; 源码 https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;vscode-react-javascript-snippets&#x2F;blob&#x2F;185bb91a0b692c54136663464e8225872c434637&#x2F;src&#x2F;sourceSnippets&#x2F;sharedSnippets.ts#L25  ],  description:    &quot;Creates a React component class with connected redux and ES7 module system and TypeScript interfaces&quot;,&#125;;</code></pre><p>测试结果</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; connect &#125; from &quot;react-redux&quot;;import React, &#123; Component &#125; from &quot;react&quot;;type Props &#x3D; &#123;&#125;;type State &#x3D; &#123;&#125;;export class tsrcredux&#x2F;**文件名 *&#x2F; extends Component&lt;Props, State&gt; &#123;  state &#x3D; &#123;&#125;;  render() &#123;    return &lt;div&gt;tsrcreduxx&lt;!--文件名 --&gt;&lt;&#x2F;div&gt;;  &#125;&#125;const mapStateToProps &#x3D; (state) &#x3D;&gt; (&#123;&#125;);const mapDispatchToProps &#x3D; &#123;&#125;;export default connect(mapStateToProps, mapDispatchToProps)(tsrcreduxx&#x2F;**文件名 *&#x2F;);</code></pre><img src="http://t-blog-images.aijs.top/img/202209051036707.webp" /><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">👑 ~&#x2F;haotian&#x2F;github&#x2F;vscode-plugins&#x2F;vscode-react-javascript-snippets&#x2F;src git:(master) $ tree -l.├── helpers &#x2F;&#x2F; 工具│   ├── extensionConfig.ts &#x2F;&#x2F; 获取工作空间的配置信息│   ├── formatters.ts &#x2F;&#x2F; 从配置工作空间中拿到配置信息对代码片段进行格式化，对代码片段进行解析，转化成vscode支持的语法│   ├── generateSnippets.ts &#x2F;&#x2F; 获取sourceSnippets 目录下的代码片段，进行格式化输出到 __dirname + &#39;&#x2F;..&#x2F;snippets&#x2F;generated.json&#39;│   ├── getPrettierConfig.ts &#x2F;&#x2F;  获取prettier的配置信息│   ├── parseSnippetToBody.ts &#x2F;&#x2F; 将代码片段放到body中，中间过程处理了是否需要引入react│   ├── replaceOrRemoveReactImport.ts &#x2F;&#x2F; 有引入react得前缀枚举, 对于不需要引入react得行进行替换除去│   ├── snippetPlaceholders.ts &#x2F;&#x2F; 1.Mappings 键转化成值， 2.Mappings 值转化成键│   └── snippetSearch.ts &#x2F;&#x2F;获取代码片段，格式化成 vscode showQuickPick 可以使用的数据├── index.ts &#x2F;&#x2F; 插件入口， 插件激活时候，1.工作空间配置更改监听， window.showWarningMessage提示是否需要重启插件；2.命令注册├── snippets│   └── generated.json &#x2F;&#x2F; generateSnippets 生成目录，以及package.json snippets字段 用于语言域配置├── sourceSnippets &#x2F;&#x2F; 源代码片段目录│   ├── components.ts &#x2F;&#x2F; react组件相关│   ├── console.ts &#x2F;&#x2F; 日志相关│   ├── hooks.ts &#x2F;&#x2F; react hooks相关│   ├── imports.ts &#x2F;&#x2F; 提供了不同的引入方式│   ├── others.ts &#x2F;&#x2F; 其他乱七八糟的归为一类 js 函数、数组、结构、class、声明周期、react createRef 叭啦叭啦一堆│   ├── propTypes.ts &#x2F;&#x2F; 属性相关的│   ├── reactNative.ts &#x2F;&#x2F; rn 相关的│   ├── redux.ts &#x2F;&#x2F; redux相关的│   ├── sharedSnippets.ts &#x2F;&#x2F; 被其他代码片段共享复用的部分│   ├── tests.ts &#x2F;&#x2F; 测试代码片段，非测试文件│   └── typescript.ts &#x2F;&#x2F; ts语法的的代码片段└── types.ts &#x2F;&#x2F; 与vsocde可识别语法的 映射关系3 directories, 22 files</code></pre><h2 id="详细源码注释"><a href="#详细源码注释" class="headerlink" title="详细源码注释"></a>详细源码注释</h2><p><a href="https://github.com/841660202/vscode-react-javascript-snippets/blob/master/src/index.ts" target="_blank" >github fork</a></p><h2 id="片段语法"><a href="#片段语法" class="headerlink" title="片段语法"></a>片段语法</h2><p><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax" target="_blank" >见 visualstudio</a><br><a href="https://blog.csdn.net/maokelong95/article/details/54379046" target="_blank" >见 博客</a><br><a href="https://code.visualstudio.com/api/references/extension-manifest#combining-extension-contributions" target="_blank" >extension-manifest categories</a><br><a href="https://code.visualstudio.com/api/references/extension-manifest" target="_blank" >activationEvents</a></p>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信 下载/导出</title>
      <link href="//post/2022-09-02wx-download.html"/>
      <url>//post/2022-09-02wx-download.html</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h2><h3 id="a-标签方式"><a href="#a-标签方式" class="headerlink" title="a 标签方式"></a>a 标签方式</h3><p>一般情况</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * @param &#123; String &#125; target 下载对象 * @param &#123; String &#125; type 类型 url &#x2F; blob *&#x2F;export const downloadFile &#x3D; (target, filename &#x3D; &quot;&quot;, type &#x3D; &quot;url&quot;) &#x3D;&gt; &#123;  const link &#x3D; document.createElement(&quot;a&quot;);  const body &#x3D; document.querySelector(&quot;body&quot;);  if (!body) return;  &#x2F;&#x2F; 需下载的文件类型  if (type &#x3D;&#x3D;&#x3D; &quot;url&quot;) &#123;    link.href &#x3D; target;  &#125; else if (type &#x3D;&#x3D;&#x3D; &quot;blob&quot;) &#123;    link.href &#x3D; window.URL.createObjectURL(target);  &#125;  &#x2F;&#x2F; 文件名  if (filename) link.download &#x3D; filename;  link.style.display &#x3D; &quot;none&quot;;  body.appendChild(link);  link.click();  window.URL.revokeObjectURL(link.href); &#x2F;&#x2F; 释放 URL 对象  body.removeChild(link);&#125;;</code></pre><h3 id="window-api-方式"><a href="#window-api-方式" class="headerlink" title="window api 方式"></a>window api 方式</h3><p><code>window.open</code> 、<code>window.location.href</code></p><p>通过 name 形式</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.open(&quot;url?name&#x3D;资源文件&quot;);window.location.href &#x3D; &quot;url?name&#x3D;资源文件&quot;;</code></pre><h2 id="企业微信环境"><a href="#企业微信环境" class="headerlink" title="企业微信环境"></a>企业微信环境</h2><p>不支持上述两种方式更改，完全由后台接口返回控制</p><img src="http://t-blog-images.aijs.top/img/202209021704425.webp" /><ul><li><p>并且企业微信下载，需要二次确认，下载之后，并不像浏览器那样提示在底部提示已下载的文件</p></li><li><p>如果这个地方 <code>Content-Disposition</code> 后台没有塞 filename 字段，企业微信提示二次确认时候的重命名 <span style="color: red">输入框默认是空的</span></p></li><li><p>企业微信文件API理论上可以用，但是有些IOS手机还是坑多多</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 企业微信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ahooks源码</title>
      <link href="//post/2022-08-24ahooks.html"/>
      <url>//post/2022-08-24ahooks.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随意看看，了解下，无固定顺序，全凭兴趣</p><h2 id="useUpdate"><a href="#useUpdate" class="headerlink" title="useUpdate"></a>useUpdate</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>useUpdate 会返回一个函数，调用该函数会强制组件重新渲染。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useCallback, useState &#125; from &quot;react&quot;;const useUpdate &#x3D; () &#x3D;&gt; &#123;  const [, setState] &#x3D; useState(&#123;&#125;);  return useCallback(() &#x3D;&gt; setState(&#123;&#125;), []); &#x2F;&#x2F; setState(&#123;&#125;) 每次置为新的对象，即使页面没有用到该useState的返回值，也会更新&#125;;export default useUpdate;</code></pre><h2 id="useControllableValue"><a href="#useControllableValue" class="headerlink" title="useControllableValue"></a>useControllableValue</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在某些组件开发时，我们需要组件的状态既可以自己管理，也可以被外部控制，useControllableValue 就是帮你管理这种状态的 Hook。</p></blockquote><p>简单来说，默认情况下,外层组件有 value, onChange 就用外层的，外层没有，自己处理</p><img src="http://t-blog-images.aijs.top/img/202208241724077.webp" /><p>虽然是复用，可这里这么写有点奇怪</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemo, useRef &#125; from &quot;react&quot;;import type &#123; SetStateAction &#125; from &quot;react&quot;;import &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;import useUpdate from &quot;..&#x2F;useUpdate&quot;;export interface Options&lt;T&gt; &#123;  defaultValue?: T;  defaultValuePropName?: string;  valuePropName?: string;  trigger?: string;&#125;export type Props &#x3D; Record&lt;string, any&gt;;export interface StandardProps&lt;T&gt; &#123;  value: T;  defaultValue?: T;  onChange: (val: T) &#x3D;&gt; void;&#125;function useControllableValue&lt;T &#x3D; any&gt;(  props: StandardProps&lt;T&gt;): [T, (v: SetStateAction&lt;T&gt;) &#x3D;&gt; void];function useControllableValue&lt;T &#x3D; any&gt;(  props?: Props,  options?: Options&lt;T&gt;): [T, (v: SetStateAction&lt;T&gt;, ...args: any[]) &#x3D;&gt; void];function useControllableValue&lt;T &#x3D; any&gt;(  props: Props &#x3D; &#123;&#125;,  options: Options&lt;T&gt; &#x3D; &#123;&#125;) &#123;  &#x2F;&#x2F; 这里一堆，是函数重写？  const &#123;    defaultValue,    defaultValuePropName &#x3D; &quot;defaultValue&quot;,    valuePropName &#x3D; &quot;value&quot;,    trigger &#x3D; &quot;onChange&quot;,  &#125; &#x3D; options;  const value &#x3D; props[valuePropName] as T;  &#x2F;&#x2F; options 默认情况， 如果 props 有 value 字段，则由父级接管控制 state  const isControlled &#x3D; props.hasOwnProperty(valuePropName);  const initialValue &#x3D; useMemo(() &#x3D;&gt; &#123;    if (isControlled) &#123;      &#x2F;&#x2F; 如果是受控，返回受控的value      return value;    &#125;    if (props.hasOwnProperty(defaultValuePropName)) &#123;      &#x2F;&#x2F; 非受控，props有默认值，返回默认值      return props[defaultValuePropName];    &#125;    return defaultValue;  &#125;, []);  const stateRef &#x3D; useRef(initialValue); &#x2F;&#x2F; 存的是父组件的值  if (isControlled) &#123;    stateRef.current &#x3D; value;  &#125;  const update &#x3D; useUpdate(); &#x2F;&#x2F; 上面了解到，该组件会强制react进行重渲染  &#x2F;&#x2F; options 默认情况，state变化时候，会触发onChange  function setState(v: SetStateAction&lt;T&gt;, ...args: any[]) &#123;    const r &#x3D; isFunction(v) ? v(stateRef.current) : v;    if (!isControlled) &#123;      &#x2F;&#x2F; 非受控，重渲染      stateRef.current &#x3D; r;      update();    &#125;    if (props[trigger]) &#123;      &#x2F;&#x2F; 有回调，执行回调      props[trigger](r, ...args);    &#125;  &#125;  &#x2F;&#x2F; 返回存的值, 对setState进行缓存  return [stateRef.current, useMemoizedFn(setState)] as const;&#125;export default useControllableValue;</code></pre><h2 id="useLatest"><a href="#useLatest" class="headerlink" title="useLatest"></a>useLatest</h2><h2 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h2><p>将值放到 ref 上，并返回，可以防“闭包陷阱”，</p><p><a href="https://juejin.cn/post/6972893133243695141" target="_blank" >见</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>useRef 每次 render 时都会返回同一个引用类型的对象，我们设置值和读取值都在这个对象上处理，这样就能获取到最新的 value 值了。<br>“闭包陷阱” 最大的问题就是在函数数内无法获取的最新的 state 的值，那 React 提供了哪些方法来解决呢？</p><ul><li>useRef 上面已有介绍</li><li>useState 更新值时传入回调函数</li></ul></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useRef &#125; from &quot;react&quot;;function useLatest&lt;T&gt;(value: T) &#123;  const ref &#x3D; useRef(value);  ref.current &#x3D; value;  return ref;&#125;export default useLatest;</code></pre><h2 id="useMemoizedFn"><a href="#useMemoizedFn" class="headerlink" title="useMemoizedFn"></a>useMemoizedFn</h2><ul><li>2+版本，为<code>usePersistFn</code>, 使用时候最好，将这些 hooks 放到一个文件中作为引用的过度文件。以防以后全局搜 <code>usePersistFn</code> 替换为 <code>useMemoizedFn</code></li></ul><p><code>useMemoizedFn</code> 如何实现 <code>useCallback</code> 效果，却不用使用第二参数 <code>deps</code> 呢？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemo, useRef &#125; from &quot;react&quot;;import &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;type noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;type PickFunction&lt;T extends noop&gt; &#x3D; (  this: ThisParameterType&lt;T&gt;,  ...args: Parameters&lt;T&gt;) &#x3D;&gt; ReturnType&lt;T&gt;;function useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;  const fnRef &#x3D; useRef&lt;T&gt;(fn);  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]); &#x2F;&#x2F; 为了兼容 react devtool  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();  if (!memoizedFn.current) &#123;    &#x2F;&#x2F; 不存在，则重新生成函数， 这里用于缓存优化，但是函数执行的时候上下文中的参数是最新的，见下面模拟（出于这点，所以不需要deps）    memoizedFn.current &#x3D; function (this, ...args) &#123;      return fnRef.current.apply(this, args);    &#125;;  &#125;  return memoizedFn.current as T;&#125;export default useMemoizedFn;</code></pre><p><strong>模拟函数声明，函数内变量更新</strong></p><img src="http://t-blog-images.aijs.top/img/202208241826880.webp" /><h2 id="useToggle"><a href="#useToggle" class="headerlink" title="useToggle"></a>useToggle</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemo, useState &#125; from &quot;react&quot;;export interface Actions&lt;T&gt; &#123;  setLeft: () &#x3D;&gt; void;  setRight: () &#x3D;&gt; void;  set: (value: T) &#x3D;&gt; void;  toggle: () &#x3D;&gt; void;&#125;&#x2F;&#x2F; 1function useToggle&lt;T &#x3D; boolean&gt;(): [boolean, Actions&lt;T&gt;];&#x2F;&#x2F; 2function useToggle&lt;T&gt;(defaultValue: T): [T, Actions&lt;T&gt;];&#x2F;&#x2F; 3function useToggle&lt;T, U&gt;(  defaultValue: T,  reverseValue: U): [T | U, Actions&lt;T | U&gt;];&#x2F;&#x2F; 4function useToggle&lt;D, R&gt;(  defaultValue: D &#x3D; false as unknown as D,  reverseValue?: R) &#123;  &#x2F;&#x2F; 可以理解为缓存吧  const [state, setState] &#x3D; useState&lt;D | R&gt;(defaultValue);  const actions &#x3D; useMemo(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 最初的相反值 &#x3D; 设置的相反值 or 是初始值的取反    const reverseValueOrigin &#x3D; (      reverseValue &#x3D;&#x3D;&#x3D; undefined ? !defaultValue : reverseValue    ) as D | R;    &#x2F;&#x2F; 默认值取反    const toggle &#x3D; () &#x3D;&gt;      setState((s) &#x3D;&gt; (s &#x3D;&#x3D;&#x3D; defaultValue ? reverseValueOrigin : defaultValue));    &#x2F;&#x2F; 设置值    const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);    &#x2F;&#x2F; 设置初始值    const setLeft &#x3D; () &#x3D;&gt; setState(defaultValue);    &#x2F;&#x2F; 设置为相反值    const setRight &#x3D; () &#x3D;&gt; setState(reverseValueOrigin);    &#x2F;&#x2F; 这就有点意思了，左边右边，反过来，再翻过去，刚好 toggle    return &#123;      toggle,      set,      setLeft,      setRight,    &#125;;    &#x2F;&#x2F; useToggle ignore value change    &#x2F;&#x2F; &#125;, [defaultValue, reverseValue]);  &#125;, []);  return [state, actions &#x2F;**这里是对象，却用了s结尾，乍一看还以为数组 *&#x2F;];&#125;export default useToggle;</code></pre><h2 id="useBoolean"><a href="#useBoolean" class="headerlink" title="useBoolean"></a>useBoolean</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemo &#125; from &quot;react&quot;;import useToggle from &quot;..&#x2F;useToggle&quot;;&#x2F;&#x2F; 这里与 useToggle很像export interface Actions &#123;  setTrue: () &#x3D;&gt; void;  setFalse: () &#x3D;&gt; void;  set: (value: boolean) &#x3D;&gt; void;  toggle: () &#x3D;&gt; void;&#125;&#x2F;&#x2F; 主要用toggle整了点事，然后暴露更具有语义话的apiexport default function useBoolean(defaultValue &#x3D; false): [boolean, Actions] &#123;  const [state, &#123; toggle, set &#125;] &#x3D; useToggle(defaultValue);  const actions: Actions &#x3D; useMemo(() &#x3D;&gt; &#123;    &#x2F;&#x2F; const set &#x3D; (value: D | R) &#x3D;&gt; setState(value);    const setTrue &#x3D; () &#x3D;&gt; set(true);    const setFalse &#x3D; () &#x3D;&gt; set(false);    return &#123;      toggle,      set: (v) &#x3D;&gt; set(!!v),      setTrue,      setFalse,    &#125;;  &#125;, []);  return [state, actions];&#125;</code></pre><h2 id="useMount"><a href="#useMount" class="headerlink" title="useMount"></a>useMount</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect &#125; from &quot;react&quot;;import &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;const useMount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;  &#x2F;&#x2F; 删减  useEffect(() &#x3D;&gt; &#123;    fn?.();  &#125;, []);&#125;;export default useMount;</code></pre><h2 id="useUnmount"><a href="#useUnmount" class="headerlink" title="useUnmount"></a>useUnmount</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect &#125; from &quot;react&quot;;import useLatest from &quot;..&#x2F;useLatest&quot;;import &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;const useUnmount &#x3D; (fn: () &#x3D;&gt; void) &#x3D;&gt; &#123;  &#x2F;&#x2F; 删减  const fnRef &#x3D; useLatest(fn);  useEffect(    () &#x3D;&gt; () &#x3D;&gt; &#123;      fnRef.current();    &#125;,    []  );&#125;;export default useUnmount;</code></pre><h2 id="useUnmountedRef"><a href="#useUnmountedRef" class="headerlink" title="useUnmountedRef"></a>useUnmountedRef</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>获取当前组件是否已经卸载的 Hook。</p></blockquote><p>什么业务场景会使用？？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect, useRef &#125; from &quot;react&quot;;const useUnmountedRef &#x3D; () &#x3D;&gt; &#123;  const unmountedRef &#x3D; useRef(false); &#x2F;&#x2F; 默认没有卸载  useEffect(() &#x3D;&gt; &#123;    unmountedRef.current &#x3D; false; &#x2F;&#x2F; 挂载    return () &#x3D;&gt; &#123;      unmountedRef.current &#x3D; true; &#x2F;&#x2F; 卸载    &#125;;  &#125;, []);  return unmountedRef;&#125;;export default useUnmountedRef;</code></pre><h2 id="useUpdateEffect-有依赖项"><a href="#useUpdateEffect-有依赖项" class="headerlink" title="useUpdateEffect (有依赖项)"></a>useUpdateEffect (有依赖项)</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。</p></blockquote><p><span style="color: red">如何实现忽略首次执行的</span></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect &#125; from &quot;react&quot;;import &#123; createUpdateEffect &#125; from &quot;..&#x2F;createUpdateEffect&quot;; &#x2F;&#x2F; 见下面源码export default createUpdateEffect(useEffect);</code></pre><h2 id="createUpdateEffect"><a href="#createUpdateEffect" class="headerlink" title="createUpdateEffect"></a>createUpdateEffect</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useRef &#125; from &quot;react&quot;;import type &#123; useEffect, useLayoutEffect &#125; from &quot;react&quot;;type EffectHookType &#x3D; typeof useEffect | typeof useLayoutEffect;&#x2F;&#x2F; export const createUpdateEffect: (hook: EffectHookType) &#x3D;&gt; EffectHookType &#x3D; (hook) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;export const createUpdateEffect &#x3D; (hook &#x2F;** useEffect *&#x2F;) &#x3D;&gt; (effect, deps) &#x3D;&gt; &#123;  &#x2F;&#x2F; 柯里化  const isMounted &#x3D; useRef(false);  &#x2F;&#x2F; for react-refresh react刷新时候执行卸载  hook(() &#x3D;&gt; &#123;    &#x2F;&#x2F;卸载    return () &#x3D;&gt; &#123;      isMounted.current &#x3D; false;    &#125;;  &#125;, []);  hook(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 挂在    if (!isMounted.current) &#123;      &#x2F;&#x2F; 非第一次， isMounted.current &#x3D; true , 此时走  effect()      isMounted.current &#x3D; true;    &#125; else &#123;      return effect();    &#125;  &#125;, deps);&#125;;export default createUpdateEffect;</code></pre><h2 id="useHistoryTravel"><a href="#useHistoryTravel" class="headerlink" title="useHistoryTravel"></a>useHistoryTravel</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>管理状态历史变化记录，方便在历史记录中前进与后退。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useRef, useState &#125; from &quot;react&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;import &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;interface IData&lt;T&gt; &#123;  present?: T;  past: T[];  future: T[];&#125;const dumpIndex &#x3D; &lt;T&gt;(step: number, arr: T[]) &#x3D;&gt; &#123;  let index &#x3D;    step &gt; 0      ? step - 1 &#x2F;&#x2F; move forward      : arr.length + step; &#x2F;&#x2F; move backward  if (index &gt;&#x3D; arr.length - 1) &#123;    index &#x3D; arr.length - 1;  &#125;  if (index &lt; 0) &#123;    index &#x3D; 0;  &#125;  return index;&#125;;const split &#x3D; &lt;T&gt;(step: number, targetArr: T[]) &#x3D;&gt; &#123;  const index &#x3D; dumpIndex(step, targetArr);  return &#123;    _current: targetArr[index],    _before: targetArr.slice(0, index),    _after: targetArr.slice(index + 1),  &#125;;&#125;;export default function useHistoryTravel&lt;T&gt;(initialValue?: T) &#123;  const [history, setHistory] &#x3D; useState&lt;IData&lt;T | undefined&gt;&gt;(&#123;    present: initialValue, &#x2F;&#x2F; 当前    past: [], &#x2F;&#x2F; 历史记录    future: [], &#x2F;&#x2F; 未来记录  &#125;);  const &#123; present, past, future &#125; &#x3D; history;  const initialValueRef &#x3D; useRef(initialValue);  const reset &#x3D; (...params: any[]) &#x3D;&gt; &#123;    const _initial &#x3D; params.length &gt; 0 ? params[0] : initialValueRef.current;    initialValueRef.current &#x3D; _initial;    setHistory(&#123;      present: _initial,      future: [],      past: [],    &#125;);  &#125;;  const updateValue &#x3D; (val: T) &#x3D;&gt; &#123;    setHistory(&#123;      present: val,      future: [],      past: [...past, present],    &#125;);  &#125;;  &#x2F;&#x2F; 向前  const _forward &#x3D; (step: number &#x3D; 1) &#x3D;&gt; &#123;    if (future.length &#x3D;&#x3D;&#x3D; 0) &#123;      return;    &#125;    const &#123; _before, _current, _after &#125; &#x3D; split(step, future);    setHistory(&#123;      past: [...past, present, ..._before],      present: _current,      future: _after,    &#125;);  &#125;;  &#x2F;&#x2F; 向后  const _backward &#x3D; (step: number &#x3D; -1) &#x3D;&gt; &#123;    if (past.length &#x3D;&#x3D;&#x3D; 0) &#123;      return;    &#125;    const &#123; _before, _current, _after &#125; &#x3D; split(step, past);    setHistory(&#123;      past: _before,      present: _current,      future: [..._after, present, ...future],    &#125;);  &#125;;  &#x2F;&#x2F; 可进，可退，可不动  const go &#x3D; (step: number) &#x3D;&gt; &#123;    const stepNum &#x3D; isNumber(step) ? step : Number(step);    if (stepNum &#x3D;&#x3D;&#x3D; 0) &#123;      return;    &#125;    if (stepNum &gt; 0) &#123;      return _forward(stepNum);    &#125;    _backward(stepNum);  &#125;;  return &#123;    value: present, &#x2F;&#x2F; 当前    backLength: past.length, &#x2F;&#x2F; 可后退长度    forwardLength: future.length, &#x2F;&#x2F; 可前进长度    setValue: useMemoizedFn(updateValue), &#x2F;&#x2F; 跳转到哪个记录    go: useMemoizedFn(go), &#x2F;&#x2F; 回退到哪个    back: useMemoizedFn(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 回退一个      go(-1);    &#125;),    forward: useMemoizedFn(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 前进一个      go(1);    &#125;),    reset: useMemoizedFn(reset), &#x2F;&#x2F; 重置  &#125;;&#125;</code></pre><h2 id="useInfiniteScroll"><a href="#useInfiniteScroll" class="headerlink" title="useInfiniteScroll"></a>useInfiniteScroll</h2><p>useInfiniteScroll 封装了常见的无限滚动逻辑。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const &#123; data, loading, loadingMore, loadMore &#125; &#x3D; useInfiniteScroll(service);</code></pre><p>useInfiniteScroll 的第一个参数 service 是一个异步函数，对这个函数的入参和出参有如下 <span style="color: red">约定</span>：</p><p>service 返回的数据必须包含 list 数组，类型为 <code>&#123; list: any[], ...rest &#125;</code><br>service 的入参为整合后的最新 data<br>假如第一次请求返回数据为<code> &#123; list: [1, 2, 3], nextId: 4 &#125;</code>, 第二次返回的数据为<code> &#123; list: [4, 5, 6], nextId: 7 &#125;</code>, 则我们会自动合并 list，整合后的的 data 为 <code>&#123; list: [1, 2, 3, 4, 5, 6], nextId: 7 &#125;</code>。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemo, useState &#125; from &quot;react&quot;;import useEventListener from &quot;..&#x2F;useEventListener&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;; &#x2F;&#x2F; 简化版useCallbackimport useRequest from &quot;..&#x2F;useRequest&quot;; &#x2F;&#x2F; 请求封装的hook&#x2F;&#x2F; useUpdateEffect 用法等同于 useEffect，但是会忽略首次执行，只在依赖更新时执行。import useUpdateEffect from &quot;..&#x2F;useUpdateEffect&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getClientHeight, getScrollHeight, getScrollTop &#125; from &quot;..&#x2F;utils&#x2F;rect&quot;;import type &#123; Data, InfiniteScrollOptions, Service &#125; from &quot;.&#x2F;types&quot;;const useInfiniteScroll &#x3D; &lt;TData extends Data&gt;(  service: Service&lt;TData&gt;,  options: InfiniteScrollOptions&lt;TData&gt; &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  const &#123;    target,    isNoMore,    threshold &#x3D; 100,    reloadDeps &#x3D; [],    manual,    onBefore,    onSuccess,    onError,    onFinally,  &#125; &#x3D; options;  const [finalData, setFinalData] &#x3D; useState&lt;TData&gt;();  const [loadingMore, setLoadingMore] &#x3D; useState(false);  const noMore &#x3D; useMemo(() &#x3D;&gt; &#123;    if (!isNoMore) return false;    return isNoMore(finalData);  &#125;, [finalData]);  const &#123; loading, run, runAsync, cancel &#125; &#x3D; useRequest(    async (lastData?: TData) &#x3D;&gt; &#123;      const currentData &#x3D; await service(lastData);      if (!lastData) &#123;        setFinalData(currentData);      &#125; else &#123;        setFinalData(&#123;          ...currentData,          &#x2F;&#x2F; @ts-ignore          list: [...lastData.list, ...currentData.list],        &#125;);      &#125;      return currentData;    &#125;,    &#123;      manual,      onFinally: (_, d, e) &#x3D;&gt; &#123;        setLoadingMore(false);        onFinally?.(d, e);      &#125;,      onBefore: () &#x3D;&gt; onBefore?.(),      onSuccess: (d) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;          &#x2F;&#x2F; eslint-disable-next-line @typescript-eslint&#x2F;no-use-before-define          scrollMethod();        &#125;);        onSuccess?.(d);      &#125;,      onError: (e) &#x3D;&gt; onError?.(e),    &#125;  );  const loadMore &#x3D; () &#x3D;&gt; &#123;    if (noMore) return;    setLoadingMore(true);    run(finalData);  &#125;;  const loadMoreAsync &#x3D; () &#x3D;&gt; &#123;    if (noMore) return Promise.reject();    setLoadingMore(true);    return runAsync(finalData);  &#125;;  const reload &#x3D; () &#x3D;&gt; run();  const reloadAsync &#x3D; () &#x3D;&gt; runAsync();  &#x2F;&#x2F; scrollMethod会尝试去检测是否满足加载条件  const scrollMethod &#x3D; () &#x3D;&gt; &#123;    const el &#x3D; getTargetElement(target);    if (!el) &#123;      return;    &#125;    const scrollTop &#x3D; getScrollTop(el);    const scrollHeight &#x3D; getScrollHeight(el);    const clientHeight &#x3D; getClientHeight(el);    if (scrollHeight - scrollTop &lt;&#x3D; clientHeight + threshold) &#123;      loadMore();    &#125;  &#125;;  &#x2F;&#x2F; 监听滚动，加载中的会被拦掉，  useEventListener(    &quot;scroll&quot;,    () &#x3D;&gt; &#123;      if (loading || loadingMore) &#123;        return;      &#125;      scrollMethod();    &#125;,    &#123; target &#125;  );  useUpdateEffect(() &#x3D;&gt; &#123;    run();  &#125;, [...reloadDeps]);  return &#123;    &#x2F;&#x2F; 数据    data: finalData,    loading: !loadingMore &amp;&amp; loading,    loadingMore,    noMore,    &#x2F;&#x2F; 一些方法    loadMore: useMemoizedFn(loadMore),    loadMoreAsync: useMemoizedFn(loadMoreAsync),    &#x2F;&#x2F; 这两个声明的函数直接返回    &#x2F;&#x2F; const reload &#x3D; () &#x3D;&gt; run();    &#x2F;&#x2F; const reloadAsync &#x3D; () &#x3D;&gt; runAsync();    reload: useMemoizedFn(reload),    reloadAsync: useMemoizedFn(reloadAsync),    mutate &#x2F;**数据突变 *&#x2F;: setFinalData,    cancel,  &#125;;&#125;;export default useInfiniteScroll;</code></pre><h3 id="getTargetElement"><a href="#getTargetElement" class="headerlink" title="getTargetElement"></a>getTargetElement</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123; MutableRefObject &#125; from &quot;react&quot;;import &#123; isFunction &#125; from &quot;.&#x2F;index&quot;;import isBrowser from &quot;.&#x2F;isBrowser&quot;;type TargetValue&lt;T&gt; &#x3D; T | undefined | null;type TargetType &#x3D; HTMLElement | Element | Window | Document;export type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;  | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数  | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom  | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; refexport function getTargetElement&lt;T extends TargetType&gt;(  target: BasicTarget&lt;T&gt;,  defaultElement?: T) &#123;  &#x2F;&#x2F; 服务端渲染情况  if (!isBrowser) &#123;    return undefined;  &#125;  &#x2F;&#x2F; 假设，一定存在  if (!target) &#123;    return defaultElement;  &#125;  let targetElement: TargetValue&lt;T&gt;;  &#x2F;&#x2F; 函数  if (isFunction(target)) &#123;    targetElement &#x3D; target();    &#x2F;&#x2F; ref  &#125; else if (&quot;current&quot; in target) &#123;    targetElement &#x3D; target.current;    &#x2F;&#x2F; 直接dom  &#125; else &#123;    targetElement &#x3D; target;  &#125;  return targetElement;&#125;</code></pre><h3 id="getClientHeight-getScrollHeight-getScrollTop"><a href="#getClientHeight-getScrollHeight-getScrollTop" class="headerlink" title="getClientHeight, getScrollHeight, getScrollTop"></a>getClientHeight, getScrollHeight, getScrollTop</h3><p>使用<code>Math.max</code>，对 rect 的计算进行兼容性处理</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const getScrollTop &#x3D; (el: Document | Element) &#x3D;&gt; &#123;  if (el &#x3D;&#x3D;&#x3D; document || el &#x3D;&#x3D;&#x3D; document.body) &#123;    &#x2F;&#x2F; 处理浏览器兼容性    &#x2F;&#x2F; IE6&#x2F;7&#x2F;8：    &#x2F;&#x2F; 可以使用 document.documentElement.scrollTop；    &#x2F;&#x2F; IE9及以上：    &#x2F;&#x2F; 可以使用window.pageYOffset或者document.documentElement.scrollTop    &#x2F;&#x2F; Safari:    &#x2F;&#x2F; safari： window.pageYOffset 与document.body.scrollTop都可以；    &#x2F;&#x2F; Firefox:    &#x2F;&#x2F; 火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；    &#x2F;&#x2F; Chrome：    &#x2F;&#x2F; 谷歌浏览器只认识document.body.scrollTop;    return Math.max(      window.pageYOffset,      document.documentElement.scrollTop,      document.body.scrollTop    );  &#125;  return (el as Element).scrollTop;&#125;;</code></pre><img src="http://t-blog-images.aijs.top/img/202208301756200.webp" /><p><a href="https://segmentfault.com/a/1190000008065472" target="_blank" >JS 基础篇– body.scrollTop 与 documentElement.scrollTop</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const getScrollHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;  return (    (el as Element).scrollHeight ||    Math.max(document.documentElement.scrollHeight, document.body.scrollHeight)  );&#125;;const getClientHeight &#x3D; (el: Document | Element) &#x3D;&gt; &#123;  return (    (el as Element).clientHeight ||    Math.max(document.documentElement.clientHeight, document.body.clientHeight)  );&#125;;export &#123; getScrollTop, getScrollHeight, getClientHeight &#125;;</code></pre><h2 id="useEventListener"><a href="#useEventListener" class="headerlink" title="useEventListener"></a>useEventListener</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useLatest from &quot;..&#x2F;useLatest&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;type noop &#x3D; (...p: any) &#x3D;&gt; void;export type Target &#x3D; BasicTarget&lt;HTMLElement | Element | Window | Document&gt;;type Options&lt;T extends Target &#x3D; Target&gt; &#x3D; &#123;  target?: T;  capture?: boolean;  once?: boolean;  passive?: boolean;&#125;;function useEventListener&lt;K extends keyof HTMLElementEventMap&gt;(  eventName: K,  handler: (ev: HTMLElementEventMap[K]) &#x3D;&gt; void,  options?: Options&lt;HTMLElement&gt;): void;function useEventListener&lt;K extends keyof ElementEventMap&gt;(  eventName: K,  handler: (ev: ElementEventMap[K]) &#x3D;&gt; void,  options?: Options&lt;Element&gt;): void;function useEventListener&lt;K extends keyof DocumentEventMap&gt;(  eventName: K,  handler: (ev: DocumentEventMap[K]) &#x3D;&gt; void,  options?: Options&lt;Document&gt;): void;function useEventListener&lt;K extends keyof WindowEventMap&gt;(  eventName: K,  handler: (ev: WindowEventMap[K]) &#x3D;&gt; void,  options?: Options&lt;Window&gt;): void;function useEventListener(  eventName: string,  handler: noop,  options: Options): void;function useEventListener(  eventName: string,  handler: noop,  options: Options &#x3D; &#123;&#125;) &#123;  const handlerRef &#x3D; useLatest(handler);  useEffectWithTarget(    &#x2F;&#x2F; 做了缓存    &#x2F;&#x2F; effect    () &#x3D;&gt; &#123;      const targetElement &#x3D; getTargetElement(options.target, window);      if (!targetElement?.addEventListener) &#123;        return;      &#125;      const eventListener &#x3D; (event: Event) &#x3D;&gt; &#123;        return handlerRef.current(event);      &#125;;      targetElement.addEventListener(eventName, eventListener, &#123;        capture: options.capture,        once: options.once,        passive: options.passive,      &#125;);      return () &#x3D;&gt; &#123;        targetElement.removeEventListener(eventName, eventListener, &#123;          capture: options.capture,        &#125;);      &#125;;    &#125;,    &#x2F;&#x2F; deps 依赖项    [eventName, options.capture, options.once, options.passive],    &#x2F;&#x2F; target    options.target  );&#125;export default useEventListener;</code></pre><h2 id="useEffectWithTarget"><a href="#useEffectWithTarget" class="headerlink" title="useEffectWithTarget"></a>useEffectWithTarget</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect &#125; from &quot;react&quot;;import createEffectWithTarget from &quot;.&#x2F;createEffectWithTarget&quot;;&#x2F;&#x2F; createEffectWithTarget将useEffect进行包裹const useEffectWithTarget &#x3D; createEffectWithTarget(useEffect);export default useEffectWithTarget;</code></pre><h2 id="createEffectWithTarget"><a href="#createEffectWithTarget" class="headerlink" title="createEffectWithTarget"></a>createEffectWithTarget</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123;  DependencyList,  EffectCallback,  useEffect,  useLayoutEffect,&#125; from &quot;react&quot;;import &#123; useRef &#125; from &quot;react&quot;;import useUnmount from &quot;..&#x2F;useUnmount&quot;;import depsAreSame from &quot;.&#x2F;depsAreSame&quot;;import type &#123; BasicTarget &#125; from &quot;.&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;.&#x2F;domTarget&quot;;const createEffectWithTarget &#x3D; (  useEffectType: typeof useEffect | typeof useLayoutEffect) &#x3D;&gt; &#123;  &#x2F;**   *   * @param effect   * @param deps   * @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom   *&#x2F;  const useEffectWithTarget &#x3D; (    effect: EffectCallback,    deps: DependencyList,    target: BasicTarget&lt;any&gt; | BasicTarget&lt;any&gt;[]  ) &#x3D;&gt; &#123;    const hasInitRef &#x3D; useRef(false);    const lastElementRef &#x3D; useRef&lt;(Element | null)[]&gt;([]);    const lastDepsRef &#x3D; useRef&lt;DependencyList&gt;([]);    const unLoadRef &#x3D; useRef&lt;any&gt;();    &#x2F;&#x2F; 类型 useEffectType: typeof useEffect | typeof useLayoutEffect    useEffectType(() &#x3D;&gt; &#123;      const targets &#x3D; Array.isArray(target) ? target : [target];      const els &#x3D; targets.map((item) &#x3D;&gt; getTargetElement(item));      &#x2F;&#x2F; init run      if (!hasInitRef.current) &#123;        hasInitRef.current &#x3D; true;        lastElementRef.current &#x3D; els;        lastDepsRef.current &#x3D; deps;        unLoadRef.current &#x3D; effect(); &#x2F;&#x2F; 执行结果        return;      &#125;      &#x2F;&#x2F; 如上文注释： @param target target should compare ref.current vs ref.current, dom vs dom, ()&#x3D;&gt;dom vs ()&#x3D;&gt;dom      &#x2F;&#x2F; 存在不等情况会执行赋值      if (        els.length !&#x3D;&#x3D; lastElementRef.current.length ||        !depsAreSame(els, lastElementRef.current) ||        !depsAreSame(deps, lastDepsRef.current)      ) &#123;        unLoadRef.current?.(); &#x2F;&#x2F; 执行        lastElementRef.current &#x3D; els;        lastDepsRef.current &#x3D; deps;        unLoadRef.current &#x3D; effect();      &#125;    &#125;);    &#x2F;&#x2F; 卸载    useUnmount(() &#x3D;&gt; &#123;      unLoadRef.current?.();      &#x2F;&#x2F; for react-refresh      hasInitRef.current &#x3D; false;    &#125;);  &#125;;  return useEffectWithTarget;&#125;;export default createEffectWithTarget;</code></pre><h2 id="useWhyDidYouUpdate"><a href="#useWhyDidYouUpdate" class="headerlink" title="useWhyDidYouUpdate"></a>useWhyDidYouUpdate</h2><p><a href="https://ahooks.js.org/zh-CN/hooks/use-why-did-you-update#params" target="_blank" >见</a></p><p>原理：useEffect 在组件更新时候会执行， 将之前的 props 存在 ref 上，之后会将所有的 key 比较，找到变更的 key 的 changedProps</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect, useRef &#125; from &quot;react&quot;;export type IProps &#x3D; Record&lt;string, any&gt;;export default function useWhyDidYouUpdate(  componentName: string,  props: IProps) &#123;  const prevProps &#x3D; useRef&lt;IProps&gt;(&#123;&#125;);  useEffect(() &#x3D;&gt; &#123;    if (prevProps.current) &#123;      const allKeys &#x3D; Object.keys(&#123; ...prevProps.current, ...props &#125;);      const changedProps: IProps &#x3D; &#123;&#125;;      allKeys.forEach((key) &#x3D;&gt; &#123;        if (!Object.is(prevProps.current[key], props[key])) &#123;          changedProps[key] &#x3D; &#123;            from: prevProps.current[key],            to: props[key],          &#125;;        &#125;      &#125;);      if (Object.keys(changedProps).length) &#123;        console.log(&quot;[why-did-you-update]&quot;, componentName, changedProps);      &#125;    &#125;    prevProps.current &#x3D; props;  &#125;);&#125;</code></pre><h2 id="useUrlState"><a href="#useUrlState" class="headerlink" title="useUrlState"></a>useUrlState</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemoizedFn, useUpdate &#125; from &quot;ahooks&quot;;import &#123; parse, stringify &#125; from &quot;query-string&quot;;import type &#123; ParseOptions, StringifyOptions &#125; from &quot;query-string&quot;;import &#123; useMemo, useRef &#125; from &quot;react&quot;;import type * as React from &quot;react&quot;;import * as tmp from &quot;react-router&quot;;&#x2F;&#x2F; ignore waring &#96;&quot;export &#39;useNavigate&#39; (imported as &#39;rc&#39;) was not found in &#39;react-router&#39;&#96;const rc &#x3D; tmp as any;export interface Options &#123;  navigateMode?: &quot;push&quot; | &quot;replace&quot;;  parseOptions?: ParseOptions;  stringifyOptions?: StringifyOptions;&#125;const baseParseConfig: ParseOptions &#x3D; &#123;  parseNumbers: false,  parseBooleans: false,&#125;;const baseStringifyConfig: StringifyOptions &#x3D; &#123;  skipNull: false,  skipEmptyString: false,&#125;;type UrlState &#x3D; Record&lt;string, any&gt;;const useUrlState &#x3D; &lt;S extends UrlState &#x3D; UrlState&gt;(  initialState?: S | (() &#x3D;&gt; S),  options?: Options) &#x3D;&gt; &#123;  type State &#x3D; Partial&lt;&#123; [key in keyof S]: any &#125;&gt;;  const &#123;    navigateMode &#x3D; &quot;push&quot;, &#x2F;&#x2F; 状态变更时切换 history 的方式    parseOptions,    stringifyOptions,  &#125; &#x3D; options || &#123;&#125;;  const mergedParseOptions &#x3D; &#123; ...baseParseConfig, ...parseOptions &#125;;  const mergedStringifyOptions &#x3D; &#123;    ...baseStringifyConfig,    ...stringifyOptions,  &#125;;  const location &#x3D; rc.useLocation();  &#x2F;&#x2F; react-router v5  const history &#x3D; rc.useHistory?.();  &#x2F;&#x2F; react-router v6  const navigate &#x3D; rc.useNavigate?.();  const update &#x3D; useUpdate();  const initialStateRef &#x3D; useRef(    typeof initialState &#x3D;&#x3D;&#x3D; &quot;function&quot;      ? (initialState as () &#x3D;&gt; S)()      : initialState || &#123;&#125;  );  &#x2F;&#x2F; 解析出 query  const queryFromUrl &#x3D; useMemo(() &#x3D;&gt; &#123;    return parse(location.search, mergedParseOptions);  &#125;, [location.search]);  &#x2F;&#x2F; 更改后的 query  const targetQuery: State &#x3D; useMemo(    () &#x3D;&gt; (&#123;      ...initialStateRef.current,      ...queryFromUrl,    &#125;),    [queryFromUrl]  );  const setState &#x3D; (s: React.SetStateAction&lt;State&gt;) &#x3D;&gt; &#123;    &#x2F;&#x2F; 如果是函数，则将上一个值，作为参数传入    const newQuery &#x3D; typeof s &#x3D;&#x3D;&#x3D; &quot;function&quot; ? s(targetQuery) : s;    &#x2F;&#x2F; 1. 如果 setState 后，search 没变化，就需要 update 来触发一次更新。比如 demo1 直接点击 clear，就需要 update 来触发更新。    &#x2F;&#x2F; 2. update 和 history 的更新会合并，不会造成多次更新    update(); &#x2F;&#x2F; 担心不更新    if (history) &#123;      history[navigateMode](&#123;        hash: location.hash,        search:          stringify(&#123; ...queryFromUrl, ...newQuery &#125;, mergedStringifyOptions) ||          &quot;?&quot;,      &#125;);    &#125;    if (navigate) &#123;      navigate(        &#123;          hash: location.hash,          search:            stringify(              &#123; ...queryFromUrl, ...newQuery &#125;,              mergedStringifyOptions            ) || &quot;?&quot;,        &#125;,        &#123;          replace: navigateMode &#x3D;&#x3D;&#x3D; &quot;replace&quot;,        &#125;      );    &#125;  &#125;;  return [targetQuery &#x2F;**url query 对象 *&#x2F;, useMemoizedFn(setState)] as const;&#125;;export default useUrlState;</code></pre><h2 id="useSafeState"><a href="#useSafeState" class="headerlink" title="useSafeState"></a>useSafeState</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>用法与 React.useState 完全一样，但是在组件卸载后异步回调内的 setState 不再执行，避免因组件卸载后更新状态而导致的内存泄漏。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useCallback, useState &#125; from &quot;react&quot;;import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;&#x2F;&#x2F; &gt; 获取当前组件是否已经卸载的 Hook。import useUnmountedRef from &quot;..&#x2F;useUnmountedRef&quot;;function useSafeState&lt;S&gt;(  initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];function useSafeState&lt;S &#x3D; undefined&gt;(): [  S | undefined,  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;];function useSafeState&lt;S&gt;(initialState?: S | (() &#x3D;&gt; S)) &#123;  const unmountedRef &#x3D; useUnmountedRef();  const [state, setState] &#x3D; useState(initialState);  const setCurrentState &#x3D; useCallback((currentState) &#x3D;&gt; &#123;    &#x2F;** if component is unmounted, stop update *&#x2F;    &#x2F;&#x2F; 组件卸载停止更新    if (unmountedRef.current) return;    setState(currentState);  &#125;, []);  return [state, setCurrentState] as const;&#125;export default useSafeState;</code></pre><h2 id="useGetState"><a href="#useGetState" class="headerlink" title="useGetState"></a>useGetState</h2><p>内部使用 <code>useRef</code> 缓存了值，在调用 <code>getState</code> 时候，将 ref 值返回.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;import &#123; useState, useRef, useCallback &#125; from &quot;react&quot;;type GetStateAction&lt;S&gt; &#x3D; () &#x3D;&gt; S;function useGetState&lt;S&gt;(  initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, GetStateAction&lt;S&gt;];function useGetState&lt;S &#x3D; undefined&gt;(): [  S | undefined,  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;,  GetStateAction&lt;S | undefined&gt;];function useGetState&lt;S&gt;(initialState?: S) &#123;  const [state, setState] &#x3D; useState(initialState);  const stateRef &#x3D; useRef(state);  stateRef.current &#x3D; state;  const getState &#x3D; useCallback(() &#x3D;&gt; stateRef.current, []);  return [state, setState, getState];&#125;export default useGetState;</code></pre><h2 id="useResetState"><a href="#useResetState" class="headerlink" title="useResetState"></a>useResetState</h2><p><code>initialState</code>的值，用于重置</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useState &#125; from &quot;react&quot;;import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;type ResetState &#x3D; () &#x3D;&gt; void;const useResetState &#x3D; &lt;S&gt;(  initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;, ResetState] &#x3D;&gt; &#123;  const [state, setState] &#x3D; useState(initialState);  const resetState &#x3D; useMemoizedFn(() &#x3D;&gt; &#123;    setState(initialState);  &#125;);  return [state, setState, resetState];&#125;;export default useResetState;</code></pre><h2 id="useRafState"><a href="#useRafState" class="headerlink" title="useRafState"></a>useRafState</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>只在 requestAnimationFrame callback 时更新 state，一般用于性能优化。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useCallback, useRef, useState &#125; from &quot;react&quot;;import type &#123; Dispatch, SetStateAction &#125; from &quot;react&quot;;import useUnmount from &quot;..&#x2F;useUnmount&quot;;function useRafState&lt;S&gt;(  initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];function useRafState&lt;S &#x3D; undefined&gt;(): [  S | undefined,  Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;];function useRafState&lt;S&gt;(initialState?: S | (() &#x3D;&gt; S)) &#123;  &#x2F;&#x2F; 先前调用window.requestAnimationFrame()方法时返回的 ID.  const ref &#x3D; useRef(0); &#x2F;&#x2F; requestID  const [state, setState] &#x3D; useState(initialState);  const setRafState &#x3D; useCallback((value: S | ((prevState: S) &#x3D;&gt; S)) &#x3D;&gt; &#123;    &#x2F;&#x2F; cancelAnimationFrame 取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。    cancelAnimationFrame(ref.current &#x2F;**requestID *&#x2F;);    ref.current &#x3D; requestAnimationFrame(() &#x3D;&gt; &#123;      setState(value);    &#125;);  &#125;, []);  &#x2F;&#x2F; 卸载，取消动画镇  useUnmount(() &#x3D;&gt; &#123;    cancelAnimationFrame(ref.current &#x2F;**requestID *&#x2F;);  &#125;);  return [state, setRafState] as const;&#125;export default useRafState;</code></pre><h2 id="usePrevious"><a href="#usePrevious" class="headerlink" title="usePrevious"></a>usePrevious</h2><p>先猜下，又用了 ref 进行缓存</p><p>悄悄源码</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useRef &#125; from &quot;react&quot;;export type ShouldUpdateFunc&lt;T&gt; &#x3D; (prev: T | undefined, next: T) &#x3D;&gt; boolean;const defaultShouldUpdate &#x3D; &lt;T&gt;(a?: T, b?: T) &#x3D;&gt; !Object.is(a, b); &#x2F;&#x2F; 默认比较function usePrevious&lt;T&gt;(  state: T,  shouldUpdate: ShouldUpdateFunc&lt;T&gt; &#x3D; defaultShouldUpdate): T | undefined &#123;  const prevRef &#x3D; useRef&lt;T&gt;(); &#x2F;&#x2F; 存前一个  const curRef &#x3D; useRef&lt;T&gt;(); &#x2F;&#x2F; 存当前，🤔，存当前的，相当于中介，如：把两瓶水交换，借助第三个瓶子  if (shouldUpdate(curRef.current, state)) &#123;    &#x2F;&#x2F; 不一样，更新值    prevRef.current &#x3D; curRef.current;    curRef.current &#x3D; state;  &#125;  return prevRef.current; &#x2F;&#x2F; 最终返回之前的值&#125;export default usePrevious;</code></pre><h2 id="useMap"><a href="#useMap" class="headerlink" title="useMap"></a>useMap</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useState &#125; from &quot;react&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;function useMap&lt;K, T&gt;(initialValue?: Iterable&lt;readonly [K, T]&gt;) &#123;  &#x2F;&#x2F; 初始值  const getInitValue &#x3D; () &#x3D;&gt; &#123;    return initialValue &#x3D;&#x3D;&#x3D; undefined ? new Map() : new Map(initialValue);  &#125;;  const [map, setMap] &#x3D; useState&lt;Map&lt;K, T&gt;&gt;(() &#x3D;&gt; getInitValue());  &#x2F;&#x2F; 设置， 新旧合并，新的属性会覆盖旧的  const set &#x3D; (key: K, entry: T) &#x3D;&gt; &#123;    setMap((prev) &#x3D;&gt; &#123;      const temp &#x3D; new Map(prev); &#x2F;&#x2F; 将之前的值拷贝，切断 temp 与 prev之间联系？      temp.set(key, entry);      return temp;    &#125;);  &#125;;  &#x2F;&#x2F; 完全重新赋值  const setAll &#x3D; (newMap: Iterable&lt;readonly [K, T]&gt;) &#x3D;&gt; &#123;    setMap(new Map(newMap));  &#125;;  &#x2F;&#x2F; 删除某个key对应的值  const remove &#x3D; (key: K) &#x3D;&gt; &#123;    setMap((prev) &#x3D;&gt; &#123;      const temp &#x3D; new Map(prev);      temp.delete(key);      return temp;    &#125;);  &#125;;  &#x2F;&#x2F; 重置，恢复为初始值  const reset &#x3D; () &#x3D;&gt; setMap(getInitValue());  &#x2F;&#x2F; 根据key返回值， map 是useState上的map  const get &#x3D; (key: K) &#x3D;&gt; map.get(key);  return [    map,    &#123;      &#x2F;&#x2F; 一些方法，包裹后，暴露出去      set: useMemoizedFn(set),      setAll: useMemoizedFn(setAll),      remove: useMemoizedFn(remove),      reset: useMemoizedFn(reset),      get: useMemoizedFn(get),    &#125;,  ] as const;&#125;export default useMap;</code></pre><h2 id="useSet"><a href="#useSet" class="headerlink" title="useSet"></a>useSet</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useState &#125; from &quot;react&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;function useSet&lt;K&gt;(initialValue?: Iterable&lt;K&gt;) &#123;  const getInitValue &#x3D; () &#x3D;&gt; &#123;    return initialValue &#x3D;&#x3D;&#x3D; undefined ? new Set&lt;K&gt;() : new Set(initialValue);  &#125;;  const [set, setSet] &#x3D; useState&lt;Set&lt;K&gt;&gt;(() &#x3D;&gt; getInitValue());  &#x2F;&#x2F; 已经有的，不会重复添加，set存值，保证唯一，没必要重复插入  const add &#x3D; (key: K) &#x3D;&gt; &#123;    if (set.has(key)) &#123;      return;    &#125;    setSet((prevSet) &#x3D;&gt; &#123;      const temp &#x3D; new Set(prevSet);      temp.add(key);      return temp;    &#125;);  &#125;;  &#x2F;&#x2F; 没有不继续执行，有继续之前，将prevSet，生成一个新的Set,然后删除key,并返回新的map，  const remove &#x3D; (key: K) &#x3D;&gt; &#123;    if (!set.has(key)) &#123;      return;    &#125;    setSet((prevSet) &#x3D;&gt; &#123;      const temp &#x3D; new Set(prevSet);      temp.delete(key);      return temp;    &#125;);  &#125;;  &#x2F;&#x2F; 重置到最初值  const reset &#x3D; () &#x3D;&gt; setSet(getInitValue());  return [    set,    &#123;      &#x2F;&#x2F; 方法，缓存下      add: useMemoizedFn(add),      remove: useMemoizedFn(remove),      reset: useMemoizedFn(reset),    &#125;,  ] as const;&#125;export default useSet;</code></pre><p>useMap&#x2F;useSet 返回的都是新的 Map&#x2F;Set 对象, 所以每次变化都会触发更新。之前开发中进行突变，不会触发页面更新</p><h2 id="useMemoizedFn-1"><a href="#useMemoizedFn-1" class="headerlink" title="useMemoizedFn"></a>useMemoizedFn</h2><p>持久化 function 的 Hook，理论上，可以使用 useMemoizedFn 完全代替 useCallback。</p><p>在某些场景中，我们需要使用 useCallback 来记住一个函数，但是在第二个参数 deps 变化时，会重新生成函数，导致函数地址变化。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const [state, setState] &#x3D; useState(&quot;&quot;);&#x2F;&#x2F; 在 state 变化时，func 地址会变化const func &#x3D; useCallback(() &#x3D;&gt; &#123;  console.log(state);&#125;, [state]);</code></pre><p>使用 useMemoizedFn，可以省略第二个参数 deps，<span style="color: red">同时保证函数地址永远不会变化</span>。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>如果以地址变化的更新，不可用 <code>useMemoizedFn</code></p></div><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const [state, setState] &#x3D; useState(&quot;&quot;);&#x2F;&#x2F; func 地址永远不会变化const func &#x3D; useMemoizedFn(() &#x3D;&gt; &#123;  console.log(state);&#125;);</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useMemo, useRef &#125; from &quot;react&quot;;import &#123; isFunction &#125; from &quot;..&#x2F;utils&quot;;import isDev from &quot;..&#x2F;utils&#x2F;isDev&quot;;type noop &#x3D; (this: any, ...args: any[]) &#x3D;&gt; any;type PickFunction&lt;T extends noop&gt; &#x3D; (  this: ThisParameterType&lt;T&gt;,  ...args: Parameters&lt;T&gt;) &#x3D;&gt; ReturnType&lt;T&gt;;function useMemoizedFn&lt;T extends noop&gt;(fn: T) &#123;  if (isDev) &#123;    if (!isFunction(fn)) &#123;      console.error(        &#96;useMemoizedFn expected parameter is a function, got $&#123;typeof fn&#125;&#96;      );    &#125;  &#125;  &#x2F;&#x2F; 下面这两行代码看上去确实有点奇怪  &#x2F;&#x2F; 为了解决 usePersistFn（useMemoizedFn）不能兼容react devtool  const fnRef &#x3D; useRef&lt;T&gt;(fn);  &#x2F;&#x2F; why not write &#96;fnRef.current &#x3D; fn&#96;?  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;728  fnRef.current &#x3D; useMemo(() &#x3D;&gt; fn, [fn]);  &#x2F;&#x2F; 缓存函数地址  const memoizedFn &#x3D; useRef&lt;PickFunction&lt;T&gt;&gt;();  if (!memoizedFn.current) &#123;    memoizedFn.current &#x3D; function (this, ...args) &#123;      &#x2F;&#x2F; 没有函数的时候，这里重新生成了一个函数，并将执行结果作为新函数的结果      return fnRef.current.apply(this, args); &#x2F;&#x2F; fnRef.current, 从缓存里取的    &#125;;  &#125;  return memoizedFn.current as T;&#125;export default useMemoizedFn;</code></pre><h2 id="useFocusWithin"><a href="#useFocusWithin" class="headerlink" title="useFocusWithin"></a>useFocusWithin</h2><p>监听当前焦点是否在某个区域之内，同 css 属性 :focus-within</p><p>可用于： 聚焦发送请求，以保证用户获取最新数据</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useState &#125; from &quot;react&quot;;import useEventListener from &quot;..&#x2F;useEventListener&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;export interface Options &#123;  onFocus?: (e: FocusEvent) &#x3D;&gt; void;  onBlur?: (e: FocusEvent) &#x3D;&gt; void;  onChange?: (isFocusWithin: boolean) &#x3D;&gt; void;&#125;export default function useFocusWithin(target: BasicTarget, options?: Options) &#123;  const [isFocusWithin, setIsFocusWithin] &#x3D; useState(false);  const &#123; onFocus, onBlur, onChange &#125; &#x3D; options || &#123;&#125;;  useEventListener(    &quot;focusin&quot;,    (e: FocusEvent) &#x3D;&gt; &#123;      if (!isFocusWithin) &#123;        onFocus?.(e);        onChange?.(true);        setIsFocusWithin(true); &#x2F;&#x2F; 聚焦      &#125;    &#125;,    &#123;      target,    &#125;  );  useEventListener(    &quot;focusout&quot;,    (e: FocusEvent) &#x3D;&gt; &#123;      &#x2F;&#x2F; contains 原生      if (        isFocusWithin &amp;&amp;        !(e.currentTarget as Element)?.contains?.(e.relatedTarget as Element)      ) &#123;        onBlur?.(e);        onChange?.(false);        setIsFocusWithin(false); &#x2F;&#x2F; 失去焦点      &#125;    &#125;,    &#123;      target,    &#125;  );  return isFocusWithin;&#125;</code></pre><p>问题：我记得有个间隔多久之后，再次聚焦才发送请求的，之后看看是哪个 api</p><h2 id="useTitle"><a href="#useTitle" class="headerlink" title="useTitle"></a>useTitle</h2><p>这个 api 在<code>nextjs</code>中或许不是那么好用，因为 nextjs 有自己的 api，<code>useTitle</code>更新后，会被 nextjs<code>&lt;Title&gt;&lt;/Title&gt;</code>给覆盖掉</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect, useRef &#125; from &quot;react&quot;;import useUnmount from &quot;..&#x2F;useUnmount&quot;;import isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;export interface Options &#123;  restoreOnUnmount?: boolean;&#125;const DEFAULT_OPTIONS: Options &#x3D; &#123;  restoreOnUnmount: false,&#125;;function useTitle(title: string, options: Options &#x3D; DEFAULT_OPTIONS) &#123;  const titleRef &#x3D; useRef(isBrowser ? document.title : &quot;&quot;);  &#x2F;&#x2F; 额，这里在服务端可以拿到 document吗？如果拿不到会报错的，没加 isBrowser 判断，那么在服务端可以拿到  useEffect(() &#x3D;&gt; &#123;    document.title &#x3D; title;  &#125;, [title]);  useUnmount(() &#x3D;&gt; &#123;    &#x2F;&#x2F; restoreOnUnmount组件卸载时，是否恢复上一个页面标题    if (options.restoreOnUnmount) &#123;      &#x2F;&#x2F; 卸载恢复      document.title &#x3D; titleRef.current;    &#125;  &#125;);&#125;export default useTitle;</code></pre><h2 id="useFavicon"><a href="#useFavicon" class="headerlink" title="useFavicon"></a>useFavicon</h2><p>实现：link 标签更改&#x2F;动态创建标签放到 head 尾部</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect &#125; from &quot;react&quot;;&#x2F;&#x2F; shortcut icon 类型限制const ImgTypeMap &#x3D; &#123;  SVG: &quot;image&#x2F;svg+xml&quot;,  ICO: &quot;image&#x2F;x-icon&quot;,  GIF: &quot;image&#x2F;gif&quot;,  PNG: &quot;image&#x2F;png&quot;,&#125;;type ImgTypes &#x3D; keyof typeof ImgTypeMap;const useFavicon &#x3D; (href: string) &#x3D;&gt; &#123;  useEffect(() &#x3D;&gt; &#123;    if (!href) return;    &#x2F;&#x2F; 截取后缀判断是否满足    const cutUrl &#x3D; href.split(&quot;.&quot;);    const imgSuffix &#x3D; cutUrl[cutUrl.length - 1].toLocaleUpperCase() as ImgTypes;    &#x2F;&#x2F;存在获取，不存在    const link: HTMLLinkElement &#x3D;      document.querySelector(&quot;link[rel*&#x3D;&#39;icon&#39;]&quot;) ||      document.createElement(&quot;link&quot;);    link.type &#x3D; ImgTypeMap[imgSuffix];    link.href &#x3D; href;    link.rel &#x3D; &quot;shortcut icon&quot;;    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(link);  &#125;, [href]);&#125;;export default useFavicon;</code></pre><h2 id="useFullscreen"><a href="#useFullscreen" class="headerlink" title="useFullscreen"></a>useFullscreen</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useState &#125; from &quot;react&quot;;import screenfull from &quot;screenfull&quot;; &#x2F;&#x2F; @link https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;main&#x2F;index.jsimport useLatest from &quot;..&#x2F;useLatest&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;import useUnmount from &quot;..&#x2F;useUnmount&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;export interface Options &#123;  onExit?: () &#x3D;&gt; void;  onEnter?: () &#x3D;&gt; void;&#125;const useFullscreen &#x3D; (target: BasicTarget, options?: Options) &#x3D;&gt; &#123;  const &#123; onExit, onEnter &#125; &#x3D; options || &#123;&#125;;  &#x2F;&#x2F; 退出  const onExitRef &#x3D; useLatest(onExit);  &#x2F;&#x2F; 进入  const onEnterRef &#x3D; useLatest(onEnter);  &#x2F;&#x2F; 是否全屏  const [state, setState] &#x3D; useState(false);  const onChange &#x3D; () &#x3D;&gt; &#123;    if (screenfull.isEnabled) &#123;      &#x2F;&#x2F; 支持全屏      const &#123; isFullscreen &#125; &#x3D; screenfull;      if (isFullscreen) &#123;        onEnterRef.current?.();      &#125; else &#123;        screenfull.off(&quot;change&quot;, onChange);        onExitRef.current?.();      &#125;      setState(isFullscreen);    &#125;  &#125;;  const enterFullscreen &#x3D; () &#x3D;&gt; &#123;    const el &#x3D; getTargetElement(target);    if (!el) &#123;      return;    &#125;    if (screenfull.isEnabled) &#123;      &#x2F;&#x2F; 支持全屏      try &#123;        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;991e917bffc818c5367186c6ec5e70ae7a37cfc5&#x2F;index.js#L80        screenfull.request(el);        screenfull.on(&quot;change&quot;, onChange);      &#125; catch (error) &#123;        console.error(error);      &#125;    &#125;  &#125;;  const exitFullscreen &#x3D; () &#x3D;&gt; &#123;    &#x2F;&#x2F; 支持全屏    if (screenfull.isEnabled) &#123;      &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sindresorhus&#x2F;screenfull&#x2F;blob&#x2F;991e917bffc818c5367186c6ec5e70ae7a37cfc5&#x2F;index.js#L96      &#x2F;&#x2F; 奇怪了，这里怎么返回了一个promise      screenfull.exit();    &#125;  &#125;;  const toggleFullscreen &#x3D; () &#x3D;&gt; &#123;    if (state) &#123;      exitFullscreen();    &#125; else &#123;      enterFullscreen();    &#125;  &#125;;  useUnmount(() &#x3D;&gt; &#123;    if (screenfull.isEnabled) &#123;      &#x2F;&#x2F; 支持全屏      screenfull.off(&quot;change&quot;, onChange);    &#125;  &#125;);  return [    state,    &#123;      enterFullscreen: useMemoizedFn(enterFullscreen),      exitFullscreen: useMemoizedFn(exitFullscreen),      toggleFullscreen: useMemoizedFn(toggleFullscreen),      isEnabled: screenfull.isEnabled,    &#125;,  ] as const;&#125;;export default useFullscreen;</code></pre><h2 id="screenfull"><a href="#screenfull" class="headerlink" title="screenfull"></a>screenfull</h2><p><a href="https://github.com/sindresorhus/screenfull/blob/991e917bffc818c5367186c6ec5e70ae7a37cfc5/index.js#L50">https://github.com/sindresorhus/screenfull/blob/991e917bffc818c5367186c6ec5e70ae7a37cfc5/index.js#L50</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const nativeAPI &#x3D; (() &#x3D;&gt; &#123;  if (typeof document &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;    return false;  &#125;  const unprefixedMethods &#x3D; methodMap[0];  const returnValue &#x3D; &#123;&#125;;  for (const methodList of methodMap &#x2F;**二维数组 *&#x2F;) &#123;    const exitFullscreenMethod &#x3D; methodList?.[1];    if (exitFullscreenMethod in document) &#123;      &#x2F;&#x2F; 支持的方法，都给提取出来，放到 nativeAPI,之后使用nativeAPI上的方法      for (const [index, method] of methodList.entries()) &#123;        returnValue[unprefixedMethods[index]] &#x3D; method;      &#125;      return returnValue;    &#125;  &#125;  return false;&#125;)();&#x2F;&#x2F; ....let screenfull &#x3D; &#123;  &#x2F;&#x2F; eslint-disable-next-line default-param-last  request(element &#x3D; document.documentElement, options) &#123;&#125;,  &#x2F;&#x2F; 退出全屏  exit() &#123;&#125;,  &#x2F;&#x2F; 全屏&#x2F;非全屏切换  toggle(element, options) &#123;&#125;,  &#x2F;&#x2F; 更改  onchange(callback) &#123;&#125;,  &#x2F;&#x2F; 错误处理  onerror(callback) &#123;&#125;,  &#x2F;&#x2F; 事件监听  on(event, callback) &#123;&#125;,  &#x2F;&#x2F; 移除监听  off(event, callback) &#123;&#125;,  &#x2F;&#x2F; 原生api  raw: nativeAPI,&#125;;&#x2F;&#x2F; 扩展三个方法Object.defineProperties(screenfull, &#123;  isFullscreen: &#123;    get: () &#x3D;&gt; Boolean(document[nativeAPI.fullscreenElement]),  &#125;,  element: &#123;    enumerable: true,    get: () &#x3D;&gt; document[nativeAPI.fullscreenElement] ?? undefined,  &#125;,  isEnabled: &#123;    enumerable: true,    &#x2F;&#x2F; Coerce to boolean in case of old WebKit.    get: () &#x3D;&gt; Boolean(document[nativeAPI.fullscreenEnabled]),  &#125;,&#125;);&#x2F;&#x2F; nativeAPI为&#123;&#125; , 不支持原生 isEnabled 为 false, 所以在用screenfull上api时候都要先用isEnabled判断下if (!nativeAPI) &#123;  screenfull &#x3D; &#123; isEnabled: false &#125;;&#125;export default screenfull;</code></pre><h2 id="useExternal"><a href="#useExternal" class="headerlink" title="useExternal"></a>useExternal</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>动态注入 JS 或 CSS 资源，useExternal 可以保证资源全局唯一。</p></blockquote><p>实现原理：通过 <code>useEffect</code>,deps 不改变，逻辑不会重复执行的特点</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;export interface Options &#123;  type?: &quot;js&quot; | &quot;css&quot;;  js?: Partial&lt;HTMLScriptElement&gt;;  css?: Partial&lt;HTMLStyleElement&gt;;&#125;&#x2F;&#x2F; &#123;[path]: count&#125;&#x2F;&#x2F; remove external when no usedconst EXTERNAL_USED_COUNT: Record&lt;string, number&gt; &#x3D; &#123;&#125;;export type Status &#x3D; &quot;unset&quot; | &quot;loading&quot; | &quot;ready&quot; | &quot;error&quot;;interface loadResult &#123;  ref: Element;  status: Status;&#125;&#x2F;&#x2F; 加载jsconst loadScript &#x3D; (path: string, props &#x3D; &#123;&#125;): loadResult &#x3D;&gt; &#123;  const script &#x3D; document.querySelector(&#96;script[src&#x3D;&quot;$&#123;path&#125;&quot;]&#96;);  if (!script) &#123;    const newScript &#x3D; document.createElement(&quot;script&quot;);    newScript.src &#x3D; path;    Object.keys(props).forEach((key) &#x3D;&gt; &#123;      newScript[key] &#x3D; props[key];    &#125;);    newScript.setAttribute(&quot;data-status&quot;, &quot;loading&quot;);    document.body.appendChild(newScript);    return &#123;      ref: newScript,      status: &quot;loading&quot;,    &#125;;  &#125;  return &#123;    ref: script,    status: (script.getAttribute(&quot;data-status&quot;) as Status) || &quot;ready&quot;,  &#125;;&#125;;&#x2F;&#x2F; 加载cssconst loadCss &#x3D; (path: string, props &#x3D; &#123;&#125;): loadResult &#x3D;&gt; &#123;  const css &#x3D; document.querySelector(&#96;link[href&#x3D;&quot;$&#123;path&#125;&quot;]&#96;);  if (!css) &#123;    const newCss &#x3D; document.createElement(&quot;link&quot;);    newCss.rel &#x3D; &quot;stylesheet&quot;;    newCss.href &#x3D; path;    Object.keys(props).forEach((key) &#x3D;&gt; &#123;      newCss[key] &#x3D; props[key];    &#125;);    &#x2F;&#x2F; IE9+    const isLegacyIECss &#x3D; &quot;hideFocus&quot; in newCss;    &#x2F;&#x2F; use preload in IE Edge (to detect load errors)    if (isLegacyIECss &amp;&amp; newCss.relList) &#123;      newCss.rel &#x3D; &quot;preload&quot;;      newCss.as &#x3D; &quot;style&quot;;    &#125;    newCss.setAttribute(&quot;data-status&quot;, &quot;loading&quot;);    document.head.appendChild(newCss);    return &#123;      ref: newCss,      status: &quot;loading&quot;,    &#125;;  &#125;  return &#123;    ref: css,    status: (css.getAttribute(&quot;data-status&quot;) as Status) || &quot;ready&quot;,  &#125;;&#125;;const useExternal &#x3D; (path?: string, options?: Options) &#x3D;&gt; &#123;  const [status, setStatus] &#x3D; useState&lt;Status&gt;(path ? &quot;loading&quot; : &quot;unset&quot;);  const ref &#x3D; useRef&lt;Element&gt;();  useEffect(() &#x3D;&gt; &#123;    if (!path) &#123;      &#x2F;&#x2F; 没有资源，直接拦截掉      setStatus(&quot;unset&quot;);      return;    &#125;    const pathname &#x3D; path.replace(&#x2F;[|#].*$&#x2F;, &quot;&quot;);    &#x2F;&#x2F; css    if (      options?.type &#x3D;&#x3D;&#x3D; &quot;css&quot; ||      (!options?.type &amp;&amp; &#x2F;(^css!|\.css$)&#x2F;.test(pathname))    ) &#123;      const result &#x3D; loadCss(path, options?.css);      ref.current &#x3D; result.ref;      setStatus(result.status);      &#x2F;&#x2F; js    &#125; else if (      options?.type &#x3D;&#x3D;&#x3D; &quot;js&quot; ||      (!options?.type &amp;&amp; &#x2F;(^js!|\.js$)&#x2F;.test(pathname))    ) &#123;      const result &#x3D; loadScript(path, options?.js);      ref.current &#x3D; result.ref;      setStatus(result.status);    &#125; else &#123;      &#x2F;&#x2F; 其他情况不处理      &#x2F;&#x2F; do nothing      console.error(        &quot;Cannot infer the type of external resource, and please provide a type (&#39;js&#39; | &#39;css&#39;). &quot; +          &quot;Refer to the https:&#x2F;&#x2F;ahooks.js.org&#x2F;hooks&#x2F;dom&#x2F;use-external&#x2F;#options&quot;      );    &#125;    &#x2F;&#x2F; 非js&#x2F;css，这里会阻止掉继续执行    if (!ref.current) &#123;      return;    &#125;    if (EXTERNAL_USED_COUNT[path] &#x3D;&#x3D;&#x3D; undefined) &#123;      EXTERNAL_USED_COUNT[path] &#x3D; 1;    &#125; else &#123;      EXTERNAL_USED_COUNT[path] +&#x3D; 1;    &#125;    const handler &#x3D; (event: Event) &#x3D;&gt; &#123;      const targetStatus &#x3D; event.type &#x3D;&#x3D;&#x3D; &quot;load&quot; ? &quot;ready&quot; : &quot;error&quot;;      ref.current?.setAttribute(&quot;data-status&quot;, targetStatus);      setStatus(targetStatus);    &#125;;    &#x2F;&#x2F; 监听资源加载情况    ref.current.addEventListener(&quot;load&quot;, handler);    ref.current.addEventListener(&quot;error&quot;, handler);    &#x2F;&#x2F; 卸载    return () &#x3D;&gt; &#123;      ref.current?.removeEventListener(&quot;load&quot;, handler);      ref.current?.removeEventListener(&quot;error&quot;, handler);      EXTERNAL_USED_COUNT[path] -&#x3D; 1;      if (EXTERNAL_USED_COUNT[path] &#x3D;&#x3D;&#x3D; 0) &#123;        ref.current?.remove(); &#x2F;&#x2F; 这里通过remove方法移除 对应的dom      &#125;      ref.current &#x3D; undefined;    &#125;;  &#125;, [path]);  return status;&#125;;export default useExternal;</code></pre><p><code>dom.remove()</code>移除 dom 测试</p><img src="http://t-blog-images.aijs.top/img/202209011131253.gif" /><h2 id="useHover"><a href="#useHover" class="headerlink" title="useHover"></a>useHover</h2><p>监听 DOM 元素是否有鼠标悬停。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useBoolean from &quot;..&#x2F;useBoolean&quot;;import useEventListener from &quot;..&#x2F;useEventListener&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;export interface Options &#123;  onEnter?: () &#x3D;&gt; void;  onLeave?: () &#x3D;&gt; void;  onChange?: (isHovering: boolean) &#x3D;&gt; void;&#125;export default (target: BasicTarget, options?: Options): boolean &#x3D;&gt; &#123;  const &#123; onEnter, onLeave, onChange &#125; &#x3D; options || &#123;&#125;;  const [state, &#123; setTrue, setFalse &#125;] &#x3D; useBoolean(false);  &#x2F;&#x2F; 监听鼠标进入  useEventListener(    &quot;mouseenter&quot;,    () &#x3D;&gt; &#123;      onEnter?.();      setTrue();      onChange?.(true);    &#125;,    &#123;      target,    &#125;  );  &#x2F;&#x2F; 监听鼠标离开  useEventListener(    &quot;mouseleave&quot;,    () &#x3D;&gt; &#123;      onLeave?.();      setFalse();      onChange?.(false);    &#125;,    &#123;      target,    &#125;  );  &#x2F;&#x2F; isHovering 鼠标元素是否处于 hover  return state;&#125;;</code></pre><h2 id="useInViewport"><a href="#useInViewport" class="headerlink" title="useInViewport"></a>useInViewport</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>观察元素是否在可见区域，以及元素可见比例。更多信息参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" >Intersection Observer API</a>。</p></blockquote><details class="custom-details"><summary>IntersectionObserver</summary><p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Intersection Observer API 提供了一种异步检测目标元素与祖先元素或 viewport 相交情况变化的方法。</p><p>过去，要检测一个元素是否可见或者两个元素是否相交并不容易，很多解决办法不可靠或性能很差。然而，随着互联网的发展，这种需求却与日俱增，比如，下面这些情况都需要用到相交检测：</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li><li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>假如有一个无限滚动的网页，开发者使用了一个第三方库来管理整个页面的广告，又用了另外一个库来实现消息盒子和点赞，并且页面有很多动画（译注：动画往往意味着较高的性能消耗）。两个库都有自己的相交检测程序，都运行在主线程里，<span style="color: red">而网站的开发者对这些库的内部实现知之甚少，所以并未意识到有什么问题</span>。但当用户滚动页面时，这些相交检测程序就会在页面滚动回调函数里不停触发调用，造成性能问题，体验效果让人失望。</p></blockquote><p><code>Intersection observer</code> 的概念和用法<br><code>Intersection Observer</code> API 允许你配置一个回调函数，当以下情况发生时会被调用</p><p>每当目标 (target) 元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根 (root)。<br>Observer 第一次监听目标元素的时候<br>通常，您需要关注文档最接近的可滚动祖先元素的交集更改，如果元素不是可滚动元素的后代，则默认为设备视窗。如果要观察相对于根 (root) 元素的交集，请指定根 (root) 元素为 null。</p><p>无论您是使用视口还是其他元素作为根，API 都以相同的方式工作，只要目标元素的可见性发生变化，就会执行您提供的回调函数，以便它与所需的交叉点交叉。</p><p>目标 (target) 元素与根 (root) 元素之间的交叉度是交叉比 (intersection ratio)。这是目标 (target) 元素相对于根 (root) 的交集百分比的表示，它的取值在 0.0 和 1.0 之间。</p><p>创建一个 <code>intersection observer</code><br>创建一个 IntersectionObserver 对象，并传入相应参数和回调用函数，该回调函数将会在目标 (target) 元素和根 (root) 元素的交集大小超过阈值 (threshold) 规定的大小时候被执行。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let options &#x3D; &#123;  root: document.querySelector(&quot;#scrollArea&quot;),  rootMargin: &quot;0px&quot;,  threshold: 1.0,&#125;;let observer &#x3D; new IntersectionObserver(callback, options);</code></pre><p>阈值为 1.0 意味着目标元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。</p><p><strong>Intersection observer options</strong><br>传递到 IntersectionObserver() 构造函数的 options 对象，允许您控制观察者的回调函数的被调用时的环境。它有以下字段：</p><p><strong>root</strong><br>指定根 (root) 元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为 null，则默认为浏览器视窗。</p><p><strong>rootMargin</strong><br>根 (root) 元素的外边距。类似于 CSS 中的 margin 属性，比如 “10px 20px 30px 40px” (top, right, bottom, left)。如果有指定 root 参数，则 rootMargin 也可以使用百分比来取值。该属性值是用作 root 元素和 target 发生交集时候的计算交集的区域范围，使用该属性可以控制 root 元素每一边的收缩或者扩张。默认值为 0。</p><p><strong>threshold</strong><br>可以是单一的 number 也可以是 number 数组，target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。如果你只是想要探测当 target 元素的在 root 元素中的可见性超过 50% 的时候，你可以指定该属性值为 0.5。如果你想要 target 元素在 root 元素的可见程度每多 25% 就执行一次回调，那么你可以指定一个数组 [0, 0.25, 0.5, 0.75, 1]。默认值是 0 (意味着只要有一个 target 像素出现在 root 元素中，回调函数将会被执行)。该值为 1.0 含义是当 target 完全出现在 root 元素中时候 回调才会被执行。</p><p><strong>Targeting an element to be observed</strong><br>创建一个 observer 后需要给定一个目标元素进行观察。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let target &#x3D; document.querySelector(&quot;#listItem&quot;);observer.observe(target);</code></pre><p>每当目标满足该 <code>IntersectionObserver</code> 指定的 <code>threshold</code> 值，回调被调用。</p><p>只要目标满足为 <code>IntersectionObserver</code> 指定的阈值，就会调用回调。回调接收 <code>IntersectionObserverEntry</code> 对象和观察者的列表：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let callback &#x3D; (entries, observer) &#x3D;&gt; &#123;  entries.forEach((entry) &#x3D;&gt; &#123;    &#x2F;&#x2F; Each entry describes an intersection change for one observed target element:    &#x2F;&#x2F; entry.boundingClientRect    &#x2F;&#x2F; entry.intersectionRatio    &#x2F;&#x2F; entry.intersectionRect    &#x2F;&#x2F; entry.isIntersecting    &#x2F;&#x2F; entry.rootBounds    &#x2F;&#x2F; entry.target    &#x2F;&#x2F; entry.time  &#125;);&#125;;</code></pre><p>请留意，<span style="color: red">你注册的回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 Window.requestIdleCallback() 方法</span>。</p></p></details><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &quot;intersection-observer&quot;;import &#123; useState &#125; from &quot;react&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;export interface Options &#123;  rootMargin?: string;  threshold?: number | number[];  root?: BasicTarget&lt;Element&gt;;&#125;function useInViewport(target: BasicTarget, options?: Options) &#123;  &#x2F;&#x2F; inViewport是否可见  const [state, setState] &#x3D; useState&lt;boolean&gt;();  &#x2F;&#x2F; ratio当前可见比例，在每次到达 options.threshold 设置节点时更新  const [ratio, setRatio] &#x3D; useState&lt;number&gt;();  useEffectWithTarget(    () &#x3D;&gt; &#123;      const el &#x3D; getTargetElement(target);      if (!el) &#123;        return;      &#125;      const observer &#x3D; new IntersectionObserver(        (entries) &#x3D;&gt; &#123;          for (const entry of entries) &#123;            setRatio(entry.intersectionRatio);            setState(entry.isIntersecting);          &#125;        &#125;,        &#123;          ...options,          root: getTargetElement(options?.root),        &#125;      );      observer.observe(el);      return () &#x3D;&gt; &#123;        observer.disconnect();      &#125;;    &#125;,    [],    target  );  return [state, ratio] as const;&#125;export default useInViewport;</code></pre><h2 id="useMutationObserver"><a href="#useMutationObserver" class="headerlink" title="useMutationObserver"></a>useMutationObserver</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useDeepCompareEffectWithTarget from &quot;..&#x2F;utils&#x2F;useDeepCompareWithTarget&quot;;import useLatest from &quot;..&#x2F;useLatest&quot;;const useMutationObserver &#x3D; (  callback: MutationCallback,  target: BasicTarget,  options: MutationObserverInit &#x3D; &#123;&#125;): void &#x3D;&gt; &#123;  &#x2F;&#x2F; 拿到最新的回调函数，useLatest内部使用useRef实现  const callbackRef &#x3D; useLatest(callback);  useDeepCompareEffectWithTarget(    () &#x3D;&gt; &#123;      const element &#x3D; getTargetElement(target); &#x2F;&#x2F; 被观察的dom对象      if (!element) &#123;        return;      &#125;      &#x2F;&#x2F; 实例化一个（突变观察者）观察对象      const observer &#x3D; new MutationObserver(callbackRef.current);      &#x2F;&#x2F; 开始观察      observer.observe(element, options);      &#x2F;&#x2F; 卸载停止观察      return () &#x3D;&gt; &#123;        if (observer) &#123;          observer.disconnect();        &#125;      &#125;;    &#125;,    [options],    target  );&#125;;export default useMutationObserver;</code></pre><details class="custom-details"><summary>MutationObserver</summary><p><code>MutationObserver</code> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p><p><strong>构造函数</strong><br>MutationObserver()<br>创建并返回一个新的 MutationObserver 它会在指定的 DOM 发生变化时被调用。</p><p><strong>方法</strong><br>disconnect()<br>阻止 MutationObserver 实例继续接收的通知，直到再次调用其 observe() 方法，该观察者对象包含的回调函数都不会再被调用。</p><p>observe()<br>配置 MutationObserver 在 DOM 更改匹配给定选项时，通过其回调函数开始接收通知。</p><p>takeRecords()<br>从 MutationObserver 的通知队列中删除所有待处理的通知，并将它们返回到 MutationRecord 对象的新 Array 中。</p><p>示例改编自 <a href="https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/" target="_blank" >这篇博客</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 选择需要观察变动的节点const targetNode &#x3D; document.getElementById(&quot;some-id&quot;);&#x2F;&#x2F; 观察器的配置（需要观察什么变动）const config &#x3D; &#123; attributes: true, childList: true, subtree: true &#125;;&#x2F;&#x2F; 当观察到变动时执行的回调函数const callback &#x3D; function (mutationsList, observer) &#123;  &#x2F;&#x2F; Use traditional &#39;for loops&#39; for IE 11  for (let mutation of mutationsList) &#123;    if (mutation.type &#x3D;&#x3D;&#x3D; &quot;childList&quot;) &#123;      console.log(&quot;A child node has been added or removed.&quot;);    &#125; else if (mutation.type &#x3D;&#x3D;&#x3D; &quot;attributes&quot;) &#123;      console.log(&quot;The &quot; + mutation.attributeName + &quot; attribute was modified.&quot;);    &#125;  &#125;&#125;;&#x2F;&#x2F; 创建一个观察器实例并传入回调函数const observer &#x3D; new MutationObserver(callback);&#x2F;&#x2F; 以上述配置开始观察目标节点observer.observe(targetNode, config);&#x2F;&#x2F; 之后，可停止观察observer.disconnect();</code></pre></details><h2 id="useKeyPress【不是很理解】"><a href="#useKeyPress【不是很理解】" class="headerlink" title="useKeyPress【不是很理解】"></a>useKeyPress【不是很理解】</h2><p>代码有点长，也不是很重要</p><details class="custom-details"><summary>useKeyPress 源码</summary><p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useLatest from &quot;..&#x2F;useLatest&quot;;import &#123; isFunction, isNumber, isString &#125; from &quot;..&#x2F;utils&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useDeepCompareEffectWithTarget from &quot;..&#x2F;utils&#x2F;useDeepCompareWithTarget&quot;;export type KeyPredicate &#x3D; (event: KeyboardEvent) &#x3D;&gt; boolean;export type keyType &#x3D; number | string;export type KeyFilter &#x3D;  | keyType  | keyType[]  | ((event: KeyboardEvent) &#x3D;&gt; boolean);export type EventHandler &#x3D; (event: KeyboardEvent) &#x3D;&gt; void;export type KeyEvent &#x3D; &quot;keydown&quot; | &quot;keyup&quot;;export type Target &#x3D; BasicTarget&lt;HTMLElement | Document | Window&gt;;export type Options &#x3D; &#123;  events?: KeyEvent[];  target?: Target;  exactMatch?: boolean;&#125;;&#x2F;&#x2F; 键盘事件 keyCode 别名const aliasKeyCodeMap &#x3D; &#123;  &quot;0&quot;: 48,  &quot;1&quot;: 49,  &quot;2&quot;: 50,  &quot;3&quot;: 51,  &quot;4&quot;: 52,  &quot;5&quot;: 53,  &quot;6&quot;: 54,  &quot;7&quot;: 55,  &quot;8&quot;: 56,  &quot;9&quot;: 57,  backspace: 8,  tab: 9,  enter: 13,  shift: 16,  ctrl: 17,  alt: 18,  pausebreak: 19,  capslock: 20,  esc: 27,  space: 32,  pageup: 33,  pagedown: 34,  end: 35,  home: 36,  leftarrow: 37,  uparrow: 38,  rightarrow: 39,  downarrow: 40,  insert: 45,  delete: 46,  a: 65,  b: 66,  c: 67,  d: 68,  e: 69,  f: 70,  g: 71,  h: 72,  i: 73,  j: 74,  k: 75,  l: 76,  m: 77,  n: 78,  o: 79,  p: 80,  q: 81,  r: 82,  s: 83,  t: 84,  u: 85,  v: 86,  w: 87,  x: 88,  y: 89,  z: 90,  leftwindowkey: 91,  rightwindowkey: 92,  selectkey: 93,  numpad0: 96,  numpad1: 97,  numpad2: 98,  numpad3: 99,  numpad4: 100,  numpad5: 101,  numpad6: 102,  numpad7: 103,  numpad8: 104,  numpad9: 105,  multiply: 106,  add: 107,  subtract: 109,  decimalpoint: 110,  divide: 111,  f1: 112,  f2: 113,  f3: 114,  f4: 115,  f5: 116,  f6: 117,  f7: 118,  f8: 119,  f9: 120,  f10: 121,  f11: 122,  f12: 123,  numlock: 144,  scrolllock: 145,  semicolon: 186,  equalsign: 187,  comma: 188,  dash: 189,  period: 190,  forwardslash: 191,  graveaccent: 192,  openbracket: 219,  backslash: 220,  closebracket: 221,  singlequote: 222,&#125;;&#x2F;&#x2F; 修饰键const modifierKey &#x3D; &#123;  ctrl: (event: KeyboardEvent) &#x3D;&gt; event.ctrlKey,  shift: (event: KeyboardEvent) &#x3D;&gt; event.shiftKey,  alt: (event: KeyboardEvent) &#x3D;&gt; event.altKey,  meta: (event: KeyboardEvent) &#x3D;&gt; event.metaKey,&#125;;&#x2F;&#x2F; 根据 event 计算激活键数量function countKeyByEvent(event: KeyboardEvent) &#123;  const countOfModifier &#x3D; Object.keys(modifierKey).reduce((total, key) &#x3D;&gt; &#123;    if (modifierKey[key](event)) &#123;      return total + 1;    &#125;    return total;  &#125;, 0);  &#x2F;&#x2F; 16 17 18 91 92 是修饰键的 keyCode，如果 keyCode 是修饰键，那么激活数量就是修饰键的数量，如果不是，那么就需要 +1  return [16, 17, 18, 91, 92].includes(event.keyCode)    ? countOfModifier    : countOfModifier + 1;&#125;&#x2F;** * 判断按键是否激活 * @param [event: KeyboardEvent]键盘事件 * @param [keyFilter: any] 当前键 * @returns Boolean *&#x2F;function genFilterKey(  event: KeyboardEvent,  keyFilter: keyType,  exactMatch: boolean) &#123;  &#x2F;&#x2F; 浏览器自动补全 input 的时候，会触发 keyDown、keyUp 事件，但此时 event.key 等为空  if (!event.key) &#123;    return false;  &#125;  &#x2F;&#x2F; 数字类型直接匹配事件的 keyCode  if (isNumber(keyFilter)) &#123;    return event.keyCode &#x3D;&#x3D;&#x3D; keyFilter;  &#125;  &#x2F;&#x2F; 字符串依次判断是否有组合键  const genArr &#x3D; keyFilter.split(&quot;.&quot;);  let genLen &#x3D; 0;  for (const key of genArr) &#123;    &#x2F;&#x2F; 组合键    const genModifier &#x3D; &#x2F;** 修饰键*&#x2F; modifierKey[key];    &#x2F;&#x2F; keyCode 别名    const aliasKeyCode &#x3D;      &#x2F;**键盘事件 keyCode 别名*&#x2F; aliasKeyCodeMap[key.toLowerCase()];    if (      (genModifier &amp;&amp; genModifier(event)) ||      (aliasKeyCode &amp;&amp; aliasKeyCode &#x3D;&#x3D;&#x3D; event.keyCode)    ) &#123;      genLen++;    &#125;  &#125;  &#x2F;**   * 需要判断触发的键位和监听的键位完全一致，判断方法就是触发的键位里有且等于监听的键位   * genLen &#x3D;&#x3D;&#x3D; genArr.length 能判断出来触发的键位里有监听的键位   * countKeyByEvent(event) &#x3D;&#x3D;&#x3D; genArr.length 判断出来触发的键位数量里有且等于监听的键位数量   * 主要用来防止按组合键其子集也会触发的情况，例如监听 ctrl+a 会触发监听 ctrl 和 a 两个键的事件。   *&#x2F;  if (exactMatch) &#123;    return genLen &#x3D;&#x3D;&#x3D; genArr.length &amp;&amp; countKeyByEvent(event) &#x3D;&#x3D;&#x3D; genArr.length;  &#125;  return genLen &#x3D;&#x3D;&#x3D; genArr.length;&#125;&#x2F;** * 键盘输入预处理方法 * @param [keyFilter: any] 当前键 * @returns () &#x3D;&gt; Boolean *&#x2F;function genKeyFormatter(  keyFilter: KeyFilter,  exactMatch: boolean): KeyPredicate &#123;  if (isFunction(keyFilter)) &#123;    return keyFilter;  &#125;  if (isString(keyFilter) || isNumber(keyFilter)) &#123;    return (event: KeyboardEvent) &#x3D;&gt; genFilterKey(event, keyFilter, exactMatch);  &#125;  if (Array.isArray(keyFilter)) &#123;    return (event: KeyboardEvent) &#x3D;&gt;      keyFilter.some((item) &#x3D;&gt; genFilterKey(event, item, exactMatch));  &#125;  return keyFilter ? () &#x3D;&gt; true : () &#x3D;&gt; false;&#125;const defaultEvents: KeyEvent[] &#x3D; [&quot;keydown&quot;];function useKeyPress(  keyFilter: KeyFilter, &#x2F;&#x2F; 支持 keyCode、别名、组合键、数组，自定义函数  eventHandler: EventHandler, &#x2F;&#x2F; 回调函数  option?: Options &#x2F;&#x2F; 可选配置项) &#123;  const &#123; events &#x3D; defaultEvents, target, exactMatch &#x3D; false &#125; &#x3D; option || &#123;&#125;;  const eventHandlerRef &#x3D; useLatest(eventHandler); &#x2F;&#x2F; 缓存了下  const keyFilterRef &#x3D; useLatest(keyFilter); &#x2F;&#x2F; 缓存了下  useDeepCompareEffectWithTarget(    () &#x3D;&gt; &#123;      const el &#x3D; getTargetElement(target, window);      if (!el) &#123;        return;      &#125;      const callbackHandler &#x3D; (event: KeyboardEvent) &#x3D;&gt; &#123;        const genGuard: KeyPredicate &#x3D; genKeyFormatter(          keyFilterRef.current,          exactMatch        );        if (genGuard(event)) &#123;          &#x2F;&#x2F; 是不是匹配到了，匹配到了执行回调          return eventHandlerRef.current?.(event);        &#125;      &#125;;      for (const eventName of events) &#123;        el?.addEventListener?.(eventName, callbackHandler);      &#125;      return () &#x3D;&gt; &#123;        for (const eventName of events) &#123;          el?.removeEventListener?.(eventName, callbackHandler);        &#125;      &#125;;    &#125;,    [events],    target  );&#125;export default useKeyPress;</code></pre></p></details><h2 id="useDrop-amp-useDrag"><a href="#useDrop-amp-useDrag" class="headerlink" title="useDrop &amp; useDrag"></a>useDrop &amp; useDrag</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>处理元素拖拽的 Hook。</p><p>useDrop 可以单独使用来接收文件、文字和网址的拖拽。</p><p>useDrag 允许一个 DOM 节点被拖拽，需要配合 useDrop 使用。</p><p>向节点内触发粘贴动作也会被视为拖拽。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useLatest from &quot;..&#x2F;useLatest&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;export interface Options &#123;  onDragStart?: (event: React.DragEvent) &#x3D;&gt; void;  onDragEnd?: (event: React.DragEvent) &#x3D;&gt; void;&#125;const useDrag &#x3D; &lt;T&gt;(data: T, target: BasicTarget, options: Options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  const optionsRef &#x3D; useLatest(options);  useEffectWithTarget(    () &#x3D;&gt; &#123;      const targetElement &#x3D; getTargetElement(target);      &#x2F;&#x2F; 不具备增加监听的方法      if (!targetElement?.addEventListener) &#123;        return;      &#125;      const onDragStart &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;        optionsRef.current.onDragStart?.(event);        event.dataTransfer.setData(&quot;custom&quot;, JSON.stringify(data));      &#125;;      const onDragEnd &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;        optionsRef.current.onDragEnd?.(event);      &#125;;      targetElement.setAttribute(&quot;draggable&quot;, &quot;true&quot;);      &#x2F;&#x2F; 绑定      targetElement.addEventListener(&quot;dragstart&quot;, onDragStart as any);      targetElement.addEventListener(&quot;dragend&quot;, onDragEnd as any);      return () &#x3D;&gt; &#123;        &#x2F;&#x2F; 解绑定        targetElement.removeEventListener(&quot;dragstart&quot;, onDragStart as any);        targetElement.removeEventListener(&quot;dragend&quot;, onDragEnd as any);      &#125;;    &#125;,    [],    target  );&#125;;export default useDrag;</code></pre><p>useDrop</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useLatest from &quot;..&#x2F;useLatest&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;import &#123; useRef &#125; from &quot;react&quot;;export interface Options &#123;  onFiles?: (files: File[], event?: React.DragEvent) &#x3D;&gt; void;  onUri?: (url: string, event?: React.DragEvent) &#x3D;&gt; void;  onDom?: (content: any, event?: React.DragEvent) &#x3D;&gt; void;  onText?: (text: string, event?: React.ClipboardEvent) &#x3D;&gt; void;  onDragEnter?: (event?: React.DragEvent) &#x3D;&gt; void;  onDragOver?: (event?: React.DragEvent) &#x3D;&gt; void;  onDragLeave?: (event?: React.DragEvent) &#x3D;&gt; void;  onDrop?: (event?: React.DragEvent) &#x3D;&gt; void;  onPaste?: (event?: React.ClipboardEvent) &#x3D;&gt; void;&#125;const useDrop &#x3D; (target: BasicTarget, options: Options &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  const optionsRef &#x3D; useLatest(options);  &#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;26459269  const dragEnterTarget &#x3D; useRef&lt;any&gt;();  useEffectWithTarget(    () &#x3D;&gt; &#123;      const targetElement &#x3D; getTargetElement(target);      if (!targetElement?.addEventListener) &#123;        return;      &#125;      const onData &#x3D; (        dataTransfer: DataTransfer, &#x2F;&#x2F; 拖数据        event: React.DragEvent | React.ClipboardEvent      ) &#x3D;&gt; &#123;        const uri &#x3D; dataTransfer.getData(&quot;text&#x2F;uri-list&quot;);        const dom &#x3D; dataTransfer.getData(&quot;custom&quot;);        if (dom &amp;&amp; optionsRef.current.onDom) &#123;          let data &#x3D; dom;          try &#123;            data &#x3D; JSON.parse(dom);          &#125; catch (e) &#123;            data &#x3D; dom;          &#125;          optionsRef.current.onDom(data, event as React.DragEvent);          return;        &#125;        &#x2F;&#x2F; uri数据类型        if (uri &amp;&amp; optionsRef.current.onUri) &#123;          optionsRef.current.onUri(uri, event as React.DragEvent);          return;        &#125;        &#x2F;&#x2F; 文件数据类型        if (          dataTransfer.files &amp;&amp;          dataTransfer.files.length &amp;&amp;          optionsRef.current.onFiles        ) &#123;          optionsRef.current.onFiles(            Array.from(dataTransfer.files),            event as React.DragEvent          );          return;        &#125;        &#x2F;&#x2F; 文本数据类型        if (          dataTransfer.items &amp;&amp;          dataTransfer.items.length &amp;&amp;          optionsRef.current.onText        ) &#123;          dataTransfer.items[0].getAsString((text) &#x3D;&gt; &#123;            optionsRef.current.onText!(text, event as React.ClipboardEvent);          &#125;);        &#125;      &#125;;      &#x2F;&#x2F; 拖拽进入      const onDragEnter &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;        event.preventDefault();        event.stopPropagation();        dragEnterTarget.current &#x3D; event.target;        optionsRef.current.onDragEnter?.(event);      &#125;;      &#x2F;&#x2F; 拖拽中      const onDragOver &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;        event.preventDefault();        optionsRef.current.onDragOver?.(event);      &#125;;      &#x2F;&#x2F; 拖拽出去      const onDragLeave &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;        if (event.target &#x3D;&#x3D;&#x3D; dragEnterTarget.current) &#123;          optionsRef.current.onDragLeave?.(event);        &#125;      &#125;;      &#x2F;&#x2F; 放下      const onDrop &#x3D; (event: React.DragEvent) &#x3D;&gt; &#123;        event.preventDefault();        onData(event.dataTransfer, event);        optionsRef.current.onDrop?.(event);      &#125;;      &#x2F;&#x2F; 粘贴      const onPaste &#x3D; (event: React.ClipboardEvent) &#x3D;&gt; &#123;        onData(event.clipboardData, event);        optionsRef.current.onPaste?.(event);      &#125;;      targetElement.addEventListener(&quot;dragenter&quot;, onDragEnter as any);      targetElement.addEventListener(&quot;dragover&quot;, onDragOver as any);      targetElement.addEventListener(&quot;dragleave&quot;, onDragLeave as any);      targetElement.addEventListener(&quot;drop&quot;, onDrop as any);      targetElement.addEventListener(&quot;paste&quot;, onPaste as any);      return () &#x3D;&gt; &#123;        targetElement.removeEventListener(&quot;dragenter&quot;, onDragEnter as any);        targetElement.removeEventListener(&quot;dragover&quot;, onDragOver as any);        targetElement.removeEventListener(&quot;dragleave&quot;, onDragLeave as any);        targetElement.removeEventListener(&quot;drop&quot;, onDrop as any);        targetElement.removeEventListener(&quot;paste&quot;, onPaste as any);      &#125;;    &#125;,    [],    target  );&#125;;export default useDrop;</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/paste_event" target="_blank" >原生事件</a></p><h2 id="useDocumentVisibility"><a href="#useDocumentVisibility" class="headerlink" title="useDocumentVisibility"></a>useDocumentVisibility</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useState &#125; from &quot;react&quot;;import useEventListener from &quot;..&#x2F;useEventListener&quot;;import isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;type VisibilityState &#x3D; &quot;hidden&quot; | &quot;visible&quot; | &quot;prerender&quot; | undefined;const getVisibility &#x3D; () &#x3D;&gt; &#123;  if (!isBrowser) &#123;    return &quot;visible&quot;;  &#125;  return document.visibilityState;&#125;;function useDocumentVisibility(): VisibilityState &#123;  const [documentVisibility, setDocumentVisibility] &#x3D; useState(() &#x3D;&gt;    getVisibility()  );  useEventListener(    &quot;visibilitychange&quot;,    () &#x3D;&gt; &#123;      setDocumentVisibility(getVisibility());    &#125;,    &#123;      target: () &#x3D;&gt; document,    &#125;  );  return documentVisibility;&#125;export default useDocumentVisibility;</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState" target="_blank" >见</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>典型用法是防止当页面正在渲染时加载资源，或者当页面在背景中或窗口最小化时禁止某些活动。</p></blockquote><p>猜想：首页<code>prerender</code>后<code>visible</code>前，可以作为<code>performance</code>上报点？</p><h2 id="useResponsive"><a href="#useResponsive" class="headerlink" title="useResponsive"></a>useResponsive</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect, useState &#125; from &quot;react&quot;;import isBrowser from &quot;..&#x2F;utils&#x2F;isBrowser&quot;;type Subscriber &#x3D; () &#x3D;&gt; void;&#x2F;&#x2F; set类型，保证唯一性，因为useEffect可能存在重复执行的情况const subscribers &#x3D; new Set&lt;Subscriber&gt;();type ResponsiveConfig &#x3D; Record&lt;string, number&gt;;type ResponsiveInfo &#x3D; Record&lt;string, boolean&gt;;let info: ResponsiveInfo;let responsiveConfig: ResponsiveConfig &#x3D; &#123;  xs: 0,  sm: 576,  md: 768,  lg: 992,  xl: 1200,&#125;;&#x2F;&#x2F; 处理size变更function handleResize() &#123;  &#x2F;&#x2F; 这里缓存上次的info  const oldInfo &#x3D; info;  &#x2F;&#x2F; 这里计算新的info  calculate();  &#x2F;&#x2F; 前后发生变化，就会实行订阅的方法  if (oldInfo &#x3D;&#x3D;&#x3D; info) return;  &#x2F;&#x2F; 将收集到的观察者统统执行一遍  for (const subscriber of subscribers) &#123;    subscriber();  &#125;&#125;&#x2F;&#x2F; 避免重复执行let listening &#x3D; false;&#x2F;&#x2F; 计算function calculate() &#123;  const width &#x3D; window.innerWidth;  const newInfo &#x3D; &#123;&#125; as ResponsiveInfo;  let shouldUpdate &#x3D; false;  for (const key of Object.keys(responsiveConfig)) &#123;    newInfo[key] &#x3D; width &gt;&#x3D; responsiveConfig[key];    if (newInfo[key] !&#x3D;&#x3D; info[key]) &#123;      shouldUpdate &#x3D; true;    &#125;  &#125;  &#x2F;&#x2F; 需要更新  if (shouldUpdate) &#123;    info &#x3D; newInfo;  &#125;&#125;&#x2F;&#x2F; 配置响应&#x2F;&#x2F; 只需配置一次，请勿在组件中重复调用该方法&#x2F;&#x2F; 每次调用都会重新计算export function configResponsive(config: ResponsiveConfig) &#123;  responsiveConfig &#x3D; config;  if (info) calculate();&#125;export function useResponsive() &#123;  &#x2F;&#x2F; 客户端渲染  if (isBrowser &amp;&amp; !listening) &#123;    info &#x3D; &#123;&#125;;    calculate();    window.addEventListener(&quot;resize&quot;, handleResize);    listening &#x3D; true;  &#125;  const [state, setState] &#x3D; useState&lt;ResponsiveInfo&gt;(info);  useEffect(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 非客户端渲染，直接拦掉    if (!isBrowser) return;    &#x2F;&#x2F; 定义一个订阅者函数    const subscriber &#x3D; () &#x3D;&gt; &#123;      setState(info);    &#125;;    &#x2F;&#x2F; 加入订阅    subscribers.add(subscriber);    return () &#x3D;&gt; &#123;      subscribers.delete(subscriber);      if (subscribers.size &#x3D;&#x3D;&#x3D; 0) &#123;        window.removeEventListener(&quot;resize&quot;, handleResize);        listening &#x3D; false;      &#125;    &#125;;  &#125;, []);  return state;&#125;</code></pre><p>小插曲：github octotree loading</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">.octotree-show  .octotree-sidebar.octotree-github-sidebar  .octotree-spin  .octotree-spin--loader &#123;  width: 16px;  height: 16px;  border-radius: 50%;  border-width: 2px;  border-style: solid;  border-color: transparent rgb(106, 115, 125) rgb(106, 115, 125) transparent;  border-image: initial;  border-top: 2px solid transparent;  border-left: 2px solid transparent;  animation: 0.5s linear 0s infinite normal none running loading;&#125;</code></pre><h2 id="useScroll"><a href="#useScroll" class="headerlink" title="useScroll"></a>useScroll</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useRafState from &quot;..&#x2F;useRafState&quot;;import useLatest from &quot;..&#x2F;useLatest&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useEffectWithTarget from &quot;..&#x2F;utils&#x2F;useEffectWithTarget&quot;;type Position &#x3D; &#123; left: number; top: number &#125;;&#x2F;&#x2F; 我把 BasicTarget 拿过来放在这里，不会有太多割裂感&#x2F;&#x2F; export type BasicTarget&lt;T extends TargetType &#x3D; Element&gt; &#x3D;&#x2F;&#x2F;   | (() &#x3D;&gt; TargetValue&lt;T&gt;) &#x2F;&#x2F; 函数&#x2F;&#x2F;   | TargetValue&lt;T&gt; &#x2F;&#x2F; 直接dom&#x2F;&#x2F;   | MutableRefObject&lt;TargetValue&lt;T&gt;&gt;; &#x2F;&#x2F; refexport type Target &#x3D; BasicTarget&lt;Element | Document&gt;;export type ScrollListenController &#x3D; (val: Position) &#x3D;&gt; boolean;function useScroll(  target?: Target,  shouldUpdate: ScrollListenController &#x3D; () &#x3D;&gt; true): Position | undefined &#123;  const [position, setPosition] &#x3D; useRafState&lt;Position&gt;();  const shouldUpdateRef &#x3D; useLatest(shouldUpdate);  useEffectWithTarget(    () &#x3D;&gt; &#123;      const el &#x3D; getTargetElement(target, document &#x2F;**兜底值 *&#x2F;);      if (!el) &#123;        return;      &#125;      const updatePosition &#x3D; () &#x3D;&gt; &#123;        let newPosition: Position;        &#x2F;&#x2F; 是不是document        if (el &#x3D;&#x3D;&#x3D; document) &#123;          &#x2F;&#x2F; ？scrollingElement啥玩意          &#x2F;&#x2F; @link https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Document&#x2F;scrollingElement          &#x2F;&#x2F; scrollingElement （ Document 的只读属性）返回滚动文档的 Element 对象的引用。          &#x2F;&#x2F; 在标准模式下，这是文档的根元素， document.documentElement.          &#x2F;&#x2F; 当在怪异模式下， scrollingElement 属性返回 HTML body 元素（若不存在返回 null ）。          if (document.scrollingElement) &#123;            newPosition &#x3D; &#123;              left: document.scrollingElement.scrollLeft,              top: document.scrollingElement.scrollTop,            &#125;;          &#125; else &#123;            &#x2F;&#x2F; When in quirks mode, the scrollingElement attribute returns the HTML body element if it exists and is potentially scrollable, otherwise it returns null.            &#x2F;&#x2F; 在quirks模式下，scrollingElement属性返回HTML主体元素（如果它存在并且可能是可滚动的），否则返回null。            &#x2F;&#x2F; https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Document&#x2F;scrollingElement            &#x2F;&#x2F; https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;28633221&#x2F;document-body-scrolltop-firefox-returns-0-only-js            newPosition &#x3D; &#123;              left: Math.max(                &#x2F;&#x2F; 兼容写法                window.pageXOffset,                document.documentElement.scrollLeft,                document.body.scrollLeft              ),              top: Math.max(                &#x2F;&#x2F; 兼容写法                window.pageYOffset,                document.documentElement.scrollTop,                document.body.scrollTop              ),            &#125;;          &#125;        &#125; else &#123;          newPosition &#x3D; &#123;            left: (el as Element).scrollLeft,            top: (el as Element).scrollTop,          &#125;;        &#125;        &#x2F;&#x2F; 默认直接返回true        if (shouldUpdateRef.current(newPosition)) &#123;          setPosition(newPosition);        &#125;      &#125;;      &#x2F;&#x2F; 立即执行一次      updatePosition();      &#x2F;&#x2F; 监听到scroll执行      el.addEventListener(&quot;scroll&quot;, updatePosition);      return () &#x3D;&gt; &#123;        el.removeEventListener(&quot;scroll&quot;, updatePosition);      &#125;;    &#125;,    [],    target  );  return position;&#125;export default useScroll;</code></pre><h2 id="useSize"><a href="#useSize" class="headerlink" title="useSize"></a>useSize</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 这里用了polyfillimport ResizeObserver from &quot;resize-observer-polyfill&quot;;import useRafState from &quot;..&#x2F;useRafState&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import useIsomorphicLayoutEffectWithTarget from &quot;..&#x2F;utils&#x2F;useIsomorphicLayoutEffectWithTarget&quot;;type Size &#x3D; &#123; width: number; height: number &#125;;function useSize(target: BasicTarget): Size | undefined &#123;  const [state, setState] &#x3D; useRafState&lt;Size&gt;();  useIsomorphicLayoutEffectWithTarget(    &#x2F;&#x2F; useEffect第一个函数    () &#x3D;&gt; &#123;      const el &#x3D; getTargetElement(target);      if (!el) &#123;        return;      &#125;      const resizeObserver &#x3D; new ResizeObserver((entries) &#x3D;&gt; &#123;        entries.forEach((entry) &#x3D;&gt; &#123;          const &#123; clientWidth, clientHeight &#125; &#x3D; entry.target;          setState(&#123;            width: clientWidth,            height: clientHeight,          &#125;);        &#125;);      &#125;);      &#x2F;&#x2F; 开始观察某个dom      resizeObserver.observe(el);      return () &#x3D;&gt; &#123;        &#x2F;&#x2F; 停止观察dom        resizeObserver.disconnect();      &#125;;    &#125;,    &#x2F;&#x2F; useEffect的依赖项    [],    target &#x2F;&#x2F; 也参与依赖项计算 depsAreSame  );  return state;&#125;export default useSize;</code></pre><h2 id="useIsomorphicLayoutEffectWithTarget"><a href="#useIsomorphicLayoutEffectWithTarget" class="headerlink" title="useIsomorphicLayoutEffectWithTarget"></a>useIsomorphicLayoutEffectWithTarget</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import isBrowser from &quot;.&#x2F;isBrowser&quot;;import useEffectWithTarget from &quot;.&#x2F;useEffectWithTarget&quot;;import useLayoutEffectWithTarget from &quot;.&#x2F;useLayoutEffectWithTarget&quot;;&#x2F;&#x2F; 对用不同的执行环境，进行区分const useIsomorphicLayoutEffectWithTarget &#x3D; isBrowser  ? useLayoutEffectWithTarget  : useEffectWithTarget;export default useIsomorphicLayoutEffectWithTarget;</code></pre><h2 id="useReactive-（这个比较特别）"><a href="#useReactive-（这个比较特别）" class="headerlink" title="useReactive （这个比较特别）"></a>useReactive （这个比较特别）</h2><p>提供一种数据响应式的操作体验，定义数据状态不需要写 useState，直接修改属性即可刷新视图。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useRef &#125; from &quot;react&quot;;import useCreation from &quot;..&#x2F;useCreation&quot;;import useUpdate from &quot;..&#x2F;useUpdate&quot;;import &#123; isObject &#125; from &quot;..&#x2F;utils&quot;;&#x2F;&#x2F; k:v 原对象:代理过的对象const proxyMap &#x3D; new WeakMap();&#x2F;&#x2F; k:v 代理过的对象:原对象const rawMap &#x3D; new WeakMap();function observer&lt;T extends Record&lt;string, any&gt;&gt;(  initialVal: T,  cb: () &#x3D;&gt; void): T &#123;  const existingProxy &#x3D; proxyMap.get(initialVal);  &#x2F;&#x2F; 添加缓存 防止重新构建proxy  &#x2F;&#x2F; 如果重复构建，会怎样？  if (existingProxy) &#123;    return existingProxy;  &#125;  &#x2F;&#x2F; 防止代理已经代理过的对象 浏览器奔溃  &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;hooks&#x2F;issues&#x2F;839  if (rawMap.has(initialVal)) &#123;    return initialVal;  &#125;  const proxy &#x3D; new Proxy&lt;T&gt;(initialVal, &#123;    get(target, key, receiver) &#123;      const res &#x3D; Reflect.get(target, key, receiver);      &#x2F;&#x2F; 把所有的嵌套对象都给监听      return isObject(res) ? observer(res, cb) : Reflect.get(target, key);    &#125;,    set(target, key, val) &#123;      const ret &#x3D; Reflect.set(target, key, val);      cb();      return ret;    &#125;,    deleteProperty(target, key) &#123;      const ret &#x3D; Reflect.deleteProperty(target, key);      cb();      return ret;    &#125;,  &#125;);  proxyMap.set(initialVal, proxy);  rawMap.set(proxy, initialVal);  return proxy;&#125;function useReactive&lt;S extends Record&lt;string, any&gt;&gt;(initialState: S): S &#123;  const update &#x3D; useUpdate();  const stateRef &#x3D; useRef&lt;S&gt;(initialState);  &#x2F;&#x2F; useCreation，非必要不更新  const state &#x3D; useCreation(    &#x2F;**工厂*&#x2F; () &#x3D;&gt; &#123;      return observer(        stateRef.current &#x2F;**initialVal *&#x2F;,        &#x2F;**回调*&#x2F; () &#x3D;&gt; &#123;          update(); &#x2F;&#x2F; 刷新，我比较好奇，这么刷新，react傻呆呆又要重新计算一遍吗        &#125;      );    &#125;,    []  );  return state;&#125;export default useReactive;</code></pre><h2 id="useCreation"><a href="#useCreation" class="headerlink" title="useCreation"></a>useCreation</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>useCreation 是 useMemo 或 useRef 的替代品。</p><p>因为 useMemo 不能保证被 memo 的值一定不会被重计算，而 useCreation 可以保证这一点。以下为 React 官方文档中的介绍</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123; DependencyList &#125; from &quot;react&quot;;import &#123; useRef &#125; from &quot;react&quot;;import depsAreSame from &quot;..&#x2F;utils&#x2F;depsAreSame&quot;;export default function useCreation&lt;T&gt;(factory: () &#x3D;&gt; T, deps: DependencyList) &#123;  const &#123; current &#125; &#x3D; useRef(&#123;    deps,    obj: undefined as undefined | T,    initialized: false,  &#125;);  &#x2F;&#x2F; 发生变化时候，就会重新计算  if (current.initialized &#x3D;&#x3D;&#x3D; false || !depsAreSame(current.deps, deps)) &#123;    current.deps &#x3D; deps;    current.obj &#x3D; factory(); &#x2F;&#x2F; 工厂    current.initialized &#x3D; true;  &#125;  return current.obj as T;&#125;</code></pre><h2 id="useTrackedEffect"><a href="#useTrackedEffect" class="headerlink" title="useTrackedEffect"></a>useTrackedEffect</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type &#123; DependencyList &#125; from &quot;react&quot;;import &#123; useEffect, useRef &#125; from &quot;react&quot;;type Effect &#x3D; (  changes?: number[],  previousDeps?: DependencyList, &#x2F;&#x2F; 之前的依赖  currentDeps?: DependencyList &#x2F;&#x2F; 之后的依赖) &#x3D;&gt; void | (() &#x3D;&gt; void);const diffTwoDeps &#x3D; (deps1?: DependencyList, deps2?: DependencyList) &#x3D;&gt; &#123;  &#x2F;&#x2F;Let&#39;s do a reference equality check on 2 dependency list.  &#x2F;&#x2F;If deps1 is defined, we iterate over deps1 and do comparison on each element with equivalent element from deps2  &#x2F;&#x2F;As this func is used only in this hook, we assume 2 deps always have same length.  return deps1    ? &#x2F;&#x2F; deps1（缓存）有， deps2 有 则用Object.is比较      deps1        .map((_ele, idx) &#x3D;&gt; (!Object.is(deps1[idx], deps2?.[idx]) ? idx : -1))        .filter((ele) &#x3D;&gt; ele &gt;&#x3D; 0)    : &#x2F;&#x2F; deps1（缓存）没有， deps2 有 则把第二个取个遍，否则，返回[]    deps2    ? deps2.map((_ele, idx) &#x3D;&gt; idx)    : [];&#125;;const useTrackedEffect &#x3D; (effect: Effect, deps?: DependencyList) &#x3D;&gt; &#123;  const previousDepsRef &#x3D; useRef&lt;DependencyList&gt;();  useEffect(() &#x3D;&gt; &#123;    const changes &#x3D; diffTwoDeps(      previousDepsRef.current &#x2F;**之前的依赖缓存了 *&#x2F;,      deps    );    const previousDeps &#x3D; previousDepsRef.current;    previousDepsRef.current &#x3D; deps;    return effect(changes, previousDeps, deps);  &#125;, deps);&#125;;export default useTrackedEffect;</code></pre><h2 id="useVirtualList"><a href="#useVirtualList" class="headerlink" title="useVirtualList"></a>useVirtualList</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; useEffect, useMemo, useState, useRef &#125; from &quot;react&quot;;import useEventListener from &quot;..&#x2F;useEventListener&quot;;import useLatest from &quot;..&#x2F;useLatest&quot;;import useMemoizedFn from &quot;..&#x2F;useMemoizedFn&quot;;import useSize from &quot;..&#x2F;useSize&quot;;import &#123; getTargetElement &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import type &#123; BasicTarget &#125; from &quot;..&#x2F;utils&#x2F;domTarget&quot;;import &#123; isNumber &#125; from &quot;..&#x2F;utils&quot;;type ItemHeight&lt;T&gt; &#x3D; (index: number, data: T) &#x3D;&gt; number;export interface Options&lt;T&gt; &#123;  containerTarget: BasicTarget; &#x2F;&#x2F; 外面容器，支持 DOM 节点或者 Ref 对象  wrapperTarget: BasicTarget; &#x2F;&#x2F; 内部容器，支持 DOM 节点或者 Ref 对象  itemHeight: number | ItemHeight&lt;T&gt;; &#x2F;&#x2F; 行高度，静态高度可以直接写入像素值，动态高度可传入函数， 这里的动态是假动态，净骗我，意思是你算好了给 useVirtualList ，就认为你的是动态，并非 “完全自动计算高度”  overscan?: number; &#x2F;&#x2F; 视区上、下额外展示的 DOM 节点数量&#125;const useVirtualList &#x3D; &lt;T &#x3D; any&gt;(list: T[], options: Options&lt;T&gt;) &#x3D;&gt; &#123;  const &#123; containerTarget, wrapperTarget, itemHeight, overscan &#x3D; 5 &#125; &#x3D; options;  &#x2F;&#x2F; 缓存了下  const itemHeightRef &#x3D; useLatest(itemHeight);  &#x2F;&#x2F; 计算容器宽高  const size &#x3D; useSize(containerTarget);  &#x2F;&#x2F; 是不是scrollToFunc 触发的滚动  const scrollTriggerByScrollToFunc &#x3D; useRef(false);  &#x2F;&#x2F; 展示的数据  const [targetList, setTargetList] &#x3D; useState&lt;&#123; index: number; data: T &#125;[]&gt;(    []  );  &#x2F;&#x2F; 可见数量  const getVisibleCount &#x3D; (containerHeight: number, fromIndex: number) &#x3D;&gt; &#123;    if (isNumber(itemHeightRef.current)) &#123;      &#x2F;&#x2F; 容器高度&#x2F;每个元素高度      return Math.ceil(        &#x2F;**天花板，向上取整*&#x2F; containerHeight &#x2F; itemHeightRef.current      );    &#125;    let sum &#x3D; 0;    let endIndex &#x3D; 0;    for (let i &#x3D; fromIndex; i &lt; list.length; i++) &#123;      const height &#x3D; itemHeightRef.current(i, list[i]);      sum +&#x3D; height;      endIndex &#x3D; i;      if (sum &gt;&#x3D; containerHeight) &#123;        break;      &#125;    &#125;    &#x2F;&#x2F; 最后一个可见元素 - 开始元素 &#x3D;  可见元素数量    return endIndex - fromIndex;  &#125;;  &#x2F;&#x2F; 获取间隔数量  const getOffset &#x3D; (scrollTop: number) &#x3D;&gt; &#123;    if (isNumber(itemHeightRef.current)) &#123;      return Math.floor(scrollTop &#x2F; itemHeightRef.current) + 1;    &#125;    let sum &#x3D; 0;    let offset &#x3D; 0;    for (let i &#x3D; 0; i &lt; list.length; i++) &#123;      const height &#x3D; itemHeightRef.current(i, list[i]);      sum +&#x3D; height;      if (sum &gt;&#x3D; scrollTop) &#123;        offset &#x3D; i;        break;      &#125;    &#125;    return offset + 1;  &#125;;  &#x2F;&#x2F; 获取顶部距离  const getDistanceTop &#x3D; (index: number) &#x3D;&gt; &#123;    if (isNumber(itemHeightRef.current)) &#123;      const height &#x3D; index * itemHeightRef.current;      return height;    &#125;    const height &#x3D; list      .slice(0, index)      .reduce(        (sum, _, i) &#x3D;&gt;          sum +          (itemHeightRef.current as ItemHeight&lt;T&gt;)(            i,            list[i]          ) &#x2F;**这块是个函数，参数是 i, item *&#x2F;,        0      );    return height;  &#125;;  &#x2F;&#x2F; 高度和  const totalHeight &#x3D; useMemo(() &#x3D;&gt; &#123;    if (isNumber(itemHeightRef.current)) &#123;      return list.length * itemHeightRef.current;    &#125;    return list.reduce(      (sum, _, index) &#x3D;&gt;        sum + (itemHeightRef.current as ItemHeight&lt;T&gt;)(index, list[index]),      0    );  &#125;, [list]);  &#x2F;&#x2F;  const calculateRange &#x3D; () &#x3D;&gt; &#123;    const container &#x3D; getTargetElement(containerTarget);    const wrapper &#x3D; getTargetElement(wrapperTarget) as HTMLElement;    if (container &amp;&amp; wrapper) &#123;      const &#123; scrollTop, clientHeight &#125; &#x3D; container;      const offset &#x3D; getOffset(scrollTop);      const visibleCount &#x3D; getVisibleCount(clientHeight, offset);      const start &#x3D; Math.max(0, offset - overscan);      const end &#x3D; Math.min(list.length, offset + visibleCount + overscan);      const offsetTop &#x3D; getDistanceTop(start);      &#x2F;&#x2F; 这里是计算内部容器上边距（用margin和height看来对未渲染的元素进行占位） 下面放个图：      &#x2F;&#x2F; http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;202209021833942.webp      wrapper.style.height &#x3D; totalHeight - offsetTop + &quot;px&quot;;      wrapper.style.marginTop &#x3D; offsetTop + &quot;px&quot;;      &#x2F;&#x2F; 可见元素      setTargetList(        list.slice(start, end).map((ele, index) &#x3D;&gt; (&#123;          data: ele,          index: index + start,        &#125;))      );    &#125;  &#125;;  useEffect(() &#x3D;&gt; &#123;    if (!size?.width || !size?.height) &#123;      return;    &#125;    calculateRange();  &#125;, [size?.width, size?.height, list]);  &#x2F;&#x2F; 监听滚动，进行不断的计算  useEventListener(    &quot;scroll&quot;,    (e) &#x3D;&gt; &#123;      if (scrollTriggerByScrollToFunc.current) &#123;        scrollTriggerByScrollToFunc.current &#x3D; false;        return;      &#125;      e.preventDefault();      calculateRange();    &#125;,    &#123;      target: containerTarget,    &#125;  );  &#x2F;&#x2F; 滚动到某个下标  const scrollTo &#x3D; (index: number) &#x3D;&gt; &#123;    const container &#x3D; getTargetElement(containerTarget);    if (container) &#123;      scrollTriggerByScrollToFunc.current &#x3D; true;      container.scrollTop &#x3D; getDistanceTop(index);      calculateRange();    &#125;  &#125;;  return [targetList, useMemoizedFn(scrollTo)] as const;&#125;;export default useVirtualList;</code></pre><p><strong>这里是计算内部容器上边距（用 margin 和 height 来对未渲染的元素进行占位）</strong></p><img src="http://t-blog-images.aijs.top/img/202209021833942.webp" /><h2 id="useRequest-难搞哦-有点多"><a href="#useRequest-难搞哦-有点多" class="headerlink" title="useRequest 难搞哦 有点多"></a>useRequest 难搞哦 有点多</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>hooks 设计目标导向，拿到哪些值 和 api</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有过期机制的localStorage</title>
      <link href="//post/2022-08-24expirestorage.html"/>
      <url>//post/2022-08-24expirestorage.html</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>对于一些数据不经常更新的数据，保持一定时间的新鲜的时候可以用于缓存</p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p><a href="https://juejin.cn/post/7068533397911502879" target="_blank" >见原文</a></p><p>把原文代码改了下，主要对<code>JSON.parse</code>进行 fixed</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Storage.prototype.setStorageWithAge &#x3D; (key, value, expires &#x3D; 60 * 1000) &#x3D;&gt; &#123;  if (isNaN(expires) || expires &lt; 1)    throw new Error(&quot;expires must be a number&quot;);  const obj &#x3D; &#123;    data: value,    &#x2F;&#x2F;存储值    time: Date.now(),    &#x2F;&#x2F;存值时间戳    maxExpires: expires,    &#x2F;&#x2F;过期时间  &#125;;  localStorage.setItem(key, JSON.stringify(obj));&#125;;Storage.prototype.getStorageWithAge &#x3D; (key) &#x3D;&gt; &#123;  try &#123;    const &#123; data, time, maxExpires &#125; &#x3D; JSON.parse(localStorage.getItem(key));    if (time + maxExpires &lt; Date.now()) &#123;      localStorage.removeItem(key);      return undefined;    &#125;    return data;  &#125; catch (error) &#123;    return undefined; &#x2F;&#x2F; JSON.parse解析undefined时候直接返回  &#125;&#125;;&#x2F;&#x2F; 测试数据localStorage.setStorageWithAge(&quot;amingxiansen&quot;, &quot;测试过期时间&quot;, 5000);localStorage.getStorageWithAge(&quot;amingxiansen&quot;);</code></pre><img src="http://t-blog-images.aijs.top/img/202208241654212.webp" /><p>注意：对于一些敏感数据，需要加密</p>]]></content>
      
      
      <categories>
          
          <category> 存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react hook 如何增加依赖更新</title>
      <link href="//post/2022-08-23react-hook.html"/>
      <url>//post/2022-08-23react-hook.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想将，业务逻辑按钮组封装为 hook,在移动端和 pc 端之间进行逻辑复用。在详情页面使用时候，发现并没有生效</p><p>原因： 无法给 useActions，增加依赖项，类似 useEffect 的第二参数一样。</p><p>查询了 ahooks 的 hook，了解类似解决方案</p><h2 id="useActions"><a href="#useActions" class="headerlink" title="useActions"></a>useActions</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; EUserType, EnumProblemStatus &#125; from &quot;@&#x2F;const&quot;;import &#123; CommonModel &#125; from &quot;@&#x2F;models&quot;;import &#123; useMemo &#125; from &quot;react&quot;;import &#123; useSelector &#125; from &quot;react-redux&quot;;export const useActions &#x3D; (detail) &#x3D;&gt; &#123;  const user &#x3D; useSelector(CommonModel.selectors.getUser);  const &#123; state: status &#125; &#x3D; detail;  const userType &#x3D; useMemo(() &#x3D;&gt; &#123;    if (detail?.creatorPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;      return EUserType.creator;    &#125;    if (detail?.solverStaffPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;      return EUserType.operator;    &#125;    if (      detail?.cooperationStaffs?.findIndex(        (item) &#x3D;&gt; item.personId &#x3D;&#x3D;&#x3D; user.staffId      ) &gt; -1    ) &#123;      return EUserType.helper;    &#125;    return EUserType.other;  &#125;, [    detail?.cooperationStaffs,    detail.creatorPerson?.personId,    detail?.solverStaffPerson?.personId,    user?.staffId,  ]);  const btnComps &#x3D; useMemo(    () &#x3D;&gt; (&#123;      &#x2F;&#x2F; edit: &#123;      &#x2F;&#x2F;   text: &#39;编辑&#39;,      &#x2F;&#x2F;   key: &#39;edit&#39;,      &#x2F;&#x2F; &#125;,      start_solve: &#123;        text: &quot;开始处理&quot;,        key: &quot;start_solve&quot;,        value: 2,      &#125;,      cancel: &#123;        text: &quot;撤销&quot;,        icon: &quot;icon-huifu&quot;,        disabledMessage: &quot;非创建人不可撤销&quot;,        key: &quot;cancel&quot;,        type: &quot;default&quot;,        confirm: true,        value: 7,        disabled: user.staffId !&#x3D;&#x3D; detail?.creatorPerson?.personId,      &#125;,      trans: &#123;        text: &quot;转交&quot;,        icon: &quot;icon-transfer&quot;,        key: &quot;trans&quot;,        message: &quot;请选择转交人&quot;,        required: true,        contact: true,        limit: 1,        allowType: [&quot;staff&quot;],        defaultValue: [],        disabledValues: [user.staffId],        value: 8,      &#125;,      finish: &#123;        text: &quot;完结&quot;,        icon: &quot;icon-guangbo&quot;,        key: &quot;finish&quot;,        confirm: true,        value: 6,      &#125;,      cuiBan: &#123;        text: &quot;催办&quot;,        key: &quot;cuiBan&quot;,        confirm: true,        value: 12,      &#125;,      solved: &#123;        text: &quot;已解决&quot;,        icon: &quot;icon-yiwancheng&quot;,        key: &quot;solved&quot;,        confirm: true,        value: 5,      &#125;,      changer: &#123;        text: &quot;变更经办人&quot;,        key: &quot;changer&quot;,        contact: true,        limit: 1,        allowType: [&quot;staff&quot;],        defaultValue: [],        message: &quot;请选择转变更经办人&quot;,        required: true,        value: 8,        disabledValues: [user.staffId],      &#125;,      add_helper: &#123;        text: &quot;添加协作人&quot;,        key: &quot;add_helper&quot;,        icon: &quot;icon-teamwork&quot;,        contact: true,        allowType: [&quot;staff&quot;],        defaultValue: [],        message: &quot;请选择协作人&quot;,        required: true,        value: 9,      &#125;,      notify_creator: &#123;        text: &quot;提醒确认&quot;,        key: &quot;notify_creator&quot;,        icon: &quot;icon-querentixing&quot;,        confirm: true,        value: 13,      &#125;,      receiver: &#123;        text: &quot;认领处理&quot;,        key: &quot;receiver&quot;,        icon: &quot;icon-receiver&quot;,        confirm: true,        value: 8,      &#125;,      exit_helper: &#123;        text: &quot;退出协作&quot;,        key: &quot;exit_helper&quot;,        confirm: true,        value: 11,      &#125;,      join: &#123;        text: &quot;加入协作&quot;,        confirm: true,        key: &quot;join&quot;,        value: 9,      &#125;,      continue: &#123;        text: &quot;继续处理&quot;,        key: &quot;continue&quot;,        value: 2,      &#125;,      end: &#123;        text: &quot;完结&quot;,        key: &quot;end&quot;,        confirm: true,        value: 6,      &#125;,    &#125;),    [detail.problemId]  );  const actionBtns &#x3D; useMemo(() &#x3D;&gt; &#123;    const btns &#x3D; [];    switch (status) &#123;      case EnumProblemStatus.waiting:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.cancel);            btns.push(btnComps.cuiBan);            btns.push(btnComps.changer);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.start_solve);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.processing:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.solved);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.delay:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.cancel);            btns.push(btnComps.cuiBan);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.solved);            btns.push(btnComps.continue);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.overdue:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.cancel);            btns.push(btnComps.cuiBan);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.solved);            btns.push(btnComps.continue);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.solved:        switch (userType) &#123;          case EUserType.creator:            btns.push(btnComps.end);            break;          case EUserType.operator:            btns.push(btnComps.notify_creator);            break;          default:        &#125;        break;      case EnumProblemStatus.finish:        break;      case EnumProblemStatus.cancel:        break;      default:        break;    &#125;    return btns;  &#125;, [detail.status, userType]);  return actionBtns;&#125;;</code></pre><h2 id="ahooks-中-依赖刷新"><a href="#ahooks-中-依赖刷新" class="headerlink" title="ahooks 中 依赖刷新"></a>ahooks 中 依赖刷新</h2><p><a href="https://ahooks.js.org/zh-CN/hooks/use-request/refresy-deps#%E4%BE%9D%E8%B5%96%E5%88%B7%E6%96%B0" target="_blank" >见</a></p><p>useRequest 提供了一个 options.refreshDeps 参数，当它的值变化后，会重新触发请求。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const [userId, setUserId] &#x3D; useState(&quot;1&quot;);const &#123; data, run &#125; &#x3D; useRequest(() &#x3D;&gt; getUserSchool(userId), &#123;  refreshDeps: [userId],&#125;);</code></pre><p>上面的示例代码，useRequest 会在初始化和 userId 变化时，触发函数执行。</p><p>与下面代码实现功能完全一致</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const [userId, setUserId] &#x3D; useState(&quot;1&quot;);const &#123; data, refresh &#125; &#x3D; useRequest(() &#x3D;&gt; getUserSchool(userId));useEffect(() &#x3D;&gt; &#123;  refresh();&#125;, [userId]);</code></pre><h2 id="useRequest-源码找找"><a href="#useRequest-源码找找" class="headerlink" title="useRequest 源码找找"></a>useRequest 源码找找</h2><p><a href="https://github.com/alibaba/hooks/blob/93630e73f445871fb6b14fcb0bf3b9fddb1ba0aa/packages/hooks/src/useRequest/src/useRequest.ts#L24" target="_blank" > options?: Options&lt;TData, TParams&gt;,</a></p><p><a href="https://github.com/alibaba/hooks/blob/93630e73f445871fb6b14fcb0bf3b9fddb1ba0aa/packages/hooks/src/useRequest/src/types.ts#L52" target="_blank" > refreshDeps type</a></p><p><a href="https://github.com/alibaba/hooks/blob/93630e73f445871fb6b14fcb0bf3b9fddb1ba0aa/packages/hooks/src/useRequest/src/useRequestImplement.ts#L27" target="_blank" > const fetchInstance &#x3D; useCreation(() &#x3D;&gt; {</a></p><p><a href="https://github.com/alibaba/hooks/blob/93630e73f445871fb6b14fcb0bf3b9fddb1ba0aa/packages/hooks/src/useCreation/index.ts#L5" target="_blank" ><code>export default function useCreation&lt;T&gt;(factory: () =&gt; T, deps: DependencyList) &#123;</code></a></p><h2 id="useCreation"><a href="#useCreation" class="headerlink" title="useCreation"></a>useCreation</h2><p><a href="https://ahooks.js.org/zh-CN/hooks/use-creation#usecreation" target="_blank" > usecreation</a></p><img src="http://t-blog-images.aijs.top/img/202208231957375.webp" /><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function useCreation&lt;T&gt;(factory: () &#x3D;&gt; T, deps: any[]): T;</code></pre><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React, &#123; useState &#125; from &quot;react&quot;;import &#123; useCreation &#125; from &quot;ahooks&quot;;class Foo &#123;  constructor() &#123;    this.data &#x3D; Math.random();  &#125;  data: number;&#125;export default function () &#123;  const foo &#x3D; useCreation(() &#x3D;&gt; new Foo(), []); &#x2F;&#x2F; 依赖项没变化， 不会重复执行 factory  const [, setFlag] &#x3D; useState(&#123;&#125;);  return (    &lt;&gt;      &lt;p&gt;&#123;foo.data&#125;&lt;&#x2F;p&gt;      &lt;button        type&#x3D;&quot;button&quot;        onClick&#x3D;&#123;() &#x3D;&gt; &#123;          setFlag(&#123;&#125;); &#x2F;&#x2F; 对象更新        &#125;&#125;      &gt;        Rerender      &lt;&#x2F;button&gt;    &lt;&#x2F;&gt;  );&#125;</code></pre><p><a href="https://github.com/alibaba/hooks/blob/93630e73f445871fb6b14fcb0bf3b9fddb1ba0aa/packages/hooks/src/useRequest/src/useRequestImplement.ts#L27" target="_blank" >至此，这里的实例化也好理解了</a></p><h2 id="以上内容想歪了"><a href="#以上内容想歪了" class="headerlink" title="以上内容想歪了"></a>以上内容想歪了</h2><ul><li>中途试用了useCreation, eslint不能够提示依赖项，所以又回到了<code>useMemo</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; useActionsimport &#123; EnumProblemStatus, EUserType &#125; from &quot;@&#x2F;const&quot;;import &#123; IProblemDetail &#125; from &quot;@&#x2F;services&#x2F;problems&quot;;import &#123; useMemo &#125; from &quot;react&quot;;export const useActions &#x3D; (  detail: IProblemDetail,  user: Staff,  mobile &#x3D; false) &#x3D;&gt; &#123;  const userType &#x3D; useMemo(() &#x3D;&gt; &#123;    if (detail?.creatorPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;      return EUserType.creator;    &#125;    if (detail?.solverStaffPerson?.personId &#x3D;&#x3D;&#x3D; user.staffId) &#123;      return EUserType.operator;    &#125;    if (      detail?.cooperationStaffs?.findIndex(        (item) &#x3D;&gt; item.personId &#x3D;&#x3D;&#x3D; user.staffId      ) &gt; -1    ) &#123;      return EUserType.helper;    &#125;    return EUserType.other;  &#125;, [    detail?.cooperationStaffs,    detail.creatorPerson?.personId,    detail?.solverStaffPerson?.personId,    user?.staffId,  ]);  const btnComps &#x3D; useMemo(() &#x3D;&gt; &#123;    const &#123; creatorPerson, solverStaffPerson, cooperationStaffs &#x3D; [] &#125; &#x3D; detail;    if (!creatorPerson) return;    const disabled_solverStaffPersonIds &#x3D; []      .concat(creatorPerson.personId)      .concat(solverStaffPerson.personId || []);    const disabled_cooperationStaffsIds &#x3D; []      .concat(creatorPerson.personId)      .concat(solverStaffPerson.personId || [])      .concat(cooperationStaffs.map((item) &#x3D;&gt; item.personId));    return &#123;      &#x2F;&#x2F; edit: &#123;      &#x2F;&#x2F;   title: &#39;编辑&#39;,      &#x2F;&#x2F;   key: &#39;edit&#39;,      &#x2F;&#x2F; &#125;,      comment: &#123;        title: &quot;评论&quot;,        key: &quot;comment&quot;,        icon: &quot;icon-kuaisuhuifu&quot;,        keep: true,      &#125;,      start_solve: &#123;        title: &quot;开始处理&quot;,        key: &quot;start_solve&quot;,        icon: &quot;icon-kaishi&quot;,        value: 2,      &#125;,      cancel: &#123;        title: &quot;撤销&quot;,        icon: &quot;icon-huifu&quot;,        disabledMessage: &quot;非创建人不可撤销&quot;,        key: &quot;cancel&quot;,        type: &quot;default&quot;,        confirm: true,        value: 7,      &#125;,      trans: &#123;        title: &quot;转交&quot;,        icon: &quot;icon-transfer&quot;,        key: &quot;trans&quot;,        message: &quot;请选择转交人&quot;,        required: true,        contact: true,        limit: 1,        allowType: [&quot;staff&quot;],        defaultValue: [],        disabledValues: disabled_solverStaffPersonIds,        value: 8,      &#125;,      finish: &#123;        title: &quot;完结&quot;,        icon: &quot;icon-guangbo&quot;,        key: &quot;finish&quot;,        confirm: true,        value: 6,      &#125;,      cuiBan: &#123;        title: &quot;催办&quot;,        key: &quot;cuiBan&quot;,        icon: &quot;icon-guangbo&quot;,        confirm: true,        value: 12,      &#125;,      solved: &#123;        title: &quot;已解决&quot;,        icon: &quot;icon-yiwancheng&quot;,        key: &quot;solved&quot;,        confirm: true,        value: 5,      &#125;,      changer: &#123;        title: &quot;变更经办人&quot;,        key: &quot;changer&quot;,        contact: true,        icon: &quot;icon-transfer&quot;,        limit: 1,        allowType: [&quot;staff&quot;],        defaultValue: [],        message: &quot;请选择转变更经办人&quot;,        required: true,        value: 8,        disabledValues: disabled_solverStaffPersonIds,      &#125;,      add_helper: &#123;        title: &quot;添加协作人&quot;,        key: &quot;add_helper&quot;,        icon: &quot;icon-teamwork&quot;,        contact: true,        allowType: [&quot;staff&quot;],        defaultValue: [],        message: &quot;请选择协作人&quot;,        required: true,        value: 9,        disabledValues: disabled_cooperationStaffsIds,      &#125;,      notify_creator: &#123;        title: &quot;提醒确认&quot;,        key: &quot;notify_creator&quot;,        icon: &quot;icon-querentixing&quot;,        confirm: true,        value: 13,      &#125;,      receiver: &#123;        title: &quot;认领处理&quot;,        key: &quot;receiver&quot;,        icon: &quot;icon-receiver&quot;,        confirm: true,        value: 8,      &#125;,      exit_helper: &#123;        title: &quot;退出协作&quot;,        key: &quot;exit_helper&quot;,        confirm: true,        icon: &quot;icon-tuichu&quot;,        value: 11,      &#125;,      join: &#123;        title: &quot;加入协作&quot;,        confirm: true,        key: &quot;join&quot;,        icon: &quot;icon-join&quot;,        value: 9,      &#125;,      continue: &#123;        title: &quot;继续处理&quot;,        key: &quot;continue&quot;,        value: 2,      &#125;,      end: &#123;        title: &quot;完结&quot;,        key: &quot;end&quot;,        confirm: true,        icon: &quot;icon-jieshu&quot;,        value: 6,      &#125;,    &#125;;  &#125;, [detail]);  const actions &#x3D; useMemo(() &#x3D;&gt; &#123;    const btns &#x3D; [];    const solverId &#x3D; detail.solverStaffPerson?.personId;    if (!btnComps) return [];    mobile &amp;&amp; btns.push(btnComps.comment);    switch (detail.state) &#123;      case EnumProblemStatus.waiting:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.cancel);            btns.push(btnComps.cuiBan);            btns.push(btnComps.changer);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.start_solve);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.processing:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            !solverId &amp;&amp; btns.push(btnComps.changer);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.solved);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.delay:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.cancel);            btns.push(btnComps.cuiBan);            !solverId &amp;&amp; btns.push(btnComps.changer);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.solved);            btns.push(btnComps.continue);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.overdue:        switch (userType) &#123;          case EUserType.creator:            &#x2F;&#x2F; btns.push(btnComps.edit)            btns.push(btnComps.cancel);            btns.push(btnComps.cuiBan);            !solverId &amp;&amp; btns.push(btnComps.changer);            btns.push(btnComps.add_helper);            break;          case EUserType.operator:            btns.push(btnComps.trans);            btns.push(btnComps.solved);            btns.push(btnComps.continue);            btns.push(btnComps.add_helper);            break;          case EUserType.helper:            btns.push(btnComps.exit_helper);            break;          case EUserType.other:            btns.push(btnComps.receiver);            btns.push(btnComps.join);            break;          default:        &#125;        break;      case EnumProblemStatus.solved:        switch (userType) &#123;          case EUserType.creator:            btns.push(btnComps.end);            break;          case EUserType.operator:            btns.push(btnComps.notify_creator);            break;          default:        &#125;        break;      case EnumProblemStatus.finish:        break;      case EnumProblemStatus.cancel:        break;      default:        break;    &#125;    return btns;  &#125;, [    detail.solverStaffPerson?.personId,    detail.state,    btnComps,    mobile,    userType,  ]);  return actions;&#125;;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 使用const actionBtns &#x3D; useActions(detail, user);</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="//post/2022-08-23tree.html"/>
      <url>//post/2022-08-23tree.html</url>
      
        <content type="html"><![CDATA[<h2 id="mysql-存储的几种方式"><a href="#mysql-存储的几种方式" class="headerlink" title="mysql 存储的几种方式"></a>mysql 存储的几种方式</h2><p><a href="https://www.zhihu.com/question/20417447" target="_blank" >见</a></p><img src="http://t-blog-images.aijs.top/img/202208231531157.webp" /><p>1,4 用过， 2 见过（当前公司 DHR 系统组织架构在用）</p><h2 id="js-获取树某个节点"><a href="#js-获取树某个节点" class="headerlink" title="js 获取树某个节点"></a>js 获取树某个节点</h2><p>场景：编辑树节点，刷新树数据，进行编辑节点回显，某些情况下，树节点被转移他人，当前节点不需要回显</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * * @param &#123;要查询的节点key&#125; targetValue * @param &#123;数组形式，树数据&#125; data * @returns *&#x2F;const findTreeNodeByKey &#x3D; (  tree: TreeNode[],  targetValue: string | number,  options &#x3D; &#123;    find_field: &quot;id&quot;,    children: &quot;children&quot;,  &#125;) &#x3D;&gt; &#123;  let result &#x3D; null;  const ffindeNodeByKey &#x3D; (    data: TreeNode[],    skey: string | number,    options  ) &#x3D;&gt; &#123;    const loop &#x3D; (_data, options) &#x3D;&gt; &#123;      _data.forEach((item) &#x3D;&gt; &#123;        if (item[find_field] &#x3D;&#x3D;&#x3D; skey) &#123;          result &#x3D; item;        &#125;        if (item[options.children]) &#123;          loop(item[options.children], options);        &#125;      &#125;);    &#125;;    return loop(data, options);  &#125;;  ffindeNodeByKey(tree, targetValue, options);  return result;&#125;;</code></pre><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><details class="custom-details"><summary>测试数据详情</summary><p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const data &#x3D; [  &#123;    id: 0,    parentId: null,    bizName: &quot;所有业务&quot;,    child: [      &#123;        id: 1,        parentId: 0,        bizName: &quot;APP项目组1&quot;,        child: [          &#123;            id: 2,            parentId: 1,            bizName: &quot;APP项目组-1&quot;,          &#125;,          &#123;            id: 27,            parentId: 1,            bizName: &quot;测试&quot;,          &#125;,        ],      &#125;,      &#123;        id: 3,        parentId: 0,        bizName: &quot;0-APP项目组&quot;,        child: [          &#123;            id: 29,            parentId: 3,            bizName: &quot;测试业务线&quot;,          &#125;,          &#123;            id: 42,            parentId: 3,            bizName: &quot;测试acl&quot;,          &#125;,        ],      &#125;,      &#123;        id: 5,        parentId: 0,        bizName: &quot;测试的业务线4&quot;,        child: [          &#123;            id: 23,            parentId: 5,            bizName: &quot;业务线测试&quot;,          &#125;,        ],      &#125;,      &#123;        id: 6,        parentId: 0,        bizName: &quot;测试的业务线5&quot;,        child: [          &#123;            id: 24,            parentId: 6,            bizName: &quot;测试测试业务线报错&quot;,          &#125;,        ],      &#125;,      &#123;        id: 8,        parentId: 0,        bizName: &quot;测试的业务线8&quot;,        child: [          &#123;            id: 25,            parentId: 8,            bizName: &quot;开发测试的业务线21&quot;,          &#125;,          &#123;            id: 26,            parentId: 8,            bizName: &quot;开发测试的业务线22&quot;,          &#125;,        ],      &#125;,      &#123;        id: 9,        parentId: 0,        bizName: &quot;测试的业务线9&quot;,      &#125;,    ],  &#125;,];</code></pre></p></details><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(&quot;res - 2&quot;, findTreeNodeByKey(2, data));console.log(&quot;res - 1326&quot;, findTreeNodeByKey(13, data));&#x2F;&#x2F; console.log(&quot;res - 0&quot;, findTreeNodeByKey(0, data));console.log(&quot;res - 996&quot;, findTreeNodeByKey(996, data));</code></pre><h2 id="js-获取某个节点-对应的路径"><a href="#js-获取某个节点-对应的路径" class="headerlink" title="js 获取某个节点, 对应的路径"></a>js 获取某个节点, 对应的路径</h2><ul><li>路径 type&#x3D;path</li><li>父节点组 type&#x3D;item</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * * @param &#123;数组：树data&#125; tree * @param &#123;目标值&#125; targetValue * @param &#123;配置信息&#125; options * @returns *&#x2F;function findNodePaths(tree, targetValue, options) &#123;  const defaultOptions &#x3D; &#123;    find_field: &quot;id&quot;, &#x2F;&#x2F; 与 targetValue匹配的字段    path_field: &quot;id&quot;, &#x2F;&#x2F; 生成路径的字段    separator: &quot;,&quot;, &#x2F;&#x2F; 路径字段分隔符    type: &quot;path&quot;, &#x2F;&#x2F; path &#x2F; item    children: &quot;children&quot;,  &#125;;  console.log(&#39;options&#39;,options)  options &#x3D; &#123;    ...defaultOptions,    ...options,  &#125;;  &#x2F;&#x2F; 首先我们先定义个数组，用来保存路径节点id  let nodePathArray &#x3D; [];  &#x2F;&#x2F; (tree为目标树，targetId为目标节点id)  function getNodeRoute(tree, targetValue, options) &#123;    for (let index &#x3D; 0; index &lt; tree.length; index++) &#123;      if (tree[index][options.children]) &#123;        let endRecursiveLoop &#x3D; getNodeRoute(          tree[index][options.children],          targetValue,          options        );        console.log(&quot;endRecursiveLoop&quot;, endRecursiveLoop);        if (endRecursiveLoop) &#123;          if (options.type &#x3D;&#x3D;&#x3D; &quot;path&quot;) &#123;            nodePathArray.push(tree[index][options.path_field]);          &#125; else &#123;            nodePathArray.push(tree[index]);          &#125;          return true;        &#125;      &#125;      if (tree[index][options.find_field] &#x3D;&#x3D;&#x3D; targetValue) &#123;        if (options.type &#x3D;&#x3D;&#x3D; &quot;path&quot;) &#123;          nodePathArray.push(tree[index][options.path_field]);        &#125; else &#123;          nodePathArray.push(tree[index]);        &#125;        return true;      &#125;    &#125;  &#125;  &#x2F;&#x2F; 转化成数组  let _tree &#x3D; [];  if (Array.isArray(tree)) &#123;    _tree &#x3D; tree;  &#125; else &#123;    _tree &#x3D; [tree];  &#125;  getNodeRoute(_tree, targetValue, options);  console.log(&quot;nodePathArray&quot;, nodePathArray);  if (options.type &#x3D;&#x3D;&#x3D; &quot;path&quot;) &#123;    return nodePathArray.reverse().join(options.separator);  &#125; else &#123;    return nodePathArray.reverse();  &#125;&#125;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const paths &#x3D; findNodePaths(data, 81); &#x2F;&#x2F;查找id为112的节点路径console.log(paths);const pathItems &#x3D; findNodePaths(treeArray, 81, &#123; type: &quot;item&quot; &#125;); &#x2F;&#x2F;查找id为112的节点路径console.log(pathItems);</code></pre>]]></content>
      
      
      <categories>
          
          <category> tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端问题（待补充）</title>
      <link href="//post/2022-08-22mb.html"/>
      <url>//post/2022-08-22mb.html</url>
      
        <content type="html"><![CDATA[<h2 id="【移动端】移动端点击可点击元素时，出现蓝色默认背景色"><a href="#【移动端】移动端点击可点击元素时，出现蓝色默认背景色" class="headerlink" title="【移动端】移动端点击可点击元素时，出现蓝色默认背景色"></a>【移动端】移动端点击可点击元素时，出现蓝色默认背景色</h2><p><a href="https://www.cnblogs.com/Mxy-cnblog/p/9856460.html" target="_blank" >见</a></p><pre class="line-numbers language-none"><code class="language-none">web页面放在移动端，点击button 标签或者添加了cursor:pointer 样式的标签，会出现 蓝色背景色， 解决方案：给相应标签 或者直接在body 标签上添加 样式：&#96;&#96;&#96;css-webkit-tap-highlight-color: transparent;</code></pre><p>或者</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">-webkit-tap-highlight-color: rgba(0, 0, 0, 0);</code></pre><h2 id="横竖屏检测"><a href="#横竖屏检测" class="headerlink" title="横竖屏检测"></a>横竖屏检测</h2><p><a href="https://www.cnblogs.com/Mxy-cnblog/p/9916605.html" target="_blank" >见</a></p><pre class="line-numbers language-css" data-language="css"><code class="language-css">@media screen and (orientation: portrait) &#123;  &#x2F;* 竖屏 *&#x2F;&#125;@media screen and (orientation: landscape) &#123;  &#x2F;* 横屏 *&#x2F;&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var d &#x3D; window.matchMedia(&quot;(orientation: portrait)&quot;);onMatchMeidaChange(d);d.addListener(onMatchMeidaChange);function onMatchMeidaChange(d) &#123;  if (d.matches) &#123;    &#x2F;&#x2F; 竖屏  &#125; else &#123;    &#x2F;&#x2F;横屏  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 移动端适配 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd-mobile 源码</title>
      <link href="//post/2022-08-20antd.html"/>
      <url>//post/2022-08-20antd.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mask-组件-getContainer"><a href="#Mask-组件-getContainer" class="headerlink" title="Mask 组件 getContainer"></a>Mask 组件 getContainer</h2><p><a href="https://github.com/ant-design/ant-design-mobile/blob/3d8d66b54e1ebadccfa17dc80208cceeeeac1555/src/utils/render-to-container.ts#L1" target="_blank" >见</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; renderToContainerimport &#123; createPortal &#125; from &quot;react-dom&quot;;import &#123; ReactElement, ReactPortal &#125; from &quot;react&quot;;import &#123; resolveContainer &#125; from &quot;.&#x2F;get-container&quot;;import &#123; canUseDom &#125; from &quot;.&#x2F;can-use-dom&quot;;export type GetContainer &#x3D; HTMLElement | (() &#x3D;&gt; HTMLElement) | null;&#x2F;&#x2F; 将节点挂在到 getContainerexport function renderToContainer(  getContainer: GetContainer,  node: ReactElement) &#123;  if (canUseDom &amp;&amp; getContainer) &#123;    const container &#x3D; resolveContainer(getContainer);    return createPortal(node, container) as ReactPortal; &#x2F;&#x2F; React portal  &#125;  return node;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function resolveContainer(  getContainer: HTMLElement | (() &#x3D;&gt; HTMLElement) | undefined | null) &#123;  const container &#x3D;    typeof getContainer &#x3D;&#x3D;&#x3D; &quot;function&quot; ? getContainer() : getContainer;  &#x2F;&#x2F; 按照这个默认应该挂在到body上，我在IOS上发现并不是这样，浏览器和安卓没问题  &#x2F;&#x2F; nextjs IOS有兼容问题  return container || document.body;&#125;</code></pre><h2 id="renderToBody"><a href="#renderToBody" class="headerlink" title="renderToBody"></a>renderToBody</h2><p><a href="https://github.com/ant-design/ant-design-mobile/blob/3d8d66b54e1ebadccfa17dc80208cceeeeac1555/src/utils/render-to-body.ts#L1" target="_blank" >见</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; ReactElement &#125; from &quot;react&quot;;import &#123; render, unmount as reactUnmount &#125; from &quot;.&#x2F;render&quot;;export function renderToBody(element: ReactElement) &#123;  const container &#x3D; document.createElement(&quot;div&quot;);  document.body.appendChild(container); &#x2F;&#x2F; 挂在到body底部  function unmount() &#123;    const unmountResult &#x3D; reactUnmount(container);    if (unmountResult &amp;&amp; container.parentNode) &#123;      container.parentNode.removeChild(container);    &#125;  &#125;  render(element, container);  return unmount;&#125;</code></pre><p><a href="https://github.com/ant-design/ant-design-mobile/blob/3d8d66b54e1ebadccfa17dc80208cceeeeac1555/src/utils/render.ts#L71" target="_blank" >见 Unmount</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Render &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F; 有点没看懂&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Unmount &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;function legacyUnmount(container: ContainerType) &#123;  return unmountComponentAtNode(container);&#125;async function concurrentUnmount(container: ContainerType) &#123;  &#x2F;&#x2F; Delay to unmount to avoid React 18 sync warning  return Promise.resolve().then(() &#x3D;&gt; &#123;    container[MARK]?.unmount();    delete container[MARK];  &#125;);&#125;export function unmount(container: ContainerType) &#123;  if (createRoot as unknown) &#123;    return concurrentUnmount(container);  &#125;  return legacyUnmount(container); &#x2F;&#x2F; 服务端渲染处理&#125;</code></pre><p>renderToBody 主要用于： <a href="https://github.com/ant-design/ant-design-mobile/search?q=renderToBody" target="_blank" >见</a>, unmount 我猜应该是为了关闭时候卸载组件</p><h2 id="客户端渲染判断"><a href="#客户端渲染判断" class="headerlink" title="客户端渲染判断"></a>客户端渲染判断</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const canUseDom &#x3D; !!(  typeof window !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;  typeof document !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;  window.document &amp;&amp;  window.document.createElement);</code></pre><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p><a href="https://github.com/ant-design/ant-design-mobile/blob/3d8d66b54e1ebadccfa17dc80208cceeeeac1555/src/utils/sleep.ts#L1" target="_blank" >见</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const sleep &#x3D; (time: number) &#x3D;&gt;  new Promise((resolve) &#x3D;&gt; setTimeout(resolve, time))&#96;&#96;;</code></pre><h2 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; mergePropsimport assignWith from &quot;lodash&#x2F;assignWith&quot;;export function mergeProps&lt;A, B&gt;(a: A, b: B): B &amp; A;export function mergeProps&lt;A, B, C&gt;(a: A, b: B, c: C): C &amp; B &amp; A;export function mergeProps(...items: any[]) &#123;  function customizer(objValue: any, srcValue: any) &#123;    return srcValue &#x3D;&#x3D;&#x3D; undefined ? objValue : srcValue;  &#125;  let ret &#x3D; &#123; ...items[0] &#125;;  for (let i &#x3D; 1; i &lt; items.length; i++) &#123;    ret &#x3D; assignWith(ret, items[i], customizer);  &#125;  return ret;&#125;</code></pre><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React, &#123; FC &#125; from &quot;react&quot;;import classNames from &quot;classnames&quot;;import &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;import &#123; mergeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;with-default-props&quot;;const classPrefix &#x3D; &#96;adm-space&#96;;export type SpaceProps &#x3D; &#123;  direction?: &quot;horizontal&quot; | &quot;vertical&quot;;  align?: &quot;start&quot; | &quot;end&quot; | &quot;center&quot; | &quot;baseline&quot;;  justify?:    | &quot;start&quot;    | &quot;end&quot;    | &quot;center&quot;    | &quot;between&quot;    | &quot;around&quot;    | &quot;evenly&quot;    | &quot;stretch&quot;;  wrap?: boolean;  block?: boolean;  onClick?: (event: React.MouseEvent&lt;HTMLDivElement, MouseEvent&gt;) &#x3D;&gt; void;  children?: React.ReactNode;&#125; &amp; NativeProps&lt;&quot;--gap&quot; | &quot;--gap-vertical&quot; | &quot;--gap-horizontal&quot;&gt;;const defaultProps &#x3D; &#123;  direction: &quot;horizontal&quot;,&#125;;export const Space: FC&lt;SpaceProps&gt; &#x3D; (p) &#x3D;&gt; &#123;  const props &#x3D; mergeProps(defaultProps, p);  const &#123; direction, onClick &#125; &#x3D; props;  return withNativeProps(    props,    &lt;div      className&#x3D;&#123;classNames(classPrefix, &#123;        [&#96;$&#123;classPrefix&#125;-wrap&#96;]: props.wrap,        [&#96;$&#123;classPrefix&#125;-block&#96;]: props.block,        [&#96;$&#123;classPrefix&#125;-$&#123;direction&#125;&#96;]: true,        [&#96;$&#123;classPrefix&#125;-align-$&#123;props.align&#125;&#96;]: !!props.align,        [&#96;$&#123;classPrefix&#125;-justify-$&#123;props.justify&#125;&#96;]: !!props.justify,      &#125;)&#125;      onClick&#x3D;&#123;onClick&#125;    &gt;      &#123;React.Children.map(props.children, (child) &#x3D;&gt; &#123;        return (          child !&#x3D;&#x3D; null &amp;&amp;          child !&#x3D;&#x3D; undefined &amp;&amp; (            &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-item&#96;&#125;&gt;&#123;child&#125;&lt;&#x2F;div&gt; &#x2F;&#x2F; 这里由下面样式，使用margin-right &#x2F; margin-bottom 实现间隔          )        );      &#125;)&#125;    &lt;&#x2F;div&gt;  );&#125;;</code></pre><p><a href="https://github.com/ant-design/ant-design-mobile/blob/7c00eee09077d7805161b249ced34852db44c53b/src/components/space/space.less#L1" target="_blank" >见</a></p><pre class="line-numbers language-less" data-language="less"><code class="language-less">&#x2F;&#x2F; space.less@class-prefix-space: ~&quot;adm-space&quot;;.@&#123;class-prefix-space&#125;-item &#123;  flex: none;&#125;.@&#123;class-prefix-space&#125; &#123;  display: inline-flex;  --gap: 8px;  --gap-vertical: var(--gap);  --gap-horizontal: var(--gap);  &amp;-vertical &#123;    flex-direction: column;    &gt; .@&#123;class-prefix-space&#125;-item &#123;      margin-bottom: var(--gap-vertical);      &amp;:last-child &#123;        margin-bottom: 0;      &#125;    &#125;  &#125;  &amp;-horizontal &#123;    flex-direction: row;    &gt; .@&#123;class-prefix-space&#125;-item &#123;      margin-right: var(--gap-horizontal);      &amp;:last-child &#123;        margin-right: 0;      &#125;    &#125;    &amp;.@&#123;class-prefix-space&#125;-wrap &#123;      flex-wrap: wrap;      margin-bottom: calc(var(--gap-vertical) * -1);      &gt; .@&#123;class-prefix-space&#125;-item &#123;        padding-bottom: var(--gap-vertical);      &#125;    &#125;  &#125;  &amp;.@&#123;class-prefix-space&#125;-block &#123;    display: flex;  &#125;  &amp;-align &#123;    &amp;-center &#123;      align-items: center;    &#125;    &amp;-start &#123;      align-items: flex-start;    &#125;    &amp;-end &#123;      align-items: flex-end;    &#125;    &amp;-baseline &#123;      align-items: baseline;    &#125;  &#125;  &amp;-justify &#123;    &amp;-center &#123;      justify-content: center;    &#125;    &amp;-start &#123;      justify-content: flex-start;    &#125;    &amp;-end &#123;      justify-content: flex-end;    &#125;    &amp;-between &#123;      justify-content: space-between;    &#125;    &amp;-around &#123;      justify-content: space-around;    &#125;    &amp;-evenly &#123;      justify-content: space-evenly;    &#125;    &amp;-stretch &#123;      justify-content: stretch;    &#125;  &#125;&#125;</code></pre><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><img src="http://t-blog-images.aijs.top/img/202208211218118.png" /><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; mergeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;with-default-props&quot;;import React, &#123; ReactNode, useState, useRef &#125; from &quot;react&quot;;import &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;import &#123; PictureOutline, PictureWrongOutline &#125; from &quot;antd-mobile-icons&quot;;import &#123; useInViewport &#125; from &quot;ahooks&quot;;import &#123; useInitialized &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;use-initialized&quot;;import &#123; staged &#125; from &quot;staged-components&quot;;import &#123; toCSSLength &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;to-css-length&quot;;const classPrefix &#x3D; &#96;adm-image&#96;;export type ImageProps &#x3D; &#123;  src: string;  alt?: string;  width?: number | string;  height?: number | string;  fit?: &quot;contain&quot; | &quot;cover&quot; | &quot;fill&quot; | &quot;none&quot; | &quot;scale-down&quot;;  placeholder?: ReactNode;  fallback?: ReactNode;  lazy?: boolean;  onClick?: (event: React.MouseEvent&lt;HTMLImageElement, Event&gt;) &#x3D;&gt; void;  onError?: (event: React.SyntheticEvent&lt;HTMLImageElement, Event&gt;) &#x3D;&gt; void;&#125; &amp; NativeProps&lt;&quot;--width&quot; | &quot;--height&quot;&gt; &amp;  Pick&lt;    React.ImgHTMLAttributes&lt;HTMLImageElement&gt;,    | &quot;crossOrigin&quot;    | &quot;decoding&quot;    | &quot;loading&quot;    | &quot;referrerPolicy&quot;    | &quot;sizes&quot;    | &quot;srcSet&quot;    | &quot;useMap&quot;  &gt;;const defaultProps &#x3D; &#123;  fit: &quot;fill&quot;,  placeholder: (    &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-tip&#96;&#125;&gt;      &lt;PictureOutline &#x2F;&gt;    &lt;&#x2F;div&gt;  ),  fallback: (    &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-tip&#96;&#125;&gt;      &lt;PictureWrongOutline &#x2F;&gt;    &lt;&#x2F;div&gt;  ),  lazy: false,&#125;;export const Image &#x3D; staged&lt;ImageProps&gt;((p) &#x3D;&gt; &#123;  const props &#x3D; mergeProps(defaultProps, p); &#x2F;&#x2F; 属性合并  const [loaded, setLoaded] &#x3D; useState(false);  const [failed, setFailed] &#x3D; useState(false);  const ref &#x3D; useRef&lt;HTMLDivElement&gt;(null);  let src: string | undefined &#x3D; props.src;  let srcSet: string | undefined &#x3D; props.srcSet;  &#x2F;&#x2F; 非懒加载  if (!props.lazy) &#123;    return render();  &#125;  &#x2F;&#x2F; 懒加载  return () &#x3D;&gt; &#123;    const inViewport &#x3D; useInViewport(ref); &#x2F;&#x2F; 当出现在视口中时，将    const initialized &#x3D; useInitialized(inViewport); &#x2F;&#x2F; inViewport为true时候进行初始化    &#x2F;&#x2F; useInitialized 源码    &#x2F;&#x2F; import &#123; useRef &#125; from &#39;react&#39;    &#x2F;&#x2F; export function useInitialized(check?: boolean) &#123; &#x2F;&#x2F; check为true的时候执行初始化    &#x2F;&#x2F;   const initializedRef &#x3D; useRef(check)    &#x2F;&#x2F;   if (check) &#123;    &#x2F;&#x2F;     initializedRef.current &#x3D; true    &#x2F;&#x2F;   &#125;    &#x2F;&#x2F;   return !!initializedRef.current    &#x2F;&#x2F; &#125;    &#x2F;&#x2F; 初始化时候，设置真实src、srcSet    src &#x3D; initialized ? props.src : undefined;    srcSet &#x3D; initialized ? props.srcSet : undefined;    return render();  &#125;;  function renderInner() &#123;    if (failed) &#123;      return props.fallback;    &#125;    return (      &lt;&gt;        &#x2F;&#x2F; 未加载完成的情况，展示placeholder        &#123;!loaded &amp;&amp; props.placeholder&#125;        &lt;img          className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-img&#96;&#125;          src&#x3D;&#123;src&#125;          alt&#x3D;&#123;props.alt&#125;          onClick&#x3D;&#123;props.onClick&#125;          onLoad&#x3D;&#123;() &#x3D;&gt; &#123;            setLoaded(true);          &#125;&#125;          onError&#x3D;&#123;(e) &#x3D;&gt; &#123;            setFailed(true);            props.onError?.(e);          &#125;&#125;          style&#x3D;&#123;&#123;            objectFit: props.fit,            display: loaded ? &quot;block&quot; : &quot;none&quot;,          &#125;&#125;          crossOrigin&#x3D;&#123;props.crossOrigin&#125; &#x2F;&#x2F; 跨域          decoding&#x3D;&#123;props.decoding&#125;          loading&#x3D;&#123;props.loading&#125;          referrerPolicy&#x3D;&#123;props.referrerPolicy&#125;          sizes&#x3D;&#123;props.sizes&#125;          srcSet&#x3D;&#123;srcSet&#125;          useMap&#x3D;&#123;props.useMap&#125; &#x2F;&#x2F; ????        &#x2F;&gt;      &lt;&#x2F;&gt;    );  &#125;  function render() &#123;    const style: ImageProps[&quot;style&quot;] &#x3D; &#123;&#125;;    if (props.width) &#123;      style[&quot;--width&quot;] &#x3D; toCSSLength(props.width);    &#125;    if (props.height) &#123;      style[&quot;--height&quot;] &#x3D; toCSSLength(props.height);    &#125;    return withNativeProps(      &#x2F;&#x2F; 组件增加属性      props,      &lt;div ref&#x3D;&#123;ref&#125; className&#x3D;&#123;classPrefix&#125; style&#x3D;&#123;style&#125;&gt;        &#123;renderInner()&#125;      &lt;&#x2F;div&gt;    );  &#125;&#125;);</code></pre><p><a href="https://github.com/ant-design/ant-design-mobile/blob/7c00eee09077d7805161b249ced34852db44c53b/src/utils/native-props.ts#L10" target="_blank" >见 withNativeProps</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; toCSSLength, 只是为了增加 px 单位export function toCSSLength(val: string | number) &#123;  return typeof val &#x3D;&#x3D;&#x3D; &quot;number&quot; ? &#96;$&#123;val&#125;px&#96; : val;&#125;</code></pre><h2 id="Floating-panel"><a href="#Floating-panel" class="headerlink" title="Floating-panel"></a>Floating-panel</h2><img src="http://t-blog-images.aijs.top/img/202208211339119.png" /><p><a href="https://github.com/ant-design/ant-design-mobile/blob/7c00eee09077d7805161b249ced34852db44c53b/src/components/floating-panel/floating-panel.tsx#L118" target="_blank" >源码</a></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React, &#123;  forwardRef,  ReactNode,  useImperativeHandle,  useRef,  useState,&#125; from &quot;react&quot;;import &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;import &#123; useDrag &#125; from &quot;@use-gesture&#x2F;react&quot;;&#x2F;&#x2F;@link: https:&#x2F;&#x2F;github.com&#x2F;pmndrs&#x2F;react-springimport &#123; useSpring, animated &#125; from &quot;@react-spring&#x2F;web&quot;;import &#123; supportsPassive &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;supports-passive&quot;;import &#123; nearest &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;nearest&quot;;export type FloatingPanelProps &#x3D; &#123;  anchors: number[];  children: ReactNode;&#125; &amp; NativeProps&lt;&quot;--border-radius&quot; | &quot;--z-index&quot;&gt;;export type FloatingPanelRef &#x3D; &#123;  setHeight: (    height: number,    options?: &#123;      immediate?: boolean;    &#125;  ) &#x3D;&gt; void;&#125;;export const FloatingPanel &#x3D; forwardRef&lt;FloatingPanelRef, FloatingPanelProps&gt;(  (props, ref) &#x3D;&gt; &#123;    const &#123; anchors &#125; &#x3D; props;    &#x2F;&#x2F;@link: https:&#x2F;&#x2F;mobile.ant.design&#x2F;zh&#x2F;components&#x2F;floating-panel#floatingpanel    &#x2F;*这里取最后一个为最大高度，[300,50,200],取的是200,😓，文档没说啊 *&#x2F;    const maxHeight &#x3D; anchors[anchors.length - 1] ?? window.innerHeight;    const possibles &#x3D; anchors.map((x) &#x3D;&gt; -x); &#x2F;&#x2F; 顶部是负值    const elementRef &#x3D; useRef&lt;HTMLDivElement&gt;(null);    const headerRef &#x3D; useRef&lt;HTMLDivElement&gt;(null);    const contentRef &#x3D; useRef&lt;HTMLDivElement&gt;(null);    const [pulling, setPulling] &#x3D; useState(false);    const pullingRef &#x3D; useRef(false);    const bounds &#x3D; &#123;      top: possibles[possibles.length - 1], &#x2F;&#x2F; 顶部是负值      bottom: possibles[0], &#x2F;&#x2F; 底部取0， 0位不一定是最小的😓    &#125;;    const [&#123; y &#125;, api] &#x3D; useSpring(() &#x3D;&gt; (&#123;      &#x2F;&#x2F; useSpring      y: bounds.bottom,      config: &#123; tension: 300 &#125;,    &#125;));    useDrag(      (state) &#x3D;&gt; &#123;        const [, offsetY] &#x3D; state.offset;        if (state.first) &#123;          const target &#x3D; state.event.target as Element;          const header &#x3D; headerRef.current;          if (header &#x3D;&#x3D;&#x3D; target || header?.contains(target)) &#123;            pullingRef.current &#x3D; true;          &#125; else &#123;            const reachedTop &#x3D; y.goal &lt;&#x3D; bounds.top;            const content &#x3D; contentRef.current;            if (!content) return;            if (reachedTop) &#123;              if (content.scrollTop &lt;&#x3D; 0 &amp;&amp; state.direction[1] &gt; 0) &#123;                pullingRef.current &#x3D; true;              &#125;            &#125; else &#123;              pullingRef.current &#x3D; true;            &#125;          &#125;        &#125;        setPulling(pullingRef.current);        if (!pullingRef.current) return;        const &#123; event &#125; &#x3D; state;        if (event.cancelable) &#123;          event.preventDefault();        &#125;        event.stopPropagation();        let nextY &#x3D; offsetY;        if (state.last) &#123;          pullingRef.current &#x3D; false;          setPulling(false);          nextY &#x3D; nearest(possibles, offsetY);        &#125;        api.start(&#123;          y: nextY,        &#125;);      &#125;,      &#123;        axis: &quot;y&quot;,        bounds,        rubberband: true,        from: () &#x3D;&gt; [0, y.get()],        pointer: &#123; touch: true &#125;,        target: elementRef,        eventOptions: supportsPassive ? &#123; passive: false &#125; : false,      &#125;    );    useImperativeHandle(      ref,      () &#x3D;&gt; (&#123;        setHeight: (          height: number,          options?: &#123;            immediate?: boolean;          &#125;        ) &#x3D;&gt; &#123;          api.start(&#123;            y: -height,            immediate: options?.immediate,          &#125;);        &#125;,      &#125;),      [api]    );    return withNativeProps(      props,      &lt;animated.div        ref&#x3D;&#123;elementRef&#125;        className&#x3D;&quot;adm-floating-panel&quot;        style&#x3D;&#123;&#123;          height: maxHeight,          y,        &#125;&#125;      &gt;        &#x2F;&#x2F; 遮照， 怎么没看到效果呢？？？？        &lt;div          className&#x3D;&quot;adm-floating-panel-mask&quot;          style&#x3D;&#123;&#123;            display: pulling ? &quot;block&quot; : &quot;none&quot;,          &#125;&#125;        &#x2F;&gt;        &#x2F;&#x2F; bar内容        &lt;div className&#x3D;&quot;adm-floating-panel-header&quot; ref&#x3D;&#123;headerRef&#125;&gt;          &lt;div className&#x3D;&quot;adm-floating-panel-bar&quot; &#x2F;&gt;        &lt;&#x2F;div&gt;        &lt;div className&#x3D;&quot;adm-floating-panel-content&quot; ref&#x3D;&#123;contentRef&#125;&gt;          &#123;props.children&#125;        &lt;&#x2F;div&gt;      &lt;&#x2F;animated.div&gt;    );  &#125;);</code></pre><p><a href="https://github.com/ant-design/ant-design-mobile/blob/7c00eee09077d7805161b249ced34852db44c53b/src/components/floating-panel/floating-panel.tsx#L100" target="_blank" >useImperativeHandle</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>正常情况下 ref 是不能挂在到函数组件上的，因为函数组件没有实例，但是 useImperativeHandle 为我们提供了一个类似实例的东西。它帮助我们通过 useImperativeHandle 的第 2 个参数，所返回的对象的内容挂载到 父组件的 ref.current 上。</p><p>forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。</p><p>作者：机智的狮老师<br>链接：<a href="https://www.jianshu.com/p/bf9f66ac3f9c">https://www.jianshu.com/p/bf9f66ac3f9c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import React, &#123;  forwardRef,  useImperativeHandle,  useEffect,  useRef,&#125; from &quot;react&quot;;const TestRef &#x3D; forwardRef((props, ref) &#x3D;&gt; &#123;  useImperativeHandle(ref, () &#x3D;&gt; (&#123;    open() &#123;      console.log(&quot;open&quot;);    &#125;,  &#125;));&#125;);function App() &#123;  const ref &#x3D; useRef();  useEffect(() &#x3D;&gt; &#123;    ref.current.open();  &#125;, []);  return (    &lt;&gt;      &lt;div&gt;石小阳&lt;&#x2F;div&gt;      &lt;TestRef ref&#x3D;&#123;ref&#125;&gt;&lt;&#x2F;TestRef&gt;    &lt;&#x2F;&gt;  );&#125;export default App;</code></pre><p>另一种实现：可以使用 hooks 把子组件数据绑定到一个 ref 上（这个 ref 是父组件传入的）如下：</p><p><strong>子组件</strong></p><img src="http://t-blog-images.aijs.top/img/202208211349068.png" /><p><strong>父组件</strong></p><img src="http://t-blog-images.aijs.top/img/202208211351388.png" /><img src="http://t-blog-images.aijs.top/img/202208211351568.png" /><p>可见 <code>useImperativeHandle</code>方式更优雅</p><h2 id="tabs-与-内容联动"><a href="#tabs-与-内容联动" class="headerlink" title="tabs 与 内容联动"></a>tabs 与 内容联动</h2><img src="http://t-blog-images.aijs.top/img/202208211737240.gif" /><p><a href="https://mobile.ant.design/zh/components/tabs" target="_blank" >见</a></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; Tabs &#125; from &quot;antd-mobile&quot;;import &#123; DemoBlock, lorem &#125; from &quot;demos&quot;;import styles from &quot;.&#x2F;demo4.less&quot;;import &#123; useThrottleFn &#125; from &quot;ahooks&quot;;const tabItems &#x3D; [  &#123; key: &quot;1&quot;, title: &quot;第一项&quot;, text: lorem.generateParagraphs(8) &#125;,  &#123; key: &quot;2&quot;, title: &quot;第二项&quot;, text: lorem.generateParagraphs(8) &#125;,  &#123; key: &quot;3&quot;, title: &quot;第三项&quot;, text: lorem.generateParagraphs(8) &#125;,  &#123; key: &quot;4&quot;, title: &quot;第四项&quot;, text: lorem.generateParagraphs(8) &#125;,];const tabHeight &#x3D; 42;export default () &#x3D;&gt; &#123;  const [activeKey, setActiveKey] &#x3D; useState(&quot;1&quot;);  const &#123; run: handleScroll &#125; &#x3D; useThrottleFn(    () &#x3D;&gt; &#123;      let currentKey &#x3D; tabItems[0].key;      for (const item of tabItems) &#123;        const element &#x3D; document.getElementById(&#96;anchor-$&#123;item.key&#125;&#96;);        if (!element) continue;        const rect &#x3D; element.getBoundingClientRect();        if (rect.top &lt;&#x3D; tabHeight) &#123;          &#x2F;&#x2F; 通过滚动设置key          currentKey &#x3D; item.key;        &#125; else &#123;          break;        &#125;      &#125;      setActiveKey(currentKey);    &#125;,    &#123;      leading: true,      trailing: true,      wait: 100,    &#125;  );  useEffect(() &#x3D;&gt; &#123;    window.addEventListener(&quot;scroll&quot;, handleScroll);    return () &#x3D;&gt; &#123;      window.removeEventListener(&quot;scroll&quot;, handleScroll);    &#125;;  &#125;, []);  return (    &lt;&gt;      &lt;DemoBlock title&#x3D;&quot;作为页面滚动的导航&quot; padding&#x3D;&quot;0&quot;&gt;        &lt;div className&#x3D;&#123;styles.tabsContainer&#125;&gt;          &lt;Tabs            activeKey&#x3D;&#123;activeKey&#125; &#x2F;&#x2F; 滚动时候设置 activeKey            onChange&#x3D;&#123;(key) &#x3D;&gt; &#123;              document.getElementById(&#96;anchor-$&#123;key&#125;&#96;)?.scrollIntoView(); &#x2F;&#x2F; 滚动到视口              window.scrollTo(&#123;                &#x2F;&#x2F; 点击时候滚动的位置                top: window.scrollY - tabHeight,              &#125;);            &#125;&#125;          &gt;            &#123;tabItems.map((item) &#x3D;&gt; (              &lt;Tabs.Tab title&#x3D;&#123;item.title&#125; key&#x3D;&#123;item.key&#125; &#x2F;&gt;            ))&#125;          &lt;&#x2F;Tabs&gt;        &lt;&#x2F;div&gt;        &lt;div className&#x3D;&#123;styles.content&#125;&gt;          &#123;tabItems.map((item) &#x3D;&gt; (            &lt;div key&#x3D;&#123;item.key&#125;&gt;              &#x2F;&#x2F; 这里设置id              &lt;h2 id&#x3D;&#123;&#96;anchor-$&#123;item.key&#125;&#96;&#125;&gt;&#123;item.title&#125;&lt;&#x2F;h2&gt;              &#123;item.text&#125;            &lt;&#x2F;div&gt;          ))&#125;        &lt;&#x2F;div&gt;      &lt;&#x2F;DemoBlock&gt;    &lt;&#x2F;&gt;  );&#125;;</code></pre><p><a href="https://github.com/ant-design/ant-design-mobile/blob/7c00eee09077d7805161b249ced34852db44c53b/src/components/tabs/index.ts#L7" target="_blank" >见</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &quot;.&#x2F;tabs.less&quot;;import &#123; TabPane, Tabs &#125; from &quot;.&#x2F;tabs&quot;;import &#123; attachPropertiesToComponent &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;attach-properties-to-component&quot;;export type &#123; TabsProps, TabPaneProps &#125; from &quot;.&#x2F;tabs&quot;;export default attachPropertiesToComponent(Tabs, &#123;  &#x2F;&#x2F; 之后可以使用 Tabs.TabPane提示  TabPane,&#125;);</code></pre><h2 id="badge-看个简单的放松下"><a href="#badge-看个简单的放松下" class="headerlink" title="badge 看个简单的放松下"></a>badge 看个简单的放松下</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &quot;.&#x2F;badge.less&quot;;import &#123; Badge, dot &#125; from &quot;.&#x2F;badge&quot;;import &#123; attachPropertiesToComponent &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;attach-properties-to-component&quot;;export type &#123; BadgeProps &#125; from &quot;.&#x2F;badge&quot;;export default attachPropertiesToComponent(Badge, &#123;  dot, &#x2F;&#x2F; Badge 增加 dot属性&#125;);</code></pre><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import classNames from &quot;classnames&quot;;import React from &quot;react&quot;;import &#123; NativeProps, withNativeProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;native-props&quot;;import &#123; withDefaultProps &#125; from &quot;..&#x2F;..&#x2F;utils&#x2F;with-default-props&quot;;const classPrefix &#x3D; &#96;adm-badge&#96;;export const dot &#x3D; Symbol(); &#x2F;&#x2F; ????export type BadgeProps &#x3D; &#123;  content?: React.ReactNode | typeof dot;  color?: string;&#125; &amp; NativeProps&lt;&quot;--right&quot; | &quot;--top&quot;&gt;;export const Badge &#x3D; withDefaultProps(&#123;  color: &quot;#FF411C&quot;,&#125;)&lt;BadgeProps&gt;((props) &#x3D;&gt; &#123;  const &#123; content, color, children &#125; &#x3D; props;  const isDot &#x3D; content &#x3D;&#x3D;&#x3D; dot; &#x2F;&#x2F; 判断是不是 dot  const badgeCls &#x3D; classNames(classPrefix, &#123;    [&#96;$&#123;classPrefix&#125;-fixed&#96;]: !!children,    [&#96;$&#123;classPrefix&#125;-dot&#96;]: isDot,  &#125;);  &#x2F;&#x2F; 有内容不是dot 渲染内容，是dot 不渲染内容  const element &#x3D; content    ? withNativeProps(        props,        &lt;div &#x2F;&#x2F; dot 是元素，不是伪元素          className&#x3D;&#123;badgeCls&#125;          style&#x3D;&#123;&#123;            backgroundColor: color,          &#125;&#125;        &gt;          &#123;!isDot &amp;&amp; content&#125;        &lt;&#x2F;div&gt;      )    : null;  &#x2F;&#x2F; 有子节点， 无子节点，直接渲染  return children ? (    &lt;div className&#x3D;&#123;&#96;$&#123;classPrefix&#125;-wrap&#96;&#125;&gt;      &#123;children&#125;      &#123;element&#125;    &lt;&#x2F;div&gt;  ) : (    element  );&#125;);</code></pre><pre class="line-numbers language-less" data-language="less"><code class="language-less">@class-prefix-badge: ~&quot;adm-badge&quot;;.@&#123;class-prefix-badge&#125;-wrap &#123;  display: inline-block;  position: relative;&#125;.@&#123;class-prefix-badge&#125; &#123;  display: inline-block;  color: #fff;  font-weight: normal;  text-align: center;  vertical-align: middle;  box-sizing: border-box;  min-width: 16px;  border-radius: 100px;  padding: 0 4px;  font-size: 9px;  line-height: 1.2;  white-space: nowrap;  --right: 0;  --top: 0;  &amp;-fixed &#123;    position: absolute;    right: var(--right);    top: var(--top);    transform: translate(50%, -50%);  &#125;  &amp;-dot &#123;    &#x2F;&#x2F;  元素dot    min-width: 10px;    width: 10px;    height: 10px;    border-radius: 5px;  &#125;&#125;</code></pre><h2 id="暂时放下"><a href="#暂时放下" class="headerlink" title="暂时放下"></a>暂时放下</h2><!-- <img src="http://t-blog-images.aijs.top/img/202208212104877.png" /> 需删除 -->]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-实操</title>
      <link href="//post/2022-08-20ts.html"/>
      <url>//post/2022-08-20ts.html</url>
      
        <content type="html"><![CDATA[<h2 id="对于不能穷举的处理"><a href="#对于不能穷举的处理" class="headerlink" title="对于不能穷举的处理"></a>对于不能穷举的处理</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Option &#123;  label: string;  value: any;&#125;interface EnumOption &#123;  &#x2F;** 价值观成绩 *&#x2F;  valuesGrade: Option[];  &#x2F;** 绩效成绩 *&#x2F;  perfLevel: Option[];  &#x2F;** 户口状态 *&#x2F;  censusRegister: Option[];  [key: string]: Option[]; &#x2F;&#x2F; 这里&#125;type OfferOption &#x3D; EnumOption;</code></pre><h2 id="这个还没想好"><a href="#这个还没想好" class="headerlink" title="这个还没想好"></a>这个还没想好</h2><img src="http://t-blog-images.aijs.top/img/202208201107064.webp" /><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface IMBOrgStaffContext &#123;  orgs: Org[];  setOrgs?: (orgs: Org[]) &#x3D;&gt; void;  staffs: Staff[];  setStaffs?: (staffs: Staff[]) &#x3D;&gt; void;  values: OrgStaff;  setValues?: (staffs: OrgStaff) &#x3D;&gt; void;&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/202208201108809.webp" /><h2 id="Enum-的注释"><a href="#Enum-的注释" class="headerlink" title="Enum 的注释"></a>Enum 的注释</h2><p><code>/** 开始处理 */</code> 不要写成 <code>//开始处理</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export enum EOperator &#123;  &#x2F;** 开始处理 *&#x2F;  processing &#x3D; 2,  &#x2F;** 已解决 *&#x2F;  solved &#x3D; 5,  &#x2F;** 完结 *&#x2F;  finish &#x3D; 6,  &#x2F;** 取消 *&#x2F;  cancel &#x3D; 7,  &#x2F;** 经办人变更 *&#x2F;  solver &#x3D; 1008,  &#x2F;** 协作人添加 *&#x2F;  add_helper &#x3D; 1009,  &#x2F;** 协作人移除 *&#x2F;  &#x2F;&#x2F;  无  &#x2F;** 退出协作 *&#x2F;  exit_helper &#x3D; 1011,  &#x2F;** 催办 *&#x2F;  remind &#x3D; 1012,  &#x2F;** 提醒确认 *&#x2F;  notify_creator &#x3D; 1013,  &#x2F;** 指派经办人 *&#x2F;  assign_operator &#x3D; 1014,  &#x2F;** 添加关注人 *&#x2F;  add_follower &#x3D; 1015,  &#x2F;** 关注问题 *&#x2F;  to_follow &#x3D; 1016,&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/202209091433185.webp" />]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包管理工具-pnpm</title>
      <link href="//post/2022-08-19pnpm.html"/>
      <url>//post/2022-08-19pnpm.html</url>
      
        <content type="html"><![CDATA[<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><!-- <img src="http://t-blog-images.aijs.top/img/202208182037738.png" /> TODO:del--><p><a href="https://pnpm.io/zh/pnpm-cli" target="_blank" >官网</a></p><img src="http://t-blog-images.aijs.top/img/202208191037942.webp" /><h2 id="pnpm-安装路径"><a href="#pnpm-安装路径" class="headerlink" title="pnpm 安装路径"></a>pnpm 安装路径</h2><pre class="line-numbers language-none"><code class="language-none">👑 ~ $ which pnpm&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pnpm👑 ~ $ which pnpn: aliased to pnpm</code></pre><h2 id="使用较短的别名"><a href="#使用较短的别名" class="headerlink" title="使用较短的别名"></a>使用较短的别名</h2><p>pnpm 可能很难输入，因此您可以使用较短的别名，例如 pn。 只需将下面这行放入 <code>.bashrc</code>、 <code>.zshrc</code> 或 <code>config.fish</code> 中：</p><pre class="line-numbers language-none"><code class="language-none">alias pn&#x3D;pnpm</code></pre><p>我的<code>.zshrc</code>路径：<code>/Users/haotian/.zshrc</code></p><p>同理，我们可以将其他命令也简化</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">alias yn&#x3D;yarn♠ &#x2F;Users&#x2F;chenhailong $ which pnpn: aliased to pnpm♠ &#x2F;Users&#x2F;chenhailong $ which ynyn: aliased to yarn♠ &#x2F;Users&#x2F;chenhailong $</code></pre><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>有关更多信息，请参阅各个 CLI 命令的文档。 以下是简便的 npm 命令等效列表，可帮助您入门：</p><pre class="line-numbers language-none"><code class="language-none">npm 命令 pnpm 等效npm install pnpm installnpm i &lt;pkg&gt; [pnpm add &lt;pkg&gt;]npm run &lt;cmd&gt; [pnpm &lt;cmd&gt;]</code></pre><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><img src="http://t-blog-images.aijs.top/img/202210100950400.webp" />]]></content>
      
      
      <categories>
          
          <category> 包管理工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-es6+</title>
      <link href="//post/2022-08-17es.html"/>
      <url>//post/2022-08-17es.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903959283367950" target="_blank" >1.5万字概括ES6全部特性(已更新ES2020)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信- 授权</title>
      <link href="//post/2022-08-17wx-auth.html"/>
      <url>//post/2022-08-17wx-auth.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>项目：已经有一个项目了，又整一个新项目共存</li><li>域名：一级相同，二级域名不同</li></ul><p><strong>微信授权回调限制, 回调可信域名只能配置一个</strong></p><img src="http://t-blog-images.aijs.top/img/202208171607858.webp" /><h2 id="变更后的授权流程"><a href="#变更后的授权流程" class="headerlink" title="变更后的授权流程"></a>变更后的授权流程</h2><img src="http://t-blog-images.aijs.top/img/202208171604440.webp" /><p><a href="https://app.diagrams.net/?src=about#H841660202%2Fpic%2Fmain%2Ftask-report" target="_blank" >draw.io</a></p><h2 id="增加调试-强制内网"><a href="#增加调试-强制内网" class="headerlink" title="增加调试 - 强制内网"></a>增加调试 - 强制内网</h2><p>强制 本地&#x2F;日常&#x2F;预发环境 走内网，方便在企业微信进行适配</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Config 为nextjs， 运行时配置信息&#x2F;&#x2F; 方便 日常&#x2F;预发环境 到企业微信中调试let forceInNetwork &#x3D; true;if (isServer &amp;&amp; Config.env &#x3D;&#x3D;&#x3D; &quot;pro&quot;) &#123;  &#x2F;&#x2F; 线上环境 + 服务端渲染，不强制走内网  forceInNetwork &#x3D; false;&#125; else if (!isServer &amp;&amp; window.__NEXT_DATA__.runtimeConfig.env &#x3D;&#x3D;&#x3D; &quot;pro&quot;) &#123;  &#x2F;&#x2F; 线上环境 + 客户端渲染，不强制走内网  forceInNetwork &#x3D; false;&#125;if (  !forceInNetwork &amp;&amp; &#x2F;&#x2F; 非强制内网 + 微信环境，请求头设置 x-ty-auth-type  getWechatUserAgent(    isServer ? ctx.req.headers[&quot;user-agent&quot;] : navigator.userAgent  )) &#123;  options.headers[&quot;x-ty-auth-type&quot;] &#x3D; &quot;wx&quot;;&#125;&#x2F;&#x2F; ....let apiUrl &#x3D; &quot;&quot;;&#x2F;&#x2F; 非强制内网 + 服务端 + 企业微信环境， 走企业微信授权if (  !forceInNetwork &amp;&amp;  isServer &amp;&amp;  getWechatUserAgent(options.headers[&quot;user-agent&quot;])) &#123;  apiUrl &#x3D; Config.wechatAuthProviderOrigin;&#125; else &#123;  apiUrl &#x3D; Config.api;&#125;</code></pre><h2 id="增加调试-设置-cookie"><a href="#增加调试-设置-cookie" class="headerlink" title="增加调试 - 设置 cookie"></a>增加调试 - 设置 cookie</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; useRouter &#125; from &quot;@ty-fe&#x2F;next&#x2F;router&quot;;import &#123; usePersistFn &#125; from &quot;ahooks&quot;;import &#123; AutoCenter, Button, Card, Input, Space &#125; from &quot;antd-mobile&quot;;import React, &#123; useState &#125; from &quot;react&quot;;interface IProps &#123;&#125;const SetCookie: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const router &#x3D; useRouter();  const [cookie, setCookie] &#x3D; useState(    &quot;ss_pweTnTjCiU_1bVtt6GNbd4UT2B7nK87S8xCXE3t0xuqMqDmlu7mH7PoBQ_HwwCYA616QM_9d_2yUsduiNyRrXrXQWZG1TtD7ZNNI1k3XMBx-wsYq59DKsv3Bh6nnZ9zkG-NCHsSdxbHZZ-2bCQIZ-oZ9eGiXEIo&quot;  );  const handleSetCookie &#x3D; usePersistFn(() &#x3D;&gt; &#123;    document.cookie &#x3D; &quot;SSO_USER_TOKEN&quot; + &quot;&#x3D;&quot; + cookie;  &#125;);  const handleChange &#x3D; usePersistFn((v) &#x3D;&gt; &#123;    setCookie(v);  &#125;);  const handleGoMbHome &#x3D; usePersistFn(() &#x3D;&gt; &#123;    router.push(&quot;&#x2F;my&#x2F;mobile?activeTab&#x3D;1&quot;);  &#125;);  return (    &lt;Card&gt;      &lt;p&gt;设置cookie&lt;&#x2F;p&gt;      &lt;Input        style&#x3D;&#123;&#123; border: &quot;1px solid #000&quot; &#125;&#125;        value&#x3D;&#123;cookie&#125;        placeholder&#x3D;&quot;输入cookie&quot;        onChange&#x3D;&#123;handleChange&#125;      &#x2F;&gt;      &lt;br&gt;&lt;&#x2F;br&gt;      &lt;Space&gt;        &lt;Button color&#x3D;&quot;primary&quot; fill&#x3D;&quot;solid&quot; onClick&#x3D;&#123;handleSetCookie&#125;&gt;          设置cookie        &lt;&#x2F;Button&gt;        &lt;Button color&#x3D;&quot;primary&quot; fill&#x3D;&quot;solid&quot; onClick&#x3D;&#123;handleGoMbHome&#125;&gt;          移动端首页        &lt;&#x2F;Button&gt;      &lt;&#x2F;Space&gt;    &lt;&#x2F;Card&gt;  );&#125;;export default SetCookie;</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="No-1"><a href="#No-1" class="headerlink" title="No.1"></a>No.1</h3><p>对于某些需要使用到当前用户数据的页面，在作为入口的时候需要特别注意</p><p><span style="color: red">会出现拿不到当前登录用户信息的情况</span></p><p><strong>过程如下</strong></p><ol><li>开始是没有授权的</li><li>授权之后，页面被重定向回到该页面</li><li>由于已加载了，有缓存，服务端不会再走一遍，在服务端往<code>redux</code>塞数据的时候，不会再次触发</li><li>如果服务端有些接口设计的时候不是从 cookie 中获取用户信息，前端在传当前用户信息的时候，很有可能<code>redux</code>中没有该用户信息</li></ol><p><strong>解决方案</strong>： 在一些入口页面，<code>redux</code> 取不到用户信息时候，客户端渲染时候再次获取用户信息</p><h3 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h3><p>部分企业微信 pc 客户端不支持<code>[].at()</code>方法, 避免使用此 api 的时候， polyfill 是解决不了问题的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/at#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5" target="_blank" >见</a></p><p><a href="https://github.com/zloirock/core-js/blob/b61f3c334f7a3010f376eae4fc465e68232da102/packages/core-js/modules/es.array.at.js#L11" target="_blank" >code</a></p><img src="http://t-blog-images.aijs.top/img/202208250909849.webp" /><p><a href="/#/post/2022-07-14js-arr#:~:text=Copy-,at,-at()%20%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6" target="_blank" >2022-07-14js-arr</a></p><p>经测试发现 polyfill 无效, 应该是被企业微信限制了</p><img src="http://t-blog-images.aijs.top/img/202208250920994.webp" /><p>企业微信限制了<code>Array</code>，为何有的企业微信客户端可以，我猜是企业微信的一个 bug</p><img src="http://t-blog-images.aijs.top/img/202208250949357.webp" /><h3 id="No-3"><a href="#No-3" class="headerlink" title="No.3"></a>No.3</h3>]]></content>
      
      
      <categories>
          
          <category> 企业微信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备份插件排查code helper</title>
      <link href="//post/2022-08-11vscode-plugins.html"/>
      <url>//post/2022-08-11vscode-plugins.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre class="line-numbers language-none"><code class="language-none">codegen_anythingcodegen_mockcodegen_sinipetsCSS Module TypedCSS ModulesColor HighlightES7+ React&#x2F;Redux&#x2F;React-Native snippetsLeetCodeReact Native SnippetReact Native ToolsReact-Native&#x2F;React&#x2F;Redux snippets for es6&#x2F;es7XMLPaste JSON as CodeNested CommentsMaterial Icon ThemeAuto Rename Tagbackground-coverESLintImport CostBookmarksCode RunnerFavoritesgitignoreImageToTextGit GraphTodo TreeLive ServerES7+ React&#x2F;Redux&#x2F;React-Native snippetsPath IntellisenseSettings SyncSort JS object keysi18n Ally</code></pre><h2 id="Git-History"><a href="#Git-History" class="headerlink" title="Git History"></a>Git History</h2><p>插件引起内存泄漏,导致 code helper cpu 超负荷运行</p><h2 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h2><img src="http://t-blog-images.aijs.top/img/202208171557626.webp" /><h2 id="新学的几个"><a href="#新学的几个" class="headerlink" title="新学的几个"></a>新学的几个</h2><ul><li>Project Manager : 还是比较需要的，目前维护上个部门所有任务，<code>recent open</code>找项目确实有点头大</li><li>Template String Converter: 字符串转字符串模版，<span style="color: red">TODO: 源码：可以学习下这个项目是如何实现的</span></li><li>合并行: 这个是vscode快捷键，不是插件</li></ul>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React使用swiper</title>
      <link href="//post/2022-08-05swiper.html"/>
      <url>//post/2022-08-05swiper.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">.maskBody &#123;  display: flex;  align-items: center;  justify-content: center;  height: 100vh;  width: 100vw;&#125;.swiperItem &#123;  height: calc(100vh - 48px);  width: 100%;  display: flex;  align-items: center;  justify-content: center;  text-align: center;&#125;</code></pre><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&lt;Swiper activeSlideKey&#x3D;&#123;activeSlideKey&#125; &#123;...params&#125;&gt;  &#123;files.map((item) &#x3D;&gt; (    &lt;div key&#x3D;&#123;item.fileKey&#125; className&#x3D;&#123;styles.swiperItem&#125;&gt; &lt;!--不写此处,无法滚动--&gt;      &lt;ImageViewer url&#x3D;&#123;item.signaturedUrls&#125; &#x2F;&gt;    &lt;&#x2F;div&gt;  ))&#125;&lt;&#x2F;Swiper&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> swiper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swiper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React hooks执行</title>
      <link href="//post/2022-08-02-react-hooks.html"/>
      <url>//post/2022-08-02-react-hooks.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>hooks是什么？</li><li>react怎么执行函数组件</li><li>函数组件的fiber是什么？</li><li>为什么setState可以获取最新的State</li><li>updateWorkInProgressHook如何获取hooks</li><li>优先级跳过update，react为了避免状态丢失做的处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OA业务相关</title>
      <link href="//post/2022-08-01oa%E5%B7%A5%E5%85%B7.html"/>
      <url>//post/2022-08-01oa%E5%B7%A5%E5%85%B7.html</url>
      
        <content type="html"><![CDATA[<h2 id="slate"><a href="#slate" class="headerlink" title="slate"></a>slate</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/ianstormtaylor/slate">https://github.com/ianstormtaylor/slate</a><img src="https://img.shields.io/github/stars/ianstormtaylor/slate?style=social" /></div><img src="http://t-blog-images.aijs.top/img/202208011820703.webp" style="max-width: 100%; width: 600px"/><p><code>钉钉文档</code>、<code>BOSS直聘文档</code>、<code>我们公司的wiki文档</code> 都是使用 slate 开发的</p><p>我们公司的 wiki 文档</p><img src="http://t-blog-images.aijs.top/img/202209091046015.webp"  style="max-width: 100%; width: 600px"/><p><a href="https://www.zhihu.com/people/dingsuite/posts" target="_blank" >钉钉文档</a></p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="http://t-blog-images.aijs.top/img/202208011817748.webp" style="max-width: 100%; width: 600px" /><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>不建议直接使用百度脑图仓库进行二次开发。</p><p>需要脑图可视化需求的，可以基于 <a href="https://github.com/fex-team/kityminder-core" target="_blank" >kityminder-core</a> 进行二次开发；<br>需要脑图编辑需求的，可以使用 <a href="https://github.com/fex-team/kityminder-editor" target="_blank" >kityminder-editor</a> 进行二次开发。</p></blockquote><h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><img src="http://t-blog-images.aijs.top/img/202208011824433.webp" style="max-width: 100%; width: 600px"/><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/StavinLi/Workflow"">https://github.com/StavinLi/Workflow"</a><img src="https://img.shields.io/github/stars/StavinLi/Workflow"?style=social" /></div><h2 id="logicflow"><a href="#logicflow" class="headerlink" title="logicflow"></a>logicflow</h2><p><a href="http://logic-flow.org/" target="_blank" >logic-flow</a></p><div style="display: flex;justify-content: center;">  <img src="http://logic-flow.org/horizontal-logo.png" style="width: 200px"/></div><img src="https://dpubstatic.udache.com/static/dpubimg/e35cef10-bb7c-4662-a494-f5aac024c092.gif" /><h2 id="excalidraw"><a href="#excalidraw" class="headerlink" title="excalidraw"></a>excalidraw</h2><img src="http://t-blog-images.aijs.top/img/202207281742669.webp" style="max-width: 100%; width: 600px" /><p><a href="https://excalidraw.com/" target="_blank" >excalidraw</a></p><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/excalidraw/excalidraw">https://github.com/excalidraw/excalidraw</a><img src="https://img.shields.io/github/stars/excalidraw/excalidraw?style=social" /></div><h2 id="tldraw"><a href="#tldraw" class="headerlink" title="tldraw"></a>tldraw</h2><img src="http://t-blog-images.aijs.top/img/202207281745647.webp" style="max-width: 100%; width: 600px" /><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/tldraw/tldraw">https://github.com/tldraw/tldraw</a><img src="https://img.shields.io/github/stars/tldraw/tldraw?style=social" /></div><p><a href="https://www.tldraw.com/" target="_blank" >tldraw</a></p><h2 id="wfd"><a href="#wfd" class="headerlink" title="wfd"></a>wfd</h2><img src="http://t-blog-images.aijs.top/img/202207281755202.webp" style="max-width: 100%; width: 600px" /><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/guozhaolong/wfd">https://github.com/guozhaolong/wfd</a><img src="https://img.shields.io/github/stars/guozhaolong/wfd?style=social" /></div><h2 id="butterfly"><a href="#butterfly" class="headerlink" title="butterfly"></a>butterfly</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/alibaba/butterfly">https://github.com/alibaba/butterfly</a><img src="https://img.shields.io/github/stars/alibaba/butterfly?style=social" /></div><p><a href="https://butterfly-dag.gitee.io/butterfly-dag/demo/analysis" target="_blank" >小蝴蝶官网</a></p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p><a href="http://developer.le5le.com/tutorial/start.html" target="_blank" >le5le-com&#x2F;topology</a></p><p><a href="https://github.com/search?o=desc&q=uml&s=stars&type=Repositories" target="_blank" >github 搜索</a></p><h2 id="react-data-flow"><a href="#react-data-flow" class="headerlink" title="react-data-flow"></a>react-data-flow</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/chicAboo/react-data-flow">https://github.com/chicAboo/react-data-flow</a><img src="https://img.shields.io/github/stars/chicAboo/react-data-flow?style=social" /></div><img src="http://t-blog-images.aijs.top/img/202210271020235.webp" /><h2 id="n8n"><a href="#n8n" class="headerlink" title="n8n"></a>n8n</h2><p>免费且源代码可用的公平代码授权工作流自动化工具。跨不同服务轻松执行自动任务。</p><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/n8n-io/n8n">https://github.com/n8n-io/n8n</a><img src="https://img.shields.io/github/stars/n8n-io/n8n?style=social" /></div><img src="http://t-blog-images.aijs.top/img/202211101808710.webp" /><h2 id="flowy"><a href="#flowy" class="headerlink" title="flowy"></a>flowy</h2><div style="display: flex;align-items: center;padding-top:4px;padding-bottom: 4px"><a target="_blank" href="https://github.com/alyssaxuu/flowy">https://github.com/alyssaxuu/flowy</a><img src="https://img.shields.io/github/stars/alyssaxuu/flowy?style=social" /></div><h2 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h2>]]></content>
      
      
      <categories>
          
          <category> 业务相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js 作用域</title>
      <link href="//post/2022-07-30js-scope.html"/>
      <url>//post/2022-07-30js-scope.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>var let const 区别：</p><ol><li>版本： var 是 es6 之前， const、let es6 之后，</li><li>分类： 在 es6 之前只有全局作用域和函数作用域， const、let 块级作用域</li><li>提升：三者都会有变量提升，但是 let const 有暂时性死区，没执行声明出，提前使用会报错</li><li>重复：var 可以重复声明、重复赋值，let 不可以重复声明，单可重复赋值，const 不可重复声明和赋值</li><li>存储：全局 var 是存储到 Gloabl 上的，let const 是存储到 Script 上的</li><li>默认： 默认情况下是 var 声明</li><li>函数：函数声明提升优先于 var</li></ol><p>作用域：</p><ol><li>什么是执行上下文？</li><li>什么是词法环境？</li><li>什么是作用域？</li><li>什么是作用域链？</li></ol><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="http://t-blog-images.aijs.top/img/作用域.png" style="max-width: 100%; width: 600px" /><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>MDN:</strong></p><p><span style="color: red">在当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。</span> 如果一个<strong>变量或者其他表达式</strong>,不 “在当前的作用域中”，那么它就是不可用的。</p><p>作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p><p>作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在函数之外声明的变量，叫做<code>全局变量</code>，因为它可被当前文档中的任何其他代码所访问。<br>在函数内部声明的变量，叫做<code>局部变量</code>，因为它只能在当前函数的内部访问。<br>ECMAScript 6 之前的 JavaScript 没有 <code>语句块作用域</code>；<br>es6 之后，<code>语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量</code>。</p></blockquote><p>例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (true) &#123;  var x &#x3D; 5;&#125;console.log(x); &#x2F;&#x2F; 5</code></pre><p>使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (true) &#123;  let y &#x3D; 5;&#125;console.log(y); &#x2F;&#x2F; ReferenceError: y 没有被声明</code></pre><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>JavaScript 在执⾏过程中, 会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了<code>作⽤域链</code>。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p><code>块语句</code>（或其他语言的<code>复合语句</code>）用于组合零个或多个语句。该块由一对大括号界定，可以是 labelled</p><p>其他语言中通常将语句块称为<code>复合语句</code>。它允许你使用多个语句，其中 JavaScript 只需要一个语句。将语句组合成块是 JavaScript 中的常见做法。相反的做法是可以使用一个<code>空语句(即 ;)</code>，你不提供任何语句，虽然一个是必需的。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><ul><li>1.通过 var 声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域</li><li>2.使用 let 和 const 声明的变量是有块级作用域的</li><li>3.使用 let 声明的变量, 在块级作用域内, 能强制执行更新变量</li><li>4.使用 function 函数声明同样被限制在声明他的语句块内：</li></ul></blockquote><p><strong>1. 通过 var 声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var x &#x3D; 1;&#123;  var x &#x3D; 2;&#125;console.log(x); &#x2F;&#x2F; 输出 2&#x2F;&#x2F; 输出结果是 2，因为块中的 var x语句与块前面的var x语句作用域相同。在 C 或 Java 中，这段代码会输出 1。</code></pre><p><strong>2. 使用 let 和 const 声明的变量是有块级作用域的。</strong></p><p>事例 1</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let x &#x3D; 1;&#123;  let x &#x3D; 2;&#125;console.log(x); &#x2F;&#x2F; 输出 1&#x2F;&#x2F; x &#x3D; 2仅限在定义它的块中</code></pre><p>事例 2</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const c &#x3D; 1;&#123;  const c &#x3D; 2;&#125;console.log(c); &#x2F;&#x2F; 输出 1，而且不会报错&#x2F;&#x2F; 位于块范围之内的 const c &#x3D; 2 并不会抛出SyntaxError: Identifier &#39;c&#39; has already been declared这样的语法错误，因为在它自己的块中它可能是唯一一个被声明的常量。</code></pre><p><strong>3. 使用 let 声明的变量, 在块级作用域内, 能强制执行更新变量</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; [];for (var i &#x3D; 0; i &lt; 10; i++) &#123;  a[i] &#x3D; function () &#123;    console.log(i);  &#125;;&#125;a[0](); &#x2F;&#x2F; 10a[1](); &#x2F;&#x2F; 10a[6](); &#x2F;&#x2F; 10&#x2F;********************&#x2F;var a &#x3D; [];for (let i &#x3D; 0; i &lt; 10; i++) &#123;  a[i] &#x3D; function () &#123;    console.log(i);  &#125;;&#125;a[0](); &#x2F;&#x2F; 0a[1](); &#x2F;&#x2F; 1a[6](); &#x2F;&#x2F; 6</code></pre><p><strong>4. 使用 function 函数声明同样被限制在声明他的语句块内：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">foo(&quot;outside&quot;); &#x2F;&#x2F; TypeError: foo is not a function&#123;  function foo(location) &#123;    console.log(&quot;foo is called &quot; + location);  &#125;  foo(&quot;inside&quot;); &#x2F;&#x2F; 正常工作并且打印 &#39;foo is called inside&#39;&#125;</code></pre><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>JavaScript 有三种声明方式。</p><ul><li>var 声明一个变量，可选初始化一个值。</li><li>let 声明一个块作用域的局部变量，可选初始化一个值。</li><li>const 声明一个块作用域的只读常量。</li></ul><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升: <strong>可以先使用变量稍后再声明变量而不会引发异常</strong></p><p>JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。</p><p>但是，<code>提升后的变量将返回 undefined 值</code>。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 例子 1 *&#x2F;console.log(x &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; truevar x &#x3D; 3;&#x2F;** * 例子 2 *&#x2F;&#x2F;&#x2F; will return a value of undefinedvar myvar &#x3D; &quot;my value&quot;;(function () &#123;  console.log(myvar); &#x2F;&#x2F; undefined  var myvar &#x3D; &quot;local value&quot;;&#125;)();</code></pre><p>上面的例子，也可写作：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 例子 1 *&#x2F;var x;console.log(x &#x3D;&#x3D;&#x3D; undefined); &#x2F;&#x2F; truex &#x3D; 3;&#x2F;** * 例子 2 *&#x2F;var myvar &#x3D; &quot;my value&quot;;(function () &#123;  var myvar;  console.log(myvar); &#x2F;&#x2F; undefined  myvar &#x3D; &quot;local value&quot;;&#125;)();</code></pre><p>由于存在变量提升，一个函数中所有的 var 语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。</p><p>在 ECMAScript 6 中，<strong>let 和 const 同样会被提升变量到代码块的顶部</strong>, <strong>但是不会被赋予初始值</strong>。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types#:~:text=%E5%9C%A8%20ECMAScript%206%20%E4%B8%AD%EF%BC%8Clet%E5%92%8Cconst%E5%90%8C%E6%A0%B7%E4%BC%9A%E8%A2%AB%E6%8F%90%E5%8D%87%E5%8F%98%E9%87%8F%E5%88%B0%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E9%A1%B6%E9%83%A8%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E8%A2%AB%E8%B5%8B%E4%BA%88%E5%88%9D%E5%A7%8B%E5%80%BC%E3%80%82%E5%9C%A8%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B9%8B%E5%89%8D%E5%BC%95%E7%94%A8%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E5%B0%86%E6%8A%9B%E5%87%BA%E5%BC%95%E7%94%A8%E9%94%99%E8%AF%AF%EF%BC%88ReferenceError%EF%BC%89%E3%80%82%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E5%B0%86%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%A4%84%E5%9C%A8%E4%B8%80%E4%B8%AA%E2%80%9C%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E2%80%9D%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E8%A2%AB%E5%A3%B0%E6%98%8E%E4%B8%BA%E6%AD%A2" target="_blank" >原文</a></p><p><code>暂时性死区</code>：程序未执行到声明处时,访问该变量都会报引用错误</p><p>这个不是太好理解啊：<strong>let const 变量会提升，但是不会进行变量声明，如果在声明之前引用，将抛出错误;</strong></p><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>对于函数来说，<strong>只有函数声明会被提升到顶部，而函数表达式不会被提升</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;* 函数声明 *&#x2F;foo(); &#x2F;&#x2F; &quot;bar&quot;function foo() &#123;  console.log(&quot;bar&quot;);&#125;&#x2F;* 函数表达式 *&#x2F;baz(); &#x2F;&#x2F; 类型错误：baz 不是一个函数var baz &#x3D; function () &#123;  console.log(&quot;bar2&quot;);&#125;;</code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量是全局对象的属性。在网页中，（译注：缺省的）全局对象是 window ，所以你可以用形如 window.variable 的语法来设置和访问全局变量。</p><p>因此，你可以通过指定 window 或 frame 的名字，在当前 window 或 frame 访问另一个 window 或 frame 中声明的变量。例如，在文档里声明一个叫 phoneNumber 的变量，那么你就可以在子框架里使用 parent.phoneNumber 的方式来引用它。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>你可以用关键字 const 创建一个只读的常量。常量标识符的命名规则和变量相同：必须以字母、下划线（_）或美元符号（$）开头并可以包含有字母、数字或下划线。</p><p>const PI &#x3D; 3.14;</p><p>常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。</p><p>常量的作用域规则与 let 块级作用域变量相同。若省略 const 关键字，则该标识符将被视为变量。</p><p>在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。例如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这会造成错误function f() &#123;&#125;const f &#x3D; 5;&#x2F;&#x2F; 这也会造成错误function f() &#123;  const g &#x3D; 5;  var g;  &#x2F;&#x2F;语句&#125;</code></pre><p>然而，对象属性被赋值为常量是不受保护的，所以下面的语句执行时不会产生错误。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const MY_OBJECT &#x3D; &#123; key: &quot;value&quot; &#125;;MY_OBJECT.key &#x3D; &quot;otherValue&quot;;</code></pre><p>同样的，数组的被定义为常量也是不受保护的，所以下面的语句执行时也不会产生错误。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const MY_ARRAY &#x3D; [&quot;HTML&quot;, &quot;CSS&quot;];MY_ARRAY.push(&quot;JAVASCRIPT&quot;);console.log(MY_ARRAY); &#x2F;&#x2F;logs [&#39;HTML&#39;,&#39;CSS&#39;,&#39;JAVASCRIPT&#39;];</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="/#/post/2022-07-28js-closures" target="_blank" >前端基础-js 闭包</a></p><h2 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h2><h2 id="es6-之前没有块级作用域"><a href="#es6-之前没有块级作用域" class="headerlink" title="es6 之前没有块级作用域"></a>es6 之前没有块级作用域</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; 12;if (a &gt; 10) &#123;  var c &#x3D; a + 1;&#125;console.log(a, c);</code></pre><h3 id="有-var-和-无-var"><a href="#有-var-和-无-var" class="headerlink" title="有 var 和 无 var"></a>有 var 和 无 var</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function fn() &#123;  var a &#x3D; (b &#x3D; 30);  console.log(a, b); &#x2F;&#x2F; 30,30&#125;fn();console.log(b); &#x2F;&#x2F; 30console.log(a); &#x2F;&#x2F; Uncaught ReferenceError: a is not defined&#x2F;&#x2F; 解释：在非严格模式下，允许不用var声明变量，不用var声明的变量会默认为全局变量。var a &#x3D; b &#x3D;30 等价于b &#x3D; 10;b &#x3D; 10; 所以b是一个全局变量，a是个局部变量。</code></pre><h3 id="变量提升，函数声明提升"><a href="#变量提升，函数声明提升" class="headerlink" title="变量提升，函数声明提升"></a>变量提升，函数声明提升</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fn1(); &#x2F;&#x2F; fn1fn2(); &#x2F;&#x2F;第一次fn2调用  &#x2F;&#x2F; 报错function fn1() &#123;  console.log(&quot;fn1&quot;);&#125;var fn2 &#x3D; function () &#123;  console.log(&quot;fn2&quot;);&#125;;fn2(); &#x2F;&#x2F;第二次fn2调用&#x2F;&#x2F; 解释：第一个位置调用fn2报错，代码终止执行；如果屏蔽第一个位置调用fn2，在第二个位置调用，正常调用，并输出“fn2”。这里考察的是变量提升和函数提升。上述代码等介于：</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 函数提升和变量提升function fn1() &#123;  console.log(&quot;fn1&quot;);&#125;var fn2;fn1();fn2();fn2 &#x3D; function () &#123;  console.log(&quot;fn2&quot;);&#125;;fn2();</code></pre><h3 id="函数提升在变量之前进行"><a href="#函数提升在变量之前进行" class="headerlink" title="函数提升在变量之前进行"></a>函数提升在变量之前进行</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(a); &#x2F;&#x2F; f a() &#123;console.log(10)&#125;console.log(a()); &#x2F;&#x2F;  undefinedvar a &#x3D; 3;function a() &#123;  console.log(10); &#x2F;&#x2F;10&#125;console.log(a); &#x2F;&#x2F;3a &#x3D; 6;console.log(a()); &#x2F;&#x2F;a is not a function;</code></pre><p>实际编译过程如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; funtion () &#123;  console.log(10)&#125;var a;console.log(a);    &#x2F;&#x2F; f a() &#123;console.log(10)&#125;console.log(a());  &#x2F;&#x2F;  undefineda &#x3D; 3;console.log(a)   &#x2F;&#x2F;3a &#x3D; 6;console.log(a());   &#x2F;&#x2F;a() is not a function;</code></pre><h3 id="循环中-IIFE-函数形成的匿名空间"><a href="#循环中-IIFE-函数形成的匿名空间" class="headerlink" title="循环中,IIFE 函数形成的匿名空间"></a>循环中,IIFE 函数形成的匿名空间</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 代码1for (var i &#x3D; 0; i &lt; 3; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, i * 2000);&#125;&#x2F;&#x2F; 代码2for (var i &#x3D; 0; i &lt; 3; i++) &#123;  (function (i) &#123;    setTimeout(function () &#123;      console.log(i);    &#125;, i * 2000);  &#125;)(i);&#125;</code></pre><h3 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 代码var a &#x3D; 10;function fn() &#123;  console.log(a);&#125;function fn2(f) &#123;  var a &#x3D; 20;  f();&#125;fn2();&#x2F;&#x2F; 解释：考察了作用域与作用域链的相关知识。记住两点：&#x2F;&#x2F; 1、作用域与作用域链都是一个静态的概念，在函数定义的时候就确定了；&#x2F;&#x2F; 2、通过作用域链查找遍了的时候，首先要找到函数本身的作用域，从它本身的作用域开始沿着作用域链向它的上一级依次查找。</code></pre><h3 id="作用域与作用域链-1"><a href="#作用域与作用域链-1" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var fn &#x3D; function () &#123;  console.log(fn);&#125;;fn();var obj &#x3D; &#123;  fn2: function () &#123;    console.log(fn2);  &#125;,&#125;;obj.fn2();&#x2F;&#x2F; 解释：这里同样考察的是作用域和作用域链的知识。同时要注意：在obj中的console.log(fn2) 和 console.log(this.fn2)的区别。</code></pre><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj &#x3D; &#123;  fn2: function () &#123;    console.log(this.fn2);  &#125;,&#125;;obj.fn2(); &#x2F;&#x2F;输出fn2函数</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/block" target="_blank" >MDN 块语句</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank" >MDN let</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank" >MDN var</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank" >MDN const </a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types" target="_blank" >MDN 语法和数据类型</a></p><p><a href="https://blog.csdn.net/jingsi1991/article/details/84770480" target="_blank" >作用域相关</a></p><p><a href="https://blog.csdn.net/liuanpingfirst/article/details/84947816" target="_blank" >let 和 const 定义的变量在哪？在 Script 这个域中</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js eventloop</title>
      <link href="//post/2022-07-29js-eventloop.html"/>
      <url>//post/2022-07-29js-eventloop.html</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="http://t-blog-images.aijs.top/img/事件循环.png" style="max-width: 100%; width: 500px"/><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事</p><p>为什么要这么设计，跟 JavaScript 的应用场景有关</p><p>JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？</p><p>为了解决单线程运行阻塞问题，JavaScript 用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）</p><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>js 运行的环境,被称为<code>宿主环境</code>，目前有三种运行环境，</p><ul><li>一种运行在<code>浏览器(javaScript)</code></li><li>一种运行在<code>服务端(nodejs)</code></li><li>另一种是运行在我们的<code>客户端(比如 Vscode 客户端就是使用 js 写的)</code></li></ul><p>其他的比如：IOS 中<code>jscore</code>，Android <code>JavascriptInterace</code>, C++ <code>JSI</code></p><p><strong>因此只要给 js 配备的相应的执行引擎，js 可以运行在任何环境</strong></p><h2 id="浏览器宿主环境"><a href="#浏览器宿主环境" class="headerlink" title="浏览器宿主环境"></a>浏览器宿主环境</h2><img src="http://t-blog-images.aijs.top/img/20220729223730.png"  style="height: 60px"/><h3 id="JS-线程"><a href="#JS-线程" class="headerlink" title="JS 线程"></a>JS 线程</h3><p>负责执行执行栈的最顶层 JS 代码<br>和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。</p><h3 id="GUI-线程"><a href="#GUI-线程" class="headerlink" title="GUI 线程"></a>GUI 线程</h3><p>负责渲染页面,解析 HTML、CSS 构成 渲染树等，当页面重绘或者由于某种操作引起回流都会调起该线程。<br>和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。</p><h3 id="事件监听线程"><a href="#事件监听线程" class="headerlink" title="事件监听线程"></a>事件监听线程</h3><p>(DOM 事件，window 窗口事件等等)</p><p>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到事件队列的队尾，等待 JS 引擎处理。</p><h3 id="计时线程"><a href="#计时线程" class="headerlink" title="计时线程"></a>计时线程</h3><p>（SetTimeout、setInterval 计时器）</p><p>开启定时器触发线程来计时并触发计时，计时完毕后，将计时器结束的回调函数添加到事件队列中，等待 JS 引擎空闲后执行，等待 JS 引擎处理。<br>浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。</p><h3 id="网络线程"><a href="#网络线程" class="headerlink" title="网络线程"></a>网络线程</h3><p>（ajax 网络请求）</p><p>http 请求的时候会开启一条请求线程。<br>请求完成有结果了之后，将请求的 http 回调函数添加到任务队列中，等待 JS 引擎处理。</p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><ul><li><p>栈是先进后出</p></li><li><p>队列先进先出</p></li></ul><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：</p><p><code>宏任务（队列）macroTack</code>：计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列<br><code>微任务（队列）microTack</code>：<code>MutationObserver</code>,<code>Promise 产生的回调</code>进入微队列</p><p>当执行栈清空时、JS 引擎首<code>先会将微任务中的所有任务依次执行结束</code>，如果没有微任务，执行宏任务</p><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h2><p>事件循环分为三个部分，分别由 <code>浏览器宿主</code>，<code>web api</code> 与 <code>事件队列（也称任务队列）</code>组成</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>由于 JavaScript 引擎是单线程，同一时间只能执行一个任务，其他任务都得按照顺序排队等待被执行，只有当前的任务执行完成之后才会往下执行下一个任务，因此这些任务被排队在一个单独的地方。这个地方被称为执行栈</p><p><code>执行栈是一个后进先出数据结构</code>，用于存放各种函数的执行环境，<br>每一个函数执行之前，它的相关信息会加入到执行栈，<br>函数调用之前，创建执行环境，然后 push 到执行栈；<br>函数调用之后，销毁执行环境，并从执行栈顶部推（pop）出去</p><h2 id="Event-Loop-在浏览器与-node-环境中的区别："><a href="#Event-Loop-在浏览器与-node-环境中的区别：" class="headerlink" title="Event Loop 在浏览器与 node 环境中的区别："></a>Event Loop 在浏览器与 node 环境中的区别：</h2><p>浏览器环境每次执行一个宏任务，再去检查微任务<br>node 会清空当前所处阶段的队列，即执行所有 task，再去检查微任务</p><h2 id="浏览器环境-事例"><a href="#浏览器环境-事例" class="headerlink" title="浏览器环境 事例"></a>浏览器环境 事例</h2><h3 id="事例-1"><a href="#事例-1" class="headerlink" title="事例 1"></a>事例 1</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;script&gt;    function a() &#123;        console.log(&quot;a&quot;)        b();    &#125;    function b() &#123;        console.log(&quot;b&quot;);        c();    &#125;    function c() &#123;        console.log(&quot;c&quot;)    &#125;    console.log(&quot;global&quot;);    a();&lt;&#x2F;script&gt;</code></pre><h3 id="事例-2"><a href="#事例-2" class="headerlink" title="事例 2"></a>事例 2</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(1);setTimeout(() &#x3D;&gt; &#123;  console.log(2);  setTimeout(() &#x3D;&gt; &#123;    console.log(3);    setTimeout(() &#x3D;&gt; &#123;      console.log(4);    &#125;, 0);  &#125;, 0);&#125;, 0);setTimeout(() &#x3D;&gt; &#123;  console.log(5);  setTimeout(() &#x3D;&gt; &#123;    console.log(6);  &#125;, 0);&#125;, 0);console.log(&quot;ok&quot;);</code></pre><h3 id="事例-3"><a href="#事例-3" class="headerlink" title="事例 3"></a>事例 3</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(1);setTimeout(() &#x3D;&gt; &#123;  console.log(&quot;setTimeout&quot;);&#125;, 0);let promise &#x3D; new Promise((resolve) &#x3D;&gt; &#123;  console.log(3);  resolve();&#125;)  .then((data) &#x3D;&gt; &#123;    console.log(100);  &#125;)  .then((data) &#x3D;&gt; &#123;    console.log(200);  &#125;);console.log(2);</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/41543963" target="_blank" >Event Loop 这个循环你晓得么？(附 GIF 详解)</a></p><p><a href="https://juejin.cn/post/6844904008134426638" target="_blank" >[回顾]事件循环机制 (Event-loop)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js 闭包</title>
      <link href="//post/2022-07-28js-closures.html"/>
      <url>//post/2022-07-28js-closures.html</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="http://t-blog-images.aijs.top/img/202207291656804.webp" /><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>一个函数 和 对其周围状态<code>（lexical environment，词法环境）</code>的引用, 捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）</p><p>也就是说，闭包让你可以在一个内层函数中 访问到 其外层函数的<code>作用域</code>。在形式上体现为函数嵌套，内层函数有外层函数的变量引用， 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p><h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment.<br>翻译：词法环境： 是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成</p></blockquote><p>词法环境是: 由内部 JavaScript 引擎构造，用来保存标识符和变量&#x2F;函数的映射关系，同时，保存了对父级（词法环境- 标识符与变量映射）的引用。</p><ul><li><code>标识符</code> ： 指变量或者函数的名称</li><li><code>变量</code>：对 <code>实际对象</code>（包括函数类型对象）或者<code>原始值</code>的引用</li></ul><p>词法环境组成：</p><ul><li><code>环境记录</code>：存储变量和函数声明的实际位置</li><li><code>对外引用</code>：实际上就是对外部或者说是父级词法环境的引用</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>MDN:</strong><br>在当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。如果一个<strong>变量</strong>或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p><p>作用域可以视为一套规则，这套规则用来管理 js 引擎,如何在当前作用域以及嵌套的子作用域，根据标识符名称进行变量查找。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>JavaScript 在执⾏过程中, 会创造可执⾏上下⽂，可执⾏上下⽂中的词法环境中含有外部词法环境的引⽤，我们可以通过这个引⽤获取外部词法环境的变量、声明等，这些引⽤串联起来⼀直指向全局的词法环境，因此形成了<code>作⽤域链</code>。</p><h2 id="可执行上下文"><a href="#可执行上下文" class="headerlink" title="可执行上下文"></a>可执行上下文</h2><p>当 js 引擎执行到一段可执行代码时，就会为之<code>创建对应的执行上下文(Execution Context)</code>。<br>那么因此执行上下文对应也有三种：<code>全局执行上下文</code>，<code>函数执行上下文</code>，<code>eval 执行上下文</code>。</p><h2 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h2><p>ECMAScript 可执行代码分为三种类型：<code>全局代码</code>，<code>函数代码</code>，<code>eval 代码</code>。</p><h2 id="可执行上下文栈"><a href="#可执行上下文栈" class="headerlink" title="可执行上下文栈"></a>可执行上下文栈</h2><img src="http://t-blog-images.aijs.top/img/202207291418098.webp" /><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>分析器如何在函数嵌套的情况下解析变量名</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="http://t-blog-images.aijs.top/img/202207291656804.webp" /><img src="http://t-blog-images.aijs.top/img/202207291703485.webp" /><h2 id="闭包作用"><a href="#闭包作用" class="headerlink" title="闭包作用"></a>闭包作用</h2><ul><li>用闭包模拟私有方法</li><li>数据缓存</li></ul><h2 id="闭包性能"><a href="#闭包性能" class="headerlink" title="闭包性能"></a>闭包性能</h2><ul><li>如果不是某些特定任务, 需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</li></ul><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。</p><p><strong>示例：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function MyObject(name, message) &#123;  this.name &#x3D; name.toString();  this.message &#x3D; message.toString();  this.getName &#x3D; function () &#123;    return this.name;  &#125;;  this.getMessage &#x3D; function () &#123;    return this.message;  &#125;;&#125;</code></pre><p><strong>可改成如下例子：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function MyObject(name, message) &#123;  this.name &#x3D; name.toString();  this.message &#x3D; message.toString();&#125;MyObject.prototype.getName &#x3D; function () &#123;  return this.name;&#125;;MyObject.prototype.getMessage &#x3D; function () &#123;  return this.message;&#125;;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_42345237/article/details/120603881" target="_blank" >词法环境是什么？</a></p><p><a href="https://baijiahao.baidu.com/s?id=1729331413156806540&wfr=spider&for=pc" target="_blank" >词法作用域</a></p><p><a href="https://juejin.cn/post/7019682405896175653" target="_blank" >可执行代码与执行上下文</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope" target="_blank" >Scope（作用域）</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js 函数</title>
      <link href="//post/2022-07-28js-fun.html"/>
      <url>//post/2022-07-28js-fun.html</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="http://t-blog-images.aijs.top/img/202208011605439.webp" style="max-width: 100%; width: 600px" /><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>arguments 对象不是一个 Array 。它类似于 Array，但除了 length 属性和索引元素之外没有任何 Array 属性</p></blockquote><h3 id="使用数组方法"><a href="#使用数组方法" class="headerlink" title="使用数组方法"></a>使用数组方法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Array.prototype.slice.callfunction myConcat(separator) &#123;  var args &#x3D; Array.prototype.slice.call(arguments, 1);  return args.join(separator);&#125;</code></pre><h3 id="转化成真实数组"><a href="#转化成真实数组" class="headerlink" title="转化成真实数组"></a>转化成真实数组</h3><p>可以使用<code>Array.from()</code>方法或<code>扩展运算符</code>将参数转换为真实数组：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var args &#x3D; Array.from(arguments);var args &#x3D; [...arguments];</code></pre><h3 id="参数影响"><a href="#参数影响" class="headerlink" title="参数影响"></a>参数影响</h3><h3 id="严格模式下，-无影响"><a href="#严格模式下，-无影响" class="headerlink" title="严格模式下， 无影响"></a>严格模式下， 无影响</h3><p>在严格模式下，<code>剩余参数</code>、<code>默认参数</code>和<code>解构赋值参数</code>的存在, <strong>不会改变 arguments 对象的行为, 不跟踪</strong>。<br><strong>示例 1</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;function func(a) &#123;  arguments[0] &#x3D; 34;  console.log(a); &#x2F;&#x2F; 1  console.log(arguments[0]); &#x2F;&#x2F; 34&#125;func(1);</code></pre><p><strong>示例 2</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;function func(a &#x3D; 2) &#123;  arguments[0] &#x3D; 34;  console.log(arguments[0]); &#x2F;&#x2F;34  console.log(a); &#x2F;&#x2F; 3&#125;func(3);</code></pre><h3 id="非严格模式，没有…，跟踪"><a href="#非严格模式，没有…，跟踪" class="headerlink" title="非严格模式，没有…，跟踪"></a>非严格模式，没有…，跟踪</h3><p><strong>非严格模式中</strong>, 函数 <strong>没有包含</strong> <code>剩余参数</code>、<code>默认参数</code>、<code>解构赋值</code>， <strong>arguments 对象中的值会跟踪参数的值</strong></p><p><strong>示例 1:</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a) &#123;  arguments[0] &#x3D; 99; &#x2F;&#x2F; 更新了 arguments[0] 同样更新了 a  console.log(a); &#x2F;&#x2F; 99  console.log(arguments[0]); &#x2F;&#x2F; 9&#125;func(10);</code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a) &#123;  a &#x3D; 99; &#x2F;&#x2F; 更新了 a 同样更新了 arguments[0]  console.log(a); &#x2F;&#x2F; 99  console.log(arguments[0]); &#x2F;&#x2F; 99&#125;func(10);</code></pre><h3 id="非严格模式，有…，不跟踪"><a href="#非严格模式，有…，不跟踪" class="headerlink" title="非严格模式，有…，不跟踪"></a>非严格模式，有…，不跟踪</h3><p>当非严格模式中的函数, <strong>有包含</strong> <code>剩余参数</code>、<code>默认参数</code>、<code>解构赋值</code>， <strong>arguments 对象中的值不会跟踪参数的值</strong></p><p><strong>示例 1:</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a &#x3D; 55) &#123;  arguments[0] &#x3D; 99; &#x2F;&#x2F; updating arguments[0] does not also update a  console.log(a); &#x2F;&#x2F; 10  console.log(arguments[0]); &#x2F;&#x2F; 99&#125;func(10);</code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a &#x3D; 55) &#123;  a &#x3D; 99; &#x2F;&#x2F; updating a does not also update arguments[0]  console.log(a); &#x2F;&#x2F; 99  console.log(arguments[0]); &#x2F;&#x2F; 10&#125;func(10);</code></pre><p><strong>示例 3:</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a &#x3D; 55) &#123;  console.log(a); &#x2F;&#x2F; 55  console.log(arguments[0]); &#x2F;&#x2F; undefined&#125;func();</code></pre><h2 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul></blockquote><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数表达式</strong>的语法比函数表达式更简洁，并且没有自己的 <code>this</code>，<code>arguments</code>，<code>super</code>, <code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它<code>不能用作构造函数</code>。<code>解析顺序也有区别</code>。</p><h3 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="headerlink" title="箭头函数与普通函数区别"></a>箭头函数与普通函数区别</h3><ul><li>语法比函数表达式更简洁</li><li>没有自己的 <code>this</code>，<code>arguments</code>，<code>super</code>, <code>new.target</code></li><li>不能用 new 操作符号</li><li>不能用作构造函数</li><li>不能用 yield</li><li>无 prototype 属性</li><li>解析顺序也有区别</li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 多参数(param1, param2, …, paramN) &#x3D;&gt; &#123; statements &#125;(param1, param2, …, paramN) &#x3D;&gt; expression&#x2F;&#x2F;相当于：(param1, param2, …, paramN) &#x3D;&gt;&#123; return expression; &#125;&#x2F;&#x2F; 单参数&#x2F;&#x2F; 当只有一个参数时，圆括号是可选的：(singleParam) &#x3D;&gt; &#123; statements &#125;singleParam &#x3D;&gt; &#123; statements &#125;&#x2F;&#x2F; 无参数&#x2F;&#x2F; 没有参数的函数应该写成一对圆括号。() &#x3D;&gt; &#123; statements &#125;</code></pre><h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;加括号的函数体, 返回对象字面量表达式：params &#x3D;&gt; (&#123;foo: bar&#125;) &#x2F;&#x2F; 返回 &#123;foo: bar&#125;， 不加 () 函数默认返回undefine&#x2F;&#x2F;支持剩余参数、默认参数(param1, param2, ...rest) &#x3D;&gt; &#123; statements &#125;(param1 &#x3D; defaultValue1, param2, …, paramN &#x3D; defaultValueN) &#x3D;&gt; &#123;statements &#125;&#x2F;&#x2F;同样支持参数列表解构let f &#x3D; ([a, b] &#x3D; [1, 2], &#123;x: c&#125; &#x3D; &#123;x: a + b&#125;) &#x3D;&gt; a + b + c;f();  &#x2F;&#x2F; 6</code></pre><h3 id="没有单独的-this"><a href="#没有单独的-this" class="headerlink" title="没有单独的 this"></a>没有单独的 this</h3><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：</p><ul><li>如果该函数是一个构造函数，this 指针指向一个新的对象</li><li>在严格模式下的函数调用下，this 指向 undefined</li><li>如果该函数是一个对象的方法，则它的 this 指针指向这个对象</li><li>等等</li></ul><h3 id="不受限严格模式的-this-规则"><a href="#不受限严格模式的-this-规则" class="headerlink" title="不受限严格模式的 this 规则"></a>不受限严格模式的 this 规则</h3><p>鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。</p><p><span style="color: red">箭头函数中 this 是语法层面的</span></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var f &#x3D; () &#x3D;&gt; &#123;  &quot;use strict&quot;;  return this;&#125;;f() &#x3D;&#x3D;&#x3D; window; &#x2F;&#x2F; 或者 global</code></pre><h3 id="通过-call-或-apply-调用"><a href="#通过-call-或-apply-调用" class="headerlink" title="通过 call 或 apply 调用"></a>通过 call 或 apply 调用</h3><p>由于 箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定 this—译者注），他们的<strong>第一个参数会被忽略</strong>。（这种现象对于 bind 方法同样成立 — 译者注）</p><h3 id="不绑定-arguments"><a href="#不绑定-arguments" class="headerlink" title="不绑定 arguments"></a>不绑定 arguments</h3><p>箭头函数不绑定 Arguments 对象。</p><p><strong>可以使用剩余参数</strong></p><h3 id="使用箭头函数作为方法"><a href="#使用箭头函数作为方法" class="headerlink" title="使用箭头函数作为方法"></a>使用箭头函数作为方法</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;var obj &#x3D; &#123;  i: 10,  b: () &#x3D;&gt; console.log(this.i, this), &#x2F;&#x2F; 并不指向对象  c: function () &#123;    console.log(this.i, this);  &#125;,&#125;;obj.b();&#x2F;&#x2F; undefined, Window&#123;...&#125;obj.c();&#x2F;&#x2F; 10, Object &#123;...&#125;</code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;var obj &#x3D; &#123;  a: 10,&#125;;Object.defineProperty(obj, &quot;b&quot;, &#123;  get: () &#x3D;&gt; &#123;    console.log(this.a, typeof this.a, this);    return this.a + 10;    &#x2F;&#x2F; 代表全局对象 &#39;Window&#39;, 因此 &#39;this.a&#39; 返回 &#39;undefined&#39;  &#125;,&#125;);obj.b; &#x2F;&#x2F; undefined   &quot;undefined&quot;   Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</code></pre><h3 id="使用-new-操作符"><a href="#使用-new-操作符" class="headerlink" title="使用 new 操作符"></a>使用 new 操作符</h3><p>箭头函数不能用作构造器，和 new 一起用会抛出错误。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var Foo &#x3D; () &#x3D;&gt; &#123;&#125;;var foo &#x3D; new Foo(); &#x2F;&#x2F; TypeError: Foo is not a constructor</code></pre><h3 id="使用-prototype-属性"><a href="#使用-prototype-属性" class="headerlink" title="使用 prototype 属性"></a>使用 prototype 属性</h3><p>箭头函数没有 prototype 属性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var Foo &#x3D; () &#x3D;&gt; &#123;&#125;;console.log(Foo.prototype); &#x2F;&#x2F; undefined</code></pre><h3 id="使用-yield-关键字"><a href="#使用-yield-关键字" class="headerlink" title="使用 yield 关键字"></a>使用 yield 关键字</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。</p><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>箭头函数可以有一个“简写体”或常见的“块体”。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var func &#x3D; (x) &#x3D;&gt; x * x;&#x2F;&#x2F; 简写函数 省略 returnvar func &#x3D; (x, y) &#x3D;&gt; &#123;  return x + y;&#125;;&#x2F;&#x2F;常规编写 明确的返回值</code></pre><h3 id="返回对象字面量"><a href="#返回对象字面量" class="headerlink" title="返回对象字面量"></a>返回对象字面量</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var func &#x3D; () &#x3D;&gt; &#123; foo: 1 &#125;;&#x2F;&#x2F; Calling func() returns undefined!var func &#x3D; () &#x3D;&gt; &#123; foo: function() &#123;&#125; &#125;;&#x2F;&#x2F; SyntaxError: function statement requires a name</code></pre><p>花括号（{} ）里面的代码被解析为一系列语句（即 foo 被认为是一个标签，而非对象字面量的组成部分）。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var func &#x3D; () &#x3D;&gt; (&#123; foo: 1 &#125;);</code></pre><h3 id="注意换行"><a href="#注意换行" class="headerlink" title="注意换行"></a>注意换行</h3><p><span style="color: red">幸运的是：vscode Prettier - Code formatter 插件，自动格式化代码</span></p><p><strong>箭头函数在参数和箭头之间不能换行。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var func &#x3D; ()           &#x3D;&gt; 1;&#x2F;&#x2F; SyntaxError: expected expression, got &#39;&#x3D;&gt;&#39;</code></pre><p><strong>可以通过在 ‘&#x3D;&gt;’ 之后换行，或者用 ‘( )’、’{ }’来实现换行，如下：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var func &#x3D; (a, b, c) &#x3D;&gt;  1;var func &#x3D; (a, b, c) &#x3D;&gt; (  1);var func &#x3D; (a, b, c) &#x3D;&gt; &#123;  return 1&#125;;var func &#x3D; (  a,  b,  c) &#x3D;&gt; 1;&#x2F;&#x2F; 不会有语法错误</code></pre><h3 id="不同于普通函数的解析顺序"><a href="#不同于普通函数的解析顺序" class="headerlink" title="不同于普通函数的解析顺序"></a>不同于普通函数的解析顺序</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let callback;callback &#x3D; callback || function() &#123;&#125;; &#x2F;&#x2F; okcallback &#x3D; callback || () &#x3D;&gt; &#123;&#125;;&#x2F;&#x2F; SyntaxError: invalid arrow-function argumentscallback &#x3D; callback || (() &#x3D;&gt; &#123;&#125;);    &#x2F;&#x2F; ok</code></pre><h3 id="箭头函数可以使用条件（三元）运算符"><a href="#箭头函数可以使用条件（三元）运算符" class="headerlink" title="箭头函数可以使用条件（三元）运算符"></a>箭头函数可以使用条件（三元）运算符</h3><h3 id="箭头函数可以使用闭包"><a href="#箭头函数可以使用闭包" class="headerlink" title="箭头函数可以使用闭包"></a>箭头函数可以使用闭包</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" >Web 开发技术&#x2F;JavaScript&#x2F;JavaScript 参考&#x2F;函数&#x2F;arguments 对象</a></p><p><a href="https://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" >Javascript 严格模式详解</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" >Web 开发技术&#x2F;JavaScript&#x2F;JavaScript 参考&#x2F;函数&#x2F;箭头函数</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-性能优化2</title>
      <link href="//post/2022-07-27%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
      <url>//post/2022-07-27%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么速度很重要"><a href="#为什么速度很重要" class="headerlink" title="为什么速度很重要"></a>为什么速度很重要</h2><ul><li>用户要求变高，爱挑毛病</li><li>性能是留住用户的关键</li><li>性能意味着提高转化率</li><li>性能关乎用户体验</li><li>性能影响人们</li></ul><details class="custom-details"><summary>查看更多</summary><p>消费者越来越依赖移动设备来访问数字内容和服务，如果您查看自己站点的分析，可能会看到这个故事正在您自己的数据中上演。消费者也比以往任何时候都要求更高，<strong>当他们权衡您网站上的体验时，他们不仅仅将您与您的竞争对手进行比较，他们还会根据他们每天使用的一流服务对您进行评级</strong>。</p><p><strong>性能是留住用户的关键</strong></p><p>性能直接影响公司的命运. 性能在任何在线企业的成功中都起着至关重要的作用。高性能网站比低性能网站更能吸引和留住用户。</p><p>研究还表明，性能不佳会对业务目标产生负面影响。例如，</p><ul><li><code>Pinterest</code> 将感知等待时间减少了 40%，这将搜索引擎流量和注册量增加了 15% 。</li><li><code>COOK</code> 将页面平均加载时间减少了 850 毫秒，从而将转化次数提高了 7%，将跳出率降低了 7%，并将每个会话的页面增加了 10% 。</li><li><code>BBC</code> 发现他们的网站加载时间每增加一秒，他们就会失去 10% 的用户。</li></ul><p><strong>性能意味着提高转化率</strong></p><p>留住用户对于提高转化率至关重要。慢速网站对收入有负面影响，而快速网站显示可以提高转化率。</p><p>例如：</p><ul><li><p>对于 <code>Mobify</code> 而言，主页加载速度每提高 100 毫秒，基于会话的转化率就会增加 1.11%，平均年收入增加近 380,000 美元。此外，结账页面加载速度每提高 100 毫秒，基于会话的转化率就会增加 1.55%，从而使年均收入增加近 530,000 美元。</p></li><li><p>当 <code>AutoAnything</code> 将页面加载时间减少一半时，他们的销售额增长了 12% 到 13%。</p></li><li><p>零售商 <code>Furniture Village </code>审核了他们的网站速度，并制定了解决他们发现的问题的计划，导致页面加载时间降低了 20%，转化率提高了 10%。</p></li></ul><p><strong>性能关乎用户体验</strong></p><p>性能是良好用户体验的基础。当网站发布大量代码时，浏览器必须使用用户数以百万计的数据计算才能下载代码。移动设备的 CPU 能力和内存有限。它们经常被我们认为所谓的“少量”未优化的代码所淹没。这会导致性能不佳，从而导致无响应。了解我们人类的行为后就会知道，用户只有对低性能的应用程序忍无可忍时才会选择放弃。</p><p><strong>性能影响人们</strong></p><p>性能不佳的网站和应用程序也会给使用它们的人们带来实际成本</p><p>随着移动用户继续在全球互联网用户中占据更大比例，请务必记住，其中许多用户通过移动 LTE、4G、3G 甚至 2G 网络访问互联网。正如 Calibre 的 Ben Schwarz 在关于现实世界性能的研究中指出的那样，预付费数据计划的成本正在下降，这反过来又使得过去无法负担的地方开始有能力访问互联网。移动设备和互联网接入不再是奢侈品。它们是日益互联的世界中导航和发挥作用所必需的常用工具。</p><p>至少自 2011 年以来，总页面大小一直在稳步增加，而且这种趋势似乎还在继续。随着典型页面发送更多数据，用户必须更频繁地补充他们的计量数据计划，这会花费他们的资金。</p><p>除了为用户节省资金外，快速和轻量级的用户体验对于处于危机中的用户也至关重要。医院、诊所和危机中心等公共资源拥有在线资源，可为用户提供他们在危机期间所需的重要和具体信息。虽然设计对于在压力时刻有效地呈现重要信息至关重要，但不能低估快速传递这些信息的重要性。这是我们工作的一部分。</p></details><h2 id="性能优化基础"><a href="#性能优化基础" class="headerlink" title="性能优化基础"></a>性能优化基础</h2><p>最佳实践（个人觉得按照<code>performance</code> API 来聊性能优化更贴切）</p><ul><li>从学习浏览器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path" target="_blank" ><code>关键渲染路径(CRP- Critical rendering path)</code></a> 开始。了解这些会帮助你通晓如何提升浏览器的性能。</li><li>使用 <code>资源提示（resource hints）</code> 例如 （<strong>预连接、预获取、预加载</strong>） <code>rel=preconnect</code>, <code>rel=dns-prefetch</code>, <code>rel=prefetch</code>, and <code>rel=preload</code></li><li>压缩 <code>Js 代码</code>至最小。只为当前页面加载需要使用到的 js 代码</li><li><code>CSS 性能因素</code></li><li>在你的服务器（或者 CDN）上使用 <code>HTTP/2</code> 协议</li><li>使用 <code>CDN</code> 托管静态资源，这样可以显著减少加载时间</li><li>使用 <code>gzip</code>, <code>Brotli</code> 或者 <code>Zopfli</code> 压缩您的资源</li><li>图片优化（如果可以，尽可能使用 css 动画或者 svg）</li><li>在超出应用视口范围的部分使用懒加载，如果你这么做了，为 SEO 制定一个后备计划（例如为 bot traffic 渲染整个页面）</li></ul><h2 id="CSS-性能优化"><a href="#CSS-性能优化" class="headerlink" title="CSS 性能优化"></a>CSS 性能优化</h2><ul><li><p>阻塞渲染优化</p></li><li><p>在 GPU 上呈现动画</p></li><li><p>will-change 属性</p></li><li><p>font-display 属性</p></li><li><p>contain 属性</p></li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>页面在样式没有渲染完毕的情况下被绘制，在样式渲染完毕后又被刷新，这大概是很糟糕的用户体验 <code>FOUC - Flash Of Unstyled Content 文档样式闪烁</code>。因此，除非浏览器知道当前不需要 该 CSS，否则 该 CSS 将阻止渲染。浏览器只会在下载 CSS 和构建 CSSOM 之后绘制页面。<strong>浏览器遵循特定的渲染路径</strong>：绘制 paint 仅在布局 layout 之后进行，布局 layout 则在创建渲染树 render tree 之后进行，创建渲染树则需要在 DOM 和 CSSOM 树解析完成后进行。</p></blockquote><p><strong>浏览器遵循特定的渲染路径</strong></p><ol><li>下载 CSS</li><li>DOM 和 CSSOM 树解析完成</li><li>创建渲染树 render tree</li><li>布局 layout</li><li>绘制 paint</li></ol><p><strong>优化方向</strong></p><p>为了优化 CSSOM 的构造，<code>请删除不必要的样式</code>，<code>对 CSS 进行最小化，压缩和缓存</code>，<code>并将页面加载时不需要的 CSS 拆分为其他文件，以减少 CSS 渲染阻塞</code>。</p><h3 id="阻塞渲染优化"><a href="#阻塞渲染优化" class="headerlink" title="阻塞渲染优化"></a>阻塞渲染优化</h3><p>CSS 可以使用媒体查询将样式应用在特定条件下。媒体查询对于响应式 Web 设计非常重要，可以帮助我们优化关键渲染路径。浏览器会阻塞渲染，直到它解析完全部的样式，但不会阻塞渲染它认为不会使用的样式，例如打印样式表。通过基于媒体查询将 CSS 分成多个文件，可以防止在下载未使用的 CSS 期间阻止渲染。为了创建非阻塞 CSS 链接，将不会立即使用的样式（例如打印样式）移动到单独的文件中，将 <link> 添加到 HTML 中，并添加媒体查询，在这种情况下说明它是打印样式表。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;styles.css&quot; &#x2F;&gt;&lt;!-- blocking --&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;print.css&quot; media&#x3D;&quot;print&quot; &#x2F;&gt;&lt;!-- not blocking --&gt;&lt;link  rel&#x3D;&quot;stylesheet&quot;  href&#x3D;&quot;mobile.css&quot;  media&#x3D;&quot;screen and (max-width: 480px)&quot;&#x2F;&gt;&lt;!-- not blocking on large screens --&gt;</code></pre><p>默认情况下，浏览器假设每个指定的样式表都是阻塞渲染的。通过添加 media 属性附加媒体查询，告诉浏览器何时应用样式表。<strong>当浏览器看到一个它知道只会用于特定场景的样式表时，它仍会下载样式，但不会阻塞渲染</strong>。通过将 CSS 分成多个文件，主要的 阻塞渲染 文件（本例中为 styles.css）的大小变得更小，从而减少了渲染被阻塞的时间。</p><h3 id="在-GPU-上呈现动画"><a href="#在-GPU-上呈现动画" class="headerlink" title="在 GPU 上呈现动画"></a>在 GPU 上呈现动画</h3><p>浏览器针对处理 CSS 动画和不会很好地触发重排（因此也导致重新绘制）的动画属性进行了优化。为了提高性能，可以将被动画化的节点从主线程移到 GPU 上。将导致合成的属性包括 <code>3D transforms (transform: translateZ(), rotate3d()，etc.)</code>，<code>animating transform</code> 和 <code>opacity</code>,<code> position: fixed</code>，<code>will-change</code>，和 <code>filter</code>。一些元素，例如 <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code> 和 <code>&lt;iframe&gt;</code>，<span style="color: red">也位于各自的图层上</span>。 将元素提升为图层（也称为合成）时，动画转换属性将在 GPU 中完成，从而改善性能，尤其是在移动设备上。</p><p><strong>额～，怎么看像与“层叠上下文”有关呢， 7 阶层叠 ？</strong> <a href="/#/post/2022-07-17css" target="_blank" >见</a></p><h3 id="will-change-属性"><a href="#will-change-属性" class="headerlink" title="will-change 属性"></a>will-change 属性</h3><p>CSS will-change 属性告诉浏览器元素的哪些属性需要修改，使浏览器能够在元素实际更改之前设置优化，通过在实际更改前执行耗时的工作以提升性能。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">will-change: opacity, transform;</code></pre><p>与“层叠上下文”有关</p><h3 id="font-display-属性"><a href="#font-display-属性" class="headerlink" title="font-display 属性"></a>font-display 属性</h3><p>根据 <code>@font-face</code> 规则，<code>font-display</code> 属性定义了浏览器如何加载和显示字体文件，<strong>允许文本在字体加载或加载失败时显示回退字体</strong>。可以通过依靠折中无样式文本闪现使文本可见替代白屏来提高性能。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">@font-face &#123;  font-family: someFont;  src: url(&#x2F;path&#x2F;to&#x2F;fonts&#x2F;someFont.woff) format(&quot;woff&quot;);  font-weight: 400;  font-style: normal;  font-display: fallback; &#x2F;&#x2F; 回滚&#125;</code></pre><h3 id="contain-属性"><a href="#contain-属性" class="headerlink" title="contain 属性"></a>contain 属性</h3><p>CSS 的 contain 属性允许作者指示<code>元素及其内容尽可能独立于文档树的其余部分</code>。这允许浏览器针对 DOM 的有限区域而不是整个页面重新计算布局，样式，绘画，大小或它们的任意组合。</p><p><strong>伪元素</strong></p><h2 id="性能衡量"><a href="#性能衡量" class="headerlink" title="性能衡量"></a>性能衡量</h2><p><a href="/#/post/2022-05-12performance" target="_blank" >前端基础-性能优化 1</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Performance/CSS" target="_blank" >火狐家的 MDN CSS 性能优化</a></p><p><a href="https://web.dev/i18n/zh/why-speed-matters/" target="_blank" >google 家的 web.dev why-speed-matters</a></p><p><a href="https://www.cnblogs.com/zhimao/p/15068536.html" target="_blank" >(十三) 性能优化 CRP </a></p><p><a href="https://blog.csdn.net/gongzhuxiaoxin/article/details/52454143" target="_blank" >什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-http 连接管理</title>
      <link href="//post/2022-07-26http-connect.html"/>
      <url>//post/2022-07-26http-connect.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-x2F-1-x-的连接管理"><a href="#HTTP-x2F-1-x-的连接管理" class="headerlink" title="HTTP&#x2F;1.x 的连接管理"></a>HTTP&#x2F;1.x 的连接管理</h2><img src="http://t-blog-images.aijs.top/img/20220726221631.png" style="max-width:450px"/><h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h3><ul><li>HTTP&#x2F;1.0 默认是短连接(<code>冷连接</code>),每一个 HTTP 请求都由它自己独立的连接完成,</li><li>TCP 协议握手耗费时间,TCP 可以保持更多的<code>热连接</code>来适应负载</li></ul><details class="custom-details"><summary>查看更多</summary><p>HTTP 最早期的模型，也是 HTTP&#x2F;1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。</p><p>TCP 协议握手本身就是耗费时间的，所以 TCP 可以保持更多的热连接来适应负载。短连接破坏了 TCP 具备的能力，新的<code>冷连接</code>降低了其性能。</p><p>这是 HTTP&#x2F;1.0 的默认模型 (如果没有指定 Connection 协议头，或者是值被设置为 close)。而在 HTTP&#x2F;1.1 中，只有当 Connection 被设置为 close 时才会用到这个模型。</p></details><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><span style="color: red">除非是要兼容一个非常古老的，不支持长连接的系统，没有一个令人信服的理由继续使用这个模型。</span></p></div><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p><strong>优点：</strong></p><p>解决<code>短连接</code>的两个比较大的问题：</p><ul><li>创建新连接耗费的时间尤为明显，</li><li>TCP 连接的性能只有在该连接被使用一段时间后 (<code>热连接</code>) 才能得到改善。</li></ul><p><strong>缺点</strong></p><ul><li>空闲状态，它还是会消耗服务器资源，</li><li>在重负载时，还有可能遭受 <code>DoS attacks</code> 攻击。</li></ul><details class="custom-details"><summary>查看更多</summary><p>为了缓解这些问题，长连接 的概念便被设计出来了，甚至在 HTTP&#x2F;1.1 之前。或者这被称之为一个 keep-alive 连接。</p><p><strong>优点</strong></p><p>一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：<span style="color: red">连接在空闲一段时间后会被关闭</span> (服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。</p><p><strong>缺点</strong></p><p>长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。</p><p>HTTP&#x2F;1.0 里默认并不使用长连接。把 Connection 设置成 close 以外的其它参数都可以让其保持长连接，通常会设置为 retry-after。(TODO:没懂)</p></p></details><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>在 HTTP&#x2F;1.1 里，默认就是长连接的，协议头都不用再去声明它 (但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP&#x2F;1.0 呢)</p></div><h3 id="Http-流水线"><a href="#Http-流水线" class="headerlink" title="Http 流水线"></a>Http 流水线</h3><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>流水线已经被更好的算法给代替，如 multiplexing，已经用在 HTTP&#x2F;2</p></div><ul><li>同一条长连接上发出连续的请求，不用等待应答返回</li><li>打包成消息包提升性能</li><li>幂等请求支持流水线</li><li>浏览器默认关闭</li></ul><details class="custom-details"><summary>查看更多</summary><p>默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p><code>流水线</code>是 在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟 。</p><p><strong>打包成消息包提升性能</strong></p><p>理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。就算 HTTP 请求不断的继续，尺寸会增加，但设置 TCP 的 MSS(Maximum Segment Size) 选项，仍然足够包含一系列简单的请求。</p><p><strong>幂等 请求支持流水线</strong><br>并不是所有类型的 HTTP 请求都能用到流水线：只有 <code>idempotent(幂等)</code> 方式，比如 <code>GET、HEAD、PUT 和 DELETE 能够被安全的重试</code>：<code>如果有故障发生时，流水线的内容要能被轻易的重试</code>。</p><p><strong>浏览器默认关闭</strong><br>今天，所有遵循 HTTP&#x2F;1.1 的代理和服务器都应该支持流水线，虽然实际情况中还是有很多限制：一个很重要的原因是，目前没有现代浏览器默认启用这个特性。</p></details><h3 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h3><div class="custom-quote danger"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 16H12"></path></svg></span><p class="custom-quote-title">WARNING</p><p>除非你有紧急而迫切的需求，不要使用这一过时的技术，升级到 HTTP&#x2F;2 就好了。在 HTTP&#x2F;2 里，做域名分片就没必要了：HTTP&#x2F;2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP&#x2F;2 的实现还会使用一种称作连接凝聚的技术去尝试合并被分片的域名。</p></div><p>作为 HTTP&#x2F;1.x 的连接，请求是序列化的，哪怕本来是无序的，在没有足够庞大可用的带宽时，也无从优化。一个解决方案是，浏览器为每个域名建立多个连接，以实现并发请求。曾经默认的连接数量为 2 到 3 个，现在比较常用的并发连接数已经增加到 6 条。<span style="color: red">如果尝试大于这个数字，就有触发服务器 DoS 保护的风险</span>。</p><p>如果服务器端想要更快速的响应网站或应用程序的应答，它可以迫使客户端建立更多的连接。例如，不要在同一个域名下获取所有资源，假设有个域名是 <a href="http://www.example.com，我们可以把它拆分成好几个域名：`www1.example.com`、`www2.example.com`、`www3.example.com`。所有这些域名都指向同一台服务器，浏览器会同时为每个域名建立">www.example.com，我们可以把它拆分成好几个域名：`www1.example.com`、`www2.example.com`、`www3.example.com`。所有这些域名都指向同一台服务器，浏览器会同时为每个域名建立</a> 6 条连接 (在我们这个例子中，连接数会达到 18 条)。这一技术被称<code>作域名分片</code>。</p><img src="http://t-blog-images.aijs.top/img/202207271036850.webp" /><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http2_-_%E4%B8%BA%E4%BA%86%E6%9B%B4%E4%BC%98%E5%BC%82%E7%9A%84%E8%A1%A8%E7%8E%B0" target="_blank" >见</a></p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p><code>帧</code>：HTTP&#x2F;2 数据通信的最⼩单位<br><code>消息</code>：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。</p><p>例如请求和响应等，消息由⼀个或多个帧 组成。</p><p><code>流</code>：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID</p><p>HTTP&#x2F;2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议解析起来更⾼效。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP&#x2F;1.x 会在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。</p><p>HTTP&#x2F;2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 ⾸部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 你可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</p><img src="http://t-blog-images.aijs.top/img/202207271040589.webp" /><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。</p><p>同域名下所有通信都在单个连接上完成。 单个连接可以承载任意数量的双向数据流。 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可 以重新组装</p><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p><code>HTTP/3</code>是第三个主要版本的 HTTP 协议。与其前任 HTTP&#x2F;1.1 和 HTTP&#x2F;2 不同，在 HTTP&#x2F;3 中，<code>将弃用TCP协议，改为使用基于UDP协议的QUIC协议实现</code>。</p><p>此变化主要为了解决 HTTP&#x2F;2 中存在的<code>队头阻塞</code>问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了<code>多路复用</code>，受到 TCP<code>拥塞控制</code>的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p><p><code>QUIC（快速UDP网络连接）</code>是一种实验性的网络传输协议，由 Google 开发，该协议旨在使网页传输更快。在 2018 年 10 月 28 日的邮件列表讨论中，互联网工程任务组（IETF） HTTP 和 QUIC 工作组主席 Mark Nottingham 提出了将 HTTP-over-QUIC 更名为 HTTP&#x2F;3 的正式请求，以“明确地将其标识为 HTTP 语义的另一个绑定……使人们理解它与 QUIC 的不同”，并在最终确定并发布草案后，将 QUIC 工作组继承到 HTTP 工作组。 在随后的几天讨论中，Mark Nottingham 的提议得到了 IETF 成员的接受，他们在 2018 年 11 月给出了官方批准，认可 HTTP-over-QUIC 成为 HTTP&#x2F;3。</p><p>2019 年 9 月，<strong>HTTP&#x2F;3 支持已添加到 Cloudflare 和 Google Chrome（Canary build）。Firefox Nightly 在 2019 年秋季之后添加支持</strong>。</p><p>2022 年 6 月 6 日，<strong>IETF 正式标准化 HTTP&#x2F;3 为 RFC9114</strong>。</p><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>虽然 QUIC 的名称最初是“<code>快速 UDP 互联网连接</code>”（Fast UDP Internet Connection）的首字母缩写，但 IETF 指定的标准中 QUIC 并不是任何内容的缩写。QUIC 提高了目前使用 TCP 的面向连接的网络应用的性能。它通过使用用户数据报协议（UDP）在两个端点之间创建若干个多路连接来实现这一目标，其目的是为了在网络层淘汰 TCP，以满足许多应用的需求，因此该协议偶尔也会获得 “TCP&#x2F;2”的昵称。</p><p>QUIC 与 HTTP&#x2F;2 的多路复用连接协同工作，允许多个数据流独立到达所有端点，因此不受涉及其他数据流的丢包影响。<br>相反，HTTP&#x2F;2 创建在传输控制协议（TCP）上，如果任何一个 TCP 数据包延迟或丢失，所有多路数据流都会遭受队头阻塞延迟。</p><ul><li>QUIC 的<code>次要目标包括降低连接和传输时延，以及每个方向的带宽估计以避免拥塞</code>。</li><li>将拥塞控制算法移到了两个端点的用户空间，而不是内核空间，据称这将使这些算法得到更快的改进。</li><li>该协议还可以扩展前向纠错（FEC），以进一步提高预期错误时的性能，这被视为协议演进的下一步。</li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>QUIC 旨在提供几乎等同于 TCP 连接的<code>可靠性</code>，但延迟大大减少。它主要通过两个理解 HTTP 流量的行为来实现这一点。</p><p><strong>TODO：没懂</strong></p><p>第一个变化是在连接创建期间大大减少开销。由于大多数 HTTP 连接都需要 TLS，因此 QUIC 使协商密钥和支持的协议成为初始握手过程的一部分。 当客户端打开连接时，服务器响应的数据包包括将来的数据包加密所需的数据。这消除了 TCP 上的先连接并通过附加数据包协商安全协议的需要。其他协议可以以相同的方式进行服务，并将多个步骤组合到一个请求中。 然后，这些数据既可用于初始设置中的后续请求，也可用于未来的请求。</p><p><strong>QUIC 流是单独控制的</strong></p><p><code>QUIC 使用 UDP 协议作为其基础，不包括丢失恢复。相反，每个 QUIC 流是单独控制的，并且在 QUIC 级别而不是 UDP 级别重传丢失的数据。这意味着如果在一个流中发生错误，协议栈仍然可以独立地继续为其他流提供服务。</code> 这在提高易出错链路的性能方面非常有用，因为在大多数情况下 TCP 协议通知数据包丢失或损坏之前可能会收到大量的正常数据，但是在纠正错误之前其他的正常请求都会等待甚至重发。 QUIC 在修复单个流时可以自由处理其他数据，也就是说即使一个请求发生了错误也不会影响到其他的请求。</p><p><strong>每个数据包单独加密、单个握手过程</strong></p><p>QUIC 包括许多其他更普通的更改，这些更改也可以<code>优化整体延迟</code>和<code>吞吐量</code>。例如，<code>每个数据包是单独加密的，因此加密数据时不需要等待部分数据包</code>。 在 TCP 下通常不可能这样做，其中加密记录在字节流中，并且协议栈不知道该流中的更高层边界。这些可以由运行在更上层的协议进行协商，但 QUIC 旨在通过<strong>单个握手过程完成</strong>这些。</p><p><strong>提高网络切换期间的性能</strong></p><p><code>QUIC 的另一个目标是提高网络切换期间的性能，例如当移动设备的用户从 WiFi 热点切换到移动网络时发生的情况。</code> 当这发生在 TCP 上时，一个冗长的过程开始了：每个现有连接一个接一个地超时，然后根据需要重新创建。期间存在较高延迟，因为新连接需要等待旧连接超时后才会创建。 为解决此问题，QUIC 包含一个<code>连接标识符</code>(是不是 MAC 地址？)，该标识符唯一地标识客户端与服务器之间的连接，而无论源 IP 地址是什么。这样只需发送一个包含此 ID 的数据包即可重新创建连接，因为即使用户的 IP 地址发生变化，原始连接 ID 仍然有效。</p><p><strong>QUIC 在应用程序空间中实现，而不是在操作系统内核中实现，容易扩展</strong><br><code>QUIC 在应用程序空间中实现，而不是在操作系统内核中实现。当数据在应用程序之间移动时，这通常会由于上下文切换而调用额外的开销。</code> 但是在 QUIC 下协议栈旨在由单个应用程序使用，每个应用程序使用 QUIC 在 UDP 上托管自己的连接。最终差异可能非常小，因为整个 HTTP&#x2F;2 堆栈的大部分已经存在于应用程序（或更常见的库）中。 将剩余部分放在这些库中，基本上是纠错，对 HTTP&#x2F;2 堆栈的大小或整体复杂性几乎没有影响。</p><p>QUIC 允许更容易地进行未来更改，因为它不需要更改内核就可以进行更新。 QUIC 的长期目标之一是添加前向纠错和改进的拥塞控制。</p><p>关于从 TCP 迁移到 UDP 的一个问题是 TCP 被广泛采用，并且互联网基础设施中的许多中间设备被调整为 UDP 速率限制甚至阻止 UDP。 Google 进行了一些探索性实验来描述这一点，发现只有少数连接存在此问题。所以 Chromium 的网络堆栈同时打开 QUIC 和传统 TCP 连接，并在 QUIC 连接失败时以零延迟回退到 TCP 连接。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><span style="color: red">注意：流量控制是 QUICK 实现的，UDP 并没有</span></p><p>与大多数传输协议一样，<strong>QUIC 具有流量控制以保护接收端免受缓冲器 overflow 的影响</strong>。QUIC 是基于 UDP 传输，而 UDP 没有流量控制，<code>因此 QUIC 实现了自己的流量控制机制</code>。与 TCP 不同，QUIC 并非通过 ACK 回应目前接收到第几笔资料，而是通过 <code>control frame </code>实现类似于 HTTP&#x2F;2 的基于信用的方案。</p><h2 id="HTTP-的发展历史"><a href="#HTTP-的发展历史" class="headerlink" title="HTTP 的发展历史"></a>HTTP 的发展历史</h2><p>先后经历了：</p><ul><li>万维网的发明</li><li>HTTP&#x2F;0.9 - 单行协议</li><li>HTTP&#x2F;1.0 - 构建可扩展性</li><li>HTTP&#x2F;1.1 - 标准化的协议</li><li>超过 15 年的发展（restful api、Server-send events、WebSocket、跨域资源共享 CORS、内容安全策略 CSP、隐私控制 DNT、X-Frame-Options）</li><li>HTTP2 - 为了更优异的表现</li><li>HTTP3 - 弃用 TCP 协议</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP" target="_blank" >见</a></p><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 <code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code> 或者 <code>&lt;object&gt;</code> 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持攻击。</p><pre class="line-numbers language-none"><code class="language-none">X-Frame-Options: DENYX-Frame-Options: SAMEORIGIN</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" >见</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x" target="_blank" >MDN HTTP 连接管理</a></p><p><a href="https://zh.wikipedia.org/wiki/QUIC" target="_blank" >维基百科 QUIC</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP/3" target="_blank" >维基百科 HTTP&#x2F;3</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-http CORS</title>
      <link href="//post/2022-07-26http-CORS.html"/>
      <url>//post/2022-07-26http-CORS.html</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><!-- <img src="http://t-blog-images.aijs.top/img/202208011714853.webp"  style="max-width:100%;width: 400px"/> --><img src="http://t-blog-images.aijs.top/img/202208011718040.webp"  style="max-width:100%;width: 400px"/><h2 id="跨源资源共享（CORS）"><a href="#跨源资源共享（CORS）" class="headerlink" title="跨源资源共享（CORS）"></a>跨源资源共享（CORS）</h2><p>CORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。</p><p><code>同源安全策略</code> 默认阻止“跨域”获取资源。但是 <code>CORS 给了 web 服务器这样的权限</code>，即服务器可以选择，允许跨域请求访问到它们的资源。</p><p><code>跨源资源共享 (CORS)</code>（或通俗地译为<code>跨域资源共享</code>）是一种<strong>基于 HTTP 头的机制</strong>，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。<strong>跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的”预检”请求</strong>。<strong>在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</strong></p><p>出于安全性(<code>应对CSRF攻击</code>)，浏览器<strong>限制</strong>脚本内发起的跨源 <code>HTTP</code> 请求。 例如，<code>XMLHttpRequest</code> 和 <code>Fetch API</code> 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p><img src="http://t-blog-images.aijs.top/img/202207261534554.webp" style="max-width: 100%; width: 400px"/><p><code>跨源域资源共享（CORS）机制</code>, 允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 <code>XMLHttpRequest</code> 或 <code>Fetch</code>）使用 CORS，以降低跨源 <code>HTTP</code> 请求所带来的风险。</p><h2 id="什么情况下需要-CORS？"><a href="#什么情况下需要-CORS？" class="headerlink" title="什么情况下需要 CORS？"></a>什么情况下需要 CORS？</h2><ul><li><code>HTTP</code>请求</li><li><code>Web字体</code></li><li><code>WebGL</code>贴图</li><li>使用 <code>drawImage</code> 将 Images&#x2F;video 画面绘制到 <code>canvas</code>。</li><li>来自图像的 CSS 图形 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Shapes/Shapes_From_Images#cors_compatibility" target="_blank" >见</a></li></ul><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul><li><p>跨源资源共享标准新增了一组 <code>HTTP</code> 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。</p></li><li><p>对那些<code>可能对服务器数据产生副作用的 HTTP 请求方法</code>（特别是 <code>GET</code> 以外的 <code>HTTP</code> 请求，或者搭配某些 MIME 类型 的 <code>POST</code> 请求），浏览器必须首先使用 <code>OPTIONS</code> 方法发起一个<code>预检请求</code>（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，<code>是否需要携带身份凭证</code>（包括 <code>Cookies</code> 和 <code>HTTP 认证</code> 相关数据）。</p></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><code>CORS</code> 请求失败会产生错误，但是为了安全，在 <code>JavaScript 代码层面是无法获知到底具体是哪里出了问题</code>。你只能查看浏览器的控制台以得知具体是哪里出现了错误。</p></div><h2 id="HTTP-访问控制场景"><a href="#HTTP-访问控制场景" class="headerlink" title="HTTP 访问控制场景"></a>HTTP 访问控制场景</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p><strong>某些请求不会触发 CORS 预检请求</strong>。本文称这样的请求为<code>“简单请求”</code>，请注意，该术语并不属于 Fetch（其中定义了 CORS）规范。若请求 满足所有下述条件，则该请求可视为“简单请求”：</p><ul><li><p>使用下列方法之一：<code>GET</code>、<code>HEAD</code>、<code>POST</code></p><br/><br/></li><li><p>除了被用户代理自动设置的首部字段（例如 <code>Connection</code>，<code>User-Agent</code>）和在 <code>Fetch</code> 规范中定义为 禁用首部名称 的其他首部，允许人为设置的字段为 <code>Fetch</code> 规范定义的 对 <code>CORS</code> 安全的首部字段集合</p><pre class="line-numbers language-none"><code class="language-none">AcceptAccept-LanguageContent-LanguageContent-Type（需要注意额外的限制）</code></pre></li><li><p><code>Content-Type</code> 的值仅限于下列三者之一：</p><pre class="line-numbers language-none"><code class="language-none">text&#x2F;plainmultipart&#x2F;form-dataapplication&#x2F;x-www-form-urlencoded</code></pre><br/><br/></li><li><p>请求中的任意 <code>XMLHttpRequest</code> 对象均没有注册任何事件监听器；（除了： <code>XMLHttpRequest</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问)</p><br/><br/></li><li><p>请求中没有使用 <code>ReadableStream</code> 对象</p></li></ul><p>比如说，假如站点 <code>https://foo.example</code> 的网页应用想要访问 <code>https://bar.other</code> 的资源。foo.example 的网页中可能包含类似于下面的 JavaScript 代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const xhr &#x3D; new XMLHttpRequest();const url &#x3D; &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;public-data&#x2F;&quot;;xhr.open(&quot;GET&quot;, url);xhr.onreadystatechange &#x3D; someHandler;xhr.send();</code></pre><p>客户端和服务器之间使用 <code>CORS</code> 首部字段来处理权限：</p><p>以下是浏览器发送给服务器的请求报文：</p><pre class="line-numbers language-GET" data-language="GET"><div class="caption"><span>/resources/public-data/ HTTP/1.1</span></div><code class="language-GET">Host: bar.otherUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko&#x2F;20100101 Firefox&#x2F;71.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: en-us,en;q&#x3D;0.5Accept-Encoding: gzip,deflateConnection: keep-aliveOrigin: https:&#x2F;&#x2F;foo.example</code></pre><p>请求首部字段 <code>Origin</code> 表明该请求来源于 <code>http://foo.example</code></p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache&#x2F;2Access-Control-Allow-Origin: *Keep-Alive: timeout&#x3D;2, max&#x3D;100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application&#x2F;xml[XML Data]</code></pre><p>本例中，服务端返回的 <code>Access-Control-Allow-Origin: * </code>表明，该资源可以被 <em>任意</em> 外域访问。</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Origin: *</code></pre><p>使用 <code>Origin</code> 和 <code>Access-Control-Allow-Origin</code> 就能完成最简单的访问控制。如果服务端仅允许来自 <a href="https://foo.example/">https://foo.example</a> 的访问，该首部字段的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Origin: https:&#x2F;&#x2F;foo.example</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>备注： 当响应的是附带身份凭证的请求时，服务端 必须 明确 Access-Control-Allow-Origin 的值，而不能使用通配符“*”。不过可以是<code>$http_origin</code> <a href="https://blog.csdn.net/u014589884/article/details/108028681" target="_blank" >$http_XXX 这个格式是 nginx 取请求中 header 的 XXX 的值的</a></p></div><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><p>与前述简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>如下是一个需要执行预检请求的 HTTP 请求：<span style="color: red">预检是浏览器主动发起的，研发都不用做</span></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const xhr &#x3D; new XMLHttpRequest();xhr.open(&quot;POST&quot;, &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;post-here&#x2F;&quot;);xhr.setRequestHeader(&quot;X-PINGOTHER&quot;, &quot;pingpong&quot;);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;xml&quot;);xhr.onreadystatechange &#x3D; handler;xhr.send(&quot;&lt;person&gt;&lt;name&gt;Arun&lt;&#x2F;name&gt;&lt;&#x2F;person&gt;&quot;);</code></pre><p>上面的代码使用 <code>POST</code> 请求发送一个 <code>XML</code> 文档，该请求包含了一个<code>自定义的请求首部字段（X-PINGOTHER: pingpong）</code>。另外，该请求的 <code>Content-Type</code> 为 <code>application/xml</code>。因此，该请求需要首先发起“预检请求”。</p><img src="http://t-blog-images.aijs.top/img/202207261604436.webp" style="max-width: 100%; width: 400px"/><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>备注： 如下所述，实际的 POST 请求不会携带 Access-Control-Request-* 首部，它们仅用于 OPTIONS 请求。</p></p></div><p><strong>下面是服务端和客户端完整的信息交互。首次交互是 预检请求&#x2F;响应：</strong></p><pre class="line-numbers language-none"><code class="language-none">OPTIONS &#x2F;doc HTTP&#x2F;1.1 # 这里Host: bar.otherUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko&#x2F;20100101 Firefox&#x2F;71.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: en-us,en;q&#x3D;0.5Accept-Encoding: gzip,deflateConnection: keep-aliveOrigin: https:&#x2F;&#x2F;foo.example # 这里Access-Control-Request-Method: POST # 这里Access-Control-Request-Headers: X-PINGOTHER, Content-Type # 这里HTTP&#x2F;1.1 204 No ContentDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache&#x2F;2Access-Control-Allow-Origin: https:&#x2F;&#x2F;foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400Vary: Accept-Encoding, OriginKeep-Alive: timeout&#x3D;2, max&#x3D;100Connection: Keep-Alive</code></pre><p>浏览器检测到，从 <code>JavaScript</code> 中发起的请求需要被预检。从上面的报文中，我们看到，第 1~10 行发送了一个使用 OPTIONS 方法 的“预检请求”。<strong>OPTIONS 是 HTTP&#x2F;1.1 协议中定义的方法，用以从服务器获取更多信息</strong>。<strong>该方法不会对服务器资源产生影响</strong>。 预检请求中同时携带了下面两个首部字段：</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Request-Method: POSTAccess-Control-Request-Headers: X-PINGOTHER, Content-Type # X-PINGOTHER 是自定义的</code></pre><p>首部字段 <code>Access-Control-Request-Method</code> 告知服务器，实际请求将使用 <code>POST</code> 方法。<br>首部字段 <code>Access-Control-Request-Headers</code> 告知服务器，实际请求将携带两个自定义请求首部字段：<code>X-PINGOTHER</code> 与 <code>Content-Type</code>。服务器据此决定，该实际请求是否被允许。</p><p>第 13-22 行为预检请求的响应，表明服务器将接受后续的实际请求。重点看第 16-19 行：</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Origin: https:&#x2F;&#x2F;foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400</code></pre><p>服务器的响应携带了 <code>Access-Control-Allow-Origin: https://foo.example</code>，从而限制请求的源域。同时，携带的 <code>Access-Control-Allow-Methods</code> 表明服务器允许客户端使用 <code>POST</code> 和 <code>GET</code> 方法发起请求（与 <code>Allow</code> 响应首部类似，但其具有严格的访问控制）。</p><p>首部字段 <code>Access-Control-Allow-Headers</code> 表明服务器允许请求中携带字段 X-<code>PINGOTHER</code> 与<code> Content-Type</code>。与 <code>Access-Control-Allow-Methods</code> 一样，<code>Access-Control-Allow-Headers</code> 的值为逗号分割的列表。</p><p>最后，首部字段 <code>Access-Control-Max-Age</code> 表明该响应的有效时间为 <code>86400</code> 秒，也就是 24 小时。<strong>在有效时间内，浏览器无须为同一请求再次发起预检请求。</strong> <span style="color: red">请注意，浏览器自身维护了一个 最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</span></p><h3 id="预检会拖慢速度"><a href="#预检会拖慢速度" class="headerlink" title="预检会拖慢速度"></a>预检会拖慢速度</h3><p>类似要去看病，先预检台、挂号、分诊。。。对于“急诊的”咋整？</p><p><code>Access-Control-Max-Age</code>整个上限，对于不同的浏览器上限要区别对待， <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age" target="_blank" >见</a></p><h3 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h3><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>当发出跨源请求时，第三方 cookie 策略仍将适用。无论如何改变本章节中描述的服务器和客户端的设置，该策略都会强制执行</p></div><p><code>XMLHttpRequest</code> 或 <code>Fetch</code> 与 <code>CORS</code> 的一个有趣的特性是，可以基于<code> HTTP cookies</code> 和<code> HTTP 认证信息</code>发送身份凭证。<br>一般而言，对于跨源 <code>XMLHttpRequest</code> 或 <code>Fetch</code> 请求，浏览器 <em>不会</em> 发送身份凭证信息。<strong>如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。</strong></p><p>本例中，<a href="https://foo.example/">https://foo.example</a> 的某脚本向 <a href="https://bar.other/">https://bar.other</a> 发起一个 GET 请求，并设置 Cookies：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const invocation &#x3D; new XMLHttpRequest();const url &#x3D; &quot;https:&#x2F;&#x2F;bar.other&#x2F;resources&#x2F;credentialed-content&#x2F;&quot;;function callOtherDomain() &#123;  if (invocation) &#123;    invocation.open(&quot;GET&quot;, url, true);    invocation.withCredentials &#x3D; true; &#x2F;&#x2F; 这里    invocation.onreadystatechange &#x3D; handler;    invocation.send();  &#125;&#125;</code></pre><p>第 7 行将 <code>XMLHttpRequest</code> 的 <code>withCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送 <code>Cookies</code>。<br><strong>因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”</strong>。但是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，<strong>浏览器将不会把响应内容返回给请求的发送者</strong>。</p><img src="http://t-blog-images.aijs.top/img/202207261630388.webp" style="max-width: 100%; width: 400px"/><p>CORS 预检请求不能包含凭据。预检请求的 <em>响应</em> 必须指定 <code>Access-Control-Allow-Credentials: true</code> 来表明可以携带凭据进行实际的请求。</p><p><strong>附带身份凭证的请求与通配符</strong></p><p>在响应附带身份凭证的请求时：</p><ul><li>服务器不能将 <code>Access-Control-Allow-Origin</code> 的值设为通配符“*”，而应将其设置为特定的域，如：<code>Access-Control-Allow-Origin: https://example.com</code>。</li><li>服务器不能将 <code>Access-Control-Allow-Headers</code>的值设为通配符“*”，而应将其设置为首部名称的列表，如：<code>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</code></li><li>服务器不能将 <code>Access-Control-Allow-Methods</code> 的值设为通配符“*”，而应将其设置为特定请求方法名称的列表，如：<code>Access-Control-Allow-Methods: POST, GET</code></li><li>对于附带身份凭证的请求（通常是 Cookie），服务器不得设置 <code>Access-Control-Allow-Origin 的值为“*”</code>。</li></ul><p>这是因为请求的首部中携带了 Cookie 信息，如果 <code>Access-Control-Allow-Origin 的值为“*”</code>，请求将会失败。<br>而将 <code>Access-Control-Allow-Origin</code> 的值设置为 <code>https://example.com</code>，则请求将成功执行。<br>另外，响应首部中也携带了 <code>Set-Cookie</code> 字段，尝试对 <code>Cookie</code> 进行修改。如果操作失败(<code>SameSite</code>限制)，将会抛出异常。</p><p><strong>第三方 cookies</strong></p><p>在 <code>CORS</code> 响应中设置的 <code>cookies</code> 适用一般性第三方 <code>cookie</code> 策略, <code>Cookie</code> 策略受 <code>SameSite</code> 属性控制</p><h2 id="http-响应首部字段"><a href="#http-响应首部字段" class="headerlink" title="http 响应首部字段"></a>http 响应首部字段</h2><ul><li><code>Access-Control-Allow-Origin: &lt;origin&gt; | *</code>, 对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符</li><li><code>Access-Control-Expose-Headers</code> , 让服务器把允许浏览器访问的头放入白名单</li><li><code>Access-Control-Max-Age: &lt;delta-seconds&gt;</code>, 指定了 preflight 请求的结果能够被缓存多久</li><li><code>Access-Control-Allow-Credentials</code>, 它指定了实际的请求是否可以使用 credentials</li><li><code>Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code>,其指明了实际请求中允许携带的首部字段</li><li><code>Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code>, 其指明了实际请求中允许携带的首部字段</li></ul><details class="custom-details"><summary>查看更多</summary><p>本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。</p><p><strong>Access-Control-Allow-Origin</strong></p><p>响应首部中可以携带一个 Access-Control-Allow-Origin 字段，其语法如下：</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Origin: &lt;origin&gt; | *</code></pre><p>其中，origin 参数的值指定了允许访问该资源的外域 URI。<strong>对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符</strong>，表示允许来自所有域的请求。</p><p>例如，下面的字段值将允许来自 <a href="https://mozilla.org/">https://mozilla.org</a> 的请求：</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Origin: https:&#x2F;&#x2F;mozilla.orgVary: Origin</code></pre><p>_如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容_。</p><p><strong>Access-Control-Expose-Headers</strong><br>译者注：在跨源访问时，<code>XMLHttpRequest</code> 对象的 <code>getResponseHeader()</code> 方法只能拿到一些最基本的响应头，</p><ul><li><code>Cache-Control</code>、</li><li><code>Content-Language</code>、</li><li><code>Content-Type</code>、</li><li><code>Expires</code>、</li><li><code>Last-Modified</code>、</li><li><code>Pragma</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers" target="_blank" >见 Access-Control-Expose-Headers</a><br>如果要访问其他头，则需要服务器设置本响应头。</li></ul><p><code>Access-Control-Expose-Headers</code> 头, 让服务器把允许浏览器访问的头放入白名单，例如：</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header</code></pre><p><strong>这样浏览器就能够通过 getResponseHeader 访问 X-My-Custom-Header 和 X-Another-Custom-Header 响应头了。</strong></p><p><strong>Access-Control-Max-Age</strong><br>Access-Control-Max-Age 头指定了 preflight 请求的结果能够被缓存多久，请参考本文在前面提到的 preflight 例子。</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Max-Age: &lt;delta-seconds&gt;</code></pre><p>delta-seconds 参数表示 preflight 预检请求的结果在多少秒内有效。</p><ul><li>在 Firefox 中，上限是 24 小时 （即 86400 秒）。</li><li>在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。</li><li>从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。</li><li>Chromium 同时规定了一个默认值 5 秒。</li><li>如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age" target="_blank" >见 Access-Control-Max-Age</a></li></ul><p><strong>Access-Control-Allow-Credentials</strong><br>Access-Control-Allow-Credentials 头指定了当浏览器的 credentials 设置为 true 时是否允许浏览器读取 response 的内容。当用在对 preflight 预检测请求的响应中时，它指定了实际的请求是否可以使用 credentials。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Credentials: true</code></pre><p>上文已经讨论了附带身份凭证的请求。</p><p><strong>Access-Control-Allow-Methods</strong><br>Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code></pre><p>有关 preflight request 的示例已在上方给出。</p><p><strong>Access-Control-Allow-Headers</strong><br>Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p><pre class="line-numbers language-none"><code class="language-none">Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code></pre></p></details><h2 id="http-请求首部字段"><a href="#http-请求首部字段" class="headerlink" title="http 请求首部字段"></a>http 请求首部字段</h2><p>可用于发起跨源请求的首部字段。请注意，这些首部字段<strong>无须手动设置</strong>。 当开发者使用 <code>XMLHttpRequest</code> 对象发起跨源请求时，它们已经被设置就绪。</p><ul><li><code>Origin</code> 首部字段表明预检请求或实际请求的源站</li><li><code>Access-Control-Request-Method</code> 首部字段用于预检请求。其作用是，将实际请求所使用的 <code>HTTP</code> 方法告诉服务器。</li><li><code>Access-Control-Request-Headers</code> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</li></ul><h2 id="CORS-错误及处理"><a href="#CORS-错误及处理" class="headerlink" title="CORS 错误及处理"></a>CORS 错误及处理</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSAllowOriginNotMatchingOrigin" target="_blank" >见</a></p><h2 id="在-nestjs-中本地调试"><a href="#在-nestjs-中本地调试" class="headerlink" title="在 nestjs 中本地调试"></a>在 nestjs 中本地调试</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">async function bootstrap() &#123;  const app &#x3D; await NestFactory.create&lt;NestExpressApplication&gt;(    ApplicationModule,  )  &#x2F;&#x2F; 允许跨域  app.enableCors(&#123;    origin: &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;,    credentials: true,  &#125;)</code></pre><p><strong>正确结果</strong></p><img src="http://t-blog-images.aijs.top/img/202208250949357.webp" /><ul><li>去掉 <code>credentials: true,</code> 测试</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">app.enableCors(&#123;  origin: &quot;http:&#x2F;&#x2F;127.0.0.1:5501&quot;,  &#x2F;&#x2F; credentials: true,&#125;);</code></pre><img src="http://t-blog-images.aijs.top/img/202208291423214.webp" /><ul><li>去掉 <code>origin: &#39;http://127.0.0.1:5501&#39;,</code> 测试</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">app.enableCors(&#123;  &#x2F;&#x2F; origin: &#39;http:&#x2F;&#x2F;127.0.0.1:5501&#39;,  credentials: true,&#125;);</code></pre><img src="http://t-blog-images.aijs.top/img/202208291425435.webp" /><h2 id="阿里云-COS-跨域配置"><a href="#阿里云-COS-跨域配置" class="headerlink" title="阿里云 COS 跨域配置"></a>阿里云 COS 跨域配置</h2><img src="http://t-blog-images.aijs.top/img/202209021744126.webp" style="width: 500px;max-width: 100%" /><img src="http://t-blog-images.aijs.top/img/202209021746095.webp" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" >Web 开发技术&gt;HTTP&gt;跨源资源共享（CORS）</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS/Errors/CORSAllowOriginNotMatchingOrigin" target="_blank" >Web 开发技术&gt;HTTP&gt;跨源资源共享（CORS）&gt;CORS errors</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React V17.0 候选版本：无新功能</title>
      <link href="//post/2022-07-25React-v17.html"/>
      <url>//post/2022-07-25React-v17.html</url>
      
        <content type="html"><![CDATA[<h2 id="无新特性"><a href="#无新特性" class="headerlink" title="无新特性"></a>无新特性</h2><p>React 17 的版本是非比寻常的，因为它<strong>没有添加任何面向开发人员的新功能</strong>。而主要<strong>侧重于升级简化 React 本身</strong>。</p><p>我们正在积极开发 React 的新功能，但它们并不属于此版本。React 17 是我们进行深度推广战略的关键所在。</p><p>此版本之所以特殊，你可以认为 <code>React 17 是 “垫脚石” 版本</code>，它会使得由<code>一个 React 版本管理的 tree 嵌入到另一个 React 版本管理的 tree 中时会更加安全</code>。</p><h2 id="逐步升级"><a href="#逐步升级" class="headerlink" title="逐步升级"></a>逐步升级</h2><p>在过去 7 年里，React 一直遵循 <code>“all-or-nothing”</code> 的升级策略。你可以继续使用旧版本，也可以将整个应用程序升级至新版本。但没有介于两者之间的情况。</p><p>此方式持续至今，但是我们遇到了 <code>“all-or-nothing” </code>升级策略的局限性。许多 API 的变更，例如，弃用旧版 context API 时，并不能以自动化的方式来完成。至今可能大多数应用程序从未使用过它们，但我们仍然选择在 React 中支持它们。<code>我们必须在无限期支持过时的 API 或针对某些应用仍使用旧版本 React 间进行选择。但这两个方案都不合适</code>。</p><p>因此，我们想提供另一种方案。</p><p>React 17 开始支持逐步升级 React 版本。当从 React 15 升级至 16 时（或者从 React 16 升级至 17 时），通常会一次升级整个应用程序。这适用于大部分应用程序。但是，如果代码库是在几年前编写的，并且并没有得到很好的维护，那么升级它会变得越来越有挑战性。<code>尽管可以在页面上使用两个版本的 React，但是直到 React 17 依旧有事件问题出现</code>。</p><p>我们使用 React 17 解决了许多诸如此类的问题。这将意味着当 React 18 或未来版本问世时，你将有更多选择。首选还是像以前一样，一次升级整个应用程序。但你也可以选择逐步升级你的应用程序。例如，你可能会将大部分应用程序迁移至 React 18，但在 React 17 上保留一些延迟加载的对话框或子路由。</p><p>但这不意味着你必须逐步升级。对于大部分应用程序来说，一次全量升级仍是最好的解决方案。加载两个 React 版本，即使其中一个是按需延迟加载的，仍然不太理想。但是，对于没有积极维护的大型应用来说，可以考虑此种方案，并且 React 17 开始可以保证这些应用程序不落伍。</p><p>为了实现逐步升级，我们需要对 React 事件系统进行一些更改。而这些更改可能会对代码产生影响，这也是 React 17 成为主要版本的原因。实际上，10 万个以上的组件中受影响的组件不超过 20 个，因此，我们<strong>希望大多数应用程序都可以升级到 React 17，而不会产生太多影响</strong>。如果你遇到问题，请联系我们。</p><h2 id="更改事件委托"><a href="#更改事件委托" class="headerlink" title="更改事件委托"></a>更改事件委托</h2><p>从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 React 事件系统的工作原理，这很难实现。</p><p>在 React 组件中，通常会内联编写事件处理：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;button onClick&#x3D;&#123;handleClick&#125;&gt;</code></pre><p>与此代码等效的原生 DOM 操作如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">myButton.addEventListener(&quot;click&quot;, handleClick);</code></pre><p>但是，对大多数事件来说，React 实际上并不会将它们附加到 DOM 节点上。相反，React 会直接在 document 节点上为每种事件类型附加一个处理器。这被称为事件委托。除了在大型应用程序上具有性能优势外，它还使添加类似于 <code>replaying events</code> 这样的新特性变得更加容易。</p><p>自从其发布以来，React 一直自动进行事件委托。<code>当 document 上触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。但实际上，原生事件已经冒泡出了 document 级别</code>，React 在其中安装了事件处理器。</p><p>但是，这就是逐步升级的困难所在。</p><p><span style="color: red">如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 e.stopPropagation()：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重<span>。这种担忧并不是没有根据的 —— 例如，四年前 Atom 编辑器就遇到了相同的问题。</p><p>这也是我们为什么要改变 React 底层附加事件方式的原因。</p><p><strong>在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const rootNode &#x3D; document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App &#x2F;&gt;, rootNode);</code></pre><p>在 React 16 或更早版本中，React 会对大多数事件执行 <code>document.addEventListener()</code>。React 17 将会在底层调用 <code>rootNode.addEventListener()</code>。</p><img src="https://react.docschina.org/static/bb4b10114882a50090b8ff61b3c4d0fd/1e088/react_17_delegation.png" /><p><strong>由于此更改，现在可以更加安全地进行新旧版本 React 树的嵌套</strong>。<span style="color: red">请注意，要使其正常工作，两个版本都必须为 17 或更高版本，这就是为什么强烈建议升级到 React 17 的根本原因</span>。从某种意义上讲，React 17 是一个 “垫脚石” 版本，使逐步升级成为可能。</p><p><strong>此更改还使得将 React 嵌入使用其他技术构建的应用程序变得更加容易</strong>。例如，如果应用程序的“外壳”是用 jQuery 编写的，但其中较新的代码是用 React 编写的，则 React 代码中的 e.stopPropagation() 会阻止它影响 jQuery 的代码 —— 这符合预期。换个角度来说，如果你不再喜欢 React 并想重写应用程序（比如，用 jQuery），则可以从外壳开始将 React 转换为 jQuery，而不会破坏事件冒泡。</p><p>经核实，多年来在 issue 追踪器 上报告的许多问题都已被新特性解决，这些问题大多都与将 React 与非 React 代码集成有关。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>你可能想知道这是否会破坏根 DOM 容器之外的 Portals。答案是 React 还会监听 portals 容器上的事件，所以这不是问题。</p></div><p><strong>解决隐患</strong></p><p>与其他重大更改一样，可能需要对代码进行调整。在 Facebook，我们在成千上万个模块中，大约调整了 10 个模块以适应此更改。</p><p>例如，如果模块中使用<code> document.addEventListener(...)</code> 手动添加了 DOM 监听，你可能希望能捕获到所有 React 事件。<span style="color: red">在 React 16 或更早版本中，即使你在 React 事件处理器中调用 <code>e.stopPropagation()</code>，你创建的 DOM 监听仍会触发，这是因为原生事件已经处于 document 级别</span>。使用 React 17 冒泡将被阻止（按需），因此你的 document 级别的事件监听不会触发：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.addEventListener(&quot;click&quot;, function () &#123;  &#x2F;&#x2F; This custom handler will no longer receive clicks  &#x2F;&#x2F; from React components that called e.stopPropagation()&#125;);</code></pre><p>你可以将监听转换为使用捕获来修复此类代码。为此，你可以将 <code>&#123; capture: true &#125; </code>作为 <code>document.addEventListener </code>的第三个参数传递：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.addEventListener(  &quot;click&quot;,  function () &#123;    &#x2F;&#x2F; Now this event handler uses the capture phase,    &#x2F;&#x2F; so it receives *all* click events below!  &#125;,  &#123; capture: true &#125;);</code></pre><p>请注意，此策略在全局上具有更好的适应性。例如，它可能会修复代码中现有的错误，这些错误在 React 事件处理器外部调用 <code>e.stopPropagation()</code> 发生。换句话说，<strong>React 17 的事件冒泡更接近常规 DOM</strong>。</p><h2 id="其他重大更改"><a href="#其他重大更改" class="headerlink" title="其他重大更改"></a>其他重大更改</h2><p>我们将 React 17 中的重大更改保持在最低水平。例如，它不会删除以前版本中弃用的任务方法。但是，它的确包含一些其他重大更改，根据经验，这些更改会相对安全。总体而言，由于这些因素的存在，在 10 万个以上的组件中受影响的组件不超过 20 个。</p><h3 id="对标浏览器"><a href="#对标浏览器" class="headerlink" title="对标浏览器"></a>对标浏览器</h3><p>我们对事件系统进行了一些较小的更改：</p><ul><li><code>onScroll</code> 事件不再冒泡，以防止出现常见的混淆。</li><li>React 的 <code>onFocus</code> 和 <code>onBlur</code> 事件已在底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件。它们更接近 <code>React</code> 现有行为，有时还会提供额外的信息。</li><li>捕获事件（例如，<code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器。</li></ul><p>这些更改会使 React 与浏览器行为更接近，并提高了互操作性。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：</p><p>尽管 React 17 底层已将 onFocus 事件从 focus 切换为 focusin，但请注意，这并未影响冒泡行为。在 React 中，onFocus 事件总是冒泡的，在 React 17 中会继续保持，因为通常它是一个更有用的默认值</p></div><h3 id="去除事件池"><a href="#去除事件池" class="headerlink" title="去除事件池"></a>去除事件池</h3><p>React 17 中移除了 “event pooling（事件池）“。它并不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function handleChange(e) &#123;  setData((data) &#x3D;&gt; (&#123;    ...data,    &#x2F;&#x2F; This crashes in React 16 and earlier:    text: e.target.value,  &#125;));&#125;</code></pre><p>这是因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 <code>e.persist()</code> 才能正确的使用该事件，或者正确读取需要的属性。</p><p><strong>在 React 17 中，此代码可以按照预期效果执行。旧的事件池优化操作已被完成删除，因此，使用者可以在需要时读取事件字段。</strong></p><p>这改变了行为，因此我们将其标记为重大更改，但在实践中我们没有看到它在 Facebook 上造成影响。（甚至还修复了一些错误！）请注意，<span style="color: red"><code>e.persist()</code> 在 React 事件对象中仍然可用，只是无效果罢了</span>。</p><h3 id="副作用清理时间"><a href="#副作用清理时间" class="headerlink" title="副作用清理时间"></a>副作用清理时间</h3><p>我们将使 <code>useEffect</code> 和清理函数的时间保持一致。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">useEffect(() &#x3D;&gt; &#123;  &#x2F;&#x2F; This is the effect itself.  return () &#x3D;&gt; &#123;    &#x2F;&#x2F; This is its cleanup.  &#125;;&#125;);</code></pre><p>大多数副作用（<code>effect</code>）不需要延迟屏幕更新，因此 React 在屏幕上反映出更新后立即异步执行它们。（在极少数情况下，你需要一种副作用来阻止绘制，例如，如果需要获取尺寸和位置，请使用 <code>useLayoutEffect</code>。）</p><p>然而，<span style="color: red">当组件被卸载时，副作用清理函数（类似于在 class 组件中同步调用 componentWillUnmount）同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）</span>。</p><p><strong>在 React 17 中，副作用清理函数总会异步执行 —— 如果要卸载组件，则清理会在屏幕更新后运行。</strong></p><p>这反映了副作用本身如何更紧密地运行。在极少数情况下，你可能希望依靠同步执行，可以改用 <code>useLayoutEffect</code>。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意</p><p>你可能想知道这是否意味着你现在将无法修复有关未挂载组件上的 setState 的警告。不必担心，React 专门处理了这种情况，并且不会在卸载和清理之间短暂间隔内发出 setState 的警告。因此，取消代码的请求或间隔几乎总是可以保存不变的。</p></div><p><strong>此外，React 17 将<code>在运行任何新副作用之前执行所有副作用的清理函数（针对所有组件）</code>。React 16 只对组件内的 effect 保证这种顺序。</strong></p><h3 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h3><p>可复用的库可能需要对此情况进行深度测试，但我们只遇到了几个组件会因为这次改变出现问题。有问题的代码的其中一个示例如下所示：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">useEffect(() &#x3D;&gt; &#123;  someRef.current.someSetupMethod();  return () &#x3D;&gt; &#123;    someRef.current.someCleanupMethod();  &#125;;&#125;);</code></pre><p>问题在于 someRef.current 是可变的，因此在运行清除函数时，它可能已经设置为 null。解决方案是在副作用内部存储会发生变化的值：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">useEffect(() &#x3D;&gt; &#123;  const instance &#x3D; someRef.current;  instance.someSetupMethod();  return () &#x3D;&gt; &#123;    instance.someCleanupMethod();  &#125;;&#125;);</code></pre><p><strong>我们不希望此问题对大家造成影响，我们提供了 <code>eslint-plugin-react-hooks/exhaustive-deps</code> 的 lint 规则（<span style="color: red">请确保在项目中使用它</span>）会对此情况发出警告。</strong></p><h3 id="返回一致的-undefined-错误"><a href="#返回一致的-undefined-错误" class="headerlink" title="返回一致的 undefined 错误"></a>返回一致的 undefined 错误</h3><p>在 React 16 及更早版本中，返回 undefined 始终是一个错误：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Button() &#123;  return; &#x2F;&#x2F; Error: Nothing was returned from render&#125;</code></pre><p>部分原因是这很容易无意间返回 undefined：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Button() &#123;  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.  &#x2F;&#x2F; React surfaces this as an error instead of ignoring it.  &lt;button &#x2F;&gt;;&#125;</code></pre><p>以前，<strong>React 只对 class 和函数组件执行此操作，但并不会检查 forwardRef 和 memo 组件的返回值。这是由于编码错误导致</strong>。</p><p>在 React 17 中，<strong>forwardRef 和 memo 组件的行为会与常规函数组件和 class 组件保持一致</strong>。在返回 undefined 时会报错</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let Button &#x3D; forwardRef(() &#x3D;&gt; &#123;  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.  &#x2F;&#x2F; React 17 surfaces this as an error instead of ignoring it.  &lt;button &#x2F;&gt;;&#125;);let Button &#x3D; memo(() &#x3D;&gt; &#123;  &#x2F;&#x2F; We forgot to write return, so this component returns undefined.  &#x2F;&#x2F; React 17 surfaces this as an error instead of ignoring it.  &lt;button &#x2F;&gt;;&#125;);</code></pre><p><strong>对于不想进行任何渲染的情况，请返回 null。</strong></p><h3 id="原生组件栈"><a href="#原生组件栈" class="headerlink" title="原生组件栈"></a>原生组件栈</h3><p>当你在浏览器中遇到错误时，浏览器会为你提供带有 JavaScript 函数的名称及位置的调用栈信息。然而，JavaScript 调用栈通常不足以诊断问题，因为 React 树的层次结构可能同样重要。你不仅要知道哪个 Button 抛出了错误，而且还想知道 Button 在 React 树中的哪个位置。</p><p>为了解决这个问题，当你遇到错误时，从 React 16 开始会打印 “组件栈” 信息。尽管如此，它们仍然不如原生的 JavaScript 调用栈。特别是，它们在控制台中不可点击，因为 React 不知道函数在源代码中的声明位置。此外，它们在生产中几乎无用。不同于常规压缩后的 JavaScript 调用栈，它们可以通过 sourcemap 的形式自动恢复到原始函数的位置，而使用 React 组件栈，在生产环境下必须在调用栈信息和 bundle 大小间进行选择。</p><p><strong>在 React 17 中，使用了不同的机制生成组件调用栈，该机制会将它们与常规的原生 JavaScript 调用栈缝合在一起。这使得你可以在生产环境中获得完全符号化的 React 组件调用栈信息。</strong></p><p>React 实现这一点的方式有点非常规。目前，浏览器无法提供获取函数调用栈框架（源文件和位置）的方法。_因此，当 React 捕获到错误时，将通过组件上述组件内部抛出的临时错误（并捕获）来重建其组件调用栈信息。这会增加崩溃时的性能损失，但每个组件类型只会发生一次_。</p><p>如果你对此感兴趣，可以在这个 PR 中阅读更多详细信息，但是在大多数情况下，这种机制不会影响你的代码。从使用者的角度来看，新功能就是可以单击组件调用栈（因为它们依赖于本机浏览器调用栈框架），并且可以像常规 JavaScript 错误那样在生产中进行解码。</p><p>构成重大变化的部分是，要使此功能正常工作，React 将在捕获错误后在调用栈中重新执行上面某些函数和某些 class 构造函数的部分。由于渲染函数和 class 构造函数不应具有副作用（这对于 SSR 也很重要），因此这不会造成任何实际问题。</p><h3 id="移除私有导出"><a href="#移除私有导出" class="headerlink" title="移除私有导出"></a>移除私有导出</h3><p>最后，值得注意的重大变化时我们<em>删除了一些以前暴露给其他项目的 React 内部组件</em>。特别是，React Native for Web 过去常常依赖于事件系统的某些内部组件，但这种依赖关系很脆弱且经常被破坏。</p><p>在 React 17 中，这些私有导出已被移除。据我们所知，React Native for Web 是唯一使用它们的项目，它们已经完成了向不依赖那些私有导出函数的其他方法迁移。</p><p><strong>这意味着旧版本的 React Native for Web 不会与 React 17 兼容</strong>，但是新版本可以使用它。实际上，并没有太大的变化，因为 React Native for Web 必须发布新版本以适应其内部 React 的变化。</p><p>另外，我们删除了 ReactTestUtils.SimulateNative 的 helper 方法。他们从未被记录，没有按照他们名字所暗示的那样去做，也没有处理我们对事件系统所做的更改。如果你想要一种简便的方式来触发测试中原生浏览器的事件，请改用 React Testing Library。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React@16、17 杂货</title>
      <link href="//post/2022-07-23react-%E6%9D%82%E8%B4%A7.html"/>
      <url>//post/2022-07-23react-%E6%9D%82%E8%B4%A7.html</url>
      
        <content type="html"><![CDATA[<h2 id="注意版本哈"><a href="#注意版本哈" class="headerlink" title="注意版本哈"></a>注意版本哈</h2><p><a href="https://juejin.cn/post/7034899177205137438" target="_blank" >从前有座山之 react 源码解读之 ReactContext</a></p><p><a href="https://blog.csdn.net/m0_51744158/article/details/120870752" target="_blank" >React 源码解析————ReactContext.js,ReactLazy.js</a></p><p><a href="https://www.cnblogs.com/sunxiaopei/p/12239160.html" target="_blank" >React 的 React.createRef()&#x2F;forwardRef()源码解析(三)</a></p><p><a href="https://www.cnblogs.com/sunxiaopei/p/12205447.html" target="_blank" >React 的 React.createElement 源码解析(一)</a></p><p><a href="https://zhuanlan.zhihu.com/p/81947864" target="_blank" >React 源码解析(三) requestWork 之前的的准备工作</a></p><p><a href="https://wenku.baidu.com/view/4306c6f2d25abe23482fb4daa58da0116c171fe1.html" target="_blank" >react 源码解析 7.Fiber 架构</a></p><h2 id="前后版本差异"><a href="#前后版本差异" class="headerlink" title="前后版本差异"></a>前后版本差异</h2><h3 id="expirationTime"><a href="#expirationTime" class="headerlink" title="expirationTime"></a>expirationTime</h3><p>expirationTime 越小优先级越高，而现在是 expirationTime 越大优先级越高</p><h3 id="React16-与-17-版本合成事件的区别"><a href="#React16-与-17-版本合成事件的区别" class="headerlink" title="React16 与 17 版本合成事件的区别"></a>React16 与 17 版本合成事件的区别</h3><ul><li>react16 时事件委托的对象是 document，react17 时事件委托的对象是容器组件</li><li>react16 时原生事件与 react 事件执行时，冒泡阶段与捕获阶段没有区分开（捕获-&gt; 冒泡 -&gt; 捕获）；</li><li>react17 时优化了合成事件的执行，当与原生事件一起调用时，捕获阶段总是先于冒泡阶段（捕获 -&gt; 冒泡）</li><li>react17 废弃了事件池</li></ul><!-- ————————————————版权声明：本文为CSDN博主「Monkey_Kcode」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_47431743/article/details/122156714 --><h3 id="更改事件委托"><a href="#更改事件委托" class="headerlink" title="更改事件委托"></a>更改事件委托</h3><p>从技术上讲，始终可以在应用程序中嵌套不同版本的 React。但是，由于 React 事件系统的工作原理，这很难实现。</p><p>自从其发布以来，React 一直自动进行事件委托。当 document 上触发 DOM 事件时，React 会找出调用的组件，然后 React 事件会在组件中向上 “冒泡”。但实际上，原生事件已经冒泡出了 document 级别，React 在其中安装了事件处理器。</p><p>但是，这就是逐步升级的困难所在。</p><p><span style="color: red">如果页面上有多个 React 版本，他们都将在顶层注册事件处理器。这会破坏 <code>e.stopPropagation()</code>：如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本 React 嵌套变得困难重重</span>。这种担忧并不是没有根据的 —— 例如，四年前 Atom 编辑器就遇到了相同的问题。</p><p>基于此： 在 React 17 中，React 将不再向 document 附加事件处理器。而会将事件处理器附加到渲染 React 树的根 DOM 容器中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const rootNode &#x3D; document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App &#x2F;&gt;, rootNode);</code></pre><p>在 React 16 或更早版本中，React 会对大多数事件执行 <code>document.addEventListener()</code>。React 17 将会在底层调用 <code>rootNode.addEventListener()</code>。</p><h3 id="Hooks-的实现原理"><a href="#Hooks-的实现原理" class="headerlink" title="Hooks 的实现原理"></a>Hooks 的实现原理</h3><p>React 会维护俩个链表，一个是 <code>currentHook</code>，另外一个是 <code>WorkInProgressHook</code>,每一个节点类型都是 <code>Hooks</code>，每当 <code>hooks</code> 函数被调用，react 就会创建一个 <code>hooks</code> 对象，并挂在链表的尾部，函数组件之所以能做一些类组件不能做的事儿，就是因为 <code>hook</code> 对象，函数组件的状态，计算值，缓存等都是交给 <code>hook</code> 去完成的，这样组件通过 Fiber.memoizedState 属性指向 hook 链表的头部来关联 <code>hook</code> 对象和当前组件，这样就发挥了 <code>hooks</code> 的作用。每次调用 hooks API 的时候，就会首先调用 <code>createWorkInProgressHook</code> 函数。得到 <code>hooks</code> 的串联不是一个数组，而是一个链式结构，从根节点 <code>workInProgressHook</code> 向下通过 next 进行串联，这也是为什么 <code>Hooks</code> 不能嵌套使用，不能在条件判断中使用，不能在循环中使用，否则链式就会被破坏。</p><!-- ————————————————版权声明：本文为CSDN博主「leoxiaoge」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/github_37759996/article/details/119187241 --><h3 id="createSyntheticEvent-源码"><a href="#createSyntheticEvent-源码" class="headerlink" title="createSyntheticEvent 源码"></a>createSyntheticEvent 源码</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function createSyntheticEvent(Interface: EventInterfaceType) &#123;  function SyntheticBaseEvent(    reactName: string | null,    reactEventType: string,    targetInst: Fiber,    nativeEvent: &#123;[propName: string]: mixed&#125;,    nativeEventTarget: null | EventTarget,  ) &#123;  Object.assign(SyntheticBaseEvent.prototype, &#123;    preventDefault: function() &#123;&#125;,    stopPropagation: function() &#123;&#125;,    &#x2F;**     * We release all dispatched &#96;SyntheticEvent&#96;s after each event loop, adding     * them back into the pool. This allows a way to hold onto a reference that     * won&#39;t be added back into the pool.     *&#x2F;    &#x2F;**    *我们在每个事件循环后释放所有调度的&#39;SyntheticEvent&#39;，添加    *他们回到水池里。这允许一种保持引用的方法    *不会被添加回池中。    *&#x2F;    persist: function() &#123;      &#x2F;&#x2F; Modern event system doesn&#39;t use pooling.      &#x2F;&#x2F; 现代事件系统不使用池。    &#125;,    &#x2F;**     * Checks if this event should be released back into the pool.     *     * @return &#123;boolean&#125; True if this should not be released, false otherwise.     *&#x2F;    isPersistent: functionThatReturnsTrue,  &#125;);  return SyntheticBaseEvent;&#125;</code></pre><p><code>persist</code>是个空函数，因为现在的事件系统不使用<code>事件池机制</code></p><p><code>事件池</code>可以形象地理解为有个池子里装满了 SyntheticEvent 对象，程序有需要时会从池中取出一些使用，使用完后再放回池中。</p><p><code>事件池机制</code>意味着 SyntheticEvent 对象会被缓存且反复使用，目的是提高性能，减少创建不必要的对象。当 SyntheticEvent 对象被收回到事件池中时，属性会被抹除、重置为 null。</p><p>因此，我们在写 React 事件回调函数的时候切记<code>不能将 event 用于异步操作</code> —— 当异步操作真正执行的时候，SyntheticEvent 对象有可能已经被重置了</p><p><strong>有事件池的情况下，如何处理异步事件</strong></p><ul><li>解决方案一： 使用 event.persist() 方法</li><li>解决方案二： 及时缓存所需的 event 属性值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 解决方案一：handleChange &#x3D; (event) &#x3D;&gt; &#123;  event.persist(); &#x2F;&#x2F; 持久化  this.setState((prevState) &#x3D;&gt; (&#123;    value: event.target.value,    editionCounter: prevState.editionCounter + 1,  &#125;));&#125;;&#x2F;&#x2F; 解决方案二：handleChange &#x3D; (event) &#x3D;&gt; &#123;  const value &#x3D; event.target.value; &#x2F;&#x2F; value这个本地变量已经保存了目标值  this.setState((prevState) &#x3D;&gt; (&#123;    value,    editionCounter: prevState.editionCounter + 1,  &#125;));&#125;;</code></pre><p><a href="https://zhuanlan.zhihu.com/p/212187297" target="_blank" >见</a></p><p><strong>移除版本</strong><br>在 17.0.0 (October 20, 2020)，React DOM，Remove event pooling. (@trueadm in #18969)</p><p><strong>移除原因</strong></p><p><a href="https://blog.saeloun.com/2021/04/06/react-17-removes-event-pooling-in-modern-system.html#event-pooling" target="_blank" >见 Event Pooling</a></p><ul><li>虽然建立事件池是为了提高性能，但在现代浏览器中并没有提高性能。</li><li>事件池也让开发人员感到困惑。例如，无法访问<code>eventx.target</code>。设置状态更新程序中的目标。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>With React 16 and earlier, we have to call event.persist() to properly use the event, or read the property we need.</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">handleChange(event) &#123;  console.log(event.target.value);  event.persist();  this.setState(() &#x3D;&gt; (&#123;    text: event.target.value  &#125;));&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>In React 17, the same code works as expected allowing us to fetch event.target.value without calling event.persist().<br>The old event pooling optimization has been fully removed, so we can read the event fields whenever we need them.</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export class App extends React.Component &#123;  constructor() &#123;    super();    this.state &#x3D; &#123; text: &quot;&quot; &#125;;    this.handleChange &#x3D; this.handleChange.bind(this);  &#125;  handleChange(event) &#123;    console.log(event.target.value);    this.setState(() &#x3D;&gt; (&#123;      text: event.target.value,    &#125;));  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;span&gt;Text: &lt;&#x2F;span&gt;        &lt;input onChange&#x3D;&#123;this.handleChange&#125; value&#x3D;&#123;this.state.text&#125; &#x2F;&gt;      &lt;&#x2F;div&gt;    );  &#125;&#125;</code></pre><h3 id="为什么原生事件的-stopPropagation-可以阻止合成事件的传递？"><a href="#为什么原生事件的-stopPropagation-可以阻止合成事件的传递？" class="headerlink" title="为什么原生事件的 stopPropagation 可以阻止合成事件的传递？"></a>为什么原生事件的 stopPropagation 可以阻止合成事件的传递？</h3><p>因为合成事件是在原生事件触发之后才开始收集并触发的，所以当原生事件调用 stopPropagation 阻止传递后，根本到不到 root 节点，触发不了 React 绑定的处理函数，自然合成事件也不会触发，所以原生事件不是阻止了合成事件的传递，而是阻止了 React 中绑定的事件函数的执行。</p><h3 id="react-基础知识总结"><a href="#react-基础知识总结" class="headerlink" title="react 基础知识总结"></a>react 基础知识总结</h3><p><a href="http://www.zzvips.com/article/230111.html" target="_blank" >见</a></p><h2 id="React17-源码"><a href="#React17-源码" class="headerlink" title="React17 源码"></a>React17 源码</h2><p><a href="https://www.zhihu.com/column/c_1203007131219533824" target="_blank" >见</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.zzvips.com/article/230111.html" target="_blank" >react 基础知识总结</a></p><p><a href="http://www.zzvips.com/article/227118.html" target="_blank" >React 事件机制源码解析 17.0.1</a></p><p><a href="https://react.docschina.org/blog/2020/08/10/react-v17-rc.html#changes-to-event-delegation" target="_blank" >更改事件委托</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React@16.5.0 diffing algorithm</title>
      <link href="//post/2022-07-22react-diffing.html"/>
      <url>//post/2022-07-22react-diffing.html</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>React provides a declarative API so that you don’t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React’s “diffing” algorithm so that component updates are predictable while being fast enough for high-performance apps.</p></blockquote><p>嗯，这里使用了英文原文，我觉得中文版本，翻译的不够准确</p><p>撇开中文版官方不谈，译文如下：</p><p>React 提供了响应式 API,所以你不用担心每次更新都会发生什么变化。这使得开发应用更点单，但在 React 中如何实现这一点可能并不明显。这篇文章解释了我们在 React 的 diffing 算法的选择，因此，组件更新是可预测的，同时对高性能应用程序来说足够快。</p><h2 id="设计动机"><a href="#设计动机" class="headerlink" title="设计动机"></a>设计动机</h2><p>在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。</p><p>在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。</p><p>React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p><p>此算法有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作次数。然而，即使使用最优的算法，该算法的复杂程度仍为 O(n 3 )，其中 n 是树中元素的数量。</p><p>如果在 React 中使用该算法，那么展示 1000 个元素则需要 10 亿次的比较。这个开销实在是太过高昂。于是 React 在以下两个假设的基础之上提出了一套 O(n) 的 <code>启发式算法</code>：</p><ul><li><code>两个不同类型的元素会产生出不同的树；</code></li><li><code>开发者可以使用 key 属性标识哪些子元素在不同的渲染中可能是不变的。</code></li></ul><p>在实践中，我们发现以上假设在几乎所有实用的场景下都成立。</p><details class="custom-details"><summary>启发式算法定义</summary><p><a href="https://baike.baidu.com/item/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/938987" target="_blank" ><code>启发式算法</code></a>（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计</p></details><h2 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h2><p>当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。</p><h3 id="对比不同类型的元素"><a href="#对比不同类型的元素" class="headerlink" title="对比不同类型的元素"></a>对比不同类型的元素</h3><p>当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树</p><ul><li><p>当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 <code>componentWillUnmount()</code> 方法。</p></li><li><p>当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 <code>UNSAFE_componentWillMount()</code> 方法，紧接着 <code>componentDidMount()</code> 方法。</p></li></ul><p>所有与之前的树相关联的 state 也会被销毁。</p><p>在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div&gt;  &lt;Counter &#x2F;&gt;&lt;&#x2F;div&gt;&lt;span&gt;  &lt;Counter &#x2F;&gt;&lt;&#x2F;span&gt;</code></pre><p>React 会销毁 Counter 组件并且重新装载一个新的组件。</p><h3 id="对比同一类型的元素"><a href="#对比同一类型的元素" class="headerlink" title="对比同一类型的元素"></a>对比同一类型的元素</h3><p>当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div className&#x3D;&quot;before&quot; title&#x3D;&quot;stuff&quot; &#x2F;&gt;&lt;div className&#x3D;&quot;after&quot; title&#x3D;&quot;stuff&quot; &#x2F;&gt;</code></pre><p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>className</code> 属性。</p><br/><br/><p>当更新 <code>style</code> 属性时，React 仅更新有所更变的属性。比如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;div style&#x3D;&#123;&#123;color: &#39;red&#39;, fontWeight: &#39;bold&#39;&#125;&#125; &#x2F;&gt;&lt;div style&#x3D;&#123;&#123;color: &#39;green&#39;, fontWeight: &#39;bold&#39;&#125;&#125; &#x2F;&gt;</code></pre><p>通过对比这两个元素，React 知道只需要修改 DOM 元素上的 <code>color</code> 样式，无需修改 <code>fontWeight</code>。</p><p>在处理完当前节点之后，React 继续对子节点进行递归。</p><h3 id="对比同类型的组件元素"><a href="#对比同类型的组件元素" class="headerlink" title="对比同类型的组件元素"></a>对比同类型的组件元素</h3><p>当一个组件更新时，<code>组件实例会保持不变</code>，因此可以在不同的渲染时保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 <code>UNSAFE_componentWillReceiveProps()</code>、<code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code>方法。</p><p>下一步，调用 render() 方法，<strong>diff 算法将在之前的结果以及新的结果中进行递归</strong>。</p><h3 id="对子节点进行递归"><a href="#对子节点进行递归" class="headerlink" title="对子节点进行递归"></a>对子节点进行递归</h3><p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 <code>mutation</code>变化。</p><p><code>在子元素列表末尾新增元素时，更新开销比较小</code>。比如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;ul&gt;  &lt;li&gt;first&lt;&#x2F;li&gt;  &lt;li&gt;second&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ul&gt;  &lt;li&gt;first&lt;&#x2F;li&gt;  &lt;li&gt;second&lt;&#x2F;li&gt;  &lt;li&gt;third&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;</code></pre><p>React 会先匹配两个 <li>first</li> 对应的树，然后匹配第二个元素 <li>second</li> 对应的树，最后插入第三个元素的 <li>third</li> 树。</p><p>如果只是简单的将新增元素插入到表头，那么更新开销会比较大。比如：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;ul&gt;  &lt;li&gt;Duke&lt;&#x2F;li&gt;  &lt;li&gt;Villanova&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ul&gt;  &lt;li&gt;Connecticut&lt;&#x2F;li&gt;  &lt;li&gt;Duke&lt;&#x2F;li&gt;  &lt;li&gt;Villanova&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;</code></pre><p>React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和 <code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;ul&gt;  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;ul&gt;  &lt;li key&#x3D;&quot;2014&quot;&gt;Connecticut&lt;&#x2F;li&gt;  &lt;li key&#x3D;&quot;2015&quot;&gt;Duke&lt;&#x2F;li&gt;  &lt;li key&#x3D;&quot;2016&quot;&gt;Villanova&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;</code></pre><p>现在 React 知道只有带着 <code>&#39;2014&#39;</code> key 的元素是新元素，带着 <code>&#39;2015&#39;</code> 以及 <code>&#39;2016&#39;</code> key 的元素仅仅移动了。</p><p>实际开发中，编写一个 key 并不困难。你要展现的元素可能已经有了一个唯一 ID，于是 key 可以直接从你的数据中提取：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;</code></pre><p>当以上情况不成立时，你可以新增一个 ID 字段到你的模型中，或者利用一部分内容作为哈希值来生成一个 key。<strong>这个 key 不需要全局唯一，但在列表中需要保持唯一</strong>。</p><p>最后，_你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢_。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><strong>当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题</strong>。由于组件实例是基于它们的 key 来决定是否更新以及复用，<code>如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致</code><small style="color: red;">非受控组件的 state（比如输入框）</small><code>可能相互篡改，会出现无法预期的变动</code>。</p></p></div><p>在 Codepen 有两个例子，分别为 <a href="https://zh-hans.reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key" target="_blank" >展示使用下标作为 key 时导致的问题</a>，以及 <a href="https://zh-hans.reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key" target="_blank" >不使用下标作为 key 的例子的版本，修复了重新排列，排序，以及在列表头插入的问题</a>。</p><p><strong>修复前</strong></p><img src="http://t-blog-images.aijs.top/img/Kapture 2022-07-22 at 09.23.57.gif" style="max-width: 100%; width: 400px" /><p><strong>修复后</strong></p><img src="http://t-blog-images.aijs.top/img/Kapture 2022-07-22 at 09.29.46.gif" style="max-width: 100%; width: 400px" /><h2 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h2><p>请谨记协调算法是一个实现细节。</p><p>React 可以在每个 action 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 render 方法，这不代表 React 会卸载或装载它们。React 只会基于以上提到的规则来决定如何进行差异的合并。</p><p>我们定期优化启发式算法，让常见用例更高效地执行。<strong>在当前的实现中，可以理解为一棵子树能在其兄弟之间移动，但不能移动到其他位置。</strong>在这种情况下，算法会重新渲染整棵子树。</p><p>由于 React 依赖启发式算法，因此当以下假设没有得到满足，性能会有所损耗。</p><ul><li>该算法不会尝试匹配不同组件类型的子树。<strong>如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型</strong>。在实践中，我们没有遇到这类问题。<br/><br/></li><li>Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，<strong>这可能导致性能下降和子组件中的状态丢失。</strong></li></ul><h2 id="diffing-algorithm"><a href="#diffing-algorithm" class="headerlink" title="diffing algorithm"></a>diffing algorithm</h2><p><a href="https://react.iamkasong.com/diff/prepare.html#diff%E7%9A%84%E7%93%B6%E9%A2%88%E4%BB%A5%E5%8F%8Areact%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9" target="_blank" >见</a></p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：React 技术揭秘讲的内容并不一定是全面且正确的，可能你在读的源码版本不一致，但可借鉴</p></div><h2 id="reconcileChildFibers"><a href="#reconcileChildFibers" class="headerlink" title="reconcileChildFibers"></a>reconcileChildFibers</h2><img src="http://t-blog-images.aijs.top/img/begin-diff.png" /><p>读源码中…</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm" target="_blank" >reconciliation</a></p><p><a href="https://blog.csdn.net/weixin_47431743/article/details/121589419" target="_blank" >代码调试</a></p><p><a href="https://www.jianshu.com/p/c87cc324756f" target="_blank" >探索 React 源码：Reconciler</a></p>]]></content>
      
      
      <categories>
          
          <category> react_1650 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react_1650 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React@16.5.0 PureComponent</title>
      <link href="//post/2022-07-21react-PureComponent.html"/>
      <url>//post/2022-07-21react-PureComponent.html</url>
      
        <content type="html"><![CDATA[<h2 id="串串"><a href="#串串" class="headerlink" title="串串"></a>串串</h2><img src="http://t-blog-images.aijs.top/img/pureComponent1.webp" /><p>PureComponent 继承 Component,添加 isPureReactComponent 标记</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ComponentDummy 是典型的 JavaScript 原型模拟继承的做法，function ComponentDummy() &#123;&#125;ComponentDummy.prototype &#x3D; Component.prototype;&#x2F;** * Convenience component with default shallow equality check for sCU. * 具有sCU默认浅相等检查的便利组件。 *&#x2F;function PureComponent(props, context, updater) &#123;  this.props &#x3D; props;  this.context &#x3D; context;  &#x2F;&#x2F; If a component has string refs, we will assign a different object later.  &#x2F;&#x2F; 如果组件具有字符串引用，我们将稍后指定其他对象。  this.refs &#x3D; emptyObject;  this.updater &#x3D; updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype &#x3D; (PureComponent.prototype &#x3D; new ComponentDummy());pureComponentPrototype.constructor &#x3D; PureComponent;&#x2F;&#x2F; Avoid an extra prototype jump for these methods.  避免这些方法的额外原型跳转。&#x2F;&#x2F; 为了避免原型链拉长导致方法查找的性能开销，还用 Object.assign 把方法从 ReactComponent 拷贝过来了Object.assign(pureComponentPrototype, Component.prototype);pureComponentPrototype.isPureReactComponent &#x3D; true; &#x2F;&#x2F; checkShouldComponentUpdate中有浅比较&#96;shallowEqual&#96;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; packages&#x2F;react&#x2F;src&#x2F;ReactBaseClasses.js&#x2F;&#x2F; PureComponent-&gt;继承Component, 添加 isPureReactComponent &#x3D; true&#x2F;&#x2F; packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberClassComponent.js&#x2F;&#x2F; checkShouldComponentUpdate-&gt;&#x2F;&#x2F; shallowEqual</code></pre><h2 id="checkShouldComponentUpdate"><a href="#checkShouldComponentUpdate" class="headerlink" title="checkShouldComponentUpdate"></a>checkShouldComponentUpdate</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function checkShouldComponentUpdate(  workInProgress,  ctor,  oldProps,  newProps,  oldState,  newState,  nextLegacyContext) &#123;  const instance &#x3D; workInProgress.stateNode;  &#x2F;&#x2F; 实例上有shouldComponentUpdate，走实例的判断  if (typeof instance.shouldComponentUpdate &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;    startPhaseTimer(workInProgress, &quot;shouldComponentUpdate&quot;);    const shouldUpdate &#x3D; instance.shouldComponentUpdate(      newProps,      newState,      nextLegacyContext    );    stopPhaseTimer();    if (__DEV__) &#123;      warningWithoutStack(        shouldUpdate !&#x3D;&#x3D; undefined,        &quot;%s.shouldComponentUpdate(): Returned undefined instead of a &quot; +          &quot;boolean value. Make sure to return true or false.&quot;,        getComponentName(ctor) || &quot;Component&quot;      );    &#125;    return shouldUpdate; &#x2F;&#x2F; 返回了  &#125;  &#x2F;&#x2F; 实例没有看看组件是不是PureComponent,如果是进行浅比较  &#x2F;&#x2F; 浅比较  if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;    return (      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)    );  &#125;  return true;&#125;</code></pre><h2 id="shallowEqual"><a href="#shallowEqual" class="headerlink" title="shallowEqual"></a>shallowEqual</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function shallowEqual(objA: mixed, objB: mixed): boolean &#123;  if (is(objA, objB)) &#123;    return true;  &#125;  if (    typeof objA !&#x3D;&#x3D; &quot;object&quot; ||    objA &#x3D;&#x3D;&#x3D; null ||    typeof objB !&#x3D;&#x3D; &quot;object&quot; ||    objB &#x3D;&#x3D;&#x3D; null  ) &#123;    return false;  &#125;  const keysA &#x3D; Object.keys(objA);  const keysB &#x3D; Object.keys(objB);  if (keysA.length !&#x3D;&#x3D; keysB.length) &#123;    return false;  &#125;  &#x2F;&#x2F; Test for A&#39;s keys different from B.  &#x2F;&#x2F; 只是对键对应的值进行比较，从MDN Object.is Api了解到 都是相同对象（意味着都是同一个对象的值引用）  &#x2F;&#x2F; 如果这里进行递归处理，就变成了deepCompare  for (let i &#x3D; 0; i &lt; keysA.length; i++) &#123;    if (      !hasOwnProperty.call(objB, keysA[i]) ||      !is(objA[keysA[i]], objB[keysA[i]])    ) &#123;      return false;    &#125;  &#125;  return true;&#125;</code></pre><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * inlined Object.is polyfill to avoid requiring consumers ship their own * https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Global_Objects&#x2F;Object&#x2F;is *&#x2F;function is(x, y) &#123;  &#x2F;&#x2F; SameValue algorithm  if (x &#x3D;&#x3D;&#x3D; y) &#123;    &#x2F;&#x2F; Steps 1-5, 7-10    &#x2F;&#x2F; Steps 6.b-6.e: +0 !&#x3D; -0    &#x2F;&#x2F; Added the nonzero y check to make Flow happy, but it is redundant    return x !&#x3D;&#x3D; 0 || y !&#x3D;&#x3D; 0 || 1 &#x2F; x &#x3D;&#x3D;&#x3D; 1 &#x2F; y;  &#125; else &#123;    &#x2F;&#x2F; Step 6.a: NaN &#x3D;&#x3D; NaN    return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D; y;  &#125;&#125;</code></pre><h2 id="end-and-start"><a href="#end-and-start" class="headerlink" title="end and start"></a>end and start</h2><p>其实上到这个地方，PureComponent 就聊完了</p><h2 id="与-beginWork-串串"><a href="#与-beginWork-串串" class="headerlink" title="与 beginWork 串串"></a>与 beginWork 串串</h2><img src="http://t-blog-images.aijs.top/img/pureComponent.webp" /><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; beginWork-&gt;&#x2F;&#x2F; updateClassComponent(到这里就与@link: &#x2F;posts&#x2F;2022-07-21react-createElement 串起来了)-&gt;&#x2F;&#x2F; resumeMountClassInstance-&gt; | updateClassInstance-&gt;&#x2F;&#x2F; checkShouldComponentUpdate-&gt;&#x2F;&#x2F; shallowEqual</code></pre><h2 id="resumeMountClassInstance"><a href="#resumeMountClassInstance" class="headerlink" title="resumeMountClassInstance"></a>resumeMountClassInstance</h2><p>如果已经创建实例，则重用实例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function resumeMountClassInstance(  workInProgress: Fiber,  ctor: any,  newProps: any,  renderExpirationTime: ExpirationTime): boolean &#123;  &#x2F;&#x2F; 是否应该更新，两种情况：forceUpdate 或者 checkShouldComponentUpdate 返回true  const shouldUpdate &#x3D;    checkHasForceUpdateAfterProcessing() ||    checkShouldComponentUpdate(      workInProgress,      ctor,      oldProps,      newProps,      oldState,      newState,      nextLegacyContext    );  if (shouldUpdate) &#123;    &#x2F;&#x2F; In order to support react-lifecycles-compat polyfilled components,    &#x2F;&#x2F; Unsafe lifecycles should not be invoked for components using the new APIs.    if (      !hasNewLifecycles &amp;&amp;      (typeof instance.UNSAFE_componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot; ||        typeof instance.componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;)    ) &#123;      startPhaseTimer(workInProgress, &quot;componentWillMount&quot;);      if (typeof instance.componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;        instance.componentWillMount();      &#125;      if (typeof instance.UNSAFE_componentWillMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;        instance.UNSAFE_componentWillMount();      &#125;      stopPhaseTimer();    &#125;    &#x2F;&#x2F; 这里进行标记了    if (typeof instance.componentDidMount &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;      workInProgress.effectTag |&#x3D; Update;    &#125;  &#125; else &#123;  &#125;  &#x2F;&#x2F; Update the existing instance&#39;s state, props, and context pointers even  &#x2F;&#x2F; if shouldComponentUpdate returns false.  instance.props &#x3D; newProps;  instance.state &#x3D; newState;  instance.context &#x3D; nextLegacyContext;  return shouldUpdate;&#125;</code></pre><h2 id="startPhaseTimer"><a href="#startPhaseTimer" class="headerlink" title="startPhaseTimer"></a>startPhaseTimer</h2><p><code>packages/react-reconciler/src/ReactDebugFiberPerf.js</code>文件中，性能测量相关，不用关心</p><h2 id="updateClassComponent"><a href="#updateClassComponent" class="headerlink" title="updateClassComponent"></a>updateClassComponent</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function updateClassComponent(  current: Fiber | null,  workInProgress: Fiber,  Component: any,  nextProps,  renderExpirationTime: ExpirationTime) &#123;  let shouldUpdate;  if (current &#x3D;&#x3D;&#x3D; null) &#123;    &#x2F;&#x2F;  如果还没创建实例，初始化    if (workInProgress.stateNode &#x3D;&#x3D;&#x3D; null) &#123;    &#125; else &#123;      &#x2F;&#x2F;  如果已经创建实例，则重用实例      &#x2F;&#x2F; In a resume, we&#39;ll already have an instance we can reuse.      shouldUpdate &#x3D; resumeMountClassInstance(        workInProgress,        Component,        nextProps,        renderExpirationTime      );    &#125;  &#125; else &#123;    &#x2F;&#x2F; 更新类实例    shouldUpdate &#x3D; updateClassInstance(      current,      workInProgress,      Component,      nextProps,      renderExpirationTime    );  &#125;  return finishClassComponent(    &#x2F;&#x2F; 调用组件实例的render函数获取需渲染的子元素，并把子元素进行处理为Fiber类型，处理state和props：    current,    workInProgress,    Component,    shouldUpdate,    hasContext,    renderExpirationTime  );&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> react_1650 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react_1650 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React@16.5.0 unsafe_</title>
      <link href="//post/2022-07-21react-unsafe.html"/>
      <url>//post/2022-07-21react-unsafe.html</url>
      
        <content type="html"><![CDATA[<h2 id="我整理这篇文章的目的"><a href="#我整理这篇文章的目的" class="headerlink" title="我整理这篇文章的目的"></a>我整理这篇文章的目的</h2><p>很多时候，我在学技术时候更多关注的是<code>教程</code>和<code>文档</code>,原因有三：时间紧、任务重、新技术很多</p><p>最近手头无事，刚好搜源码搜到了，希望闲暇之余，你也能了解 React 变更过程，加深 React 的理解</p><h2 id="过时的组件生命周期往往会带来不安全的编码实践"><a href="#过时的组件生命周期往往会带来不安全的编码实践" class="headerlink" title="过时的组件生命周期往往会带来不安全的编码实践"></a>过时的组件生命周期往往会带来不安全的编码实践</h2><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>这些生命周期方法经常被<code>误解和滥用</code>；此外，React 团队预计到，在异步渲染中，它们潜在的<code>误用问题可能更大</code>。所以在 March 27, 2018 提出</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>我们将在即将发布的版本中为这些生命周期添加 <code>UNSAFE_</code> 前缀。（这里的 “unsafe” <code>不是指安全性</code>，<code>而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug</code>，<code>尤其是在启用异步渲染之后</code>。）</p></blockquote><h2 id="遵循语义版本控制"><a href="#遵循语义版本控制" class="headerlink" title="遵循语义版本控制"></a>遵循语义版本控制</h2><p>React <a href="https://semver.org/lang/zh-CN/" target="_blank" >遵循语义版本控制</a>，因此这种变化将是逐步的。我们目前的计划是：</p><ul><li>16.3：为不安全的生命周期引入别名，<code>UNSAFE_componentWillMount``、UNSAFE_componentWillReceiveProps</code> 和 <code>UNSAFE_componentWillUpdate</code>。（旧的生命周期名称和新的别名都可以在此版本中使用。）<br>未来</li><li>16.x 版本：为 <code>componentWillMount``、componentWillReceiveProps</code> 和 <code>componentWillUpdate</code> 启用废弃告警。（旧的生命周期名称和新的别名都将在这个版本中工作，但是旧的名称在开发模式下会产生一个警告。）</li><li>17.0：删除 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 和 <code>componentWillUpdate</code>。（在此版本之后，只有新的 “UNSAFE_” 生命周期名称可以使用。）</li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意，如果你是 React 应用程序开发人员，则无需对这些过时的方法执行任何操作。即将发布的 16.3 版本的主要目的是使开源项目维护人员能够在任何废弃警告之前更新他们的库。在未来的 16.x 版本发布之前，不会启用这些警告。</p></div><h2 id="迁移过时的生命周期"><a href="#迁移过时的生命周期" class="headerlink" title="迁移过时的生命周期"></a>迁移过时的生命周期</h2><p>在开始之前，下面是关于 16.3 版本计划的生命周期变更的快速概述：</p><ul><li>添加以下生命周期别名：<code>UNSAFE_componentWillMount</code>、<code>UNSAFE_componentWillReceiveProps</code> 和 <code>UNSAFE_componentWillUpdate</code>。（将同时支持旧的生命周期名称和新别名。）</li><li>引入两个新的生命周期，静态的 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code>。</li></ul><h2 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Example extends React.Component &#123;  static getDerivedStateFromProps(props, state) &#123;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>新的静态 <code>getDerivedStateFromProps</code> 生命周期方法<code>在组件实例化之后以及重新渲染之前调用</code>。它可以返回一个对象来更新 state，或者<code>返回 null 来表示新的 props 不需要任何 state 的更新</code>。</p><p>与 <code>componentDidUpdate</code> 一起，这个新的生命周期涵盖过时的 <code>componentWillReceiveProps</code> 的所有用例。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：</p><p>旧的 componentWillReceiveProps 和新的 getDerivedStateFromProps 方法都会增加组件的复杂性。这经常会导致 bug。考虑使用 <a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" >派生 state 的简单替代方法</a> 让组件可预测且可维护。</p></div><h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Example extends React.Component &#123;  getSnapshotBeforeUpdate(prevProps, prevState) &#123;    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>新的 <code>getSnapshotBeforeUpdate</code> 生命周期方法<code>在更新之前（如：更新 DOM 之前）被调用</code>。<strong>此生命周期的返回值将作为第三个参数传递给 componentDidUpdate</strong>。（通常不需要，但在重新渲染过程中手动保留滚动位置等情况下非常有用。）</p><p>与 <code>componentDidUpdate</code> 一起，这个新的生命周期涵盖过时的 <code>componentWillUpdate</code> 的所有用例。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="初始化-state"><a href="#初始化-state" class="headerlink" title="初始化 state"></a>初始化 state</h3><p>这个例子显示了组件在 componentWillMount 中调用 setState：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;&#125;;  componentWillMount() &#123;    this.setState(&#123;      currentColor: this.props.defaultColor,      palette: &quot;rgb&quot;,    &#125;);  &#125;&#125;</code></pre><p>对于这种类型的组件，最简单的重构是将 state 的初始化，移到构造函数或属性的初始化器内，</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    currentColor: this.props.defaultColor,    palette: &quot;rgb&quot;,  &#125;;&#125;</code></pre><h3 id="获取外部数据"><a href="#获取外部数据" class="headerlink" title="获取外部数据"></a>获取外部数据</h3><p>以下是使用 componentWillMount 获取外部数据的组件的示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    externalData: null,  &#125;;  componentWillMount() &#123;    this._asyncRequest &#x3D; loadMyAsyncData().then((externalData) &#x3D;&gt; &#123;      this._asyncRequest &#x3D; null;      this.setState(&#123; externalData &#125;);    &#125;);  &#125;  componentWillUnmount() &#123;    if (this._asyncRequest) &#123;      this._asyncRequest.cancel();    &#125;  &#125;  render() &#123;    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;      &#x2F;&#x2F; 渲染加载状态 ...    &#125; else &#123;      &#x2F;&#x2F; 渲染真实 UI ...    &#125;  &#125;&#125;</code></pre><p>上述代码对于服务器渲染（不使用外部数据）和即将推出的异步渲染模式（可能多次启动请求）都存在问题。</p><p>大多数用例推荐的升级方式是将数据获取移到 componentDidMount：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    externalData: null,  &#125;;  componentDidMount() &#123;    this._asyncRequest &#x3D; loadMyAsyncData().then((externalData) &#x3D;&gt; &#123;      this._asyncRequest &#x3D; null;      this.setState(&#123; externalData &#125;);    &#125;);  &#125;  componentWillUnmount() &#123;    if (this._asyncRequest) &#123;      this._asyncRequest.cancel();    &#125;  &#125;  render() &#123;    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;      &#x2F;&#x2F; 渲染加载状态 ...    &#125; else &#123;      &#x2F;&#x2F; 渲染真实 UI ...    &#125;  &#125;&#125;</code></pre><h3 id="误解-1"><a href="#误解-1" class="headerlink" title="误解 1"></a>误解 1</h3><p>有一个常见的误解是，在 <code>componentWillMount</code> 中获取数据可以避免第一次渲染为空的状态。实际上，这是不对的，因为 React 总是在 <code>componentWillMount</code> 之后立即执行 <code>render</code>。如果在 <code>componentWillMount</code> 触发时数据不可用，那么第一次 <code>render</code> 仍然会显示加载的状态，而不管你在哪里初始化获取数据。这就是为什么在绝大多数情况下，将获取数据移到 <code>componentDidMount</code> 没有明显效果的原因。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意</p><p>一些高级用例（如：<code>Relay</code> 库）可能尝试提前获取异步数据。这里提供了一个如何实现的示例。</p><p>从长远来看，在 React 组件中获取数据的标准方法应该基于 “<code>suspense</code>” API 在冰岛 JSConf 提出。无论是简单的数据获取解决方案，还是像 <code>Apollo</code> 和 <code>Relay</code> 这样的库，都可以在内部使用它。它比上面的任何一个解决方案都要简洁，但是不会在 16.3 版本发布之前完成。</p><p>当支持服务器渲染时，需要同步获取数据——<code>componentWillMount</code> 经常用于此目的，也可以用构造函数替代。即将推出的 suspense API 将使异步数据获取对于客户端和服务器渲染都是完全有可能的。</p></div><h3 id="添加事件监听器（或订阅）"><a href="#添加事件监听器（或订阅）" class="headerlink" title="添加事件监听器（或订阅）"></a>添加事件监听器（或订阅）</h3><p>下面是一个示例，在组件挂载时订阅了外部事件：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  componentWillMount() &#123;    this.setState(&#123;      subscribedValue: this.props.dataSource.value,    &#125;);    &#x2F;&#x2F; 这是不安全的，它会导致内存泄漏！    this.props.dataSource.subscribe(this.handleSubscriptionChange);  &#125;  componentWillUnmount() &#123;    this.props.dataSource.unsubscribe(this.handleSubscriptionChange);  &#125;  handleSubscriptionChange &#x3D; (dataSource) &#x3D;&gt; &#123;    this.setState(&#123;      subscribedValue: dataSource.value,    &#125;);  &#125;;&#125;</code></pre><p>遗憾的是，这可能导致服务器渲染（永远不会调用 <code>componentWillUnmount</code>）和异步渲染（在渲染完成之前可能被中断，导致不调用 <code>componentWillUnmount</code>）的<code>内存泄漏</code>。</p><h3 id="误解-2"><a href="#误解-2" class="headerlink" title="误解 2"></a>误解 2</h3><p>人们通常认为 <code>componentWillMount</code> 和 <code>componentWillUnmount</code> 是成对出现的，但这并不能保证。只有调用了 <code>componentDidMount</code> 之后，React 才能保证稍后调用 <code>componentWillUnmount</code> 进行清理。</p><p>因此，添加监听器&#x2F;订阅的推荐方法是使用 <code>componentDidMount</code> 生命周期：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    subscribedValue: this.props.dataSource.value,  &#125;;  componentDidMount() &#123;    &#x2F;&#x2F; 事件监听器只有在挂载后添加才是安全的，    &#x2F;&#x2F; 因此，如果挂载中断或错误，它们不会泄漏。    this.props.dataSource.subscribe(this.handleSubscriptionChange);    &#x2F;&#x2F; 外部值可能在渲染和挂载期间改变，    &#x2F;&#x2F; 在某些情况下，处理这种情况很重要。    if (this.state.subscribedValue !&#x3D;&#x3D; this.props.dataSource.value) &#123;      this.setState(&#123;        subscribedValue: this.props.dataSource.value,      &#125;);    &#125;  &#125;  componentWillUnmount() &#123;    this.props.dataSource.unsubscribe(this.handleSubscriptionChange);  &#125;  handleSubscriptionChange &#x3D; (dataSource) &#x3D;&gt; &#123;    this.setState(&#123;      subscribedValue: dataSource.value,    &#125;);  &#125;;&#125;</code></pre><p>有时，更新订阅来响应属性变更非常重要。如果你正在使用像 <code>Redux</code> 或 <code>MobX</code> 这样的库，<code>库的容器组件应该为你处理了这个问题</code>。对于应用程序作者，我们创建了一个小型库，<code>create-subscription</code>，来帮助解决这个问题。我们将它与 React 16.3 一起发布。</p><p>我们可以使用 <code>create-subscription</code> 来传递订阅的值，而不是像上面示例那样传递一个可订阅的 dataSource prop：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createSubscription &#125; from &quot;create-subscription&quot;;const Subscription &#x3D; createSubscription(&#123;  getCurrentValue(sourceProp) &#123;    &#x2F;&#x2F; 返回订阅的当前值（sourceProp）。    return sourceProp.value;  &#125;,  subscribe(sourceProp, callback) &#123;    function handleSubscriptionChange() &#123;      callback(sourceProp.value);    &#125;    &#x2F;&#x2F; 订阅（例如：向订阅（sourceProp）添加事件监听器。    &#x2F;&#x2F; 每当订阅发生变化时，调用回调函数（新值）。    sourceProp.subscribe(handleSubscriptionChange);    &#x2F;&#x2F; 返回取消订阅方法。    return function unsubscribe() &#123;      sourceProp.unsubscribe(handleSubscriptionChange);    &#125;;  &#125;,&#125;);&#x2F;&#x2F; 我们可以直接传递订阅的值，&#x2F;&#x2F; 而不是将可订阅的源传递给我们的 ExampleComponent：&lt;Subscription source&#x3D;&#123;dataSource&#125;&gt;  &#123;(value) &#x3D;&gt; &lt;ExampleComponent subscribedValue&#x3D;&#123;value&#125; &#x2F;&gt;&#125;&lt;&#x2F;Subscription&gt;;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：</p><p>像 <code>Relay/Apollo</code> 这样的库，内部应该使用了与 <code>create-subscription</code> 相同的技术，用最适合他们库使用的方式手动管理订阅（参考这里）。</p></div><h3 id="基于-props-更新-state"><a href="#基于-props-更新-state" class="headerlink" title="基于 props 更新 state"></a>基于 props 更新 state</h3><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：</p><p>旧的 <code>componentWillReceiveProps</code> 和新的 <code>getDerivedStateFromProps</code> 方法都会给组件增加明显的复杂性。这通常会导致 <code>bug</code>。考虑 派生 state 的简单替代方法 使组件可预测且可维护。</div><p>这是一个示例，组件使用过时的 <code>componentWillReceiveProps</code> 生命周期基于新的 <code>props</code> 更新 <code>state</code>：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    isScrollingDown: false,  &#125;;  componentWillReceiveProps(nextProps) &#123;    if (this.props.currentRow !&#x3D;&#x3D; nextProps.currentRow) &#123;      this.setState(&#123;        isScrollingDown: nextProps.currentRow &gt; this.props.currentRow,      &#125;);    &#125;  &#125;&#125;</code></pre><p>尽管上面的代码本身没有问题，但是 <code>componentWillReceiveProps</code> 生命周期经常被误用，会产生问题。因此，该方法将被废弃。</p><p>从 16.3 版本开始，当 <code>props</code> 变化时，建议使用新的 <code>static getDerivedStateFromProps</code> 生命周期更新 <code>state</code>。创建组件以及每次组件由于 <code>props</code> 或 <code>state</code> 的改变而重新渲染时都会调用该生命周期：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  &#x2F;&#x2F; 在构造函数中初始化 state，  &#x2F;&#x2F; 或者使用属性初始化器。  state &#x3D; &#123;    isScrollingDown: false,    lastRow: null,  &#125;;  static getDerivedStateFromProps(props, state) &#123;    if (props.currentRow !&#x3D;&#x3D; state.lastRow) &#123;      return &#123;        isScrollingDown: props.currentRow &gt; state.lastRow,        lastRow: props.currentRow,      &#125;;    &#125;    &#x2F;&#x2F; 返回 null 表示无需更新 state。    return null;  &#125;&#125;</code></pre><p>在上面的示例中，你可能会注意到 <code>props.currentRow</code> 在 state 中的镜像（<code>state.lastRow</code>）。这使得 <code>getDerivedStateFromProps</code> 能够像在 <code>componentWillReceiveProps</code> 中相同的方式访问上一个 <code>props</code> 的值。</p><p>你可能想知道为什么我们不将上一个 <code>props</code> 作为参数传递给 <code>getDerivedStateFromProps</code>。我们在设计 API 时考虑过这个方案，但最终决定不采用它，原因有两个：</p><ul><li><p><code>prevProps</code> 参数在第一次调用 <code>getDerivedStateFromProps</code>（实例化之后）时为 <code>null</code>，需要在每次访问 <code>prevProps</code> 时添加 <code>if-not-null</code> 检查。</p></li><li><p>在 <code>React</code> 的未来版本中，不传递上一个 <code>props</code> 给这个方法是为了释放内存。（如果 <code>React</code> 无需传递上一个 <code>props</code> 给生命周期，那么它就无需保存上一个 <code>props</code> 对象在内存中。）</p></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>注意</p><p>如果你正在编写共享组件，<code>react-lifecycles-compat</code> polyfill 可以在旧版本的 React 里面使用新的 <code>getDerivedStateFromProps</code> 生命周期。在下面了解更多如何使用。</p></p></div><h3 id="调用外部回调"><a href="#调用外部回调" class="headerlink" title="调用外部回调"></a>调用外部回调</h3><p>调用外部回调<br>下面是一个组件的示例，它在内部 state 发生变化时调用了外部函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  componentWillUpdate(nextProps, nextState) &#123;    if (this.state.someStatefulValue !&#x3D;&#x3D; nextState.someStatefulValue) &#123;      nextProps.onChange(nextState.someStatefulValue);    &#125;  &#125;&#125;</code></pre><h3 id="误解-3"><a href="#误解-3" class="headerlink" title="误解 3"></a>误解 3</h3><p>有时人们使用 <code>componentWillUpdate</code> 是出于一种错误的担心，即当 <code>componentDidUpdate</code> 触发时，更新其他组件的 <code>state</code> 已经”太晚”了。事实并非如此。React 可确保在用户看到更新的 UI 之前，刷新在 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 期间发生的任何 <code>setState</code> 调用。通常，最好避免这样的级联更新，<em>但在某些情况下，这些更新是必需的（例如：如果你需要在测量渲染的 DOM 元素后，定位工具的提示）。</em></p><p>不管怎样，在异步模式下使用 <code>componentWillUpdate</code> 都是不安全的，因为<code>外部回调可能会在一次更新中被多次调用</code>。相反，应该使用 <code>componentDidUpdate</code> 生命周期，因为它保证每次更新只调用一次：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  componentDidUpdate(prevProps, prevState) &#123;    if (this.state.someStatefulValue !&#x3D;&#x3D; prevState.someStatefulValue) &#123;      this.props.onChange(this.state.someStatefulValue);    &#125;  &#125;&#125;</code></pre><h3 id="props-更新的副作用"><a href="#props-更新的副作用" class="headerlink" title="props 更新的副作用"></a>props 更新的副作用</h3><p>类似于上面的例子，有时候组件在 <code>props</code> 发生变化时会产生副作用。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  componentWillReceiveProps(nextProps) &#123;    if (this.props.isVisible !&#x3D;&#x3D; nextProps.isVisible) &#123;      logVisibleChange(nextProps.isVisible);    &#125;  &#125;&#125;</code></pre><p>与 <code>componentWillUpdate</code> 类似，<code>componentWillReceiveProps</code> 可能在一次更新中被多次调用。<strong>因此，避免在此方法中产生副作用非常重要</strong>。相反，应该使用 <code>componentDidUpdate</code>，因为它保证每次更新只调用一次：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  componentDidUpdate(prevProps, prevState) &#123;    if (this.props.isVisible !&#x3D;&#x3D; prevProps.isVisible) &#123;      logVisibleChange(this.props.isVisible);    &#125;  &#125;&#125;</code></pre><h3 id="props-更新时获取外部数据"><a href="#props-更新时获取外部数据" class="headerlink" title="props 更新时获取外部数据"></a>props 更新时获取外部数据</h3><p>下面是一个组件的示例，它根据 props 的值获取外部数据：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Beforeclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    externalData: null,  &#125;;  componentDidMount() &#123;    this._loadAsyncData(this.props.id);  &#125;  componentWillReceiveProps(nextProps) &#123;    if (nextProps.id !&#x3D;&#x3D; this.props.id) &#123;      this.setState(&#123; externalData: null &#125;);      this._loadAsyncData(nextProps.id);    &#125;  &#125;  componentWillUnmount() &#123;    if (this._asyncRequest) &#123;      this._asyncRequest.cancel();    &#125;  &#125;  render() &#123;    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;      &#x2F;&#x2F; 渲染加载状态 ...    &#125; else &#123;      &#x2F;&#x2F; 渲染真实 UI ...    &#125;  &#125;  _loadAsyncData(id) &#123;    this._asyncRequest &#x3D; loadMyAsyncData(id).then((externalData) &#x3D;&gt; &#123;      this._asyncRequest &#x3D; null;      this.setState(&#123; externalData &#125;);    &#125;);  &#125;&#125;</code></pre><p>此组件的推荐升级路径是将数据更新移动到 <code>componentDidUpdate</code>。你还可以使用新的 <code>getDerivedStateFromProps</code> 生命周期，在渲染新的 props 之前清除旧数据：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Afterclass ExampleComponent extends React.Component &#123;  state &#x3D; &#123;    externalData: null,  &#125;;  static getDerivedStateFromProps(props, state) &#123;    &#x2F;&#x2F; 保存 prevId 在 state 中，以便我们在 props 变化时进行对比。    &#x2F;&#x2F; 清除之前加载的数据（这样我们就不会渲染旧的内容）。    if (props.id !&#x3D;&#x3D; state.prevId) &#123;      return &#123;        externalData: null,        prevId: props.id,      &#125;;    &#125;    &#x2F;&#x2F; 无需更新 state    return null;  &#125;  componentDidMount() &#123;    this._loadAsyncData(this.props.id);  &#125;  componentDidUpdate(prevProps, prevState) &#123;    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;      this._loadAsyncData(this.props.id);    &#125;  &#125;  componentWillUnmount() &#123;    if (this._asyncRequest) &#123;      this._asyncRequest.cancel();    &#125;  &#125;  render() &#123;    if (this.state.externalData &#x3D;&#x3D;&#x3D; null) &#123;      &#x2F;&#x2F; 渲染加载状态 ...    &#125; else &#123;      &#x2F;&#x2F; 渲染真实 UI ...    &#125;  &#125;  _loadAsyncData(id) &#123;    this._asyncRequest &#x3D; loadMyAsyncData(id).then((externalData) &#x3D;&gt; &#123;      this._asyncRequest &#x3D; null;      this.setState(&#123; externalData &#125;);    &#125;);  &#125;&#125;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意</p><p>如果你正在使用支持取消的 HTTP 库，例如 axios 那么在卸载时取消正在进行的请求非常简单。对于原生的 Promise，<a href="https://gist.github.com/bvaughn/982ab689a41097237f6e9860db7ca8d6" target="_blank" >你可以使用类似此处所示的方法</a>。</p></div><h3 id="更新前读取-DOM-属性"><a href="#更新前读取-DOM-属性" class="headerlink" title="更新前读取 DOM 属性"></a>更新前读取 DOM 属性</h3><p>下面是一个组件的示例，该组件在更新之前从 DOM 中读取属性，以便在列表中保持滚动的位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class ScrollingList extends React.Component &#123;  listRef &#x3D; null;  previousScrollOffset &#x3D; null;  componentWillUpdate(nextProps, nextState) &#123;    &#x2F;&#x2F; 我们正在向列表中添加新项吗？    &#x2F;&#x2F; 捕获滚动位置，以便我们稍后可以调整滚动位置。    if (this.props.list.length &lt; nextProps.list.length) &#123;      this.previousScrollOffset &#x3D;        this.listRef.scrollHeight - this.listRef.scrollTop;    &#125;  &#125;  componentDidUpdate(prevProps, prevState) &#123;    &#x2F;&#x2F; 如果我们刚刚添加了新项，并且设置了 previousScrollOffset。    &#x2F;&#x2F; 调整滚动位置，以便这些新项不会把旧项挤出视图。    if (this.previousScrollOffset !&#x3D;&#x3D; null) &#123;      this.listRef.scrollTop &#x3D;        this.listRef.scrollHeight - this.previousScrollOffset;      this.previousScrollOffset &#x3D; null;    &#125;  &#125;  render() &#123;    return &lt;div ref&#x3D;&#123;this.setListRef&#125;&gt;&#123;&#x2F;* ...内容... *&#x2F;&#125;&lt;&#x2F;div&gt;;  &#125;  setListRef &#x3D; (ref) &#x3D;&gt; &#123;    this.listRef &#x3D; ref;  &#125;;&#125;</code></pre><p>在上面的示例中，<code>componentWillUpdate</code> 用于读取 DOM 属性。但是，对于异步渲染，“渲染”阶段的生命周期（如 <code>componentWillUpdate</code> 和 <code>render</code>）和”提交”阶段的生命周期（如 <code>componentDidUpdate</code>）之间可能存在延迟。如果用户在这段时间内调整窗口大小，那么从 <code>componentWillUpdate</code> 读取的 <code>scrollHeight</code> 值将过时。</p><p>这个问题的解决方案是使用新的“提交”阶段生命周期 <code>getSnapshotBeforeUpdate</code>。这个方法在发生变化 <em>前立即</em> 被调用（例如在更新 DOM 之前）。它可以返回一个 React 的值作为参数传递给 <code>componentDidUpdate</code> 方法，该方法在发生变化 <em>后立即</em> 被调用。</p><p>这两个生命周期可以像这样一起使用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class ScrollingList extends React.Component &#123;  listRef &#x3D; null;  getSnapshotBeforeUpdate(prevProps, prevState) &#123;    &#x2F;&#x2F; 我们正在向列表中添加新项吗？    &#x2F;&#x2F; 捕获滚动位置，以便我们稍后可以调整滚动位置。    if (prevProps.list.length &lt; this.props.list.length) &#123;      return this.listRef.scrollHeight - this.listRef.scrollTop;    &#125;    return null;  &#125;  componentDidUpdate(prevProps, prevState, snapshot) &#123;    &#x2F;&#x2F; 如果我们刚刚添加了新项，并且有了快照值。    &#x2F;&#x2F; 调整滚动位置，以便这些新项不会把旧项挤出视图。    &#x2F;&#x2F; （此处的快照是从 getSnapshotBeforeUpdate 返回的值）    if (snapshot !&#x3D;&#x3D; null) &#123;      this.listRef.scrollTop &#x3D; this.listRef.scrollHeight - snapshot;    &#125;  &#125;  render() &#123;    return &lt;div ref&#x3D;&#123;this.setListRef&#125;&gt;&#123;&#x2F;* ...内容... *&#x2F;&#125;&lt;&#x2F;div&gt;;  &#125;  setListRef &#x3D; (ref) &#x3D;&gt; &#123;    this.listRef &#x3D; ref;  &#125;;&#125;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意</p><p>如果你正在编写共享组件，那么 react-lifecycles-compat polyfill 可以使新的 getSnapshotBeforeUpdate 生命周期与旧版本的 React 一起使用。在下面了解更多如何使用。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>误解、滥用、异步中老 API 多次调用</p><ul><li><p>误解 <code>componentWillMount</code> 中初始化 state</p><br/><br/></li><li><p>误解 <code>componentWillMount</code> 中获取数据，在 <code>componentWillMount</code> 之后立即执行 <code>render</code>。如果在 <code>componentWillMount</code> 触发时数据不可用，那么第一次 <code>render</code> 仍然会显示加载的状态，而不管你在哪里初始化获取数据</p><br/><br/></li><li><p>误解 <code>componentWillMount</code> 中订阅，在服务端不会调用<code>componentWillUnMount</code>,导致内存泄漏,</p><br/><br/></li><li><p>使用 <code>componentWillUpdate</code> 是出于一种错误的担心，即当 <code>componentDidUpdate</code> 触发时，更新其他组件的 <code>state</code> 已经”太晚”了。事实并非如此。React 可确保在用户看到更新的 UI 之前，刷新在 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 期间发生的任何 <code>setState</code> 调用。通常，最好避免这样的级联更新，<em>但在某些情况下，这些更新是必需的（例如：如果你需要在测量渲染的 DOM 元素后，定位工具的提示）。</em> <strong>异步中，多次调用</strong></p><br/><br/></li><li><p><code>componentWillReceiveProps</code> 可能在一次更新中被多次调用。<strong>因此，避免在此方法中产生副作用非常重要</strong></p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" >异步渲染之更新</a></p>]]></content>
      
      
      <categories>
          
          <category> react_1650 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react_1650 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React@16.5.0 createElement</title>
      <link href="//post/2022-07-21react-createElement.html"/>
      <url>//post/2022-07-21react-createElement.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目开发时候书写代码"><a href="#项目开发时候书写代码" class="headerlink" title="项目开发时候书写代码"></a>项目开发时候书写代码</h2><p><strong>某个页面或者是组件</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;  class ReactComponent extends React.Component &#123;&#x2F;&#x2F;      render() &#123;&#x2F;&#x2F;          return &lt;p className&#x3D;&quot;class&quot;&gt;Hello React&lt;&#x2F;p&gt;;&#x2F;&#x2F;      &#125;&#x2F;&#x2F;  &#125;&#x2F;&#x2F;  以上代码会编译为：class ReactComponent extends React.Component &#123;  render() &#123;    React.createElement(&quot;p&quot;, &#123; className: &quot;class&quot; &#125;, &quot;Hello React&quot;); &#x2F;&#x2F; 之前看到蜜壳代码是这个样子，我还以为是研发手写的呢  &#125;&#125;&#x2F;&#x2F;  &lt;ReactComponent someProp&#x3D;&quot;prop&quot; &#x2F;&gt;React.createElement(ReactComponent, &#123; someProp: &quot;prop&quot; &#125;, null);</code></pre><p>以上代码 api 在<code>packages/react/src/React.js</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const React &#x3D; &#123;  createElement: createElement, &#x2F;&#x2F; packages&#x2F;react&#x2F;src&#x2F;ReactElement.js  createElement -&gt; ReactElement  version: ReactVersion,&#125;;export default React;</code></pre><h2 id="React-是如何将虚拟-DOM-转换为真实-DOM"><a href="#React-是如何将虚拟-DOM-转换为真实-DOM" class="headerlink" title="React 是如何将虚拟 DOM 转换为真实 DOM"></a>React 是如何将虚拟 DOM 转换为真实 DOM</h2><ol><li>首先我们要通过 <code>React.createElement</code> 函数来将我们定义好的组件进行转换为 React 元素</li><li>将创建好的 <code>React</code> 元素通过调用 <code>ReactDom.render</code> 来进行渲染</li><li><code>ReactDom.render</code> 调用后先创建根对象 <code>root</code>，然后调用 <code>root.render</code></li><li>然后经过若干函数调用，来到 <code>workLoop</code> 函数，它将遍历虚拟 DOM 树，将下一个需要处理的虚拟 DOM 传给 <code>performUnitOfWork</code>，<code>performUnitOfWork</code> 再将虚拟 DOM 传给 <code>beginWork</code> 后，<code>beginWork</code>根据虚拟 DOM 的类型不同进行相应处理，并对子节点进行处理为 <code>Fiber</code> 类型，为 <code>Fiber</code> 类型虚拟 DOM , 添加父节点、兄弟节点等细节，以方便遍历树。</li><li><code>beginWork</code> 处理完后返回需要处理的子元素再继续处理，直到没有子元素（即返回 null），此时 <code>performUnitOfWork</code> 调用 <code>completeUnitOfWork</code> 处理这颗<code>虚拟 DOM 子树</code>，将其转<code>换为真实 DOM</code>。</li><li>最后所有的<code>虚拟 DOM</code> 都将转为<code>真实 DOM</code>。</li></ol><h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">root.render(children, callback) -&gt;DOMRenderer.updateContainer(children, root, null, work._onCommit) -&gt;updateContainerAtExpirationTime(    element,    container,    parentComponent,    expirationTime,    callback,) -&gt;scheduleRootUpdate(current, element, expirationTime, callback) -&gt;scheduleWork(current, expirationTime) -&gt;requestWork(root, rootExpirationTime) -&gt;performWorkOnRoot(root, Sync, false) -&gt;renderRoot(root, false) -&gt;workLoop(isYieldy) -&gt;performUnitOfWork(nextUnitOfWork: Fiber) &#x3D;&gt; Fiber | null -&gt;beginWork(current, workInProgress, nextRenderExpirationTime)</code></pre><p><strong>使用 ReactDom 渲染到 页面上</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ReactDom.render(React.createElement(App), document.getElementById(&quot;root&quot;));</code></pre><h2 id="我艹，有点懵～"><a href="#我艹，有点懵～" class="headerlink" title="我艹，有点懵～"></a>我艹，有点懵～</h2><p>待补，先写个其他的压压惊</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_34221276/article/details/88770678" target="_blank" >React 源码阅读：虚拟 DOM 的初始化</a></p><p><a href="https://www.cnblogs.com/JhoneLee/p/9481321.html" target="_blank" >React 16 源码瞎几把解读 【一】 从jsx到一个react 虚拟dom对象</a></p><p><a href="https://www.cnblogs.com/JhoneLee/p/9482911.html" target="_blank" >React 16 源码瞎几把解读 【二】 react组件的解析过程</a></p><p><a href="https://www.cnblogs.com/JhoneLee/p/9481618.html" target="_blank" >React 16 源码瞎几把解读 【三 点 一】 把react组件对象弄到dom中去(矛头指向fiber，fiber不解读这个过程也不知道) </a></p><p><a href="https://www.cnblogs.com/JhoneLee/p/9493776.html" target="_blank" >React 16 源码瞎几把解读 【三 点 二】 react中的fiberRoot</a></p>]]></content>
      
      
      <categories>
          
          <category> react_1650 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react_1650 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React@16.5.0 syntheticEvent</title>
      <link href="//post/2022-07-20react-syntheticEvent.html"/>
      <url>//post/2022-07-20react-syntheticEvent.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文说明"><a href="#本文说明" class="headerlink" title="本文说明"></a>本文说明</h2><p>本文主要内容是 <a href="https://github.com/facebook/react/tree/v16.5.0" target="_blank" >React v16.5.0</a>, 部分内容会涉及到 React v17+, React v17+合成事件与 React16 有很大差异</p><h2 id="React-和事件系统概述"><a href="#React-和事件系统概述" class="headerlink" title="React 和事件系统概述"></a>React 和事件系统概述</h2><p><a href="https://github.com/facebook/react/blob/71c0e05ba79e2e12556980ffbab264b41fdc19cd/packages/react-dom/src/events/ReactBrowserEventEmitter.js#L52" target="_blank" >见</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * * +------------+    . * |    DOM     |    . * +------------+    . *       |           . *       v           . * +------------+    . * | ReactEvent |    . * |  Listener  |    . * +------------+    .                         +-----------+ *       |           .               +--------+|SimpleEvent| *       |           .               |         |Plugin     | * +-----|------+    .               v         +-----------+ * |     |      |    .    +--------------+                    +------------+ * |     +-----------.---&gt;|EventPluginHub|                    |    Event   | * |            |    .    |              |     +-----------+  | Propagators| * | ReactEvent |    .    |              |     |TapEvent   |  |------------| * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin| * |            |    .    |              |     +-----------+  |  utilities | * |     +-----------.---&gt;|              |                    +------------+ * |     |      |    .    +--------------+ * +-----|------+    .                ^        +-----------+ *       |           .                |        |Enter&#x2F;Leave| *       +           .                +-------+|Plugin     | * +-------------+   .                         +-----------+ * | application |   . * |-------------|   . * |             |   . * |             |   . * +-------------+   . *                   . *    React Core     .  General Purpose Event Plugin System *&#x2F;</code></pre><h2 id="为什么-React-需要自己实现一套事件系统？"><a href="#为什么-React-需要自己实现一套事件系统？" class="headerlink" title="为什么 React 需要自己实现一套事件系统？"></a>为什么 React 需要自己实现一套事件系统？</h2><img src="http://t-blog-images.aijs.top/img/20220720095157.webp" style="max-width: 100%; width: 600px" /><p>这个问题主要是为了<code>性能</code>和<code>复用</code>两个方面来考虑。</p><h3 id="首先对于性能来说"><a href="#首先对于性能来说" class="headerlink" title="首先对于性能来说"></a>首先对于<code>性能</code>来说</h3><p>React 作为一套 View 层面的框架，通过渲染得到 vDOM，再由 diff 算法决定 DOM 树那些结点需要新增、替换或修改，假如直接在 DOM 结点插入原生事件监听，则会导致频繁的调用 addEventListener 和 removeEventListener，造成性能的浪费。所以 React 采用了事件代理的方法，对于大部分事件 1 而言都在 document 上做监听，然后<code>根据Event中的target来判断事件触发的结点</code>。</p><p>其次 React 合成的 SyntheticEvent 采用了<code>池的思想</code>，从而达到节约内存，避免频繁的创建和销毁事件对象的目的。这也是<code>“如果我们需要异步使用一个 syntheticEvent，需要执行 event.persist()才能防止事件对象被释放”</code>的原因。</p><p>最后在 React 源码中随处可见 <code>batch 做批量更新</code>，基本上凡是可以批量处理的事情（最普遍的 setState）React 都会将中间过程保存起来，留到最后面 flush（渲染，并最终提交到 DOM 树上）掉。就如<code>浏览器对 DOM 树进行 Style，Layout，Paint 一样，都不会在操作 ele.style.color=&#39;red&#39;;之后马上执行，只会将这些操作打包起来并最终在需要渲染的时候再做渲染,</code>。<a href="/#/post/2022-07-17css" target="_blank" >队列机制来批量更新布局 (1000ms&#x2F;60 &#x3D; 16.6ms 进行一次渲染)</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ele.style.color &#x3D; &quot;red&quot;;ele.style.color &#x3D; &quot;blue&quot;;ele.style.color &#x3D; &quot;red&quot;;&#x2F;&#x2F; 浏览器只会渲染一次;</code></pre><h3 id="而对于复用来说"><a href="#而对于复用来说" class="headerlink" title="而对于复用来说"></a>而对于复用来说</h3><p>React 看到在不同的浏览器和平台上，用户界面上的事件其实非常相似，例如普通的 click，change 等等。React 希望通过封装一层事件系统，将不同平台的原生事件都封装成 <code>SyntheticEvent</code>。</p><ul><li><p>使得<code>不同平台只需要通过加入EventEmitter以及对应的Renderer就能使用相同的一个事件系统</code>，WEB 平台上加入 <code>ReactBrowserEventEmitter</code>，Native 上加入 <code>ReactNativeEventEmitter</code>。如下图，对于不同平台，React 只需要替换掉左边部分，而右边 EventPluginHub 部分可以保持复用。</p></li><li><p>而<code>对于不同的浏览器而言，React帮我们统一了事件，做了浏览器的兼容</code>，例如对于 transitionEnd,webkitTransitionEnd,MozTransitionEnd 和 oTransitionEnd, React 都会集合成 topAnimationEnd，所以我们只用处理这一个标准的事件即可。</p></li></ul><img src="http://t-blog-images.aijs.top/img/20220720100225.webp" /><h2 id="React-的事件系统是怎么运作起来的？"><a href="#React-的事件系统是怎么运作起来的？" class="headerlink" title="React 的事件系统是怎么运作起来的？"></a>React 的事件系统是怎么运作起来的？</h2><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>我们来看一下我们在 JSX 中写的 onClickhandler 是怎么被记录到 DOM 结点上，并且在 document 上做监听的。</p><img src="http://t-blog-images.aijs.top/img/20220720100423.webp" /><p>React 对于大部分事件的绑定都是使用<code>trapBubbledEvent</code>和<code>trapCapturedEvent</code>这两个函数来注册的。如上图所示，当我们执行了 render 或者 setState 之后，React 的 <code>Fiber</code> 调度系统，<span style="text-decoration: underline">会在最后 commit 到 DOM 树之前, 执行<code>trapBubbledEvent</code>或<code>trapCapturedEvent</code>，在<code>document</code>节点上绑定回调</span>（通过执行<code>addEventListener</code>在 document 结点上绑定对应的<code>dispatch</code>函数,作为回调负责监听类型为<code>topLevelType</code>的事件）。</p><p>这里面的 <code>dispatchInteractiveEvent</code> 和 <code>dispatchEvent</code> 两个回调函数的区别为，React16 开始换掉了原本 <code>Stack Reconciliation</code> 成 <code>Fiber</code> 希望实现异步渲染（React16 仍未默认打开，仍需使用 <code>unstable_</code>开头的 api，此特性与例子 2 有关，将在文章最后配图解释），所以异步渲染的情况下假如我点了两次按钮，那么第二次按钮响应的时候，可能第一次按钮的 handlerA 中调用的 <code>setState</code> 还未最终被 commit 到 DOM 树上，这时需要把第一次按钮的结果先给 flush 掉并 commit 到 DOM 树，才能够保持一致性。这个时候就会用到 <code>dispatchInteractiveEvent</code>。可以理解成 <code>dispatchInteractiveEvent</code> 在执行前都会确保之前所有操作都已最总 commit 到 DOM 树，再开始自己的流程，并最终触发 dispatchEvent。但由于 React16 仍是同步渲染的，所以这两个函数在目前的表现是一致的，React17 默认打开的异步渲染功能。</p><p>到现在我们已经在 document 结点上监听了事件了，现在需要来看如何将我们在 jsx 中写的 handler 存起来对应到相应的结点上。</p><p>在我们每次新建或者更新结点时，React 会调用 <code>createInstance</code> 或者 <code>commitUpdate</code> 这两个函数，而这两个函数都会最终调用 <code>updateFiberProps</code> 这个函数，将 props 也就是我们的 onClick，onChange 等 handler 给存到 DOM 结点上。</p><p>至此，我们我们已经在 document 上监听了事件，并且将 handler 存在对应 DOM 结点。接下来需要看 React 怎么监听并处理浏览器的原生事件，最终触发对应的 handler 了。</p><h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><p>动画见原文 <a href="https://www.lzane.com/tech/react-event-system-and-source-code/#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91" target="_blank" >Hype 动画</a></p><p>动画应该是使用 <a href="https://www.hypeapp.cn/" target="_blank" >Hype 工具</a> 制作的</p><p>以简单的 <code>click</code> 事件为例，通过事件绑定我们已经在 <code>document</code> 上监听了 <code>click</code> 事件，当我们真正点击了这个按钮的时候，原生的事件是如何进入 React 的管辖范围的？如何合成 <code>SyntheticEvent</code> 以及如何模拟捕获和冒泡的？以及最后我们在 jsx 中写的 <code>onClickhandler</code> 是如何被最终触发的？带着这些问题，我们一起来看一下事件触发阶段。</p><p>大概用下图这种方式来解析代码，左边是我点击一个绑定了 <code>handleClick</code> 的按钮后的 js 调用栈，右边是每一步的代码，均已删除部分不影响理解的代码。希望通过这种方式能使大家更易理解 React 的事件触发机制。</p><img src="http://t-blog-images.aijs.top/img/20220720101536.webp" /><p>当我们点击一个按钮是，click 事件将会最终冒泡至 document，并触发我们监听在 document 上的 <code>handler dispatchEvent</code>，接着触发 <code>batchedUpdates</code>。<code>batchedUpdates</code> 这个格式的代码在 React 的源码里面会频繁的出现，基本上 React 将所有能够批量处理的事情都会先收集起来，再一次性处理。</p><p>可以看到默认的 <code>isBatching</code> 是 false 的，当调用了一次 <code>batchedUpdates</code>，<code>isBatching</code> 的值将会变成 true，此时如果在接下来的调用中有执行 <code>batchedUpdates</code> 的话，就会直接执行 <code>handleTopLevel</code>,此时的 <code>setState</code> 等不会被更新到 DOM 上。直到调用栈重新回到第一次调用 <code>batchedUpdates</code> 的时候，才会将所有结果一起 <code>flush</code> 掉（更新到 DOM 上）。</p><img src="http://t-blog-images.aijs.top/img/20220720101657.webp" /><p><strong>调用栈中的 BatchedUpdates$1 是什么？或者浏览器的 renderer 和 Native 的 renderer 是如果挂在到 React 的事件系统上的?</strong></p><p>其实 React 事件系统里面提供了一个函数 <code>setBatchingImplementation</code>，用来动态挂载不同平台的 renderer，这个也体现了 React 事件系统的复用。（如图右边所示，在 <code>DOM Renderer</code> 里面和 <code>Native Renderer</code> 里面分别调用这个函数动态注入相应的实现）</p><p>这里的 <code>interactiveUpdates 交互式更新是用户交互的结果</code> 和 <code>batchedUpdates</code> 的区别在上文已经解释过，这里就不再赘述。</p><img src="http://t-blog-images.aijs.top/img/20220720102322.webp" /><p><code>handleTopLevel</code> 会调用 <code>runExtractedEventsInBatch()</code>，这是 React 事件处理最重要的函数。如上面动画我们看到的，在 EventEmitter 里面做的事，其实主要就是这个函数的两步。</p><ul><li>第一步是根据原生事件合成为合成事件，并且在 vDOM 上模拟捕获冒泡，收集所有需要执行的事件回调构成回调数组。</li><li>第二步是遍历回调数组，触发回调函数。</li></ul><img src="http://t-blog-images.aijs.top/img/20220720102726.webp" /><p>首先调用 <code>extractEvents</code>，传入原生事件 e，React 事件系统根据可能的事件插件合成合成事件 <code>Synthetic e</code>。 这里我们可以看到调用了 <code>EventConstructor.getPooled()</code>，从事件池中去取一个合成事件对象，如果事件池为空，则新创建一个合成事件对象，这体现了 React 为了性能实现了池的思想。</p><img src="http://t-blog-images.aijs.top/img/20220720102846.webp" /><p>然后传入 <code>Propagator</code>，在 vDOM 上模拟捕获和冒泡，并收集所有需要执行的事件回调和对应的结点。<code>traverseTwoPhase</code> 模拟了捕获和冒泡的两个阶段，这里实现很巧妙，简单而言就是<code>正向和反向遍历了一下数组</code>。接着对每一个结点，调用 listenerAtPhase 取出事件绑定时挂载在结点上的回调函数，把它加入回调数组中。</p><img src="http://t-blog-images.aijs.top/img/20220720103038.webp" /><p>接着<code>executeDispatchesAndRelease</code>遍历所有合成事件。这里可以看到当一个事件处理完的时候，React 会调用 <code>event.isPersistent()</code>来查看这个合成事件是否需要被持久化，如果不需要就会释放这个合成事件，这也就是为什么当我们需要异步读取操作一个合成事件的时候，需要执行 <code>event.persist()</code>，不然 React 就是在这里释放掉这个事件。</p><img src="http://t-blog-images.aijs.top/img/20220720103344.webp" /><p>最后<code>executeDispatchesInOrder</code>这里就是回调函数被真正触发的时候了，取出回调数组 <code>event._dispatchListeners</code>，遍历触发回调函数。并通过 <code>event.isPropagationStopped()</code>这一步来模拟停止冒泡。这里我们可以看到，React 在收集回调数组的时候并不会去管我们是否调用了 <code>stopPropagation</code>，而是会在触发的阶段才会去检查是否需要停止冒泡。</p><p>至此，一个事件回调函数就被触发了，里面如果执行了 setState 等就会等到调用栈弹回到最低部的 interactiveUpdate 中的被最终 flush 掉，构造 vDOM，和好，并最终被 commit 到 DOM 上。</p><p>这就是事件触发的整个过程了，可以回去再看一下 <a href="https://www.lzane.com/tech/react-event-system-and-source-code/#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91" target="_blank" >动画</a>，相信你会更加理解这个过程的。</p><h2 id="合成事件与原生事件有怎样的执行顺序？"><a href="#合成事件与原生事件有怎样的执行顺序？" class="headerlink" title="合成事件与原生事件有怎样的执行顺序？"></a>合成事件与原生事件有怎样的执行顺序？</h2><p><strong>原生事件</strong></p><img src="http://t-blog-images.aijs.top/img/20220720105851.webp" style="max-width: 100%; width: 600px" /><p><strong>原生+合成事件</strong></p><ul><li><p>在 V17 版本前，<code>原生事件的执行时机是恒早于合成事件的执行时机的</code>。</p></li><li><p>V17 版本后，<code>合成事件和原生事件的执行顺序与冒泡/捕获模式相关</code>，</p><ul><li><code>捕获模式，合成事件早于原生事件</code>，</li><li><code>冒泡模式，原生事件早于合成事件</code>。</li></ul></li></ul><img src="http://t-blog-images.aijs.top/img/20220720105608.webp" style="max-width: 100%; width: 600px"/><a href="https://www.jianshu.com/p/a68219093f88?u_atoken=96c66af6-4b4a-4701-a859-9a64483aaf89&u_asession=01viVXNjWZraXNpt12w6P6wnowBQUY7pona1ulf4v0L73wrchou90FiDGe5jR2qHfDX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K8qavJ7EhmnVdJXQEmE6OtSPpcarp92QKzyJKyYjREPlmBkFo3NEHBv0PZUm6pbxQU&u_asig=05CjAbRIhQ-YGOcSOjfs7WtQu4QiGw5txoYvhryOA5fFYlLiTzNiJXY_hpLV7WJGud4m5iROx4wQ0h3ZgRAXTxp-H_GUJK2jgttmFqvD-hHIPJWVv2NwOqKBXAP-u08vsfCUr3lwfKUBWx5D2_14AeRY0il1Ll8VBsxPq6mesMKSv9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzbzCM-4012j1JNGnXBVIbaIllXASt-Dgl7eSMGAtA78aWPRPQyB_SKrj-61LB_f61u3h9VXwMyh6PgyDIVSG1W8MY0PcDXuTpF4MGYSjFBSfODK7bhW2M-c7MIitG1svzaDy9TZTqvO1bRJoi-cZx4Wss1heq_Xsfq5Pn8i8a2-MmWspDxyAEEo4kbsryBKb9Q&u_aref=0RPjny1vlRI4nr3ZC63TqSOZUa0%3D#:~:text=%E5%9B%9B%E3%80%81-,React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F,-%E5%9C%A8%20React%20%E4%B8%AD" target="_blank" >React 合成事件与原生事件执行顺序</a><p><a href="https://juejin.cn/post/7005129812981317668#:~:text=%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82-,%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F,-%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%AA" target="_blank" >合成事件和原生事件的执行顺序</a></p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class App extends React.Component &#123;  innerClick &#x3D; (e) &#x3D;&gt; &#123;    console.log(&quot;A: react inner click.&quot;);    &#x2F;&#x2F; e.stopPropagation();  &#125;;  outerClick &#x3D; () &#x3D;&gt; &#123;    console.log(&quot;B: react outer click.&quot;);  &#125;;  componentDidMount() &#123;    document      .getElementById(&quot;outer&quot;)      .addEventListener(&quot;click&quot;, () &#x3D;&gt; console.log(&quot;C: native outer click&quot;));    window.addEventListener(&quot;click&quot;, () &#x3D;&gt;      console.log(&quot;D: native window click&quot;)    );  &#125;  render() &#123;    return (      &lt;div id&#x3D;&quot;outer&quot; onClick&#x3D;&#123;this.outerClick&#125;&gt;        &lt;button id&#x3D;&quot;inner&quot; onClick&#x3D;&#123;this.innerClick&#125;&gt;          BUTTON        &lt;&#x2F;button&gt;      &lt;&#x2F;div&gt;    );  &#125;&#125;</code></pre><p>相信看完这篇文章，如果你已经对 React 事件系统有所理解，这道题应该是不难了。</p><ul><li><p>因为 React 事件监听是挂载在 document 上的，所以原生系统在#outer 上监听的回调 C 会最先被输出；接着原生事件冒泡至 <code>document</code> 进入 React 事件系统，React 事件系统模拟捕获冒泡输出 A 和 B；最后 React 事件系统执行完毕回到浏览器继续冒泡到 window，输出 D。</p></li><li><p>浏览器在#outer 上监听原生事件的回调 C 会最先被执行；接着原生事件冒泡至 document 进入 React 事件系统，输出 A，在 React 事件处理中#inner 调用了 stopPropagation，事件被停止冒泡。</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1. 不阻止合成事件冒泡&#x2F;&#x2F;     C: native outer click&#x2F;&#x2F;     A: react inner click.&#x2F;&#x2F;     B: react outer click.&#x2F;&#x2F;     D: native window click&#x2F;&#x2F; 2. 阻止合成事件冒泡&#x2F;&#x2F;     C: native outer click&#x2F;&#x2F;     A: react inner click.</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>所以，最好不要混用 React 事件系统和原生事件系统，如果混用了，请保证你清楚知道会发生什么。</p></div><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123;      editable: false,    &#125;;  &#125;  handleClick &#x3D; () &#x3D;&gt; &#123;    console.log(&quot;edit button click!!&quot;);    this.setState(&#123; editable: true &#125;);  &#125;;  handleSubmit &#x3D; (e) &#x3D;&gt; &#123;    console.log(&quot;submit event!!&quot;);    e.preventDefault();  &#125;;  render() &#123;    return (      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;        &#123;this.state.editable ? (          &lt;button type&#x3D;&quot;submit&quot;&gt;submit&lt;&#x2F;button&gt;        ) : (          &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;this.handleClick&#125;&gt;            edit          &lt;&#x2F;button&gt;        )&#125;      &lt;&#x2F;form&gt;    );  &#125;&#125;const rootElement &#x3D; document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App &#x2F;&gt;, rootElement);</code></pre><p>首先我们点击 edit 按钮浏览器触发一个 click 事件，冒泡至 document 进入 React 事件系统，React 执行回调调用 setState，此时 React 事件系统对事件的处理执行完毕。由于目前 React 是同步渲染的，所以接着 React 执行 <code>performSyncWork</code> 将该 <code>button 改成 type=&quot;submit&quot;</code>，由于<code>同个位置的结点并且 tag 都为 button</code>，<code>所以 React 复用了这个 button 结点 2</code>，并更新到 DOM 上。此时浏览器对 click 事件执行继续，其发现该结点的 type&#x3D;”submit”，则触发 submit 事件。</p><p><strong>解决的办法就有很多种了</strong>，给 button 加上 key；两个按钮分开写，不要用三元等都可以解决问题。</p><h2 id="e-stopPropagation-如何阻止合成事件冒泡？"><a href="#e-stopPropagation-如何阻止合成事件冒泡？" class="headerlink" title="e.stopPropagation() 如何阻止合成事件冒泡？"></a>e.stopPropagation() 如何阻止合成事件冒泡？</h2><p><code>executeDispatchesInOrder</code>这里就是回调函数被真正触发的时候了，取出回调数组 <code>event._dispatchListeners</code>，遍历触发回调函数。并通过 <code>event.isPropagationStopped()</code>这一步来模拟停止冒泡。这里我们可以看到，React 在收集回调数组的时候并不会去管我们是否调用了 <code>stopPropagation</code>，而是会在触发的阶段才会去检查是否需要停止冒泡。</p><h2 id="同级别的两个按钮，使用三元运算符，会出问题？"><a href="#同级别的两个按钮，使用三元运算符，会出问题？" class="headerlink" title="同级别的两个按钮，使用三元运算符，会出问题？"></a>同级别的两个按钮，使用三元运算符，会出问题？</h2><p>渲染后按钮的事件是否会触发</p><p><strong>React16 例子 2 一定触发 <code>submit</code>, 原因：同步更新</strong></p><img src="http://t-blog-images.aijs.top/img/20220720104906.webp" style="max-width: 100%; width: 600px"/><p><strong>React17+ 例子 2 不一定触发 <code>submit</code> 原因：异步更新</strong></p><img src="http://t-blog-images.aijs.top/img/20220720104951.webp" style="max-width: 100%; width: 600px"/><h2 id="React-提示-event-persist-，为什么会提示？"><a href="#React-提示-event-persist-，为什么会提示？" class="headerlink" title="React 提示 event.persist() ，为什么会提示？"></a>React 提示 event.persist() ，为什么会提示？</h2><p>React 在<code>executeDispatchesAndRelease</code>遍历所有合成事件，会调用 <code>event.isPersistent()</code>来查看这个合成事件是否需要被持久化，如果不需要就会释放这个合成事件，这也就是为什么当我们需要异步读取操作一个合成事件的时候，需要执行 <code>event.persist()</code>，不然 React 就是在这里释放掉这个事件。</p><h2 id="setState-有时候是异步的，setState-相对于浏览器而言是同步的，如何理解？"><a href="#setState-有时候是异步的，setState-相对于浏览器而言是同步的，如何理解？" class="headerlink" title="setState 有时候是异步的，setState 相对于浏览器而言是同步的，如何理解？"></a>setState 有时候是异步的，setState 相对于浏览器而言是同步的，如何理解？</h2><p><code>setState</code> 在生命周期以及事件回调中是异步的，也就是会收集起来批量处理。在其它情况下如 <code>promise</code>，<code>setTimeout</code> 中都是同步执行的，也就是调用一次 setState 就会 render 一次并更新到 DOM 上面</p><p>且在 JS 调用栈被弹空时候，必定是已经将结果更新到 DOM 上面了（同步渲染）。这也就是 setState 相对于浏览器是同步的含义。如下图所示</p><img src="http://t-blog-images.aijs.top/img/20220720104906.webp" style="max-width: 100%; width: 600px"/><p>异步渲染的流程图大概如下图所示，最近一次思考这个问题的时候，发现如果现在是异步渲染的话，那我们的例子二将变成偶现的坑 😂，因为如果 setState 的结果还没被更新到 DOM 上，浏览器就不会触发 submit 事件。</p><img src="http://t-blog-images.aijs.top/img/20220720104951.webp" style="max-width: 100%; width: 600px"/><h2 id="异步渲染使用不安全的生命周期会有怎样的现象？"><a href="#异步渲染使用不安全的生命周期会有怎样的现象？" class="headerlink" title="异步渲染使用不安全的生命周期会有怎样的现象？"></a>异步渲染使用不安全的生命周期会有怎样的现象？</h2><p>例子 2 变成偶现</p><h2 id="之前将事件监听挂载到-document-上，现在为何挂载到-root-上？"><a href="#之前将事件监听挂载到-document-上，现在为何挂载到-root-上？" class="headerlink" title="之前将事件监听挂载到 document 上，现在为何挂载到 root 上？"></a>之前将事件监听挂载到 document 上，现在为何挂载到 root 上？</h2><p>当同个项目里，<code>有多个 React 根节点时</code>（也可能是 React 多版本共存），避免可能的一些操作（如阻止冒泡）会影响到其他 React 节点的正常工作。</p><img src="http://t-blog-images.aijs.top/img/20220720110733.webp" style="max-width: 700px"  /><p><a href="https://github.com/facebook/react/releases/tag/v17.0.0" target="_blank" >Delegate events to roots instead of document</a></p><p><a href="https://www.bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document" target="_blank" >React 17 delegates events to root instead of document</a></p><p>为了演示其中一个问题，让我们以 select 下拉列表为例。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Div&#39;s change event contains stopPropagation()--&gt;&lt;div id&#x3D;&quot;main&quot;&gt;  &lt;!--Div where react component will be rendered --&gt;  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class CountryDropDown extends React.Component &#123;  state &#x3D; &#123;    country: &#39;&#39;,  &#125;  const handleChange &#x3D; e &#x3D;&gt; &#123;    this.setState(&#123; country: e.target.value &#125;);  &#125;  render() &#123;    return (      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;        &lt;thead&gt;          &lt;tr&gt;            &lt;th&gt;Country&lt;&#x2F;th&gt;            &lt;th&gt;Selected country&lt;&#x2F;th&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;thead&gt;        &lt;tbody&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;select value&#x3D;&#123;this.state.country&#125;                onChange&#x3D;&#123;this.handleChange&#125;              &gt;                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;              &lt;&#x2F;select&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &#123;this.state.country&#125;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;tbody&gt;      &lt;&#x2F;table&gt;    );  &#125;&#125;ReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));</code></pre><p>给<code>main-div</code>增加一个阻止冒泡的事件</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.getElementById(&quot;main&quot;).addEventListener(  &quot;change&quot;,  function (e) &#123;    e.stopPropagation();  &#125;,  false);</code></pre><p>附加到文档节点的 onChange 下拉事件出现意外行为，原因是：包含 e.stopPropagation（）的主 div 的 change 事件阻止了下拉的 onChange 事件。</p><h2 id="合成事件的冒泡捕获机制如何实现？"><a href="#合成事件的冒泡捕获机制如何实现？" class="headerlink" title="合成事件的冒泡捕获机制如何实现？"></a>合成事件的冒泡捕获机制如何实现？</h2><p><code>traverseTwoPhase</code> 模拟了捕获和冒泡的两个阶段，这里实现很巧妙，简单而言就是<code>正向和反向遍历了一下数组</code></p><h2 id="合成事件源码函数调用关系图"><a href="#合成事件源码函数调用关系图" class="headerlink" title="合成事件源码函数调用关系图"></a>合成事件源码函数调用关系图</h2><img src="http://t-blog-images.aijs.top/img/SyntheticEvent-第 2 页.drawio.webp" /><h2 id="v17-0-1"><a href="#v17-0-1" class="headerlink" title="v17.0.1"></a>v17.0.1</h2><p>React 中事件分为<code>委托事件（DelegatedEvent）</code>和<code>不需要委托事件（NonDelegatedEvent）</code>，</p><ul><li>委托事件在 fiberRoot 创建的时候，<code>就会在 root 节点的 DOM 元素上绑定几乎所有事件的处理函数</code>，</li><li>而不需要委托事件只<code>会将处理函数绑定在 DOM 元素本身</code>。</li></ul><p>同时，React 将事件分为 3 种类型——discreteEvent(离散事件，对应<code>discreteEventPairsForSimpleEventPlugin</code>)、userBlockingEvent(用户阻止事件，对应<code>userBlockingPairsForSimpleEventPlugin</code>)、continuousEvent(连续事件，对应<code>continuousPairsForSimpleEventPlugin</code>)，它们拥有不同的优先级，在绑定事件处理函数时会使用不同的回调函数。</p><p>React 事件建立在原生基础上，模拟了一套冒泡和捕获的事件机制，当某一个 DOM 元素触发事件后，会冒泡到 React 绑定在 root 节点的处理函数，通过 target 获取触发事件的 DOM 对象和对应的 Fiber 节点，由该 Fiber 节点向上层父级遍历，收集一条事件队列，再遍历该队列触发队列中每个 Fiber 对象对应的事件处理函数，正向遍历模拟冒泡，反向遍历模拟捕获，所以合成事件的触发时机是在原生事件之后的。</p><p>Fiber 对象对应的事件处理函数依旧是储存在 props 里的，收集只是从 props 里取出来，它并没有绑定到任何元素上。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">createRootImpl(委托事件绑定)-&gt;listenToAllSupportedEvents(监听所有支持的事件)-&gt;listenToNativeEvent(冒泡,捕获)-&gt;getEventListenerSet,getListenerSetKey,addTrappedEventListener（函数会通过事件名取得对应优先级的listener函数，再交由下层函数处理事件绑定）-&gt;createEventListenerWrapperWithPriority(根据优先级取得对应listener)-&gt;dispatchDiscreteEvent,dispatchUserBlockingUpdate,dispatchEvent(触发事件)-&gt;attemptToDispatchEvent(触发事件)-&gt;.....略.....-&gt;dispatchEventsForPlugins(函数里会收集触发事件开始各层级的节点对应的处理函数，也就是我们实际传入JSX中的函数，并且执行它们)-&gt;extractEvents(针对不同类型的事件创建对应的合成事件，并且将各层级节点的listener收集起来，用来模拟冒泡或者捕获)-&gt;accumulateSinglePhaseListeners(函数里就是在向上层遍历来收集一个列表后面会用来模拟冒泡)-&gt;processDispatchQueue(遍历dispatchQueue,在processDispatchQueueItemsInOrder函数里遍历执行)-&gt;processDispatchQueueItemsInOrder(根据判断来正向、反向的遍历来模拟冒泡和捕获)-&gt;executeDispatch(会执行listener)-&gt;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.lzane.com/tech/react-event-system-and-source-code/" target="_blank" >动画浅析 REACT 事件系统和源码</a></p><p><a href="https://zhuanlan.zhihu.com/p/56531645" target="_blank" >小前端读源码 - React16.7.0(合成事件)</a></p><p><a href="https://blog.csdn.net/weixin_34352005/article/details/85995026" target="_blank" >React16 的 interactiveUpdates</a></p><p><a src="https://blog.51cto.com/u_15127691/4626192" >React 17 All In One </a></p><p><a href="https://segmentfault.com/a/1190000039108951" target="_blank" >深入 React 合成事件机制原理</a></p><p><a href="https://juejin.cn/post/7005129812981317668" target="_blank" >React 合成事件详解</a></p><p><a href="https://www.bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document" target="_blank" >React 17 delegates events to root instead of document</a></p><p><a href="http://www.zzvips.com/article/227118.html" target="_blank" >React 事件机制源码解析 17.0.1</a></p><p><a href="https://zhuanlan.zhihu.com/p/166625150" target="_blank" >React 事件 | 4. React 事件监听</a></p><p><a href="https://juejin.cn/post/6863266370411298823#heading-0" target="_blank" >React 源码解析-事件系统</a></p>]]></content>
      
      
      <categories>
          
          <category> react_1650 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react_1650 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-native 架构变更</title>
      <link href="//post/2022-07-19rn-%E6%9E%B6%E6%9E%84%E5%8F%98%E6%9B%B4.html"/>
      <url>//post/2022-07-19rn-%E6%9E%B6%E6%9E%84%E5%8F%98%E6%9B%B4.html</url>
      
        <content type="html"><![CDATA[<h2 id="Fabric-渲染器"><a href="#Fabric-渲染器" class="headerlink" title="Fabric 渲染器"></a>Fabric 渲染器</h2><p><a href="https://www.react-native.cn/docs/fabric-renderer" target="_blank" >Fabric 渲染器</a></p><p>一开始直接看 react-native 官网，对于 Fabric 渲染器的介绍看的我一脸懵逼，在 Google 扒拉下，发现了 2018 年的一个提案。</p><p>我觉得从过去来看更符合事物的发展规律。直接拿到结果倒着看，不是很好理解。</p><h3 id="这么搜搜到的"><a href="#这么搜搜到的" class="headerlink" title="这么搜搜到的"></a>这么搜搜到的</h3><img src="http://t-blog-images.aijs.top/img/20220719151559.webp" style="max-width: 100%; width: 800px" /><h3 id="2018-年提案"><a href="#2018-年提案" class="headerlink" title="2018 年提案"></a>2018 年提案</h3><p><a href="https://github.com/react-native-community/discussions-and-proposals/issues/4#:~:text=dedicated%20issue)-,TL%3BDR,-From%20%40axe%2Dfb" target="_blank" >React Native Fabric (UI-Layer Re-architecture) #4</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>In the current architecture, all UI operations (like creating native views, managing children, etc). are handled by a native module called UIManagerModule. The React Reconciller sends UI commands over the bridge, which are eventually handled by this module and delegated to UIImplementation. This in turn creates shadow nodes that represent the layout tree and are passed to Yoga to determine the relative co-ordinates based on the Flex box styles that are passed in from JS.</p><p>In the new system, the UI operations are directly exposed to JavaScript as functions using the JSI interface described above. The new UI manager can then create ComponentDescriptors and the Shadow Nodes for specific view types (like Text, View or Images), and then communicate with Java&#x2F;ObjC to draw platform specific UI.</p></blockquote><p>大概意思是：回到 2018 年 7 月 31 日 年，当时的 fabric，在 react-native-community 中还只是个讨论和提案，</p><p><strong>站在 2018 年 7 月 31 日这个时间点,看待这个提案：</strong></p><p>在当前架构中，所有的 UI 操作（像创建原生视图，管理子组件），被一个叫作<code>UIManagerModule</code>原生模块所处理，React 协调器通过网桥发送 UI 命令，这些命令最终由该模块处理并委托给 UIImplementation。这反过来会创建表示布局树的阴影节点，并将其传递给 Yoga，以根据从 JS 传递的 Flex box 样式确定相对坐标。</p><p>在新系统中，用户界面操作作为函数使用上述 JSI 接口直接暴露给 JavaScript。然后，新的 UI 管理器可以为特定的视图类型（如文本、视图或图像）创建组件描述符和阴影节点，然后与 Java&#x2F;ObjC 通信以绘制特定于平台的 UI</p><h3 id="如今的文档"><a href="#如今的文档" class="headerlink" title="如今的文档"></a>如今的文档</h3><h3 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h3><p><a href="https://www.react-native.cn/architecture/glossary" target="_blank" >术语表</a></p><p><strong>宿主平台（Host platform）</strong></p><p>React Native 嵌入的平台，比如 Android、iOS、Windows、macOS。</p><p><strong>宿主视图树（Host View Tree）</strong></p><ul><li><p><code>宿主视图树</code>就是一系列的宿主视图。宿主平台有 Android 平台、iOS 平台等等。在 Android 上，</p></li><li><p><code>宿主视图</code>就是 android.view.ViewGroup 实例、 android.widget.TextView 实例等等。</p></li><li><p>宿主视图就像积木一样地构成了宿主视图树。</p></li><li><p><code>每个宿主视图的大小和坐标位置</code>基于的是 LayoutMetrics，而 LayoutMetrics 是通过布局引擎 Yoga 计算出来的。</p></li><li><p><code>宿主视图的样式和内容信息</code>，是从 React 影子树中得到的。</p></li></ul><p><strong>JavaScript Interfaces (JSI)</strong><br>一个轻量级的 API，给在 C++ 应用中嵌入的 JavaScript 引擎用的。Fabric 使用它在 Fabric 的 C++ 核心和 React 之间进行通信。</p><p><strong>Java Native Interface (JNI)</strong><br>Java Native Interface (JNI)：一个用于在 Java 中写 原生(译注：指调用 C++) 方法的 API。作用是实现 Fabric 的 C++ 核心和 Android 的通信。</p><p><code>怎么没有提IOS的ObjC ? ObjC可以直接调用C++ ?</code></p><p><strong>React 组件（React Component）</strong><br>React 组件就是 JavaScript 函数或者类，描述如何创建 React 元素。这篇博文中有更多介绍。</p><p><strong>React 复合组件（React Composite Components）</strong><br>React 组件的 render 方法中，包括其他 React 复合组件和 React 宿主组件。</p><p><strong>React 宿主组件（React Host Components or Host Components）</strong><br>React 组件的视图是通过宿主视图，比如 <View>、<Text>，实现的。在 Web 中，ReactDOM 的宿主组件就是 <p>标签、<div>标签代表的组件。</p><p><strong>React 元素树（React Element Trees）</strong><br>React 元素树是通过 JavaScript 中的 React 创建的，该树由一系类 React 元素组成。一个 React 元素就是一个普通的 JavaScript 对象，它描述了应该在屏幕中展示什么。一个元素包括属性 props、样式 styles、子元素 children。React 元素分为两类：React 复合组件实例（React Composite Components）和 React 宿主组件（React Host Components）实例，并且它只存在于 JavaScript 中。</p><p><strong>React 影子树（React Shadow Tree and React Shadow Node)</strong><br>React 影子树是通过 Fabric 渲染器创建的，树由一系列 React 影子节点组成。一个 React 影子节点是一个对象，代表一个已经挂载的 React 宿主组件，其包含的属性 props 来自 JavaScript。它也包括布局信息，比如坐标系 x、y，宽高 width、height。在新渲染器 Fabric 中，React 影子节点对象只存在于 C++ 中。而在老架构中，它存在于手机运行时的堆栈中，比如 Android 的 JVM。</p><p><code>Fabric 渲染器（Fabric Renderer）</code>：React Native 执行的 React 框架代码，和 React 在 Web 中执行代码是同一份。但是，React Native 渲染的是通用平台视图（宿主视图）而不是 DOM 节点（可以认为 DOM 是 Web 的宿主视图）。</p><p>Fabric 渲染器使得渲染宿主视图变得可行。<br>Fabric 让 React 与各个平台直接通信并管理其宿主视图实例。<br>Fabric 渲染器存在于 JavaScript 中，并且它调用的是由 C++ 代码暴露的接口。<a href="https://www.react-native.cn/architecture/fabric-renderer" target="_blank" >在这篇文章中有更多关于 React 渲染器的信息。</a></p><h3 id="React-源码目录"><a href="#React-源码目录" class="headerlink" title="React 源码目录"></a>React 源码目录</h3><p>Renderer 相关的文件夹<br>如下几个文件夹为对应的 Renderer</p><ul><li>react-art</li><li>react-dom # 注意这同时是 DOM 和 SSR（服务端渲染）的入口</li><li>react-native-renderer</li><li>react-noop-renderer # 用于 debug fiber（后面会介绍 fiber）</li><li>react-test-renderer</li></ul><p>react-dom 与 react-native-renderer 属于同一级别,<code>Fabric</code> 取代了 <code>react-native-renderer</code>, 可以理解为<code>Fabric</code>是 <code>react-dom</code>级别的渲染器</p><p><a href="https://github.com/facebook/react-native/blob/089c9a5c9c9a60b6bbff6dda0c9eefa9d501a092/Libraries/ReactNative/renderApplication.js#L72" target="_blank" >源码</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Libaries&#x2F;ReactNative&#x2F;renderApplication.jsif (fabric) &#123;  require(&quot;..&#x2F;Renderer&#x2F;shims&#x2F;ReactFabric&quot;).render(    renderable,    rootTag,    null,    useConcurrentRoot  );&#125; else &#123;  require(&quot;..&#x2F;Renderer&#x2F;shims&#x2F;ReactNative&quot;).render(renderable, rootTag);&#125;</code></pre><h3 id="设计的初忠"><a href="#设计的初忠" class="headerlink" title="设计的初忠"></a>设计的初忠</h3><p>开发新的渲染架构的初衷是为了更好的用户体验，而这种新体验是在老架构上是不可能实现的</p><p><strong>提升互操性</strong></p><ul><li>为了<code>提升宿主视图（host views）和 React 视图（React views）的互操作性</code>，渲染器必须有能力同步地测量和渲染 React 界面。在老架构中，React Native 布局是异步的，这导致在宿主视图中渲染嵌套的 React Native 视图，会有布局“抖动”的问题。</li></ul><p><strong>使用 React 新特性</strong></p><ul><li><p>借助多优先级和同步事件的能力，渲染器可以提高用户交互的优先级，来确保他们的操作得到及时的处理(React schedule 调度，lan 模型)</p></li><li><p>React Suspense 的集成，允许你在 React 中更符合直觉地写请求数据代码。</p></li><li><p>允许你在 React Native 使用 React Concurrent 模式 可中断渲染功能。 <a href="https://zhuanlan.zhihu.com/p/60307571#:~:text=%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%E3%80%82-,Concurrent%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F,-Concurrent%20%E5%B9%B6%E4%B8%8D%E6%98%AF" target="_blank" >Concurrent 究竟是什么？</a> 异步可中断</p></li><li><p>更容易实现 React Native 的服务端渲染。？打个问号，是不是 RN 代码可以部署在云端？进行 SSR?</p></li></ul><h3 id="设计的收益"><a href="#设计的收益" class="headerlink" title="设计的收益"></a>设计的收益</h3><ul><li><code>类型安全</code>：代码生成工具（code generation）确保了 JS 和宿主平台两方面的类型安全。代码生成工具使用 JavaScript 组件声明作为唯一事实源，生成 C++ 结构体来持有 props 属性。不会因为 JavaScript 和宿主组件 props 属性不匹配而出现构建错误。</li><li><code>共享 C++ core</code>：渲染器是用 C++ 实现的，其核心 core 在平台之间是共享的。这增加了一致性并且使得新的平台能够更容易采用 React Native。（译注：例如 VR 新平台）</li><li><code>更好的宿主平台互操作性</code>：当宿主组件集成到 React Native 时，同步和线程安全的布局计算提升了用户体验（译注：没有异步的抖动）。这意味着那些需要同步 API 的宿主平台库，变得更容易集成了。</li><li><code>性能提升</code>：新的渲染系统的实现是跨平台的，每个平台都从那些原本只在某个特定平台的实现的性能优化中，得到了收益。比如拍平视图层级，原本只是 Android 上的性能优化方案，现在 Android 和 iOS 都直接有了。</li><li><code>一致性</code>：新的渲染系统的实现是跨平台的，不同平台之间更容易保持一致。</li><li><code>更快的启动速度</code>：默认情况下，宿主组件的初始化是懒执行的。？以前不是</li><li><code>JS 和宿主平台之间的数据序列化更少</code>：React 使用序列化 JSON 在 JavaScript 和宿主平台之间传递数据。新的渲染器用 JSI（JavaScript Interface）直接获取 JavaScript 数据。</li></ul><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 以前 jsx -&gt; 原生&#x2F;&#x2F; 现在 jsx -&gt; JSI C++ -&gt; 原生</code></pre><p>多了一层，竟然不慢反快? 我猜应该在 <code>JSI C++ -&gt; 原生</code></p><p><a href="https://www.react-native.cn/architecture/xplat-implementation#:~:text=%E4%BD%BF%E7%94%A8%20C%2B%2B%20%E4%BD%9C%E4%B8%BA%E6%A0%B8%E5%BF%83%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E6%9C%89%E5%87%A0%E4%B8%AA%E6%9C%89%E7%82%B9" target="_blank" >跨平台实现中有对此说明</a></p><p>在上一代 React Native 渲染器中，React 影子树、布局逻辑、视图拍平算法是在各个平台单独实现的。当前的渲染器的设计上采用的是跨平台的解决方案，共享了核心的 C++ 实现。</p><p>使用 C++ 作为核心渲染系统有几个优点</p><ul><li>单一实现降低了开发和维护成本</li><li>它提升了创建 React 影子树的性能</li><li>在 Android 上，也因为不再使用 JNI for Yoga，降低了 Yoga 渲染引擎的开销，布局计算的性能也有所提升</li><li>每个 React 影子节点在 C++ 中占用的内存，比在 Kotlin 或 Swift 中占用的要小。</li><li>强制不可变的 C++ 特性，来确保并发访问时共享资源即便不加锁保护，也不会有问题。</li></ul><p>在 Android 端还有两种例外，渲染器依然会有 JNI 的开销：</p><ul><li>复杂视图，比如 Text、TextInput 等，依然会使用 JNI 来传输属性 props。</li><li>在挂载阶段依然会使用 JNI 来发送变更操作。</li></ul><p>React Native 团队在探索使用 ByteBuffer 序列化数据这种新的机制，来替换 ReadableMap，减少 JNI 的开销。目标是将 JNI 的开销减少 35~50%。</p><h3 id="fabric-提供了-C-与两边通信的-API"><a href="#fabric-提供了-C-与两边通信的-API" class="headerlink" title="fabric 提供了 C++ 与两边通信的 API"></a>fabric 提供了 C++ 与两边通信的 API</h3><img src="https://www.react-native.cn/assets/images/xplat-implementation-diagram-7611cf9dfb6d15667365630147d83ca5.png" /><ul><li>(i) 与 React 通信</li><li>(ii) 与宿主平台通信</li></ul><p>关于 (i) React 与渲染器的通信，包括<code>渲染（render） React 树</code>和<code>监听事件（event）</code>，比如 <code>onLayout</code>、<code>onKeyPress</code>、<code>touch</code> 等。</p><p>关于 (ii) React Native 渲染器与宿主平台的通信，包括<code>在屏幕上挂载（mount）宿主视图</code>，包括 <code>create</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 宿主视图，和<code>监听用户在宿主平台产生的事件</code>。</p><h2 id="视图拍平"><a href="#视图拍平" class="headerlink" title="视图拍平"></a>视图拍平</h2><p>视图拍平（View Flattening）是 React Native 渲染器避免布局嵌套太深的优化手段</p><p>React API 在设计上希望通过组合的方式，<code>实现组件声明和重用</code>，这为更简单的开发提供了一个很好的模型。但是在实现中，API 的这些特性会导致一些 React 元素会嵌套地很深，而其中大部分 React 元素节点只会影响视图布局，并不会在屏幕中渲染任何内容。这就是所谓的“只参与布局”类型节点。</p><p>从概念上讲，React 元素树的节点数量和屏幕上的视图数量应该是 1:1 的关系。但是，渲染一个很深的“只参与布局”的 React 元素会导致性能变慢。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>大概意思：因为 React 组合设计实现组件复用。 组件复用嵌套多了，会出现很多无内容的布局节点，这些布局节点没啥用，多个连续嵌套的节点，在 fabric 中被一巴掌拍死打成一个肉饼，嗯～</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>举个很常见的例子，例子中“只参与布局”视图导致了性能损耗。</p><p>想象一下，你要渲染一个标题。你有一个应用，应用中拥有外边距 ContainerComponent 的容器组件，容器组件的子组件是 TitleComponent 标题组件，标题组件包括一个图片和一行文字。React 代码示例如下：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">function MyComponent() &#123;  return (    &lt;View&gt;                          &#x2F;&#x2F; ReactAppComponent      &lt;View style&#x3D;&#123;&#123;margin: 10&#125;&#125; &#x2F;&gt; &#x2F;&#x2F; ContainerComponent        &lt;View style&#x3D;&#123;&#123;margin: 10&#125;&#125;&gt; &#x2F;&#x2F; TitleComponent          &lt;Image &#123;...&#125; &#x2F;&gt;          &lt;Text &#123;...&#125;&gt;This is a title&lt;&#x2F;Text&gt;        &lt;&#x2F;View&gt;      &lt;&#x2F;View&gt;    &lt;&#x2F;View&gt;  );&#125;</code></pre><h3 id="拍平前"><a href="#拍平前" class="headerlink" title="拍平前"></a>拍平前</h3><p>React Native 在渲染时，会生成以下三棵树：</p><img src="https://www.react-native.cn/assets/images/diagram-one-3f2f9d7a2fa9d97b6b86fa3bd9b886d1.png" /><p>为了提升 React 元素树中“只参与布局”类型的性能，渲染器实现了一种视图拍平的机制来合并或拍平这类节点，减少屏幕中宿主视图的层级深度。该算法考虑到了如下属性，比如 margin, padding, backgroundColor, opacity 等等。</p><p><code>视图拍平算法</code>是渲<code>染器的对比（diffing）阶段的一部分</code>，这样设计的好处是我们<code>不需要额外的 CPU 耗时</code>(不需要再遍历了，但是绝对是有 CPU 损耗的)，来<code>拍平 React 元素树中“只参与布局”的视图</code>。此外，作为 C++ 核心的一部分，<code>视图拍平算法默认是全平台共用的</code>。</p><p>在前面的例子中，视图 2 和视图 3 会作为“对比算法”（diffing algorithm）的一部分被拍平，而它们的样式结果会被合并到视图 1 中。</p><img src="https://www.react-native.cn/assets/images/diagram-two-b87959980d29e4a303465a3d0ac82c73.png" /><p>虽然，这种<code>优化让渲染器少创建和渲染两个宿主视图</code>，但<code>从用户的角度看屏幕内容没有任何区别</code>。</p><h3 id="拍平"><a href="#拍平" class="headerlink" title="拍平"></a>拍平</h3><h3 id="拍平后"><a href="#拍平后" class="headerlink" title="拍平后"></a>拍平后</h3><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>React Native 渲染器在多个线程之间分配 <a href="https://www.react-native.cn/architecture/render-pipeline" target="_blank" >渲染流水线（render pipeline）任务</a>。<br>接下来我们会给线程模型下定义，并提供一些示例来说明渲染流水线的线程用法。</p><p>React Native 渲染器是<code>线程安全</code>的。</p><p>从更高的视角看，在框架内部线程安全是<code>通过不可变的数据结果保障</code>的，其使用的是 C++ 的 const correctness 特性。这意味着，在渲染器中 React 的<code>每次更新都会重新创建或复制新对象，而不是更新原有的数据结构</code>。这是框架把线程安全和同步 API 暴露给 React 的前提。</p><p>渲染器使用三个不同的线程：</p><ul><li>UI 线程（主线程）：唯一可以操作宿主视图的线程。</li><li>JavaScript 线程：这是执行 React 渲染阶段的地方。</li><li>后台线程：专门用于布局的线程。</li></ul><h2 id="渲染场景"><a href="#渲染场景" class="headerlink" title="渲染场景"></a>渲染场景</h2><h3 id="在后台线程中渲染"><a href="#在后台线程中渲染" class="headerlink" title="在后台线程中渲染"></a>在后台线程中渲染</h3><p>这是最常见的场景，大多数的渲染流水线发生在 JavaScript 线程和后台线程。</p><img src="http://t-blog-images.aijs.top/img/case-1.webp" /><h3 id="在主线程中渲染"><a href="#在主线程中渲染" class="headerlink" title="在主线程中渲染"></a>在主线程中渲染</h3><p>当 UI 线程上有高优先级事件时，渲染器能够在 UI 线程上同步执行所有渲染流水线。</p><img src="http://t-blog-images.aijs.top/img/case-2.webp" /><h3 id="默认或连续事件中断"><a href="#默认或连续事件中断" class="headerlink" title="默认或连续事件中断"></a>默认或连续事件中断</h3><p>在这个场景中，UI 线程的低优先级事件中断了渲染步骤。React 和 React Native 渲染器能够中断渲染步骤，并把它的状态和一个在 UI 线程执行的低优先级事件合并。在这个例子中渲染过程会继续在后台线程中执行。</p><img src="http://t-blog-images.aijs.top/img/case-3.webp" /><h3 id="不相干的事件中断"><a href="#不相干的事件中断" class="headerlink" title="不相干的事件中断"></a>不相干的事件中断</h3><p>渲染步骤是可中断的。在这个场景中， <code>UI 线程的高优先级事件中断了渲染步骤</code>。React 和渲染器是能够打断渲染步骤的，并把它的状态和 UI 线程执行的高优先级事件合并。在 UI 线程渲染步骤是同步执行的。</p><img src="http://t-blog-images.aijs.top/img/case-4.webp" /><h3 id="来自-JavaScript-线程的后台线程批量更新"><a href="#来自-JavaScript-线程的后台线程批量更新" class="headerlink" title="来自 JavaScript 线程的后台线程批量更新"></a>来自 JavaScript 线程的后台线程批量更新</h3><p>在后台线程将更新分派给 UI 线程之前，它会检查是否有新的更新来自 JavaScript。 这样，当渲染器知道新的状态要到来时，它就不会直接渲染旧的状态。</p><img src="http://t-blog-images.aijs.top/img/case-5.webp" /><h3 id="C-状态更新"><a href="#C-状态更新" class="headerlink" title="C++ 状态更新"></a>C++ 状态更新</h3><p>更新来自 UI 线程，并会跳过渲染步骤。更多细节请参考 React Native 渲染器状态更新。</p><img src="http://t-blog-images.aijs.top/img/case-6.webp" /><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/react-native-community/discussions-and-proposals/issues/4" target="_blank" >React Native Fabric (UI-Layer Re-architecture) #4</a></p><p><a href="https://www.react-native.cn/docs/fabric-renderer" target="_blank" >Fabric 渲染器</a></p><p><a href="https://juejin.cn/post/7099885746697273357" target="_blank" >React Native 架构解析 - 一张图了解 Fabric</a></p><p><a href="https://react.iamkasong.com/preparation/file.html#packages%E7%9B%AE%E5%BD%95" target="_blank" >React 技术揭秘</a></p>]]></content>
      
      
      <categories>
          
          <category> react-native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-设计模式</title>
      <link href="//post/2022-07-18%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>//post/2022-07-18%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要设计模式"><a href="#为什么需要设计模式" class="headerlink" title="为什么需要设计模式"></a>为什么需要设计模式</h2><ul><li>有助于写出可复用&#x2F;可维护性更高的程序</li><li>原则：找出程序中变化的地方，并将变化封装起来，<code>它的关键是意图，而不是结构</code></li></ul><h2 id="SOLID-设计原则"><a href="#SOLID-设计原则" class="headerlink" title="SOLID 设计原则"></a>SOLID 设计原则</h2><p><strong>S: Single Responsibility Principle</strong> 单一职责原则</p><p>对象应该仅具有一种单一功能</p><p><strong>O: OpenClosed Principle</strong> 开放&#x2F;封闭原则</p><p>对扩展开放，对修改封闭</p><p><strong>L:</strong> 里氏替换原则</p><p>子类能覆盖父类，父类能出现的地方，子类也能出现</p><p><strong>I: interface Segregation Principle</strong> 接口隔离原则</p><p>保持接口的单一独立，避免出现“胖接口”。这点目前在 TS 中运用到</p><p>有一个用户服务的接口，里面有注册，登录，查询，删除几个函数暴露给客户端，但是很明显删除函数只有后台管理模块可以用到，而且其他模块如果都可以使用的话就有可能照成误删用户。这就违背了接口隔离原则，我们需要把删除函数单独抽离出来给后台管理模块使用。</p><p>作者：猫清扬<br>链接：<a href="https://www.jianshu.com/p/63bd557f6ca4">https://www.jianshu.com/p/63bd557f6ca4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>D: Dependency Inversion Principle</strong> 依赖倒转原则</p><p>面向接口编程，依赖于抽象而不依赖于具体。<br>使用方只专注接口而不用关注具体类的实现。俗称“鸭子类型”</p><h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><ul><li>创建型：<code>单例模式</code>、<code>工厂模式</code>、<code>原型模式</code></li><li>结构型：<code>装饰器模式</code>、<code>代理模式</code></li><li>行为型：<code>策略模式</code>、<code>模块方法模式</code>、<code>发布订阅模式</code>。</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的思路是：保证一个类只能被实例一次，每次获取的时候，如果该类已经创建过实例则直接返回该实例，否则创建一个实例保存并返回。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>内存中只有一个实例，减少了内存的开销。</li><li>避免了对资源多重的占用。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>违反了单一职责，一个类应该只关心内部逻辑，而不用去关心外部的实现</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是<code>用来创建对象</code>的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂</p><p>其就像工厂一样重复的<code>产生类似的产品</code>，工厂模式只需要我们传入正确的参数，就能生产类似的产品</p><p>举个例子：</p><p>编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联(耦合)</p><p>后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事;</p><p>这种情况下，就需要将创建实例的工作从调用方(A 类)中分离，与调用方「解耦」，也就是<code>使用工厂方法创建实例的工作封装起来(「减少代码重复」)</code>，由工厂管理对象的创建逻辑，<code>调用方不需要知道具体的创建过程，只管使用</code>，「而降低调用者因为创建逻辑导致的错误」;</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>调用者创建对象时只要知道其名称即可</li><li>扩展性高，如果要新增一个产品，直接扩展一个工厂类即可。</li><li>隐藏产品的具体实现，只关心产品的接口。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>每次增加一个产品时，都需要增加一个具体类，这无形增加了系统内存的压力和系统的复杂度，也增加了具体类的依赖</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>工厂模式<code>根据抽象程度</code>的不同可以分为：</p><ul><li><code>简单工厂模式</code>(Simple Factory)</li><li><code>工厂方法模式</code>(Factory Method)</li><li><code>抽象工厂模式</code>(Abstract Factory)</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式也叫静态工厂模式，<code>用一个工厂对象创建同一类对象类的实例</code></p><p>假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Factory(career) &#123;  function User(career, work) &#123;    this.career &#x3D; career;    this.work &#x3D; work;  &#125;  let work;  switch (career) &#123;    case &quot;coder&quot;:      work &#x3D; [&quot;写代码&quot;, &quot;修Bug&quot;];      return new User(career, work);      break;    case &quot;hr&quot;:      work &#x3D; [&quot;招聘&quot;, &quot;员工信息管理&quot;];      return new User(career, work);      break;    case &quot;driver&quot;:      work &#x3D; [&quot;开车&quot;];      return new User(career, work);      break;    case &quot;boss&quot;:      work &#x3D; [&quot;喝茶&quot;, &quot;开会&quot;, &quot;审批文件&quot;];      return new User(career, work);      break;  &#125;&#125;let coder &#x3D; new Factory(&quot;coder&quot;);console.log(coder);let boss &#x3D; new Factory(&quot;boss&quot;);console.log(boss);</code></pre><h3 id="简单工厂方法"><a href="#简单工厂方法" class="headerlink" title="简单工厂方法"></a>简单工厂方法</h3><p>工厂方法模式跟简单工厂模式差不多，但是<code>把具体的产品放到了工厂函数的 prototype 中</code></p><p>这样一来，扩展产品种类就不必修改工厂函数了，变成抽象类，也可以随时重写某种具体的产品</p><p>也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产;但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 工厂方法function Factory(career) &#123;  if (this instanceof Factory) &#123;    return new this[career]();  &#125; else &#123;    return new Factory(career);  &#125;&#125;&#x2F;&#x2F; 工厂方法函数的原型中设置所有对象的构造函数Factory.prototype &#x3D; &#123;  coder: function () &#123;    this.careerName &#x3D; &quot;程序员&quot;;    this.work &#x3D; [&quot;写代码&quot;, &quot;修Bug&quot;];  &#125;,  hr: function () &#123;    this.careerName &#x3D; &quot;HR&quot;;    this.work &#x3D; [&quot;招聘&quot;, &quot;员工信息管理&quot;];  &#125;,  driver: function () &#123;    this.careerName &#x3D; &quot;司机&quot;;    this.work &#x3D; [&quot;开车&quot;];  &#125;,  boss: function () &#123;    this.careerName &#x3D; &quot;老板&quot;;    this.work &#x3D; [&quot;喝茶&quot;, &quot;开会&quot;, &quot;审批文件&quot;];  &#125;,&#125;;let coder &#x3D; new Factory(&quot;coder&quot;);console.log(coder);let hr &#x3D; new Factory(&quot;hr&quot;);console.log(hr);</code></pre><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>上述<code>简单工厂模式</code>和<code>工厂方法模式</code>都<code>是直接生成实例</code>，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建</p><p>通俗点来讲就是：<code>简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的</code></p><p>由于 JavaScript 中并没有抽象类的概念，只能模拟，可以分成四部分：</p><ul><li>用于创建抽象类的函数</li><li>抽象类</li><li>具体类</li><li>实例化具体类</li></ul><p>上面的例子中有 coder、hr、boss、driver 四种岗位，其中 coder 可能使用不同的开发语言进行开发，比如 JavaScript、Java 等等。那么这两种语言就是对应的类簇</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function CareerAbstractUserFactory(type) &#123;  switch (type) &#123;    case &quot;coder&quot;:      return UserOfCoder;    case &quot;hr&quot;:      return UserOfHR;    case &quot;driver&quot;:      return UserOfDriver;    case &quot;boss&quot;:      return UserOfBoss;    default:      throw new Error(&quot;参数错误, 可选参数:coder、hr、driver、boss&quot;);  &#125;&#125;</code></pre><p>上面代码中 CareerAbstractFactory 就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>工厂模式适用场景如下：</p><ul><li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择 <code>flutter接口返回json数据转化成实例</code></li><li>将 new 操作简单封装，<code>遇到 new 的时候就应该考虑是否用工厂模式</code>;</li><li><code>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式</code>，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ul><p><a href="https://developer.51cto.com/article/688576.html" target="_blank" >说说你对工厂模式的理解？应用场景？</a><br><a href="https://juejin.cn/post/6844903653774458888#heading-3" target="_blank" >JavaScript 设计模式与实践–工厂模式</a></p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是指原型实例指向创建对象的种类，通过拷贝这些原型来创建新的对象，说白了就是克隆自己，生成一个新的对象。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>不再依赖构造函数或者类创建对象，可以将这个对象作为一个模板生成更多的新对象。</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>对于包含引用类型值的属性来说，所有实例在默认的情况下都会取得相同的属性值。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Object.createconst user &#x3D; &#123;  name: &quot;小明&quot;,  age: &quot;30&quot;,  getInfo() &#123;    console.log(&#96;姓名：$&#123;this.name&#125;，年龄：$&#123;this.age&#125;&#96;);  &#125;,&#125;;const xiaozhang &#x3D; Object.create(user);xiaozhang.name &#x3D; &quot;小张&quot;;xiaozhang.age &#x3D; 18;xiaozhang.getInfo(); &#x2F;&#x2F; 姓名：小张，年龄：18user.getInfo(); &#x2F;&#x2F; 姓名：小明，年龄：30</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>HTML 元 素事件代理</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;ul id&#x3D;&quot;ul&quot;&gt;  &lt;li&gt;1&lt;&#x2F;li&gt;  &lt;li&gt;2&lt;&#x2F;li&gt;  &lt;li&gt;3&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;script&gt;  let ul &#x3D; document.querySelector(&#39;#ul&#39;);  ul.addEventListener(&#39;click&#39;, event &#x3D;&gt; &#123;    console.log(event.target);  &#125;);&lt;&#x2F;script&gt;</code></pre><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>代理模式能将代理对象与被调用对象分离，<code>降低了系统的耦合度</code>。</li><li>代理模式在客户端和目标对象之间起到一个中介作用，这样可以<code>起到保护目标对象的作用</code></li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>处理请求速度可能有差别，非直接访问存在开销</p><p>作者：四叶舟<br>链接：<a href="https://www.jianshu.com/p/19a8c1d76257">https://www.jianshu.com/p/19a8c1d76257</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="发布订阅模式（eventbus）"><a href="#发布订阅模式（eventbus）" class="headerlink" title="发布订阅模式（eventbus）"></a>发布订阅模式（eventbus）</h2><h2 id="模块方法模式"><a href="#模块方法模式" class="headerlink" title="模块方法模式"></a>模块方法模式</h2><p>模块方法模式是一种基于继承的设计模式，</p><p>在 javascript 中没有真正意义上的继承，所有继承都来自原型(prototype)上的继承，<br>随着 ES6 的 class 到来，实现了继承的“概念”，让我们可以以一种很方便简洁的方式继承，但其本质上还是原型继承。</p><p>模板方法模式由两部分组成，<code>第一部分是抽象父类</code>，<code>第二部分是具体的实现子类</code>。</p><ul><li><code>抽象父类</code>主要封装了子类的算法框架，以及实现了一些公共的方法和其他方法的执行顺序。</li><li><code>子类</code>通过继承父类，继承了父类的算法框架，并进行重写。</li></ul><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>提供公共的代码便于维护。行为由父类控制，具体由子类来实现。</p><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>其每一个具体实现都需要继承的子类来实现，这无疑导致类的个数增加，使得系统庞大。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p><a href="https://www.bilibili.com/video/BV1WK411G7QH?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1WK411G7QH?spm_id_from=333.337.search-card.all.click</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/19a8c1d76257" target="_blank" >前端常见的 9 种设计模式</a></p><p><a href="https://juejin.cn/post/7072175210874535967" target="_blank" >javascript 的 23 种设计模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-CSS3</title>
      <link href="//post/2022-07-17css.html"/>
      <url>//post/2022-07-17css.html</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-选择器的优先级是怎样的"><a href="#CSS-选择器的优先级是怎样的" class="headerlink" title="CSS 选择器的优先级是怎样的"></a>CSS 选择器的优先级是怎样的</h2><p>CSS 选择器的优先级是：<span style="color: red">（标签选择器 &lt; 类选择器 &lt; ID 选择器）</span> <code>&lt; 内联 &lt; !important &lt; 特殊情况 </code></p><p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li>A 的值等于 1 的前提是存在内联样式, 否则 A &#x3D; 0;</li><li>B 的值等于 ID 选择器 出现的次数;</li><li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li><li>D 的值等于 标签选择器 和 伪元素 出现的总次数 。</li></ul><p>就⽐如下⾯的选择器，它不存在内联样式，所以 A&#x3D;0,不存在 id 选择器 B&#x3D;0,存在⼀个类选择器 C&#x3D;1,存在三个标签选择器 D&#x3D;3，那么最终计算结果为:</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">ul ol li .red &#123; ... &#125; &#x2F;* &#123;0, 0, 1 ,3&#125; *&#x2F;</code></pre><p>按照这个结算⽅式，下⾯的计算结果为:</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">#red &#123; &#125; &#x2F;* &#123;0, 1, 0, 0&#125; *&#x2F;</code></pre><p>⽐较优先级的⽅式是从 A 到 D 去⽐较值的⼤⼩，A、B、C、D 权重从左到右，依次减⼩。判断优先级时，从左到右，⼀⼀⽐较，<code>直到⽐较出最⼤值，即可停⽌</code>。</p><p>⽐如第⼆个例⼦的 B 与第⼀个例⼦的 B 相⽐，1&gt;0,<code>接下来就不需要⽐较了，第⼆个选择器的优先级更⾼</code>。</p><h2 id="比-important更高的优先级"><a href="#比-important更高的优先级" class="headerlink" title="比!important更高的优先级"></a>比<code>!important</code>更高的优先级</h2><p>从三个方面来说： <span style="color: red">H5 标签、CSS3 样式、媒体查询、文件关系</span></p><ul><li><code>picture source</code></li><li><code>image srcset</code></li><li><code>max-width、min-width</code></li><li><code>media媒体查询</code></li><li><code>同是!important，内部文件优先于外部文件</code></li><li><code>同是!important，link 优先于@import</code></li><li>antd <code>:global</code> 样式覆盖</li></ul><h2 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和@import 的区别"></a>link 和@import 的区别</h2><ul><li>link 属于 <code>XHTML 标签</code>，⽽@import 是 <code>CSS 提供的</code>。</li><li>⻚⾯被加载时，<code>link 会同时被加载</code>，⽽@import 引⽤的 CSS 会<code>等到⻚⾯被加载完再加载</code>。</li><li>import 只在 IE 5 以上才能识别，⽽ link 是 XHTML 标签，⽆<code>兼容问题</code>。</li><li>link ⽅式的样式<code>权重</code>⾼于@import 的权重。</li><li>使⽤ dom 控制样式时的差别。当使⽤ <code>javascript 控制 dom 去改变样式</code>的时候，只能使⽤ link 标签，因为@import 不是 dom 可以控制的。</li></ul><h2 id="CSS-隐藏⻚⾯元素"><a href="#CSS-隐藏⻚⾯元素" class="headerlink" title="CSS 隐藏⻚⾯元素"></a>CSS 隐藏⻚⾯元素</h2><ul><li><code>opacity:0 </code>：本质上是将元素的透明度将为 0，就看起来隐藏了，但是依然<code>占据空间可交互</code></li><li><code>visibility:hidden</code> : 与上⼀个⽅法类似的效果，<code>占据空间不可交互</code></li><li><code>overflow:hidden</code> : 这个只隐藏元素溢出的部分，<code>占据空间不可交互</code></li><li><code>display:none</code> : 这个是彻底隐藏了元素，元素从⽂档流中消失，<code>不占据空间不交互</code></li><li><code>z-index:-9999</code> : 原理是将层级放到底部，这样就被覆盖了，<code>不占据空间不交互</code></li><li><code>transform: scale(0,0) </code>: 平⾯变换，将元素缩放为 0，<code>占据空间不可交互</code></li><li><code>transform: </code>: 移出可视区域<code>占据空间不可交互</code></li></ul><h2 id="em-px-rem-区别"><a href="#em-px-rem-区别" class="headerlink" title="em\px\rem 区别"></a>em\px\rem 区别</h2><ul><li><code>px</code>：绝对单位，⻚⾯按精确像素展示。</li><li><code>em</code>：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了 font-size 按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内 1em 不是⼀个固定的值。</li><li><code>rem</code>：相对单位，可理解为”root em”, 相对根节点 html 的字体⼤⼩来计算，CSS3 新加属性，chrome&#x2F;firefox&#x2F;IE9+⽀ 持</li></ul><h2 id="块级元素⽔平居中的⽅法"><a href="#块级元素⽔平居中的⽅法" class="headerlink" title="块级元素⽔平居中的⽅法"></a>块级元素⽔平居中的⽅法</h2><p>如果使⽤ Hack 的话，⽔平居中的⽅法⾮常多，主流的，奇葩的⻅拓展阅读</p><ul><li><code>margin:0 auto </code>⽅法</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;style&gt;  .center &#123;    height: 200px;    width: 200px;    margin: 0 auto;    border: 1px solid red;  &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre><ul><li><code>flex</code> 布局，⽬前主流⽅法</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;style&gt;  .center&#123; display:flex; justify-content:center; 9 &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;center&quot;&gt;  &lt;div class&#x3D;&quot;flex-div&quot;&gt;1&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;flex-div&quot;&gt;2&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><ul><li><code>table</code> ⽅法 <code>标签打印时候遇到</code></li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;style&gt;  .center &#123;    display: table;    margin: 0 auto;    border: 1px solid red;  &#125;&lt;&#x2F;style&gt;&lt;div class&#x3D;&quot;center&quot;&gt;⽔平居中&lt;&#x2F;div&gt;</code></pre><p>还有⼀些通过 <code>position+(margin|transform)</code>等⽅法的不⼀样列举了，⾮重点没必要</p><h2 id="CSS-5-种定位⽅式"><a href="#CSS-5-种定位⽅式" class="headerlink" title="CSS 5 种定位⽅式"></a>CSS 5 种定位⽅式</h2><ul><li><code>static</code>: <code>正常⽂档流定位</code>，此时 top, right, bottom, left 和 z-index <code>属性⽆效</code>，<code>块级元素：从上往下纵向排布</code>，<code>⾏级元素:从左向右排列</code>。</li><li><code>relative</code>：<code>相对定位</code>，此时的『相对』是<code>相对于正常⽂档流的位置</code>。</li><li><code>absolute</code>：<code>相对于最近的⾮ static 定位祖先元素的偏移</code>，⽐如⼀个绝对定位元素它的⽗级、和祖 ⽗级元素都为 relative，它会相对他的⽗级⽽产⽣偏移。</li><li><code>fixed</code>：指定元素<code>相对于屏幕视⼝（viewport）的位置</code>。元素的位置在屏幕滚动时不会改变，⽐如那 种回到顶部的按钮⼀般都是⽤此定位⽅式。</li><li><code>sticky</code>：<code>粘性定位</code>，特性<code>近似于 relative 和 fixed 的合体</code>，其在实际应⽤中的近似效果就是 IOS 通讯录滚动的时候的 『顶屁股』。</li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>需要注意 BFC 的影响，<a href="https://blog.csdn.net/kaosini/article/details/118760075" target="_blank" >position:fixed 没有相对浏览器窗口定位的原因 transform 冲突</a>,<code>注：在虚拟列表时候会遇到</code></p></div><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p><strong>是什么</strong></p><p>层叠上下⽂是 HTML 元素的三维概念，这些 HTML 元素在⼀条假想的相对于⾯向（电脑屏幕的）视窗或者⽹⻚的⽤户的 z 轴上延伸，HTML 元素依据其⾃身属性按照优先级顺序占⽤层叠上下⽂的空间。</p><p><code>可以理解为 JS 中的作用域，一个页面中往往不仅仅只有一个层叠上下文</code></p><h3 id="如何产⽣？"><a href="#如何产⽣？" class="headerlink" title="如何产⽣？"></a>如何产⽣？</h3><p>触发以下条件则会产⽣层叠上下⽂：</p><p><strong>默认创建层叠上下文</strong></p><ul><li>根元素 (HTML)</li></ul><p><strong>需要配合 z-index 触发创建层叠上下文</strong></p><ul><li><code>z-index + position</code>值不为 “auto”的 绝对&#x2F;相对定位</li><li><code>z-index + flex</code> ⼀个 z-index 值不为 “auto”的 flex 项⽬ (flex item)，即：⽗元素 display: flex|inline-flex</li></ul><p><strong>不需要配合 z-index 触发创建层叠上下文</strong></p><ul><li>opacity 属性值⼩于 1 的元素（参考 the specification for opacity）</li><li>元素的以下属性的值不是 none：<ul><li>transform</li><li>filter 滤镜</li><li>perspective 3D 元素距视图的距离,以像素计</li><li>clip-path 裁剪图片</li><li>mask &#x2F; mask-image &#x2F; mask-border</li></ul></li><li>isolation 属性被设置为 “isolate”的元素 使用 isolation:isolate 进行阻断，形成一个混合组。组以外的其他元素不会发生层叠。<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/" target="_blank" >深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 </a></li><li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇⽂章）</li><li>-webkit-overflow-scrolling 属性被设置 “touch”的元素 (使用滚动回弹效果), <code>在 iOS 13 之后，不需要</code> <a href="https://www.cnblogs.com/xiahj/p/8036419.html#1--webkit-overflow-scrollingtouch%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" >见</a></li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>创建了层叠上下文的元素只影响其子孙代元素</code>，<code>它自身的层叠水平是由它的父层叠上下文所决定的</code></p></blockquote><p>当两个元素<code>层叠水平相同</code>的时候，这时候就要遵循下面两个准则：</p><ul><li>后来居上原则</li><li>谁 z-index 大，谁在上的准则</li></ul><h3 id="如何理解-z-index？"><a href="#如何理解-z-index？" class="headerlink" title="如何理解 z-index？"></a>如何理解 z-index？</h3><p>CSS 中的 z-index 属性控制重叠元素的垂直叠加顺序，默认元素的 z-index 为 0，可以修改 z-index 来控制元素的图层 位置，⽽且 <code>z-index 只能影响设置了 position 值的元素</code>。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>这个属性是个“拼爹”的属性。(如果父元素层级低，那么子元素再怎么努力都没有用 <a href="https://blog.csdn.net/ccq2y/article/details/82143283" target="_blank" >见</a></p></blockquote><h3 id="7-阶层叠"><a href="#7-阶层叠" class="headerlink" title="7 阶层叠"></a>7 阶层叠</h3><!-- <img src="http://t-blog-images.aijs.top/img/20220717205730.png" /> --><img src="http://t-blog-images.aijs.top/img/20220717215517.png" /><p>上图从底到上：</p><pre class="line-numbers language-none"><code class="language-none">背景 ---------&gt; 布局相关 -------&gt; 内容相关 ---------------------------------&gt;      |                                   |                    ｜z-index负值                            z-index0&#x2F;不依赖z-index   z-index正值</code></pre><ul><li>如果元素的层叠级别一样，没有别的因素干扰，则遵循后来者居上原则。<a href="https://zhuanlan.zhihu.com/p/115951908" target="_blank" >见</a></li></ul><p><a href="https://blog.csdn.net/weixin_30607659/article/details/101594118" target="_blank" >CSS 7 阶层叠水平</a></p><h3 id="如何比较两个-DOM-元素的显示顺序呢"><a href="#如何比较两个-DOM-元素的显示顺序呢" class="headerlink" title="如何比较两个 DOM 元素的显示顺序呢"></a>如何比较两个 DOM 元素的显示顺序呢</h3><!-- - 1、同一个层叠上下文，层叠级别大的元素在上- 2、同一个层叠上下文，层叠级别相同，后来居上- 3、不同的层叠上下文，由父级元素层叠上下文决定 --><ul><li>如果是<code>在不同的层叠上下文中</code>，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下, 这个两个元素所在的局部层叠上下文的层叠水平。</li><li>如果是<code>在相同的层叠上下文</code>，按照层叠水平的规则来显示元素; 层叠级别相同，后来居上</li></ul><h3 id="为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？"><a href="#为什么-inlin-block-和-inline-的层叠顺序比浮动元素和块级元素都高？" class="headerlink" title="为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？"></a>为什么 inlin-block 和 inline 的层叠顺序比浮动元素和块级元素都高？</h3><p>因为 float 和块级元素一般都作布局，内联元素都是内容。而一个网页中最重要的就是内容，所以一定要让内容的层叠顺序相当高，这样可以在发生层叠时，重要的图片、文字内容可以优先暴露在屏幕上。</p><p><a href="https://segmentfault.com/a/1190000021602879?sort=newest" target="_blank" >重学前端之 CSS(三)BFC 与层叠上下文</a></p><h2 id="块级格式化上下文"><a href="#块级格式化上下文" class="headerlink" title="块级格式化上下文"></a>块级格式化上下文</h2><h3 id="BFC-是什么"><a href="#BFC-是什么" class="headerlink" title="BFC 是什么?"></a>BFC 是什么?</h3><p>书⾯解释：BFC(Block Formatting Context)这⼏个英⽂拆解</p><ul><li><p><code>Box</code>: CSS 布局的基本单位，Box 是 CSS 布局的对象和基本单位， 直观点来说，就是⼀个⻚⾯是由很多个 Box 组成的，实际就是上个问题说的盒模型</p></li><li><p><code>Formatting context</code>：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤</p><p><code>简⽽⾔之，它是⼀块独⽴的区域，让处于 BFC 内部的元素与外部的元素互相隔离</code></p></li></ul><h3 id="如何形成"><a href="#如何形成" class="headerlink" title="如何形成?"></a>如何形成?</h3><p>BFC 触发条件:</p><ul><li><code>根元素</code>，即 HTML 元素</li><li><code>float</code> 不为 none</li><li><code>display</code> 的值为 inline-block、table-cell、table-caption(表格标题)</li><li><code>position</code>: fixed&#x2F;absolute</li><li><code>overflow</code> 不为 visible</li></ul><h3 id="BFC-特点"><a href="#BFC-特点" class="headerlink" title="BFC 特点"></a>BFC 特点</h3><p><a href="https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA" target="_blank" >BFC 的特点</a></p><ul><li>1、在一个 BFC 内部，<code>盒子会在垂直方向上排列</code></li><li>2、在一个 BFC 内部，<code>相邻的 margin-bottom 和 margin-top 叠加</code></li><li>3、在一个 BFC 内部，<code>每个元素左边紧贴着包含盒子的左边</code></li><li>4、在一个 BFC 内部，<code>如果有一个内部元素是一个新的 BFC，则新 BFC 区域不会与 float 元素的区域重叠</code></li><li>5、计算一个 BFC 高度时，<code>内部浮动元素的高度也会参与计算</code></li></ul><h3 id="作⽤是什么？"><a href="#作⽤是什么？" class="headerlink" title="作⽤是什么？"></a>作⽤是什么？</h3><ul><li>防⽌ <code>margin重叠</code></li><li>两栏布局，防⽌<code>⽂字环绕</code>等</li><li>防⽌<code>元素塌陷</code></li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。</p><h3 id="标准盒模型-x2F-怪异盒模型"><a href="#标准盒模型-x2F-怪异盒模型" class="headerlink" title="标准盒模型&#x2F;怪异盒模型"></a>标准盒模型&#x2F;怪异盒模型</h3><p>在 W3C 标准下，我们定义元素的 width 值即为盒模型中的 content 的宽度值，height 值即为盒模型中的 content 的⾼度值。 因此，</p><p><strong>标准盒模型下：</strong></p><p><code>元素的宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</code></p><img src="http://t-blog-images.aijs.top/img/20220718000736.png" /><p><strong>IE 怪异盒模型</strong></p><p>（IE8 以下）width 的宽度并不是 content 的宽度，⽽是</p><p><code>元素的宽度 = margin-left + width + margin-right</code></p><p>对于 width,</p><p><code>width = border-left + padding-left + content 的宽度值 + padding-right + border-right</code>，height 同理。</p><img src="http://t-blog-images.aijs.top/img/20220718000754.png" /><p><code>现代浏览器默认使⽤ W3C 的标准盒模型</code>，在不少情况下怪异盒模型更好⽤，于是 W3C 在 css3 中加⼊ <code>box-sizing</code> 。</p><p><code>box-sizing: content-box</code> &#x2F;&#x2F; 标准盒模型<br><code>box-sizing: border-box</code> &#x2F;&#x2F; 怪异盒模型<br><code>box-sizing: padding-box</code> &#x2F;&#x2F; ⽕狐的私有模型，没⼈⽤</p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>可以使用一个，两个或三个值来指定 flex 属性。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>元素会根据自身宽高来设置尺寸。它是完全非弹性的：<span style="color: red">既不会缩短，也不会伸长</span> 来适应 flex 容器。相当于将属性设置为<code>&quot;flex: 0 0 auto&quot;</code>。</p>  <br/>  <br/><h3 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h3><p>元素会根据自身宽高设置尺寸。它 <span style="color: red">会缩短自身以适应 flex 容器，但不会伸长并吸收 </span> flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为<code>&quot;flex: 0 1 auto&quot;</code>。<br><br/><br><br/></p><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>元素会根据自身的宽度与高度来确定尺寸，但是 <span style="color: red">会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应</span> flex 容器。这相当于将属性设置为 <code>&quot;flex: 1 1 auto&quot;</code>.</p><h3 id="单值语法"><a href="#单值语法" class="headerlink" title="单值语法:"></a>单值语法:</h3><p>值必须为以下其中之一:</p><ul><li>一个无单位数(<code>&lt;number&gt;</code>): 它会被当作 flex:<code>&lt;number&gt;</code> 1 0; 解释：<code>&lt;flex-shrink&gt;</code>的值被假定为 1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为 0。</li><li>一个有效的宽度(width)值: 它会被当作 <code>&lt;flex-basis&gt;</code>的值。</li><li>关键字 none，auto 或 initial.</li></ul><h3 id="双值语法"><a href="#双值语法" class="headerlink" title="双值语法:"></a>双值语法:</h3><p>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。第二个值必须为以下之一：</p><ul><li>无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li><li>有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li></ul><h3 id="三值语法"><a href="#三值语法" class="headerlink" title="三值语法:"></a>三值语法:</h3><ul><li>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li></ul><p><a href="/#/post/2022-05-23width0" target="_blank" >见</a></p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p><a href="https://www.cnblogs.com/xiaohuochai/p/5848612.html" target="_blank" >深入理解 CSS Media 媒体查询</a></p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>媒体查询包含⼀个可选的媒体类型和，满⾜ CSS3 规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为 true 或 false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式 的值都是 true，那么该媒体查询的结果为 true.那么媒体查询内的样式将会⽣效。<br>媒体查询，用于<code>响应适配</code>。</p><h3 id="如何使⽤？"><a href="#如何使⽤？" class="headerlink" title="如何使⽤？"></a>如何使⽤？</h3><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>媒体属性必须用括号()包起来，否则无效</p></div><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; media&#x3D;&quot;(max-width: 800px)&quot; href&#x3D;&quot;example.css&quot; &#x2F;&gt;&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;  @media (max-width: 600px) &#123;    .facet_sidebar &#123;      display: none;    &#125;  &#125;&lt;&#x2F;style&gt;</code></pre><h3 id="常见媒体属性"><a href="#常见媒体属性" class="headerlink" title="常见媒体属性"></a>常见媒体属性</h3><ul><li><p>设备宽高比（device-aspect-ratio）</p></li><li><p>设备高度（device-height）</p></li><li><p>设备宽度（device-width）</p></li><li><p>方向（orientation）值：landscape(横屏) | portrait(竖屏)</p></li><li><p>分辨率（resolution）像素密度</p></li></ul><h3 id="print-x2F-screen"><a href="#print-x2F-screen" class="headerlink" title="print&#x2F;screen"></a>print&#x2F;screen</h3><p>不用括号</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot; media&#x3D;&quot;print&quot; &#x2F;&gt;&lt;style&gt;  @media print &#123;  &#125;&lt;&#x2F;style&gt;</code></pre><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>操作符 not、and、only 和逗号(,)可以用来构建复杂的媒体查询</p><h3 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h3><p>如果媒体查询@media 使用的是相对单位，<span style="color: red">如 rem，这里有一个坑需要着重强调一下</span></p><p><span style="color: red">一般而言，rem 是相对于 HTML 的字体大小的。但是，由于媒体查询的级别非常高，它并不是 HTML 的子元素，不是相对于 HTML，而是相对于浏览器的，而浏览器的默认字体大小是 16px</span></p><p>如果 HTML 设置字体大小为 12px，设置如下媒体查询</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">media&#x3D;&quot;only screen and (max-width:1rem)&quot;</code></pre><p>实际上，max-width 等于 16px，而不是 12px</p><p>而正是<code>由于媒体查询是相对于浏览器的</code>， 所以使用 rem 就没有必要，完全可以使用 em 来替代</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">media&#x3D;&quot;only screen and (max-width:1em)&quot;</code></pre><h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><h3 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h3><p><span style="color: red">浏览器采用流式布局</span><br>浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就形成渲染树<br>有了渲染树，我们就知道所有节点的样式，然后计算他们在页面上的大小和位置，把它们绘制到页面上</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>注意：浏览器采用流式布局，对渲染树的计算只需要遍历一次就能完成，<span style="color: red">但 table 布局除外，他需要花费 3 倍的时间</span> ，所以我们要尽量避免使用 table 布局</p></blockquote><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><ul><li><code>影响部分或全部页面的布局时，会进行回流</code>，回流的代价比重绘高</li><li><code>回流一定会引起重绘，但重绘不一定会引起回流</code></li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>元素样式发生变化，但是<code>不影响页面整个布局的情况下会进行重绘</code>，如 outline、visibility、color、background-color 等</p><h3 id="浏览器优化"><a href="#浏览器优化" class="headerlink" title="浏览器优化"></a>浏览器优化</h3><p>浏览器是<code>通过队列机制来批量更新布局</code>，浏览器刷新频率为（60 帧&#x2F;s）,每刷新一次需要 16.6ms，也就是说 16.6ms 浏览器会清空队列，但是在我们获取布局信息的时候，有一些属性或方法会强制浏览器刷新，触发重绘和回流并且清空队列，比如：</p><ul><li>offset 系列：<code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code> <a href="https://www.jb51.net/article/219621.htm" target="_blank" >距离元素最近的一个具有定位的祖宗元素（relative，absolute，fixed），若祖宗都不符合条件，offsetParent 为 body</a></li><li>scroll 系列： <code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code> <a href="https://blog.csdn.net/muxi229/article/details/106849535" target="_blank" >方法返回或设置匹配元素的滚动条的偏移位置</a></li><li>client 系列：<code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code> clientTop、clientLeft 获取的是上边框、左边框的宽度 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientLeft" target="_blank" >见 MDN</a></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle()</code> 用于获取指定元素的 CSS 样式</li><li><code>getBoundingClientRect()</code> 用于获取某个元素相对于视窗的位置集合。集合中有 top, right, bottom, left 等属性。</li></ul><p>强制触发浏览器刷新,所以我们要尽量少使用以上属性和方法</p><h3 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h3><ul><li><code>替代方案</code><br>使用 transform 代替 top<br>使用 visibility(只触发重绘)代替 display(触发回流)</li><li><code>嵌套层级</code><br>尽可能在 DOM 树的末端改变样式类 class，影响尽量少的节点<br>css 选择器尽量不要嵌套过深，从右往左匹配</li><li><code>动画</code><br>动画效果最好添加到 <code>position：absolute 或 fixed 的元素上，不影响其他元素</code>，只引发重绘，不引发回流，控制动画的速度可以使用 <code>requestAnimationFrame()</code></li><li><code>css 表达式</code><br>避免使用 css 表达式，calc()会引发回流</li><li><code>设为图层</code><br>将频繁重绘或回流的节点设置为图层，如：will-change，video，iframe，cavas，防止影响别的节点</li><li><code>CSS3 硬件加速</code>，transform，opacity 等不会引起回流重绘</li><li>批量操作使用 <code>documentFragment</code>,批量更新，虚拟 dom</li></ul><p><a href="https://www.jianshu.com/p/bf5c498107e2" target="_blank" >参考链接</a></p><h2 id="层叠、优先级和继承"><a href="#层叠、优先级和继承" class="headerlink" title="层叠、优先级和继承"></a>层叠、优先级和继承</h2><p>决定着如何将 CSS 应用到 HTML 中，以及如何解决冲突。</p><h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><ul><li>简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。</li></ul><p>三要素：资源顺序，优先级，重要程度</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>高的优先级——它范围更小</li><li>覆盖 <code>!important</code> 唯一的办法就是另一个 <code>!important</code> 具有相同优先级而且顺序靠后，<code>或者更高优先级</code>。</li><li>!important 非必要不使用，影响调试</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#!important" target="_blank" >见</a></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>表单元素默认不会继承字体样式</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Images_media_form_elements#:~:text=%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%EF%BC%8C-,%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BC%9A%E7%BB%A7%E6%89%BF%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F,-%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%A6%82%E6%9E%9C%E4%BD%A0" target="_blank" >见</a></p><h2 id="display-inline-block"><a href="#display-inline-block" class="headerlink" title="display: inline-block"></a>display: inline-block</h2><p>在内联和块之间提供了一个中间状态。这对于以下情况非常有用：您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠</p><p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<a> 是像 <span> 一样的内联元素；你可以使用 display: inline-block 来设置内边距，让用户更容易点击链接</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#%E4%BD%BF%E7%94%A8_display_inline-block" target="_blank" >见</a></p><h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的内联尺寸进行计算的，也就是元素的水平宽度。在我们的示例中，所有的外边距或填充都是宽度的 10%。请记住一个事实，当你使用百分比作为元素外边距或填充的单位时，你将得到一个相同尺寸的外边距或填充。</p><h2 id="max-width-的常见用法为，"><a href="#max-width-的常见用法为，" class="headerlink" title="max-width 的常见用法为，"></a>max-width 的常见用法为，</h2><p>在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。</p><p>作为示例，如果你设定一个图像的属性为 width: 100%，而且它的原始宽度小于容器，图像会被强制拉伸以变大，看起来像素更加明显。如果它的原始宽度大于容器，它则会溢出。两种情形都不是你想要看到的。</p><p>如果你使用了 max-width: 100%，那么图像可以变得比原始尺寸更小，但是不会大于原始尺寸的 100%。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS#min-%E5%92%8C_max-%E5%B0%BA%E5%AF%B8:~:text=%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E3%80%82-,max%2Dwidth%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E4%B8%BA,-%EF%BC%8C%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%B6%B3%E5%A4%9F" target="_blank" >见</a></p><p><span style="color: red">这个技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放</span></p><h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><h2 id="替换元素-与-普通元素的区别"><a href="#替换元素-与-普通元素的区别" class="headerlink" title="替换元素 与 普通元素的区别"></a><code>替换元素</code> 与 <code>普通元素</code>的区别</h2><h3 id="什么是替换元素"><a href="#什么是替换元素" class="headerlink" title="什么是替换元素"></a>什么是替换元素</h3><p>图像和视频被描述为<strong>替换元素</strong></p><h3 id="与普通区别"><a href="#与普通区别" class="headerlink" title="与普通区别"></a>与普通区别</h3><ul><li>CSS 不能影响它们的内部布局, 仅影响它们在页面上相对于其它元素的位置</li><li>flex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。</li></ul><h2 id="介绍下-Web-字体"><a href="#介绍下-Web-字体" class="headerlink" title="介绍下 Web 字体"></a>介绍下 Web 字体</h2><h3 id="声明及使用"><a href="#声明及使用" class="headerlink" title="声明及使用"></a>声明及使用</h3><p>CSS 有一个@font-face 块，它指定要下载的字体文件：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css">@font-face &#123;  font-family: &quot;myFont&quot;;  src: url(&quot;myFont.ttf&quot;);&#125;&#x2F;* 使用 *&#x2F;html &#123;  font-family: &quot;myFont&quot;, &quot;Bitstream Vera Serif&quot;, serif;&#125;&#x2F;* 详细使用 *&#x2F;@font-face &#123;  font-family: &quot;ciclefina&quot;;  src: url(&quot;fonts&#x2F;cicle_fina-webfont.eot&quot;);  &#x2F;* 字体路径及文件格式 *&#x2F;  src: url(&quot;fonts&#x2F;cicle_fina-webfont.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.woff2&quot;)      format(&quot;woff2&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.woff&quot;) format(&quot;woff&quot;), url(&quot;fonts&#x2F;cicle_fina-webfont.ttf&quot;)      format(&quot;truetype&quot;),    url(&quot;fonts&#x2F;cicle_fina-webfont.svg#ciclefina&quot;) format(&quot;svg&quot;);  font-weight: normal;  font-style: normal;&#125;</code></pre><h3 id="字体使用注意点"><a href="#字体使用注意点" class="headerlink" title="字体使用注意点"></a>字体使用注意点</h3><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>例如，</p><ul><li>大多数现代浏览器都支持 WOFF &#x2F; WOFF2(Web Open Font Format versions 1 and 2，Web 开放字体格式版本 1 和 2)，它是最有效的格式，</li><li>但是旧版本 IE 只支持 EOT (Embedded Open Type，嵌入式开放类型) 的字体，</li><li>你可能需要包括一个 SVG 版本的字体支持旧版本的 iPhone 和 Android 浏览器。</li></ul><h3 id="付费"><a href="#付费" class="headerlink" title="付费"></a>付费</h3><p>字体一般都不能自由使用。您必须为他们付费，或者遵循其他许可条件，比如在代码中 (或者在您的站点上) 提供字体创建者。你不应该在没有适当的授权的情况下偷窃字体。</p><h3 id="字体查找"><a href="#字体查找" class="headerlink" title="字体查找"></a>字体查找</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Styling_text/Web_fonts#%E6%9F%A5%E6%89%BE%E5%AD%97%E4%BD%93" target="_blank" >见</a></p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><h3 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h3><p>引入 float 属性是为了能让 Web 开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在它的左边或右边。你可能在报纸版面上看到过</p><h3 id="浮动是如何工作的"><a href="#浮动是如何工作的" class="headerlink" title="浮动是如何工作的"></a>浮动是如何工作的</h3><p>浮动元素 (这个例子中的 <code>&lt;div&gt;</code> 元素) 会脱离正常的文档布局流，并吸附到其父容器的左边（这个例子中的 <code>&lt;body&gt;</code> 元素）。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间</p><h3 id="清除浮动-3-中方式"><a href="#清除浮动-3-中方式" class="headerlink" title="清除浮动 3 中方式"></a>清除浮动 3 中方式</h3><ul><li>伪元素方法</li><li>使用 overflow : 将包裹元素的 overflow 属性设置为除 visible 外的其他值</li><li>display: flow-root: 一个较为现代的方案是使用 display 属性的 flow-root 值</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* 伪元素方法 *&#x2F;.wrapper::after &#123;  content: &quot;&quot;;  clear: both;  display: block;&#125;&#x2F;* 将包裹元素的 overflow 属性设置为除 visible 外的其他值 *&#x2F;.wrapper &#123;  background-color: rgb(79, 185, 227);  padding: 10px;  color: #fff;  overflow: auto;&#125;.wrapper &#123;  background-color: rgb(79, 185, 227);  padding: 10px;  color: #fff;  display: flow-root;&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/202210261409914.webp" /><h2 id="介绍下-flex"><a href="#介绍下-flex" class="headerlink" title="介绍下 flex"></a>介绍下 flex</h2><h3 id="flex-出现解决了什么问题"><a href="#flex-出现解决了什么问题" class="headerlink" title="flex 出现解决了什么问题"></a>flex 出现解决了什么问题</h3><p>长久以来，CSS 布局中唯一可靠且跨浏览器兼容的创建工具只有 floats 和 positioning。这两个工具大部分情况下都很好使，但是在某些方面它们具有一定的局限性，让人难以完成任务</p><ul><li>在父内容里面垂直居中一个块内容。</li><li>使容器的<code>所有子项占用等量的可用宽度/高度</code>，而不管有多少宽度&#x2F;高度可用。</li><li>使<code>多列布局中的所有列采用相同的高度</code>，即使它们包含的内容量不同。</li></ul><p>弹性盒子使得很多布局任务变得更加容易</p><h3 id="flex-布局的特点"><a href="#flex-布局的特点" class="headerlink" title="flex 布局的特点"></a>flex 布局的特点</h3><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png" /><ul><li>主轴</li><li>交叉轴</li><li>flex 容器（flex container）</li><li>flex 项(flex item)</li></ul><h3 id="行还是列"><a href="#行还是列" class="headerlink" title="行还是列"></a>行还是列</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">flex-direction</code></pre><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">flex-wrap: wrap; &#x2F;**换行 *&#x2F;</code></pre><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">flex-direction: row;flex-wrap: wrap;&#x2F;* 简写 *&#x2F;flex-flow: row wrap;</code></pre><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><ul><li>默认值：stretch, 会使 flex 项沿着交叉轴的方向拉伸，以填充父容器</li><li>center</li><li>flex-start,flex-end,在交叉轴开始&#x2F;结束处对齐</li></ul><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><ul><li>默认值：flex-start, 会使所有的 flex 项都位于主轴开始处</li><li>flex-end 使 flex 项位于结尾处</li><li>center, 让 flex 项在主轴中居中</li><li>space-around 使所有 flex 项在主轴均匀分布，任意一端会留一点空间</li><li>space-between 与 space-around 类似，两端不留空间</li></ul><h3 id="flex-项排序"><a href="#flex-项排序" class="headerlink" title="flex 项排序"></a>flex 项排序</h3><p>可以改变 flex 项的布局位置的功能，而<code>不会影响 dom 树里元素的顺序</code></p><ul><li>默认 order 使 0</li><li>order 越大越靠后</li><li>相同 order，按 dom 树顺序排布（也就是没啥影响）</li></ul><h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><p>响应式 Web 设计不是单独的技术，它是描述 Web 设计的一种方式、或者是一组最佳实践的一个词，它是用来建立可以响应查看内容的设备的样式的一个词</p><h3 id="出现的背景"><a href="#出现的背景" class="headerlink" title="出现的背景"></a>出现的背景</h3><p>响应式设计之前的灵活布局，根据不同屏幕分辨率进行探测，载入对应的 css</p><h3 id="响应式设计包含三部分"><a href="#响应式设计包含三部分" class="headerlink" title="响应式设计包含三部分"></a>响应式设计包含三部分</h3><ul><li>液态网格</li><li>液态图像</li><li>媒体查询</li></ul><h3 id="响应式设计-1"><a href="#响应式设计-1" class="headerlink" title="响应式设计"></a>响应式设计</h3><ul><li><em>断点：</em>媒体查询，以及样式改变时的点，被叫做断点（breakpoints）</li><li><em>移动优先：</em>为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局</li></ul><h3 id="响应式图像"><a href="#响应式图像" class="headerlink" title="响应式图像"></a>响应式图像</h3><ul><li>可以用一张有着所需最大尺寸的图像。然后缩放它</li><li>响应式图像，使用了<code>&lt;picture&gt;</code>元素和<code>&lt;img&gt;</code> srcset 和 sizes 特性，解决了这两个问题</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* 方案1 *&#x2F;img &#123;  max-width: 100%:&#125;&#x2F;* 方案2，响应式图像 *&#x2F;</code></pre><h2 id="视口元标签"><a href="#视口元标签" class="headerlink" title="视口元标签"></a>视口元标签</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1&quot; &#x2F;&gt;</code></pre><h3 id="为什么需要视口元标签"><a href="#为什么需要视口元标签" class="headerlink" title="为什么需要视口元标签"></a>为什么需要视口元标签</h3><p>因为移动端浏览器倾向于在它们的视口宽度上说谎。</p><p>由于原来 iPhone 发布以后，人们开始在小的手机屏幕上阅览网页，而大多数站点未对移动端做优化的缘故。移动端浏览器因此会把视口宽度设为 960 像素，并以这个宽度渲染页面，结果展示的是桌面布局的缩放版本</p><p>其他的移动端浏览器（例如谷歌安卓上的）也是这么做的</p><p>没有做响应式的网站，依然可以看到，不过，很少见了</p><h2 id="媒体查询-1"><a href="#媒体查询-1" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用</p><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕） *&#x2F;&#x2F;* 媒体类型： all、print、screen、speech *&#x2F;&#x2F;* 一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试； *&#x2F;&#x2F;* 宽和高，orientation portrait：竖屏 landscape 横屏 *&#x2F;&#x2F;* 一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。 *&#x2F;@media media-type and (media-feature-rule) &#123;  &#x2F;* CSS rules go here *&#x2F;&#125;</code></pre><h3 id="与-x2F-或-x2F-非"><a href="#与-x2F-或-x2F-非" class="headerlink" title="与&#x2F;或&#x2F;非"></a>与&#x2F;或&#x2F;非</h3><pre class="line-numbers language-css" data-language="css"><code class="language-css">&#x2F;* 与：使用and *&#x2F;@media screen and (min-width: 400px) and (orientation: landscape) &#123;  body &#123;    color: blue;  &#125;&#125;&#x2F;* 或：使用逗号 *&#x2F;@media screen and (min-width: 400px), screen and (orientation: landscape) &#123;  body &#123;    color: blue;  &#125;&#125;&#x2F;* 非：使用not *&#x2F;@media not all and (orientation: landscape) &#123;  body &#123;    color: blue;  &#125;&#125;</code></pre><h3 id="选择断点"><a href="#选择断点" class="headerlink" title="选择断点"></a>选择断点</h3><p><code>开发工具响应式设计模式</code>能很好地帮助弄清楚断点应该设置在哪里。<br>你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/" target="_blank" >深入研究-webkit-overflow-scrolling:touch 及 ios 滚动 </a></p><p><a href="https://blog.csdn.net/weixin_30607659/article/details/101594118" target="_blank" >CSS 7 阶层叠水平</a></p><p><a href="https://www.shuzhiduo.com/A/qVdeBaYAzP/#:~:text=auto%E3%80%81hidden%E3%80%81scroll-,BFC%E7%9A%84%E7%89%B9%E7%82%B9,-1%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA" target="_blank" >BFC 的特点</a></p><p><a href="https://www.cnblogs.com/xiaohuochai/p/5848612.html" target="_blank" >深入理解 CSS Media 媒体查询</a></p><p><a href="/#/post/2022-05-23width0" target="_blank" >flex width:0</a></p><pre class="line-numbers language-none"><code class="language-none"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-html</title>
      <link href="//post/2022-07-17html.html"/>
      <url>//post/2022-07-17html.html</url>
      
        <content type="html"><![CDATA[<h2 id="doctype-的作⽤是什么？"><a href="#doctype-的作⽤是什么？" class="headerlink" title="doctype 的作⽤是什么？"></a>doctype 的作⽤是什么？</h2><p><code>DOCTYPE</code> 是 html5 标准⽹⻚声明，且必须声明在 HTML ⽂档的第⼀⾏。</p><p><code>来告知浏览器的解析器⽤什么⽂档标准解析这个⽂档</code>，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析</p><p><strong>⽂档解析类型有：</strong></p><ul><li>BackCompat：<code>怪异模式</code>，浏览器使⽤⾃⼰的怪异模式解析渲染⻚⾯。（如果没有声明 DOCTYPE，默认就是这个 模式）</li><li>CSS1Compat：<code>标准模式</code>，浏览器使⽤ W3C 的标准解析渲染⻚⾯。</li></ul><h2 id="这三种模式的区别是什么？"><a href="#这三种模式的区别是什么？" class="headerlink" title="这三种模式的区别是什么？"></a>这三种模式的区别是什么？</h2><ul><li><code>标准模式(standards mode)</code>：⻚⾯按照 HTML 与 CSS 的定义渲染</li><li><code>怪异模式(quirks mode)模式</code>： 会模拟更旧的浏览器的⾏为</li><li><code>近乎标准(almost standards)模式</code>： 会实施了⼀种表单元格尺⼨的怪异⾏为（与 IE7 之前的单元格布局⽅式⼀致）， 除此之外符合标准定义</li></ul><h2 id="HTML、XHTML、XML-有什么区别"><a href="#HTML、XHTML、XML-有什么区别" class="headerlink" title="HTML、XHTML、XML 有什么区别"></a>HTML、XHTML、XML 有什么区别</h2><ul><li><code>HTML(超⽂本标记语⾔)</code>: 在 <code>html4.0 </code>之前 HTML 先有实现再有标准，导致 HTML ⾮常混乱和松散</li><li><code>XML(可扩展标记语⾔)</code>: 主要<code>⽤于存储数据和结构</code>，可扩展，⼤家熟悉的 JSON 也是相似的作⽤，但是更加轻量⾼ 效，所以 XML 现在市场越来越⼩了</li><li><code>XHTML(可扩展超⽂本标记语⾔)</code>: 基于上⾯两者⽽来，W3C 为了解决 HTML 混乱问题⽽⽣，并<code>基于此诞⽣了 HTML5</code>，开头加⼊ <code>&lt;!DOCTYPE html&gt;</code> 的做法因此⽽来，如果不加就是兼容混乱的 HTML，加了就是标准模式。</li></ul><h2 id="什么是-data-属性？"><a href="#什么是-data-属性？" class="headerlink" title="什么是 data-属性？"></a>什么是 data-属性？</h2><p>HTML 的数据属性，⽤于将数据储存于标准的 HTML 元素中作为额外信息,<code>可以通过 js 访问并操作它，来达到操作数据的⽬的</code>。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;article  id&#x3D;&quot;electriccars&quot;  data-columns&#x3D;&quot;3&quot;  data-index-number&#x3D;&quot;12314&quot;  data-parent&#x3D;&quot;cars&quot;&gt;  ...&lt;&#x2F;article&gt;</code></pre><h2 id="你对-HTML-语义化的理解？"><a href="#你对-HTML-语义化的理解？" class="headerlink" title="你对 HTML 语义化的理解？"></a>你对 HTML 语义化的理解？</h2><p>语义化是指使⽤恰当语义的 html 标签，让⻚⾯具有良好的结构与含义，⽐如 <code>&lt;p&gt;</code> 标签就代表段落， <code>&lt;article&gt;</code> 代表正⽂ 内容等等。 语义化的好处主要有两点：</p><ul><li><code>开发者友好</code>：使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构，也更为便于团队的开发和维护</li><li><code>机器友好</code>：带有语义的⽂字表现⼒丰富，<code>更适合搜索引擎的爬⾍爬取有效信息</code>，语义类还可以<code>⽀持读屏软件</code>，根据 ⽂章可以⾃动⽣成⽬录 这对于简书、知乎这种富⽂本类的应⽤很重要，语义化对于其⽹站的内容传播有很⼤的帮助</li></ul><h2 id="有哪些常⽤的-meta-标签？"><a href="#有哪些常⽤的-meta-标签？" class="headerlink" title="有哪些常⽤的 meta 标签？"></a>有哪些常⽤的 meta 标签？</h2><p><em>No1.</em> meta 标签由<code>name</code>和<code>content</code>两个属性来定义，来描述⼀个 HTML ⽹⻚⽂档的属性，例如</p><ul><li><code>作者</code>、</li><li><code>关键词</code>、</li><li><code>⽹⻚描述</code>、</li><li><code>⽇期和时间</code>、</li><li><code>⻚⾯刷新</code>等，除了⼀些 http 标准规定了⼀些 name 作为⼤家使⽤的共识，</li><li>开发者<code>也可以⾃定义 name</code>。</li></ul><p><em>No2.</em> <code>charset</code>，⽤于描述 HTML ⽂档的编码形式 <code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code></p><p><em>No3.</em> <code>http-equiv</code><span style="color: red">（http 等效）</span>，顾名思义，相当于 http 的⽂件头作⽤,⽐如下⾯的代码就可以设置 http 的缓存过期⽇期 HTML</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot; &#x2F;&gt;</code></pre><p><em>No4.</em> <code>viewport</code>，移动前端最熟悉不过，Web 开发⼈员可以控制视⼝的⼤⼩和⽐例</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta  name&#x3D;&quot;viewport&quot;  content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, minimum-scale&#x3D;1 &quot;&#x2F;&gt;</code></pre><p><em>No5.</em> <code>apple-mobile-web-app-status-bar-style</code>,开发过 PWA 应⽤的开发者应该很熟悉，为了⾃定义评估⼯具栏的颜⾊。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta  name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot;  content&#x3D;&quot;black-translucent&quot;&#x2F;&gt;</code></pre><p><em>No6.</em> <code>iphoneX适配的 viewport-fit=cover</code></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width...... viewport-fit&#x3D;cover&quot; &#x2F;&gt;&lt;style&gt;  @supports (bottom: env(safe-area-inset-bottom)) &#123;    body,    .footer（底部栏） &#123;      padding-bottom: constant(safe-area-inset-bottom);      padding-bottom: env(safe-area-inset-bottom);    &#125;  &#125;&lt;&#x2F;style&gt;</code></pre><p><em>No7.</em> <code>format-detection</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&#x2F; telephone&#x3D;no 就禁止了把数字转化为拨号链接！meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;email&#x3D;no&quot; &#x2F;&#x2F; email&#x3D;*no 禁止作为邮箱地址！meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;adress&#x3D;no&quot;&#x2F;&#x2F; adress&#x3D;*no 禁止跳转至地图！</code></pre><p>作者：优瑞囧<br>链接：<a href="https://www.jianshu.com/p/82a85a53d5b4">https://www.jianshu.com/p/82a85a53d5b4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="爬取脚本"><a href="#爬取脚本" class="headerlink" title="爬取脚本"></a>爬取脚本</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.body.append(location.origin + &quot;\n&quot;);Array.from(document.getElementsByTagName(&quot;meta&quot;)).forEach((item) &#x3D;&gt; &#123;  document.body.append(&#96;$&#123;item.name&#125; : $&#123;item.content&#125;标记&#96;);&#125;);</code></pre><h3 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; https:&#x2F;&#x2F;juejin.cn&#x2F;&#x2F; viewport : width&#x3D;device-width, initial-scale&#x3D;1, user-scalable&#x3D;*no,* viewport-fit&#x3D;cover&#x2F;&#x2F; apple-itunes-app : app-id&#x3D;987739104&#x2F;&#x2F; theme-color : #ffffff&#x2F;&#x2F; msapplication-TileColor : #da532c&#x2F;&#x2F; description : zoomdong的收藏集：面经 —— 共收录了13篇文章，有0人关注了该收藏。&#x2F;&#x2F; keywords : 面经,面经zoomdong,zoomdong的收藏,面经掘金,掘金</code></pre><h2 id="src-和-href-的区别？"><a href="#src-和-href-的区别？" class="headerlink" title="src 和 href 的区别？"></a>src 和 href 的区别？</h2><p><code>src 是指向外部资源的位置</code>，</p><ul><li><p>资源插入到：指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，如 js 脚本，img 图⽚和 frame 等元素。</p></li><li><p>阻塞其他资源：<code>当浏览器解析到该元素时，会暂停其他资源的下载和处理</code>，指导将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在底部⽽不是头部。</p></li><li><p>指向资源：<code>href 是指向⽹络资源所在位置（的超链接）</code>，⽤来建⽴和当前元素或⽂档之间的连接，</p></li><li><p>并行下载：当浏览器识别到它他指向的 ⽂件时，就会<code>并⾏下载资源</code>，<code>不会停⽌对当前⽂档的处理</code>。</p></li></ul><h2 id="知道-img-的-srcset-的作⽤是什么？"><a href="#知道-img-的-srcset-的作⽤是什么？" class="headerlink" title="知道 img 的 srcset 的作⽤是什么？"></a>知道 img 的 srcset 的作⽤是什么？</h2><p>可以设计响应式图⽚，我们可以使⽤两个新的属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择 正确的⼀个资源。</p><p><code>srcset</code> 定义了我们允许浏览器选择的图像集，以及每个图像的⼤⼩。</p><p><code>sizes</code> 定义了⼀组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图⽚尺⼨是最佳选择。</p><p>所以，有了这些属性，浏览器会： 查看设备宽度 检查 sizes 列表中哪个媒体条件是第⼀个为真 查看给予该媒体查询的槽⼤⼩ 加载 srcset 列表中引⽤的最接近所选的槽⼤⼩的图像</p><p><code>&lt;picture&gt; </code>元素通过包含零或多个<code>&lt;source&gt;</code>元素和⼀个 <code>&lt;img&gt; </code>元素来为不同的显示&#x2F;设备场景提供图像版本。浏览器会选择最匹配的⼦ <code>&lt;source&gt; </code>元素，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的 URL。然后，所选图像呈现 在<code> &lt;img&gt;</code> 元素占据的空间中</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;picture&gt;  &lt;source    srcset&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;surfer-240-200.jpg&quot;    media&#x3D;&quot;(min-width: 800px)&quot;  &#x2F;&gt;  &lt;img src&#x3D;&quot;&#x2F;media&#x2F;examples&#x2F;painted-hand-298-332.jpg&quot; &#x2F;&gt;&lt;&#x2F;picture&gt;</code></pre><h2 id="script-标签中-defer-和-async-的区别？"><a href="#script-标签中-defer-和-async-的区别？" class="headerlink" title="script 标签中 defer 和 async 的区别？"></a>script 标签中 defer 和 async 的区别？</h2><ul><li>defer：浏览器指示脚本在⽂档被解析后执⾏，script 被<code>异步加载</code>后并<code>不会⽴刻执⾏</code>，⽽是<code>等待⽂档被解析完毕后执⾏</code>。</li><li>async：<code>异步加载</code>脚本，区别是<code>脚本加载完毕后⽴即执⾏</code>，这导致 async 属性下的脚本是乱序的，对于 script 有先后依赖关系的情况，并不适⽤。</li></ul><img src="http://t-blog-images.aijs.top/img/20220717111316.png" style="max-width: 100%; width: 400px" /><h2 id="有⼏种前端储存的⽅式？"><a href="#有⼏种前端储存的⽅式？" class="headerlink" title="有⼏种前端储存的⽅式？"></a>有⼏种前端储存的⽅式？</h2><p><code>cookies</code>、<code>localstorage</code>、<code>sessionstorage</code>、<code>Web SQL</code>、<code>IndexedDB</code> 这些⽅式的区别是什么？</p><ul><li><p><code>cookies</code>：<br>优点: 是兼容性好，请求头⾃带 cookie ⽅便，<br>缺点: 是⼤⼩只有 4k， ⾃动请求头加⼊ cookie 浪费流量，每个 domain 限制 20 个 cookie</p></li><li><p><code>localStorage</code>：HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删 除），⼤⼩为 5M，兼容 IE8+</p></li><li><p><code>sessionStorage</code>：与 localStorage 基本类似，区别是 sessionStorage 当⻚⾯关闭后会被清理，⽽且与 cookie、 localStorage 不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式</p></li><li><p><code>Web SQL</code>：2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实 现，web sql 类似于 SQLite，是真正意义上的关系型数据库，⽤ sql 进⾏操作，当我们⽤ JavaScript 时要进⾏转换， 较为繁琐。</p></li><li><p><code>IndexedDB</code>： 是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 <em>NoSQL 数据库，⽤键值对进⾏储存，可以进⾏快</em> 速读取操作，⾮常适合 web 场景，同时⽤ JavaScript 进⾏操作会⾮常⽅便。</p></li></ul><h2 id="两个-Tab-页面的通信方式"><a href="#两个-Tab-页面的通信方式" class="headerlink" title="两个 Tab 页面的通信方式"></a>两个 Tab 页面的通信方式</h2><p><a href="/#/post/2022-09-19qa" target="_blank" >两个 Tab 页面的通信方式</a></p><!-- **url 传参数** --><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/d9ca9f85d06e" target="_blank" >移动端 H5 适配 iphoneX 底部栏，css 快速解决方案</a></p><p><a href="https://www.w3.org/TR/css-round-display-1/#descdef-viewport-viewport-fit" target="_blank" >www.w3.org</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@viewport" target="_blank" >@viewport 已废弃</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-http</title>
      <link href="//post/2022-07-16http.html"/>
      <url>//post/2022-07-16http.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-⽅法"><a href="#HTTP-⽅法" class="headerlink" title="HTTP ⽅法"></a>HTTP ⽅法</h2><p><code>HTTP1.0</code> 定义了三种请求⽅法： <code>GET</code>, <code>POST</code> 和 <code>HEAD</code> ⽅法<br><code>HTTP1.1</code> 新增了五种请求⽅法：<code>OPTIONS</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code> 和 <code>CONNECT</code></p><h2 id="HTTP-⽅法的理论作⽤"><a href="#HTTP-⽅法的理论作⽤" class="headerlink" title="HTTP ⽅法的理论作⽤"></a>HTTP ⽅法的理论作⽤</h2><ul><li><code>GET</code>: 通常⽤于请求服务器发送某些资源</li><li><code>HEAD</code>: 请求资源的头部信息, <code>使⽤场景</code>是<code>在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</code></li><li><code>OPTIONS</code>: ⽤于获取⽬的资源所⽀持的通信选项 <span style="color: red">（在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。浏览器自动发起）</span></li><li><code>POST</code>: 发送数据给服务器</li><li><code>PUT</code>: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式</li><li><code>DELETE</code>: ⽤于删除指定的资源</li><li><code>PATCH</code>: ⽤于对资源进⾏部分修改</li><li><code>CONNECT</code>: HTTP&#x2F;1.1 协议中预留给能够将连接改为管道⽅式的代理服务器</li><li><code>TRACE</code>: 回显服务器收到的请求，主要⽤于测试或诊断</li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>理论上是这么回事，可有些研发并不一定这么操作</p></p></div><h2 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h2><p><strong>浏览器</strong><br>(1) <code>重新提交无害</code>GET 请求在浏览器回退和刷新时是无害的，而 POST 请求会告知用户数据会被重新提交；<br>(2) <code>收藏标签</code>GET 请求可以收藏为书签，POST 请求不可以收藏为书签；<br>(3) <code>请求缓存</code>GET 请求可以被缓存，POST 请求不可以被缓存，除非在响应头中包含合适的 Cache-Control&#x2F;Expires 字段，但是不建议缓存 POST 请求，其不满足幂等性，每次调用都会对服务器资源造成影响；<br><strong>请求特点</strong><br>(8) <code>安全性</code>GET 请求的安全性较差，数据被暴露在浏览器的 URL 中，所以不能用来传递敏感信息，POST 请求的安全性较好，数据不会暴露在 URL 中；<br>(9) <code>幂等性</code> GET 请求具有幂等性(多次请求不会对资源造成影响)，POST 请求不幂等；<br>(4) <code>数据传输⽅式不同</code>GET 请求一般不具有请求体，因此只能进行 url 编码，而 POST 请求支持多种编码方式。<br>(5) <code>参数缓存</code>GET 请求的参数可以被保留在浏览器的历史中，POST 请求不会被保留；<br>(6) <code>长度限制</code>GET 请求因为是向 URL 添加数据，不同的浏览器厂商，代理服务器，web 服务器都可能会有自己的长度限制，而 POST 请求无长度限制；<br>(7) <code>数据类型不同</code>GET 请求只允许 ASCII 字符，POST 请求无限制，支持二进制数据；</p><h2 id="PUT-和-POST-有什么区别？"><a href="#PUT-和-POST-有什么区别？" class="headerlink" title="PUT 和 POST 有什么区别？"></a>PUT 和 POST 有什么区别？</h2><ul><li><p>PUT ⽅法是<code>幂等</code>的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽ POST ⽅法是⾮幂 等的。</p></li><li><p>PUT 的 <code>URI 指向是具体单⼀资源</code>，⽽ POST 可以指向资源集合。</p></li></ul><p>举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤</p><ul><li><p>POST <a href="https://www.jianshu.com/articles">https://www.jianshu.com/articles</a> ， 这个请求的语义是，在 articles 的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂 等的。</p><br/><br/></li><li><p>PUT <a href="https://www.jianshu.com/articles/1">https://www.jianshu.com/articles/1</a> 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI 指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘华』修改成『刘德华』，提交多少次都是修改成『刘德华』</p></li></ul><h2 id="PUT-和-PATCH-的区别？"><a href="#PUT-和-PATCH-的区别？" class="headerlink" title="PUT 和 PATCH 的区别？"></a>PUT 和 PATCH 的区别？</h2><p><code>PUT</code> 和 <code>PATCH</code> 都是更新资源，⽽ <code>PATCH</code> ⽤来对已知资源进⾏局部更新。<code>PATCH</code>可以理解为打补丁<br>⽐如我们有⼀篇⽂章的地址 <a href="https://www.jianshu.com/articles/1">https://www.jianshu.com/articles/1</a> ,这篇⽂章的可以表示为:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">article &#x3D; &#123;  author: &quot;dxy&quot;,  creationDate: &quot;2019-6-12&quot;,  content: &quot;我写⽂章像刘德华&quot;,  id: 1,&#125;;</code></pre><p>当我们要修改⽂章的作者时，我们可以直接发送</p><p><code>PUT https://www.jianshu.com/articles/1</code> ，数据是:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  author:&#39;刘德华&#39;,  creationDate: &#39;2019-6-12&#39;,  content: &#39;我写⽂章像刘德华&#39;,  id: 1&#125;</code></pre><p>这种直接覆盖资源的修改⽅式应该⽤ put，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送</p><p><code>PATCH https://www.jianshu.com/articles/1</code> ，这个时候只需要:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123; author:&#39;刘德华&#39;, &#125;</code></pre><h2 id="HTTP-的状态码有哪些？"><a href="#HTTP-的状态码有哪些？" class="headerlink" title="HTTP 的状态码有哪些？"></a>HTTP 的状态码有哪些？</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100" target="_blank" >Web 开发技术&gt;HTTP&gt;HTTP 响应状态码</a></p><ul><li><code>100 Continue</code>,信息型状态响应码表示目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略</li><li><code>101 SwitchingProtocols</code>，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议(<code>h5的websocket使用时，会出现101状态码</code>)</li><li><code>103 Early Hints</code>,信息状态响应码，一般和 Link header（首部）一起使用，来允许用户在服务器还在准备响应数据的时候预加载一些资源。</li></ul><p><strong>2XX 成功</strong></p><ul><li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li><li><code>201 Created</code> 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴</li><li><code>202 Accepted</code> 请求已接受，但是还没执⾏，不保证完成请求</li><li><code>204 No content</code>，表示请求成功，但响应报⽂不含实体的主体部分 客户端不做更改(<code>浏览器不会刷新页面，也不会导向别的页面。对客户端说好了，你别管了</code>)</li><li><code>206 Partial Content</code>，进⾏范围请求 <span style="color: red">B 站视频播放时候会发起请求</span></li></ul><p><strong>3XX 重定向</strong></p><ul><li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li><li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 URL</li><li><code>303 see other</code>，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法丁⾹获取资源</li><li><code>304 not modified</code>，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况</li><li><code>307 temporary redirect</code>，临时重定向，和 302 含义相同</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><code>400 bad request</code>，请求报⽂存在语法错误</li><li><code>401 unauthorized</code>，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li><li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li><li><code>408 Request timeout</code>, 客户端请求超时</li><li><code>409 Confict</code>, 请求的资源可能引起冲突</li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><code>500 internal sever error</code>，表示服务器端在执⾏请求时发⽣了错误</li><li><code>501 Not Implemented</code> 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务器不⽀持的某个⽅法</li><li><code>502 Bad Gateway</code> 网关错误</li><li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li><li><code>504 Gateway timeout</code> 网关超时</li><li><code>505 http version not supported</code> 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</li></ul><p>后台一个服务器挂了，重启后正常<br><img src="http://t-blog-images.aijs.top/img/20220718135425.webp" /></p><h2 id="302-307-303-的区别？"><a href="#302-307-303-的区别？" class="headerlink" title="302,307,303 的区别？"></a>302,307,303 的区别？</h2><ul><li><code>302</code> 是 http1.0 的协议状态码，在<code>http1.1版本</code>的时候为了细化<code>302</code>状态码⼜出来了两个<code>303</code>和<code>307</code>。</li><li><code>303</code> 明确表示客户端应当<code>采⽤get⽅法获取资源</code>，<code>会把POST请求变为GET请求进⾏重定向</code>。</li><li><code>307</code> 会遵照浏览器标准， 不会从 post 变为 get。</li></ul><p><span style="color: red">详细内容见下文，HTTP 状态码目录</span></p><h2 id="API-网关是什么"><a href="#API-网关是什么" class="headerlink" title="API 网关是什么"></a>API 网关是什么</h2><p><a href="https://www.cnblogs.com/konglxblog/p/15170636.html" target="_blank" ><code>API 网关</code></a></p><p>是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而 <em>安全、性能、监控</em> 可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性</p><p><a href="https://github.com/Kong/kong" target="_blank" >Kong 网关</a></p><h2 id="HTTP-的-keep-alive-是⼲什么的？"><a href="#HTTP-的-keep-alive-是⼲什么的？" class="headerlink" title="HTTP 的 keep-alive 是⼲什么的？"></a>HTTP 的 keep-alive 是⼲什么的？</h2><p>在早期的 HTTP&#x2F;1.0 中，每次 http 请求都要创建⼀个连接，⽽创建连接的过程需要消耗资源和时间，<code>为了减少资源消耗， 缩短响应时间，需要重⽤连接</code>。<br>在后来的 HTTP&#x2F;1.0 中以及 HTTP&#x2F;1.1 中，引⼊了重⽤连接的机制，就是在 <code>http 请求头中</code>加⼊ <code>Connection: keep-alive</code> 来告诉对⽅这个请求响应完成后不要关闭，下⼀次咱们还⽤这个请求继续交流。</p><p>HTTP&#x2F;1.0 如果想要保持⻓连接，需要在请求头中加上 <code>Connection: keep-alive</code>。</p><h2 id="keep-alive-的优点："><a href="#keep-alive-的优点：" class="headerlink" title="keep-alive 的优点："></a>keep-alive 的优点：</h2><ul><li>较少的 CPU 和内存的使⽤（由于同时打开的连接的减少了）</li><li>降低拥塞控制 （TCP 连接减少了）</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）</li><li>报告错误⽆需关闭 TCP 连</li><li>允许请求和应答的 HTTP <code>管线化</code>(将多个 HTTP 请求（request）整批提交的技术，而在发送过程中不需先等待伺服端的回应)</li></ul><h2 id="为什么有了-HTTP-为什么还要-HTTPS？"><a href="#为什么有了-HTTP-为什么还要-HTTPS？" class="headerlink" title="为什么有了 HTTP 为什么还要 HTTPS？"></a>为什么有了 HTTP 为什么还要 HTTPS？</h2><p>https 是安全版的 http，因为 http 协议的数据都是明⽂进⾏传输的，所以对于⼀些敏感信息的传输就很不安全，HTTPS 就 是为了解决 HTTP 的不安全⽽⽣的。</p><h2 id="HTTPS-是如何保证安全的？"><a href="#HTTPS-是如何保证安全的？" class="headerlink" title="HTTPS 是如何保证安全的？"></a>HTTPS 是如何保证安全的？</h2><p>过程⽐较复杂: <code>对称加密</code>、<code>非对称加密</code>、<code>中间人</code>、<code>CA证书</code>、<code>数字签名</code></p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，⽐如特务接头的暗号，就属于对称加密 对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。</p><h3 id="⾮对称加密"><a href="#⾮对称加密" class="headerlink" title="⾮对称加密"></a>⾮对称加密</h3><ol><li>私钥 + 公钥&#x3D; 密钥对</li><li>即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密</li><li>因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅</li><li>然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密</li></ol><p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。</p><p>解决⽅案：</p><p>那么结合两种加密⽅式，将<code>对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去</code>，<code>接收⽅使⽤私钥进⾏解密 得到对称加密的密钥</code>，然后双⽅可以使⽤对称加密来进⾏沟通。</p><h3 id="中间⼈"><a href="#中间⼈" class="headerlink" title="中间⼈"></a>中间⼈</h3><p>此时⼜带来⼀个问题，<code>中间⼈</code>问题：</p><p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。(<code>偷换</code>)</p><h3 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h3><p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。</p><p>证书中包括：<code>签发者</code>、<code>证书⽤途</code>、<code>使⽤者公钥</code>、<code>使⽤者私钥</code>、<code>使⽤者的 HASH 算法</code>、<code>证书到期时间</code>等</p><p>类似一个驾驶证：<code>签发机构</code>、<code>驾驶车辆型号</code>、<code>使用者信息</code>、<code>证件有效期</code></p><h3 id="证书篡改"><a href="#证书篡改" class="headerlink" title="证书篡改"></a>证书篡改</h3><p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，<code>数字签名</code>。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名: 就是⽤ CA ⾃带的 HASH 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。 这个时候就能最⼤程度保证通信的安全了。</p><h2 id="HTTP2-特点？"><a href="#HTTP2-特点？" class="headerlink" title="HTTP2 特点？"></a>HTTP2 特点？</h2><ul><li><code>二进制分帧</code>: <code>二进制解析起来更高效</code></li><li><code>头部压缩</code>：<code>在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担</code></li><li><code>服务端推送</code>：<code>不⽤等到浏览器解析到相应位置，发起请求再响应</code></li><li><code>多路复用</code>：<code>同域名下所有通信都在单个连接上完成</code>。 <code>单个连接可以承载任意数量的双向数据流</code></li></ul><details class="custom-details"><summary>点击查看更多</summary><p><strong>⼆进制分帧</strong></p><ul><li><code>帧</code>：HTTP&#x2F;2 数据通信的最⼩单位</li><li><code>消息</code>：指 HTTP&#x2F;2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由⼀个或多个帧 组成。</li><li><code>流</code>：存在于连接中的⼀个虚拟通道。流可以承载双向消息，每个流都有⼀个唯⼀的整数 ID HTTP&#x2F;2 采⽤⼆进制格式传输数据，⽽⾮ HTTP 1.x 的⽂本格式，<code>⼆进制协议解析起来更⾼效</code>。</li></ul><p><strong>头部压缩</strong></p><p>HTTP&#x2F;1.x 会<code>在请求和响应中中重复地携带不常改变的、冗⻓的头部数据，给⽹络带来额外的负担。</code></p><p>HTTP&#x2F;2 在客户端和服务器端使⽤“⾸部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求 和响应发送 ⾸部表在 HTTP&#x2F;2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</p><p>每个新的⾸部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 <code>可以理解为只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</code></p><p><strong>服务器推送</strong></p><p>服务端可以在发送⻚⾯ HTML 时主动推送其它资源，⽽不⽤等到浏览器解析到相应位置，发起请求再响应。</p><p>场景:</p><p>例如服务端 可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发 送 <code>RST_STREAM</code> 帧来拒收。<code>主动推送也遵守同源策略，服务器不会随便推送第三⽅资源给客户端</code>。</p><p><strong>多路复⽤</strong></p><p>HTTP 1.x 中，如果想并发多个请求，必须使⽤多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 <code>6-8</code> 个的 TCP 链接请求限制。<br>HTTP2 中： <code>同域名下所有通信都在单个连接上完成</code>。 <code>单个连接可以承载任意数量的双向数据流</code>。 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成，多个帧之间可以乱序发送，因为根据帧⾸部的流标识可以重新组装</p><img src="http://t-blog-images.aijs.top/img/20220716210046.png" /></details><h2 id="HTTP3-特点？"><a href="#HTTP3-特点？" class="headerlink" title="HTTP3 特点？"></a>HTTP3 特点？</h2><h3 id="HTTP2-缺点："><a href="#HTTP2-缺点：" class="headerlink" title="HTTP2 缺点："></a>HTTP2 缺点：</h3><ul><li><code>队头阻塞</code>： 有序字节流引出的<code>队头阻塞</code>（Head-of-line blocking），使得 HTTP2 的多路复用能力大打折扣；</li><li><code>握手延迟</code>：<code>TCP 与 TLS 叠加了握手时延</code>，建链时长还有 1 倍的下降空间；</li><li><code>移动成本高</code>：基于 TCP 四元组确定一个连接，这种诞生于有线网络的设计，<code>并不适合移动状态下的无线网络</code>，这意味着 IP 地址的频繁变动会导致 TCP 连接、TLS 会话反复握手，成本高昂。</li></ul><h3 id="HTTP3-协议解决了这些问题："><a href="#HTTP3-协议解决了这些问题：" class="headerlink" title="HTTP3 协议解决了这些问题："></a>HTTP3 协议解决了这些问题：</h3><ul><li><code>队头阻塞</code>：HTTP3 基于 UDP 协议重新定义了连接，在 QUIC 层实现了无序、并发字节流的传输，解决了<code>队头阻塞问题</code>（包括基于 QPACK 解决了动态表的队头阻塞）；</li><li><code>握手延迟</code>：HTTP3 重新定义了 TLS 协议加密 QUIC 头部的方式，<code>既提高了网络攻击成本，又降低了建立连接的速度</code>（仅需 1 个 RTT 就可以同时完成建链与密钥协商）；</li><li><code>移动成本高</code>： HTTP3 将 Packet、QUIC Frame、HTTP3 Frame 分离，实现了连接迁移功能，<code>降低了 5G 环境下高速移动设备的连接维护成本</code>。</li></ul><h2 id="HTTP-的缓存的过程"><a href="#HTTP-的缓存的过程" class="headerlink" title="HTTP 的缓存的过程"></a>HTTP 的缓存的过程</h2><p>通常情况下的步骤是:</p><ol><li>客户端向服务器发出请求，请求资源</li><li>服务器返回资源，并通过响应头决定缓存策略</li><li>客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来</li><li>在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断 是直接读取本地缓存还是与服务器协商缓存</li></ol><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存离不开两个响应头 <code>Expires</code> 与 <code>Cache-Control</code></p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 http1.0 提出的⼀个表示资源过期时间的 header，<code>它描述的是⼀个绝对时间</code>，由服务器返回， Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p><p>Expires:<code>Wed, 11 May 2018 07:20:00 GMT</code> GMT 时间戳</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 出现于 HTTP &#x2F; 1.1，优先级⾼于 Expires ,<code>表示的是相对时间</code></p><p>Cache-Control: <code>max-age=315360000</code></p><p>⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有：</p><p>Cache-Control: <code>public </code>可以被所有⽤户缓存，<code>允许终端和 CDN 等中间代理服务器</code><br>Cache-Control: <code>private</code> 只能被终端浏览器缓存，<code>不允许中继缓存服务器进⾏缓存</code><br>Cache-Control: <code>no-cache</code>,<code>先缓存本地,要验证</code>，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤<br>Cache-Control: <code>no-store</code>，<code>不会产⽣任何缓存</code></p><p>在缓存有效期内命中缓存，浏览器会直接读取本地的缓存资源，当缓存过期之后会与服务器进⾏协商。</p><p>服务器判断缓存是否是新鲜的⽅法就是依靠 HTTP 的另外两组信息</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><h4 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h4><p>客户端⾸次请求资源时，服务器会把资源的最新修改时间</p><p><code>Last-Modified:Thu, 19 Feb 2019 08:20:55 GMT</code> 通过响应部⾸发送给客户端，当再次发送请求是，客户端将服务器返回的修改时间放在请求头</p><p><code>If-Modified-Since:Thu, 19 Feb 2019 08:20:55 GMT</code> 发送给服务器，服务器再跟服务器上的对应资源进⾏⽐对，</p><p>如果服务器的资源更新，那么返回最新的资源，此时状态码 200，<br>当服务器资源跟客户端的请求的部⾸时间⼀致，证明客户端的资源是最新的，返回 304 状态码， 表示客户端直接⽤缓存即可。</p><h4 id="ETag-x2F-If-None-Match"><a href="#ETag-x2F-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h4><p>ETag 的流程跟 Last-Modified 是类似的，区别就在于 ETag 是<code>根据资源内容进⾏ hash，⽣成⼀个信息摘要</code>，只要资源内容有变化，这个摘要就会发⽣巨变，通过这个摘要信息⽐对，即可确定客户端的缓存资源是否为最新，<code>⽐ Last-Modified 的精确度要更⾼</code>。 响应头</p><img src="http://t-blog-images.aijs.top/img/20220716205210.png" /><p>整体的缓存流程图如下：</p><img src="http://t-blog-images.aijs.top/img/20220716205325.png" /><h2 id="HTTP-状态码目录"><a href="#HTTP-状态码目录" class="headerlink" title="HTTP 状态码目录"></a>HTTP 状态码目录</h2><ul><li><p>1xx 消息</p></li><li><p>2xx 成功</p></li><li><p>3xx 重定向</p></li><li><p>4xx 客户端错误</p></li><li><p>5xx 服务端错误</p></li></ul><h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h3><p>响应状态码<code>100 Continue 信息型状态响应码</code>表示：目前为止一切正常，客户端应该继续请求，如果已完成请求则忽略。</p><p><span style="color: red">为了让服务器检查请求的首部，客户端必须在发送请求实体前，在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码。</span></p><h4 id="101-Switching-Protocol"><a href="#101-Switching-Protocol" class="headerlink" title="101 Switching Protocol"></a>101 Switching Protocol</h4><p>响应状态码<code>101 Switching Protocol（协议切换）</code>状态码表示服务器应客户端升级协议的请求（Upgrade (en-US)请求头）正在切换协议。</p><p>服务器会发送一个 Upgrade (en-US)响应头来表明其正在切换过去的协议。</p><p>该过程在协议升级机制（Protocol upgrade mechanism）中详细描述。</p><p>在使用 WebSockets 时会用到协议切换。</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 101 Switching ProtocolsUpgrade: websocketConnection: Upgrade</code></pre><h4 id="102-Processing"><a href="#102-Processing" class="headerlink" title="102 Processing"></a>102 Processing</h4><p>请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示服务器已经收到并正在处理请求，但无响应可用。这样可<code>以防止客户端超时</code>，并假设请求丢失。</p><h4 id="103-Early-Hints"><a href="#103-Early-Hints" class="headerlink" title="103 Early Hints"></a>103 Early Hints</h4><p>响应状态码 <code>103 Early Hints 信息状态</code>响应码，一般和 <code>Link header（首部）</code>一起使用，<span style="color: red">来允许用户在服务器还在准备响应数据的时候预加载一些资源</span></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>HTTP 实体报头 Link 提供了序列化 HTTP 头部链接的方法。它在语义上与 HTML 元素 <link> 相等</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; link 头部包含以 ; 分隔的参数，这些参数与 HTML 元素 &lt;link&gt; 的属性一致。&#x2F;&#x2F; URI 必须要用 &lt; 和 &gt; 来关闭：&#x2F;&#x2F; Link: &lt;https:&#x2F;&#x2F;example.com&gt;; rel&#x3D;&quot;preload&quot;</code></pre><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>响应状态码 <code>200 OK</code> 表明请求已经成功。默认情况下状态码为 200 的响应可以被缓存。</p><p><span style="color: red">不同请求方式对于请求成功的意义如下：</span></p><ul><li><code>HEAD:</code> 响应的消息体为头部信息。</li><li><code>GET:</code> 已经取得资源，并将资源添加到响应的消息体中。</li><li><code>POST:</code> 响应的消息体中包含此次请求的结果。</li><li><code>TRACE:</code> <span style="color: red">响应的消息体中包含服务器接收到的请求信息</span>。</li><li><code>PUT</code> 和 <code>DELETE</code> 的请求成功通常并不是响应<code>200 OK</code>的状态码, 而是 <code>204 No Content</code> 表示无内容（或者 <code>201 Created</code>表示一个资源首次被创建成功）。</li></ul><img src="https://img0.baidu.com/it/u=2485422989,671633180&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500"  style="width: 200px"/><h4 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h4><p>响应状态码<code>201 Created</code> 是一个代表成功的应答状态码，<strong>表示请求已经被成功处理，并且创建了新的资源</strong>。<br>新的资源在应答返回之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 Location 首部的值。(TODO：后半句没搞懂)</p><p><strong>使用场景</strong></p><p>这个状态码的常规使用场景是作为 POST 请求的返回值</p><h4 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h4><p>响应状态码<code>202 Accepted 表示服务器端已经收到请求消息，但是尚未进行处理。</code></p><p>但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。</p><p><strong>使用场景</strong></p><p>这个状态码被设计 <strong>用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</strong></p><h4 id="203-Non-Authoritative-Information"><a href="#203-Non-Authoritative-Information" class="headerlink" title="203 Non-Authoritative Information"></a>203 Non-Authoritative Information</h4><p>响应状态码 <code>203 Non-Authoritative Information</code> 表示请求已经成功被响应，但是获得的负载与源头服务器的状态码为<code>200 (OK)</code>的响应相比，<strong>经过了拥有转换功能的 <code>proxy</code>（代理服务器）的修改</strong>。</p><p><strong>TODO:不懂</strong><br>响应状态码<code> 203 状态码</code>有点类似于 Warning 首部的<code> 214（Transformation Applied）</code>警告码，后者的优势在于可以应用于任何状态码的响应之中。</p><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>响应状态码<code>204 No Content</code> 成功状态响应码，表示该请求已经成功了，但是<strong>客户端客户不需要离开当前页面</strong>。默认情况下 <code>204</code> 响应是可缓存的。一个 ETag 标头包含在此类响应中。</p><p><strong>使用场景</strong></p><p>使用惯例是: 在<code> PUT 请求</code>中进行资源更新，但是</p><ul><li>不需要改变当前展示给用户的页面，那么返回 <code>204 No Content</code>。</li><li>如果创建了资源，则返回<code> 201 Created</code> 。</li><li>如果应将页面更改为新更新的页面，则应改用 200 。</li></ul><h4 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h4><p>响应状态码<code>205 Reset Content</code> 用来通知客户端重置文档视图，比如<code>清空表单内容</code>、<code>重置 canvas 状态</code>或者<code>刷新用户界面</code>。</p><h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>响应状态码<code>206 Partial Content</code>成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 <code>Range</code> 首部指定的。</p><ul><li>如果只包含一个数据区间，那么整个响应的 <code>Content-Type</code> 首部的值为所请求的文件的类型，同时包含 <code>Content-Range</code> 首部。</li><li>如果包含多个数据区间，那么整个响应的 <code>Content-Type</code> 首部的值为 <code>multipart/byteranges</code> ，其中一个片段对应一个数据区间，并提供 <code>Content-Range</code> 和 <code>Content-Type</code> 描述信息。</li></ul><p><strong>只包含一个数据区间的响应：</strong></p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 206 Partial ContentDate: Wed, 15 Nov 2015 06:25:24 GMTLast-Modified: Wed, 15 Nov 2015 04:58:08 GMT# 这里Content-Range: bytes 21010-47021&#x2F;47022Content-Length: 26012Content-Type: image&#x2F;gif... 26012 bytes of partial image data ...</code></pre><p><strong>包含多个数据区间的响应：</strong></p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 206 Partial ContentDate: Wed, 15 Nov 2015 06:25:24 GMTLast-Modified: Wed, 15 Nov 2015 04:58:08 GMTContent-Length: 1741Content-Type: multipart&#x2F;byteranges; boundary&#x3D;String_separator--String_separatorContent-Type: application&#x2F;pdf # 这里Content-Range: bytes 234-639&#x2F;8000 # 这里...the first range...--String_separatorContent-Type: application&#x2F;pdf # 这里Content-Range: bytes 4590-7999&#x2F;8000 # 这里...the second range--String_separator--</code></pre><h3 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h3><p>响应状态码<code>300 Multiple Choices</code> 是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。</p><p>假如服务器可以提供一个优先选择，那么它应该生成一个 <code>Location</code> 首部。</p><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>响应状态码<code>301 永久重定向 </code>说明请求的资源已经被移动到了由 <code>Location</code> 头部指定的 <code>url</code> 上，是固定的不会再改变。</p><p><span style="color: red">搜索引擎会根据该响应修正。</span></p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>尽管标准要求浏览器在收到该响应并进行重定向时, 不应该修改<code>http method</code> 和 <code>body</code>，但是有一些浏览器可能会有问题。所以最好是在应对 <code>GET</code> 或 <code>HEAD</code> 方法时使用 <code>301</code>，其他情况使用 <code>308</code> 来替代 <code>301</code>。</p></div><h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>响应状态码<code>302 Found 重定向状态码</code>,表明请求的资源被暂时的移动到了由该 <code>HTTP</code> 响应的响应头 <code>Location</code> 指定的 <code>URL</code> 上。浏览器会重定向到这个 <code>URL</code>，但是搜索引擎不会对该资源的链接进行更新 (In SEO-speak, it is said that the link-juice is not sent to the new URL)。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。</p><p>所以推荐仅在响应 <code>GET</code> 或 <code>HEAD</code> 方法时采用 <code>302</code> 状态码，<br>而在其他时候使用 <code>307 Temporary Redirect</code> 来替代，<span style="color: red">因为在这些场景下方法变换是明确禁止的</span>。</p></div><p>在确实需要将重定向请求的方法转换为 GET 的场景下，可以使用 <code>303 See Other</code>。</p><p><strong>例如:</strong></p><p>在使用 PUT 方法进行文件上传操作时，需要返回确认信息（例如“你已经成功上传了 xyz”）而不是上传的资源本身，就可以使用这个状态码。</p><h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>响应状态码<code>303 See Other 重定向状态码</code>，<code>通常作为 PUT 或 POST 操作的返回结果</code>，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET</p><h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>响应状态码<code>304 未改变说明无需再次传输请求的内容</code>，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如 GET 或 HEAD 或在请求中附带了头部信息： <code>If-None-Match</code> 或 <code>If-Modified-Since</code>。</p><p>如果是 <code>200 OK</code> ，响应会带有头部<code> Cache-Control</code>, <code>Content-Location</code>, <code>Date</code>, <code>ETag</code>, <code>Expires</code>，和 <code>Vary</code>.</p><h4 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h4><p>被请求的资源必须通过指定的代理才能被访问</p><h4 id="306-Switch-Proxy-废弃"><a href="#306-Switch-Proxy-废弃" class="headerlink" title="306 Switch Proxy 废弃"></a>306 Switch Proxy 废弃</h4><p>306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”</p><h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>响应状态码<code>307 Temporary Redirect，临时重定向响应状态码</code>，表示请求的资源暂时地被移动到了响应的 Location 首部所指向的 URL 上。</p><p>原始请求中的请求方法和消息主体会在重定向请求中被重用。在确实需要将重定向请求的方法转换为 <code>GET</code> 的场景下，可以考虑使用 <code>303 See Other</code> 状态码。例如，在使用 PUT 方法进行文件上传操作时，如果需要返回一条确认信息（例如“你已经成功上传了 XYZ”），而不是返回上传的资源本身，就可以使用这个状态码。</p><h4 id="307-302-的区别"><a href="#307-302-的区别" class="headerlink" title="307,302 的区别"></a>307,302 的区别</h4><p><span style="color: red">当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。</span></p><ul><li>如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET：也就是说，在 Web 中，如果使用了 GET 以外的请求方法，且返回了 302 状态码，则重定向后的请求方法是不可预测的；<br/><br/></li><li>但如果使用 307 状态码，之后的请求方法就是可预测的。对于 GET 请求来说，两种情况没有区别。</li></ul><h4 id="308-Permanent-Redirect"><a href="#308-Permanent-Redirect" class="headerlink" title="308 Permanent Redirect"></a>308 Permanent Redirect</h4><p>在 HTTP 协议中， <code>308 Permanent Redirect（永久重定向）</code>是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是“链接汁”（link juice）被传递到了新的 URL）。</p><p>在重定向过程中，<code>请求方法和消息主体不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法</code>。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>一些 Web 应用可能会将 <code>308 Permanent Redirect</code> 以一种非标准的方式使用以及用作其他用途。例如，Google Drive 会使用 308 Resume Incomplete 状态码来告知客户端文件上传终止且不完整</div><h4 id="301-302-303-307-308-区别"><a href="#301-302-303-307-308-区别" class="headerlink" title="301,302,303,307,308 区别"></a>301,302,303,307,308 区别</h4><p><code>301,308 永久重定向</code>(有兼容问题)</p><ul><li>请求方法和消息主体不会发生改变，然而在返回<code> 301 状态码</code>的情况下，<code>请求方法有时候会被客户端错误地修改为 GET 方法</code></li><li>Google Drive 会使用 <code>308 Resume Incomplete</code> 状态码来告知客户端文件上传终止且不完整</li></ul><p><code>302,303,307 临时重定向</code>,</p><ul><li>对应 GET 方法，302 和 307 没有区别，</li><li>对于 HEAD，302 不会改变,307 会变</li><li>其他请求方法，302 会改成 GET 请求，303 表示都要变成 GET，307 保持请求方法不变</li></ul><p><strong>变 GET</strong>: <code>302(保留GET,HEAD) &lt; 307(保留HEAD) &lt; 303(全部)</code></p><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>响应状态码<code>400 Bad Request </code>响应状态码表示: <code>由于语法无效，服务器无法理解该请求</code>。 客户端不应该在未经修改的情况下重复此请求。</p><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>响应状态码 <code>401 Unauthorized</code> 代表客户端错误，指的是: <code>由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足</code>。</p><p>这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。</p><p>这个状态类似于 403， 但是在该情况下，依然可以进行身份验证。</p><p><strong>响应样例</strong></p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 401 UnauthorizedDate: Wed, 21 Oct 2015 07:28:00 GMTWWW-Authenticate: Basic realm&#x3D;&quot;Access to staging site&quot;</code></pre><h4 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h4><p>响应状态码 <code>402 Payment Required</code> 是一个被保留使用的非标准客户端错误状态响应码。</p><p>有时， 这个状态码表明直到客户端付费之后请求才会被处理。<strong>402 状态码被创建最初目的是用于数字现金或微型支付系统， 表明客户端请求的内容只有付费之后才能获取</strong>。目前还不存在标准的使用约定，不同的实体可以在不同的环境下使用。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>Experimental: 这是一个实验中的功能<br>此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</p></div><p><strong>响应样例</strong></p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 402 Payment RequiredDate: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>响应状态码<code>403 Forbidden</code>，指的是: <span style="color: red">服务器端有能力处理该请求，但是拒绝授权访问</span>。</p><p>这个状态类似于 <code>401</code>，但进入 <code>403</code>状态后, 即使重新验证也不会改变该状态。该访问是长期禁止的，并且与应用逻辑密切相关（例如没有足够的权限访问该资源）。</p><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>响应状态码 <code>404 Not Found</code> 指的是: 服务器无法找到所请求的资源。返回该响应的链接通常称为<code>坏链（broken link）</code>或<code>死链（dead link）</code>，它们会<code>导向链接出错处理（link rot）</code>页面。</p><p><span style="color: red">404 状态码并不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 410（Gone）而不是 404 。</span></p><h4 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h4><p>响应状态码 <code>405 Method Not Allowed</code> 表明服务器禁止了使用当前 HTTP 方法的请求。</p><p><strong>事例</strong></p><p>restful 风格 API,使用中会出现 <a href="https://blog.csdn.net/qq_42704130/article/details/125417805" target="_blank" >见</a></p><h4 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h4><p>响应状态码 <code>406 Not Acceptable</code>表示: 客户端错误，指代服务器端无法提供与 <code>Accept-Charset</code> 以及 <code>Accept-Language</code> 消息头指定的值相匹配的响应。</p><p>在实际应用中，_这个错误状态码极少使用_：不是给用户返回一个晦涩难懂（且难以更正）的错误状态码，而是将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。这种做法基于这样一个假设：即便是不能达到用户十分满意，也强于返回错误状态码。</p><p>如果服务器返回了这个错误状态码，那么消息体中应该包含所能提供的资源表现形式的列表，允许用户手动进行选择。</p><h4 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h4><p>响应状态码 <code>407 Proxy Authentication Required</code> 代表客户端错误，指的是: 由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server ）要求的身份验证凭证，发送的请求尚未得到满足。</p><p>这个状态码会与 <code>Proxy-Authenticate</code> 首部一起发送，其中包含有如何进行验证的信息。</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 407 Proxy Authentication RequiredDate: Wed, 21 Oct 2015 07:28:00 GMTProxy-Authenticate: Basic realm&#x3D;&quot;Access to internal site&quot;</code></pre><h4 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h4><p>响应状态码 <code>408 Request Timeout</code> 表示: 服务器想要将没有在使用的连接关闭。一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下。</p><p>服务器应该在此类响应中将 Connection 首部的值设置为 “close”，因为 <code>408 意味着服务器已经决定将连接关闭，而不是继续等待</code>。</p><p>这类响应出现的比较频繁，源于一些浏览器——例如 Chrome, Firefox 27+, 或者 IE9 等——<code>使用 HTTP 协议中的预连接机制来加速上网体验</code>。<span style="color: red">同时应该注意到，某些服务器会直接关闭连接，而不发送此类消息。</span></p><h4 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h4><p>响应状态码 <code>409 Conflict</code>表示: 请求与服务器端目标资源的当前状态相冲突。</p><p>冲突最有可能发生在对 <code>PUT</code> 请求的响应中。例如，<strong>当上传文件的版本比服务器上已存在的要旧</strong>，从而导致版本冲突的时候，那么就有可能收到状态码为 <code>409 的响应</code>。</p><h4 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h4><p>响应状态码 <code>410 Gone</code> 说明请求的目标资源在原服务器上不存在了，并且<code>是永久性的丢失</code>。如果不清楚是否为永久或临时的丢失，应该使用 404</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>410 响应默认会被缓存</p></div><h4 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h4><p>响应状态码 <code>411 Length Required</code> 属于客户端错误，表示: 由于缺少确定的 Content-Length 首部字段，服务器拒绝客户端的请求。</p><p>注意，按照规范，<strong>当使用分块模式传输数据的时候</strong>， <code>Content-Length</code> 首部是不存在的，但是<strong>需要在每一个分块的开始添加该分块的长度</strong>，用十六进制数字表示。参见 Transfer-Encoding 获取更多细节信息。</p><h4 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h4><p>响应状态码 <code>412 Precondition Failed（先决条件失败）</code>, 这通常发生于: 采用除 GET 和 HEAD 之外的方法进行条件请求时，由首部字段 <code>If-Unmodified-Since</code> 或 <code>If-None-Match</code> 规定的先决条件不成立的情况下。这时候，请求的操作——通常是上传或修改文件——无法执行，从而返回该错误状态码。</p><h4 id="413-Payload-Too-Large"><a href="#413-Payload-Too-Large" class="headerlink" title="413 Payload Too Large"></a>413 Payload Too Large</h4><p>响应状态码 <code>413 Payload Too Large</code> 表示: <code>请求主体的大小超过了服务器的能力处理</code>，<strong>base64 编码会增大数据体积</strong>。</p><p>如果“超出限度”是暂时性的，服务器应该返回 Retry-After 首部字段，说明这是暂时性的，以及客户端可以在什么时间（after what time）后重试。</p><h4 id="414-URI-Too-Long"><a href="#414-URI-Too-Long" class="headerlink" title="414 URI Too Long"></a>414 URI Too Long</h4><p>响应状态码 <code>414 URI Too Long</code> 表示客户端所请求的 URI 超过了服务器允许的范围。</p><p>以下是造成这种罕见情况的几种可能原因：</p><ul><li>当客户端误将 POST 请求当作 GET 请求时，会带有一个较长的查询字符串 (query)；</li><li>当客户端堕入重定向循环黑洞时，例如，指向自身后缀的重定向 URI 前缀 (a redirected URI prefix that points to a suffix of itself)；</li><li>当客户端对服务器进行攻击，试图寻找潜在的漏洞时。（<code>反射型XSS攻击</code>）</li></ul><h4 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h4><p>响应状态码 <code>415 Unsupported Media Type</code> 表示: 服务器由于不支持其有效载荷的格式，从而拒绝接受客户端的请求。</p><p>格式问题的出现有可能源于客户端在 <code>Content-Type</code> 或 <code>Content-Encoding</code> 首部中指定的格式，也可能源于直接对负载数据进行检测的结果</p><h4 id="416-Range-Not-Satisfiable"><a href="#416-Range-Not-Satisfiable" class="headerlink" title="416 Range Not Satisfiable"></a>416 Range Not Satisfiable</h4><p>响应状态码<code>416 Range Not Satisfiable </code>错误状态码意味着: <strong>服务器无法处理所请求的数据区间</strong>。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range 首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。</p><p>416 响应报文包含一个 Content-Range 首部，提示无法满足的数据区间（用星号 _ 表示），后面紧跟着一个“&#x2F;”，再后面是当前资源的长度。例如：<code>Content-Range: */12777</code></p><p>遇到这一错误状态码时，浏览器一般有两种策略：<code>要么终止操作</code>（例如，一项中断的下载操作被认为是不可恢复的），<code>要么再次请求整个文件</code>。</p><h4 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h4><p>响应状态码 <code>417 Expectation Failed</code> 状态码表示客户端错误，意味着: <strong>服务器无法满足 Expect 请求消息头中的期望条件</strong>。</p><p>参考 Expect 消息头获得更多的相关细节信息</p><p><a href="https://www.jianshu.com/p/7cb1a7bf0f5d" target="_blank" >示例</a></p><h4 id="418-I’m-a-teapot"><a href="#418-I’m-a-teapot" class="headerlink" title="418 I’m a teapot"></a>418 I’m a teapot</h4><p>响应状态码 <code>418 I&#39;m a teapot</code> 客户端错误响应代码表示: 服务器拒绝冲泡咖啡，因为它是个茶壶。</p><p>该错误是超文本咖啡壶控制协议的参考，和 1998 年愚人节的玩笑。用作彩蛋</p><pre class="line-numbers language-none"><code class="language-none">出自RFC 2324 Hyper Text Coffee Pot Control Protocol (HTCPCP&#x2F;1.0)文档文档中定义的一种返回值，协议定义“如果想用茶壶制作咖啡，就会返回一个错误码418 I&#39;m tea pot”2014年4.1发布的恶搞RFC 7168是此协议的扩展，正式支持茶壶作者：chanyi链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;cdefc3afd7ea来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><p>RFC（request for commits） 征求意见修订书</p><p>是一个互联网技术标准文档</p><h4 id="422-Unprocessable-Entity"><a href="#422-Unprocessable-Entity" class="headerlink" title="422 Unprocessable Entity"></a>422 Unprocessable Entity</h4><p>响应状态码 <code>422 状态码</code>表示: 服务器理解请求实体的内容类型，并且<code>请求实体的语法是正确的，但是服务器无法处理所包含的指令</code>。</p><p>例子：<a href="https://blog.csdn.net/weixin_30314631/article/details/97219640" target="_blank" >见</a></p><pre class="line-numbers language-none"><code class="language-none">HttpRequest中所带cookie和服务器端接收的 cookie名称不一致 ，导致返回422错误代码。</code></pre><h4 id="423-Locked"><a href="#423-Locked" class="headerlink" title="423 Locked"></a>423 Locked</h4><p>当前资源被锁定。（RFC 4918 WebDAV）,网上查到更多是和 SVN 相关</p><h4 id="424-Failed-Dependency"><a href="#424-Failed-Dependency" class="headerlink" title="424 Failed Dependency"></a>424 Failed Dependency</h4><p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p><h4 id="425-Too-Early"><a href="#425-Too-Early" class="headerlink" title="425 Too Early"></a>425 Too Early</h4><p>服务器拒绝处理在 Early Data 中的请求，以规避可能的重放攻击, <a href="https://zh.wikipedia.org/zh-cn/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB" target="_blank" >重放攻击- 中间人攻击的一种</a></p><p>是一种恶意或欺诈的重复或延迟有效数据的网络攻击形式</p><h4 id="426-Upgrade-Required"><a href="#426-Upgrade-Required" class="headerlink" title="426 Upgrade Required"></a>426 Upgrade Required</h4><p><code>426 Upgrade Required</code> 表示: 服务器拒绝处理客户端使用当前协议发送的请求，但是可以接受其使用升级后的协议发送的请求。</p><p>服务器会在响应中使用 <code>Upgrade (en-US) </code>首部来指定要求的协议。</p><h4 id="428-Precondition-Required"><a href="#428-Precondition-Required" class="headerlink" title="428 Precondition Required"></a>428 Precondition Required</h4><p>响应状态码 <code>428 Precondition Required</code> 表示: 服务器端要求发送条件请求。</p><p>一般的，这种情况意味着必要的条件首部——如<code>If-Match</code> ——的缺失。</p><p>当一个条件首部的值不能匹配服务器端的状态的时候，应答的状态码应该是 <code>412 Precondition Failed</code>，前置条件验证失败。</p><h4 id="412-与-428-区别"><a href="#412-与-428-区别" class="headerlink" title="412 与 428 区别"></a>412 与 428 区别</h4><ul><li><code>412</code> <code>一个条件首部的值</code>不能匹配服务器端的状态的时候，应答的状态码应该是 <code>412 Precondition Failed</code>，前置条件验证失败。</li><li><code>428</code> <code>必要的条件首部的缺失</code>——如<code>If-Match</code></li></ul><h4 id="429-Too-Many-Requests"><a href="#429-Too-Many-Requests" class="headerlink" title="429 Too Many Requests"></a>429 Too Many Requests</h4><p>响应状态码 <code>429 Too Many Requests</code> 表示在一定的时间内用户发送了太多的请求，即<code>超出了“频次限制”</code>。</p><p>在响应中，可以提供一个 <code>Retry-After</code> 首部来提示用户需要等待多长时间之后再发送新的请求。</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 429 Too Many RequestsContent-Type: text&#x2F;htmlRetry-After: 3600</code></pre><h4 id="431-Request-Header-Fields-Too-Large"><a href="#431-Request-Header-Fields-Too-Large" class="headerlink" title="431 Request Header Fields Too Large"></a>431 Request Header Fields Too Large</h4><p>服务器不愿处理请求，因为一个或多个头字段过大</p><p><strong>刚整理完，就收到反馈了，这也太神奇了吧</strong></p><img src="http://t-blog-images.aijs.top/img/202207261508843.webp" /><br/><br/><img src="http://t-blog-images.aijs.top/img/202207261521540.webp" /><h4 id="440-Login-Time-out"><a href="#440-Login-Time-out" class="headerlink" title="440 Login Time-out"></a>440 Login Time-out</h4><p>客户端 session 超时失效，需要重新登录。</p><h4 id="451-Unavailable-For-Legal-Reasons"><a href="#451-Unavailable-For-Legal-Reasons" class="headerlink" title="451 Unavailable For Legal Reasons"></a>451 Unavailable For Legal Reasons</h4><p>该访问，因法律的要求而被拒绝</p><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p><code>500 Internal Server Error</code> 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。</p><p>这个错误代码是一个通用的“万能”响应代码。有时候，对于类似于 500 这样的错误，服务器管理员会更加详细地记录相关的请求信息来防止以后同样错误的出现。</p><h4 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h4><p>响应状态码 <code>501 Not Implemented </code>服务器错误响应码表示: 请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD。</p><p>请注意，你无法修复 501 错误，需要被访问的 web 服务器去修复该问题。</p><h4 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h4><p>响应状态码 <code>502 Bad Gateway</code> 是一种 HTTP 协议的服务端错误状态代码，它表示作为网关或代理的服务器，从上游服务器中接收到的响应是无效的。</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>备注： 网关在计算机网络体系中可以指代不同的设备，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。</p></div><p>一般会有 <code>链路追踪</code>, 通过<code>trackId</code>可以查询到什么地方出的问题</p><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><p>响应状态码<code>503 Service Unavailable</code> 是一种 HTTP 协议的服务器端错误状态代码，它表示服务器尚未处于可以接受请求的状态。</p><p>通常造成这种情况的原因是: 由于服务器停机维护或者已超载。注意在发送该响应的时候，应该同时发送一个对用户友好的页面来解释问题发生的原因。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 <code>Retry-After</code> 首部字段中包含服务恢复的预期时间。</p><p>缓存相关的首部在与该响应一同发送时应该小心使用，<code>因为 503 状态码通常应用于临时状况下，而此类响应一般不应该进行缓存</code>。</p><h4 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h4><p>响应状态码<code>504 Gateway Timeout</code> 是一种 HTTP 协议的服务器端错误状态代码，表示: <strong><code>扮演网关</code>或者<code>代理的服务器</code>无法在规定的时间内获得想要的响应</strong>。</p><p>Gateway（网关）在计算机网络体系中可以指代不同的设备，504 错误通常不是在客户端可以修复的，而是需要由途径的 Web 服务器或者代理服务器对其进行修复。</p><h4 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h4><p>响应状态码<code>505 HTTP Version Not Supported </code>是一种 HTTP 协议的服务器端错误状态代码，表示: <strong>服务器不支持请求所使用的 HTTP 版本</strong>。</p><h4 id="506-Variant-Also-Negotiates"><a href="#506-Variant-Also-Negotiates" class="headerlink" title="506 Variant Also Negotiates"></a>506 Variant Also Negotiates</h4><p>506 码表示: <strong>内部服务器配置错误</strong>，其中所选变量&#x2F;变元自身被配置为参与内容协商，因此并不是合适的协商端点。</p><h4 id="507-Insufficient-Storage"><a href="#507-Insufficient-Storage" class="headerlink" title="507 Insufficient Storage"></a>507 Insufficient Storage</h4><p>响应状态码 <code>507 Insufficient Storage</code> 响应状态码 可以在 WebDAV 协议（基于 web 的分布式创作和版本控制，参见 RFC 4918）中给出。</p><p><strong>507 码表示服务器不能存储相关内容</strong>。准确地说，一个方法可能没有被执行，因为服务器不能存储其表达形式，这里的表达形式指：方法所附带的数据，而且其请求必需已经发送成功。</p><h4 id="508-Loop-Detected"><a href="#508-Loop-Detected" class="headerlink" title="508 Loop Detected"></a>508 Loop Detected</h4><p>响应状态码 <code>508 Loop Detected</code> 状态码可以在 WebDAV 协议（基于 Web 的分布式创作和版本控制）中给出。</p><p><strong>508 码表示服务器中断一个操作，因为它在处理具有“Depth: infinity”的请求时遇到了一个无限循环。508 码表示整个操作失败</strong>。</p><h4 id="510-Not-Extended"><a href="#510-Not-Extended" class="headerlink" title="510 Not Extended"></a>510 Not Extended</h4><p>响应状态码 <code>510 Not Extended</code> 响应状态码在 HTTP 扩展框架协议（参见 RFC 2774）中发送。</p><p>在 HTTP 扩展框架协议中 ，<strong>一个客户端可以发送一个包含扩展声明的请求，该声明描述了要使用的扩展</strong>。<strong>如果服务器接收到这样的请求，但是请求不支持任何所描述的扩展</strong>，那么服务器将使用 510 状态码进行响应。</p><h4 id="511-Network-Authentication-Required"><a href="#511-Network-Authentication-Required" class="headerlink" title="511 Network Authentication Required"></a>511 Network Authentication Required</h4><p>响应状态码<code>511 Network Authentication Required</code> 表示客户端需要通过验证才能使用该网络。</p><p>该状态码不是由源头服务器生成的，而是由控制网络访问的拦截代理服务器生成的。</p><p><strong>网络运营商们有时候会在准许使用网络之前要求用户进行身份验证、接受某些条款，或者进行其他形式的与用户之间的互动（例如在网络咖啡厅或者机场）</strong>。他们通常用用户设备的 <code>MAC 地址</code>来进行识别。</p><h3 id="600-（维基百科查不到）"><a href="#600-（维基百科查不到）" class="headerlink" title="600 （维基百科查不到）"></a>600 （维基百科查不到）</h3><p>源站没有返回响应头部，只返回实体内容</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/431672713" target="_blank" >深入剖析 HTTP3 协议</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100" target="_blank" >Web 开发技术&gt;HTTP&gt;HTTP 响应状态码</a></p><p><a href="https://www.wbolt.com/http-error-431.html" target="_blank" >HTTP Error 431：修复请求标头字段太大的 3 种方法</a></p><p><a href="https://blog.csdn.net/qq_37450814/article/details/114672359" target="_blank" >HTTP 状态码含义</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" >维基百科 HTTP 状态码</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-TCP</title>
      <link href="//post/2022-07-15TCP.html"/>
      <url>//post/2022-07-15TCP.html</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h2><ul><li>TCP 提供⼀种<code>⾯向连接的</code>、<code> 可靠的</code>、<code>字节流 </code>服务</li><li>在⼀个 TCP 连接中，<code>仅双⽅进⾏彼此通信</code>。⼴播和多播不能⽤于 TCP</li><li>TCP 使⽤<code>校验</code>、<code>确认</code>和<code>重传机制</code>来保证可靠传输</li><li>TCP 给<code>数据分节进⾏排序</code>，并使⽤累积确认保证数据的顺序不变和⾮重复</li><li>TCP 使⽤<code>滑动窗⼝机制</code>来实现流量控制，通过动态改变窗⼝的⼤⼩进⾏拥塞控制</li></ul><h2 id="TCP-UDP-的区别"><a href="#TCP-UDP-的区别" class="headerlink" title="TCP\UDP 的区别"></a>TCP\UDP 的区别</h2><ul><li>TCP 是一种面向连接的单播协议,在 TCP 中,并不存在多播、广播的这种行为,因为 TCP 报文段中能明确发送方和接受方的 IP 地址。</li><li>UDP 是无连接的 因为使用 UDP 协议的发送者和接受者之间不必存在任何长期的关系。它们没有建立连接过程,整个消息传输过程简单来说就是<code>发送即结束</code></li></ul><table><thead><tr><th align="left"><small>协议</small></th><th align="left"><small>连接性</small></th><th align="left"><small>双⼯性</small></th><th align="left"><small>可靠性</small></th><th align="left"><small>有序性</small></th><th align="left"><small>有界性</small></th><th align="left"><small>拥塞控制</small></th><th align="left"><small>传输速度</small></th><th align="left"><small>量级</small></th><th align="left"><small>头部⼤⼩</small></th></tr></thead><tbody><tr><td align="left"><small>TCP</small></td><td align="left"><small>⾯向连接</small></td><td align="left"><small>全双⼯(1:1)</small></td><td align="left"><small>可靠(重传机 制)</small></td><td align="left"><small>有序</br>(通过 SYN 排 序)</small></td><td align="left"><small>⽆,</br> 有粘包情况</small></td><td align="left"><small>有</small></td><td align="left"><small>慢</small></td><td align="left"><small>低</small></td><td align="left"><small>20~60 字节</small></td></tr><tr><td align="left"><small>UDP</small></td><td align="left"><small>⽆连接</small></td><td align="left"><small>n:m</small></td><td align="left"><small>不可靠</br>(丢包后 数据丢 失)</small></td><td align="left"><small>⽆序</small></td><td align="left"><small>有</br> ⽆粘包</small></td><td align="left"><small>⽆</small></td><td align="left"><small>快</small></td><td align="left"><small>⾼</small></td><td align="left"><small>8 字节</small></td></tr></tbody></table><p><code>意义不同</code>：TCP: <code>TransmissionControlProtocol</code>,传输控制协议，UDP: <code>UserDatagramProtocol</code>,用户数据报协议</p><p><strong>可靠、双工、连接</strong></p><p><code>可靠性</code>：TCP 可靠，有重传机制，UDP 不可靠，丢了就丢了<br><code>双⼯性</code>：TCP 全双工（1:1），UDP(n:m)<br><code>连接性</code>：TCP 面向连接，UDP 无链接</p><p><strong>有序、有界、有控制</strong></p><p><code>有序性</code>：TCP 有序，通过 SYN 排序，UDP 无序<br><code>有界性</code>：TCP 无界，有粘包情况，UDP 有消息边界，无粘包<br><code>有控制</code>：TCP 有拥塞控制，UDP 没有拥塞控制</p><p><strong>有内容，也要有速度</strong></p><p><code>头⼤</code>：TCP 头部大小 20-60 字节，UDP 头部大小 8 个字节<br><code>量小</code>：TCP 传输量级低于 UDP<br><code>传的慢</code>：TCP 相对于 UDP 而言要慢</p><h2 id="如何理解-UDP-的“无连接”特性？"><a href="#如何理解-UDP-的“无连接”特性？" class="headerlink" title="如何理解 UDP 的“无连接”特性？"></a>如何理解 UDP 的“无连接”特性？</h2><p><a href="https://www.dandelioncloud.cn/article/details/1505563355480944641" target="_blank" >如何理解UDP的“无连接”特性？</a></p><h2 id="TCP-粘包是怎么回事，如何处理"><a href="#TCP-粘包是怎么回事，如何处理" class="headerlink" title="TCP 粘包是怎么回事，如何处理?"></a>TCP 粘包是怎么回事，如何处理?</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>✨ 默认情况下, TCP 连接会<code>启⽤延迟传送算法</code> (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有<code>多个数据</code>发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), <code>这样可以减少 IO 消耗提⾼性能</code>.</p><p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了.</p><p>但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>可以参⻅⽹上流传⽐较⼴的⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:</p><p>A. 先接收到 data1, 然后接收到 data2 .<br>B. 先接收到 <code>data1 的部分数据</code>, 然后接收到 <code>data1 余下的部分</code>以及 <code>data2 的全部</code>.<br>C. 先接收到了 <code>data1 的全部数据</code>和 <code>data2 的部分数据</code>, 然后接收到了 <code>data2 的余下的数据</code>.<br>D. ⼀次性接收到了 data1 和 data2 的全部数据.</p><p><code>其中的 BCD 就是我们常⻅的粘包的情况</code>.</p><h3 id="对于处理粘包的问题-常⻅的解决⽅案有"><a href="#对于处理粘包的问题-常⻅的解决⽅案有" class="headerlink" title="对于处理粘包的问题, 常⻅的解决⽅案有:"></a>对于处理粘包的问题, 常⻅的解决⽅案有:</h3><ol><li>多次发送之前间隔⼀个等待时间 （<code>场景：交互频率低的场景</code>）</li><li>关闭 Nagle 算法 （<code>场景：数据较大，频率不是特别高的场景</code>）</li><li>进⾏封包&#x2F;拆包（<code>场景：发送特征数据，收到后按特征数据进行分割</code>）</li></ol><h2 id="为什么-udp-不会粘包？"><a href="#为什么-udp-不会粘包？" class="headerlink" title="为什么 udp 不会粘包？"></a>为什么 udp 不会粘包？</h2><ol><li>TCP 协议是⾯向流的协议，UDP 是⾯向消息的协议 UDP 段都是⼀条消息，应⽤程序必须<code>以消息为单位提取数据</code>，不能⼀次提取任意字节的数据</li><li>UDP<code>具有保护消息边界</code>，在每个 UDP 包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易 进⾏区分处理了。</li><li>传输协议<code>把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息</code>。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收</li></ol><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>所谓三次握⼿(Three-way Handshake)，是指建⽴⼀个 TCP 连接时，<code>需要客户端和服务器总共发送3个包</code>。</p><p>三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信息。</p><ul><li>客户端：<code>SYN标志+序列号</code>,进入<code>SYN_SEND</code>状态</li><li>服务端：<code>SYN标志+序列号+确认标识+确认序列号</code>, 进入<code>SYN_RCVD</code>状态</li><li>客户端：<code>确认应答+确认序列号</code>，进入<code>ESTABLISHED</code>状态</li></ul><details class="custom-details"><summary>点击查看更多</summary><p><p>在 socket 编程中，客户端执⾏ connect() 时。将触发三次握⼿。</p><ul><li><p><code>第⼀次握⼿(SYN=1, seq=x)</code>: 客户端发送⼀个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X,保存在包头 的序列号(Sequence Number)字段⾥。 发送完毕后，客户端进⼊ SYN_SEND 状态。 <code>SYN标志+序列号+SYN_SEND</code></p></li><li><p><code>第⼆次握⼿(SYN=1, ACK=1, seq=y, ACKnum=x+1)</code>: 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域 ⾥，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进⼊ SYN_RCVD 状态。</p></li><li><p><code>第三次握⼿(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确 定字段中发送给对⽅</code>，并且在数据段放写 ISN 的+1 发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿ 结束。 三次握⼿的过程的示意图如下：</p></li></ul><img src="http://t-blog-images.aijs.top/img/20220715170016.webp" /></p></details><h2 id="TCP-四次握手"><a href="#TCP-四次握手" class="headerlink" title="TCP 四次握手"></a>TCP 四次握手</h2><p>✨ TCP 的连接的拆除需要发送四个包，因此称为四次挥⼿(Four-way handshake)，也叫做改进的三次握⼿。<code>客户端或服务器均可主动发起挥⼿动作</code>，在 socket 编程中，任何⼀⽅执⾏ close() 操作即可产⽣挥⼿操作。</p><ul><li>客户端：<code>结束标识+序列号</code>,进⼊ <code>FIN_WAIT_1</code> 状态</li><li>服务端：<code>确认标识+确认应答序号</code>,进⼊ <code>FIN_WAIT_1</code> 状态</li><li>服务端：<code>结束标识+序列号</code>,进⼊ <code>FIN_WAIT_2</code> 状态</li><li>客户端：<code>确认标识+确认应答序号</code>,进⼊ <code>TIME_WAIT</code> 状态</li><li>后 续：服务端：进⼊ <code>CLOSED</code> 状态，客户端：<code>两个最⼤段⽣命周期</code>, 进⼊ <code>CLOSED</code> 状态</li></ul><details class="custom-details"><summary>点击查看更多</summary><ul><li><p><code>第⼀次挥⼿(FIN=1，seq=x)</code> 假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为 1 的包，表示⾃⼰已经没有数据可以发送了，但是仍然 可以接受数据。 发送完毕后，客户端进⼊ FIN_WAIT_1 状态。</p></li><li><p><code>第⼆次挥⼿(ACK=1，ACKnum=x+1)</code> 服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭 连接。 发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务 器端关闭连接。</p></li><li><p><code>第三次挥⼿(FIN=1，seq=y)</code> 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。 TCP ⾯试题 54 发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个 ACK。</p></li><li><p><code>第四次挥⼿(ACK=1，ACKnum=y+1)</code> 客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。</p></li><li><p>客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。 四次挥⼿的示意图如下：</p></li></ul><img src="http://t-blog-images.aijs.top/img/20220715170027.webp" /></details><h2 id="请求连接是三次，断开连接是四次"><a href="#请求连接是三次，断开连接是四次" class="headerlink" title="请求连接是三次，断开连接是四次"></a>请求连接是三次，断开连接是四次</h2><ul><li>服务端：<code>确认标识+确认应答序号</code>,进⼊ <code>FIN_WAIT_1</code> 状态</li><li>服务端：<code>结束标识+序列号</code>,进⼊ <code>FIN_WAIT_2</code> 状态</li></ul><p>分为两个，目的是在服务端发送完数据后，然后进行发送关闭信号</p><h2 id="三次握手改为两次"><a href="#三次握手改为两次" class="headerlink" title="三次握手改为两次"></a>三次握手改为两次</h2><p>采用三次握手是为了<code>防止失效的连接请求报文段突然又传送到主机B，因而产生错误</code>。</p><p>失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。</p><p>考虑这样一种特殊情况：&#96;主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。</p><p>采用两次握手不行，原因就是上面说的<code>失效的连接请求</code>的特殊情况。</p><p><strong>不是很恰当的例子</strong></p><ul><li>例子 1（3 次握手）：朋友：来吃饭 -&gt; 你：好咧，等我哈 -&gt; 朋友：👌。  <br/><br/></li><li>例子 2（2 次握手）：朋友：来吃饭 -&gt; 你（第二天你看到了）：好咧，等我哈。 朋友不在家（吃闭门羹）</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/nk298120/article/details/116596086" target="_blank" >TCP 三次握手如果使用二次握手代替则会出现的问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-安全</title>
      <link href="//post/2022-07-15%E5%AE%89%E5%85%A8.html"/>
      <url>//post/2022-07-15%E5%AE%89%E5%85%A8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端安全问题"><a href="#前端安全问题" class="headerlink" title="前端安全问题?"></a>前端安全问题?</h2><ul><li><code>跨站脚本 (Cross-Site Scripting, XSS)</code>: ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS. 早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚ ⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; VBScript &#x2F; CSS &#x2F; Flash 等</li><li><code>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）</code>: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤ 户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li><li><code>iframe 的滥⽤</code>: iframe 中的内容是由第三⽅来提供的，默认情况下他们不受我们的控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端⽤户体验</li><li><code>恶意第三⽅库</code>: 【<code>这个就需要我们在使用一些库之前，最好能够阅读其源码</code>】⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候我们都是在借助开发框架和各种类库进⾏ 快速开发,⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题,⽐如 event-stream 的恶意代码事件,2018 年 11 ⽉ 21 ⽇， 名为 FallingSnow 的⽤户在知名 JavaScript 应⽤库 event-stream 在 github Issuse 中发布了针对植⼊的恶意代码的疑 问，表示 event-stream 中存在⽤于窃取⽤户数字钱包的恶意代码</li><li>DDoS 攻击， <code>DDos</code>全名<code>Distributed Denial of Service</code>，翻译成中文就是<code>分布式拒绝服务</code></li><li>中间人攻击， (Man-in-the-middle attack, MITM)</li></ul><h2 id="XSS-分为哪⼏类"><a href="#XSS-分为哪⼏类" class="headerlink" title="XSS 分为哪⼏类?"></a>XSS 分为哪⼏类?</h2><p>根据攻击的来源，XSS 攻击可分为<code>存储型</code>、<code>反射型</code>和 <code>DOM型</code>三种。</p><h3 id="存储型："><a href="#存储型：" class="headerlink" title="存储型："></a>存储型：</h3><ul><li>恶意代码存放的位置。 插⼊点：由谁取得恶意代码，并插⼊到⽹⻚上。 存储型 XSS 存储型 XSS 的攻击步骤：</li></ul><ol><li>攻击者将恶意代码提交到⽬标⽹站的<code>数据库</code>中。</li><li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码<code>从数据库取出</code>，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p><strong>场景</strong></p><p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构<code>造出特殊的 URL</code>，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码<code>从URL中取出</code>，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p><p><strong>场景</strong></p><p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件⽐较苛刻（需要构造表单提交⻚⾯，并引导⽤户点击），所 以⾮常少⻅。</p><h3 id="DOM-型"><a href="#DOM-型" class="headerlink" title="DOM 型"></a>DOM 型</h3><p>XSS DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：</p><p>DOM 型 XSS 攻击中，<code>取出和执⾏恶意代码由浏览器端完成</code>，属于前端 JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p><h2 id="如何预防-XSS"><a href="#如何预防-XSS" class="headerlink" title="如何预防 XSS?"></a>如何预防 XSS?</h2><p>XSS 攻击有两⼤要素：</p><ol><li>攻击者提交恶意代码。</li><li>浏览器执⾏恶意代码。</li></ol><p>针对第⼀个要素：我们是否能够在⽤户输⼊的过程，过滤掉⽤户输⼊的恶意代码呢？</p><h3 id="输⼊过滤"><a href="#输⼊过滤" class="headerlink" title="输⼊过滤"></a>输⼊过滤</h3><ul><li>防⽌ HTML 中出现注⼊</li><li>防⽌ JavaScript 执⾏时，执⾏恶意代码</li></ul><h3 id="存储型和反射型-XSS"><a href="#存储型和反射型-XSS" class="headerlink" title="存储型和反射型 XSS"></a>存储型和反射型 XSS</h3><p>如何产生？</p><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插⼊到响应 HTML ⾥的，攻击者刻意编写的“数据”被内嵌到“代 码”中，被浏览器所执⾏。</p><p>预防这两种漏洞，有两种常⻅做法：</p><ul><li>改成纯前端渲染，把代码和数据分隔开</li><li>对 HTML 做充分转义。</li></ul><h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>DOM 型 XSS 攻击，实际上就是⽹站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执⾏了。</p><ul><li><p>在使⽤ <code>.innerHTML</code> 、 <code>.outerHTML</code> 、 <code>document.write()</code> 时要特别⼩⼼，不要把不可信的数据作为 HTML 插到⻚⾯上，⽽应尽量使⽤ <code>.textContent</code> 、 <code>.setAttribute()</code> 等。</p><br/><br/></li><li><p>如果⽤ Vue&#x2F;React 技术栈，并且不使⽤ <code>v-html</code> &#x2F; <code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code> 、 <code>outerHTML</code> 的 XSS 隐患。</p><br/><br/></li><li><p>DOM 中的内联事件监听器，如 location 、 onclick 、 onerror 、 onload 、 onmouseover 等，</p><br/><br/></li><li><p><code>&lt;a&gt;</code> 标签的 href 属 性，</p><br/><br/></li><li><p>JavaScript 的 <code>eval()</code> 、 <code>setTimeout()</code> 、 <code>setInterval()</code> 等，都能<code>把字符串作为代码运⾏</code>。</p></li></ul><p>如果不可信的数据拼接 到字符串中传递给这些 API，很容易产⽣安全隐患，请务必避免。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;![](https:&#x2F;&#x2F;awps-assets.meituan.net&#x2F;mit-x&#x2F;blog-images-bundle-2018b&#x2F;3e724ce0.data:image&#x2F;png,)&lt;!-- 链接内包含恶意代码 --&gt;&lt;a href&#x3D;&quot;UNTRUSTED&quot;&gt;1&lt;&#x2F;a&gt;&lt;script&gt;  &#x2F;&#x2F; setTimeout()&#x2F;setInterval() 中调⽤恶意代码  setTimeout(&quot;UNTRUSTED&quot;);  setInterval(&quot;UNTRUSTED&quot;);  &#x2F;&#x2F; location 调⽤恶意代码  location.href &#x3D; &quot;UNTRUSTED&quot;;  &#x2F;&#x2F; eval() 中调⽤恶意代码  eval(&quot;UNTRUSTED&quot;);&lt;&#x2F;script&gt;</code></pre><h3 id="其他-XSS-防范措施"><a href="#其他-XSS-防范措施" class="headerlink" title="其他 XSS 防范措施"></a>其他 XSS 防范措施</h3><p>虽然在渲染⻚⾯和执⾏ JavaScript 时，通过谨慎的转义可以防⽌ XSS 的发⽣，但完全依靠开发的谨慎仍然是不够的。</p><p>以下介绍⼀些通⽤的⽅案，可以降低 XSS 带来的⻛险和后果。</p><ul><li><p><code>Content Security Policy</code> 严格的 CSP 在 XSS 的防范中可以起到以下的作⽤： 禁⽌加载外域代码，防⽌复杂的攻击逻辑 禁⽌外域提交，⽹站被攻击后，⽤户的数据不会泄露到外域</p></li><li><p><code>禁⽌内联脚本执⾏</code>（规则较严格，⽬前发现 GitHub 使⽤） 禁⽌未授权的脚本执⾏（新特性，Google Map 移动版在使⽤）</p></li><li><p><code>合理使⽤上报</code>可以及时发现 XSS，利于尽快修复问题 输⼊内容⻓度控制 对于不受信任的输⼊，都应该限定⼀个合理的⻓度。虽然⽆法完全防⽌ XSS 发⽣，但可以增加 XSS 攻击的难度。</p></li><li><p>其他安全措施<code> HTTP-only Cookie</code>: 禁⽌ JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注⼊后也⽆法窃取此 Cookie。 验证码：防⽌脚本冒充⽤户提交危险操作。</p></li></ul><h2 id="CSRF-是什么"><a href="#CSRF-是什么" class="headerlink" title="CSRF 是什么?"></a>CSRF 是什么?</h2><p><code>CSRF（Cross-site request forgery）跨站请求伪造</code>：攻击者诱导受害者进⼊第三⽅⽹站，在第三⽅⽹站中，向被攻击⽹ 站发送跨站请求。利⽤受害者在被攻击⽹站已经获取的注册凭证，绕过后台的⽤户验证，达到冒充⽤户对被攻击的⽹站 执⾏某项操作的⽬的。 ⼀个典型的 CSRF 攻击有着如下的流程：</p><ul><li>受害者登录 a.com ，并保留了登录凭证（Cookie）</li><li>攻击者引诱受害者访问了 b.com b.com 向 a.com 发送了⼀个请求： a.com&#x2F;act&#x3D;xx</li><li>浏览器会默认携带 a.com 的 Cookie a.com 接收到请求后，对请求进⾏验证，并确认是受害者的凭证，误以为是受害者⾃⼰发送的请求</li><li>a.com 以受害者的名义执⾏了 act&#x3D;xx</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执⾏了⾃⼰定义的操作</li></ul><h2 id="CSRF-的攻击类型"><a href="#CSRF-的攻击类型" class="headerlink" title="CSRF 的攻击类型?"></a>CSRF 的攻击类型?</h2><ul><li>GET 类型的 CSRF</li><li>POST 类型的 CSRF</li><li>链接类型的 CSRF</li></ul><h2 id="如何预防-CSRF"><a href="#如何预防-CSRF" class="headerlink" title="如何预防 CSRF?"></a>如何预防 CSRF?</h2><p>CSRF 通常从第三⽅⽹站发起，被攻击的⽹站⽆法防⽌攻击发⽣，只能通过增强⾃⼰⽹站针对 CSRF 的防护能⼒来提升安全性。<br>CSRF 的两个特点：</p><ul><li>CSRF（通常）发⽣在第三⽅域名</li><li>CSRF 攻击者不能获取到 Cookie 等信息，只是使⽤。</li></ul><p>针对这两点，我们可以专⻔制定防护策略，如下：</p><ul><li>阻⽌不明外域的访问<ol><li><code>同源检测</code></li><li><code>Samesite Cookie</code></li></ol></li><li>提交时要求附加本域才能获取的信息<ol><li>CSRF Token</li><li>双重 Cookie 验证</li></ol></li></ul><p>因此我们可以针对性得进⾏预防</p><h3 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h3><p>既然 CSRF ⼤多来⾃第三⽅⽹站，那么我们就直接禁⽌外域（或者不受信任的域名）对我们发起请求:</p><ul><li>使⽤ Origin Header 确定来源域名: 在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段,如果 Origin 存在，那么直接使⽤ Origin 中的字段确认来源域名就可以</li><li>使⽤ Referer Header 确定来源域名: 根据 HTTP 协议，在 HTTP 头中有⼀个字段叫 Referer，记录了该 HTTP 请求的来 源地址</li></ul><h3 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h3><p>CSRF 的另⼀个特征是，攻击者⽆法直接窃取到⽤户的信息（Cookie，Header，⽹站内容等），仅仅是冒⽤ Cookie 中的 信息。</p><p>⽽ CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了⽤户⾃⼰的请求。那么我们可以要求所有的 ⽤户请求都携带⼀个 CSRF 攻击者⽆法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求 和攻击的请求区分开，也可以防范 CSRF 的攻击:</p><p>CSRF Token 的防护策略分为三个步骤：</p><ul><li>将 CSRF Token 输出到⻚⾯中</li><li>⻚⾯提交的请求携带这个 Token</li><li>服务器验证 Token 是否正确</li></ul><h3 id="双重-Cookie-验证"><a href="#双重-Cookie-验证" class="headerlink" title="双重 Cookie 验证"></a>双重 Cookie 验证</h3><p>在会话中存储 CSRF Token ⽐较繁琐，⽽且不能在通⽤的拦截上统⼀处理所有的接⼝ 那么另⼀种防御措施是使⽤双重提交 Cookie。利⽤ CSRF 攻击不能获取到⽤户 Cookie 的特点，我们可以要求 Ajax 和表单 请求携带⼀个 Cookie 中的值</p><p>双重 Cookie 采⽤以下流程：</p><ul><li>在⽤户访问⽹站⻚⾯时，向请求域名注⼊⼀个 Cookie，内容为随机字符串（例如 csrfcookie&#x3D;v8g9e4ksfhw ）。</li><li>在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例 POST <a href="https://www.a.com/comment">https://www.a.com/comment</a>? csrfcookie&#x3D;v8g9e4ksfhw ）。</li><li>后端接⼝验证 Cookie 中的字段与 URL 参数中的字段是否⼀致，不⼀致则拒绝。</li></ul><h3 id="Samesite-Cookie-属性"><a href="#Samesite-Cookie-属性" class="headerlink" title="Samesite Cookie 属性"></a>Samesite Cookie 属性</h3><p>Google 起草了⼀份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它⽤来标明这个 Cookie 是 个“同站 Cookie”，同站 Cookie 只能作为第⼀⽅ Cookie，不能作为第三⽅ Cookie，Samesite 有两个属性值:</p><ul><li>Samesite&#x3D;Strict: 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三⽅ Cookie</li><li>Samesite&#x3D;Lax: 这种称为宽松模式，⽐ Strict 放宽了点限制,假如这个请求是这种请求且同时是个 GET 请求，则这个 Cookie 可以作为第三⽅ Cookie</li></ul><h2 id="⽹络劫持"><a href="#⽹络劫持" class="headerlink" title="⽹络劫持"></a>⽹络劫持</h2><p>⽹络劫持⼀般分为两种:</p><ul><li><code>DNS 劫持</code>: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持) DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器</li><li><code>302 跳转的⽅式</code>: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起 302 跳转的回复，引导⽤户获取内容</li><li><code>HTTP 劫持</code>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于 http 明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)</li></ul><h2 id="如何应对⽹络劫持"><a href="#如何应对⽹络劫持" class="headerlink" title="如何应对⽹络劫持?"></a>如何应对⽹络劫持?</h2><ul><li>DNS 劫持由于涉嫌违法,已经被监管起来,现在很少会有 DNS 劫持,⽽ http 劫持依然⾮常盛⾏.</li><li>最有效的办法就是全站 HTTPS,将 HTTP 加密,这使得运营商⽆法获取明⽂,就⽆法劫持你的响应内容.</li></ul><h2 id="中间⼈攻击"><a href="#中间⼈攻击" class="headerlink" title="中间⼈攻击"></a>中间⼈攻击</h2><p>中间⼈ (Man-in-the-middle attack, MITM) 是指<code>攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话</code>, 但事实上整个会话都被攻击者完全控制. 在中间⼈攻击中, 攻击者可以拦截通讯双⽅的通话并插⼊新的内容.</p><p>⼀般的过程如下:</p><ul><li>客户端发送请求到服务端，请求被中间⼈截获服务器向客户端发送公钥中间⼈截获公钥，保留在⾃⼰⼿上。</li><li>然后⾃⼰⽣成⼀个<code>【伪造的】公钥</code>，发给客户端</li><li>客户端收到伪造的公钥后，⽣成加密 hash 值发给服务器</li><li>中间⼈获得加密 hash 值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密 hash 值，发给服务器</li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><h2 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h2><p><a href="https://zh.wikipedia.org/zh-cn/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB" target="_blank" >重放攻击- 中间人攻击的一种</a></p><h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>DDos</code>全名<code>Distributed Denial of Service</code>，翻译成中文就是<code>分布式拒绝服务</code>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p></blockquote><p>攻击方式很多，比如<code>UDP Flood</code>、<code>SYN Flood</code>、<code>DNS Query Flood</code>等等。</p><p><strong>下面是 SYN Flood 进行 DDoS 攻击的实现原理</strong></p><p>SYN Flood 是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。</p><p>一次正常的建立 TCP 连接，需要三次握手：客户端发送 SYN 报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。</p><p>SYN Flood 就是用户向服务器发送报文后突然死机或掉线，那么服务器在发出应答报文后就无法收到客户端的确认报文（第三次握手无法完成），这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。</p><p><code>一个用户出现异常导致服务器的一个线程等待一会儿并不是大问题</code>，但恶意攻击者大量模拟这种情况，服务器端为了维护数以万计的半连接而消耗非常多的资源，结果往往是无暇理睬客户的正常请求，甚至崩溃。从正常客户的角度看来，网站失去了响应，无法访问。</p><h3 id="高防服务器"><a href="#高防服务器" class="headerlink" title="高防服务器"></a>高防服务器</h3><p>还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。</p><p>高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~</p><h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p>面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。</p><h3 id="DDoS-清洗"><a href="#DDoS-清洗" class="headerlink" title="DDoS 清洗"></a>DDoS 清洗</h3><p>DDos 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。</p><p>DDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p><h3 id="CDN-加速"><a href="#CDN-加速" class="headerlink" title="CDN 加速"></a>CDN 加速</h3><p>CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。</p><p>在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/weixin_38405253/article/details/114297755" target="_blank" >DDoS 攻击原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-webpack系列</title>
      <link href="//post/2022-07-14webpack.html"/>
      <url>//post/2022-07-14webpack.html</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-与-grunt、gulp-的不同？"><a href="#webpack-与-grunt、gulp-的不同？" class="headerlink" title="webpack 与 grunt、gulp 的不同？"></a>webpack 与 grunt、gulp 的不同？</h2><ul><li><p><code>Grunt、Gulp</code> 是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插 件，能⽅便的打造各种⼯作流。</p></li><li><p><code>Webpack</code> 是基于模块化打包的⼯具: ⾃动化处理模块,webpack 把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤ npm script 代替 Grunt、Gulp,npm script 同样可以打造任务流</p></li></ul><h2 id="webpack、rollup、parcel、vite-优劣？"><a href="#webpack、rollup、parcel、vite-优劣？" class="headerlink" title="webpack、rollup、parcel、vite 优劣？"></a>webpack、rollup、parcel、vite 优劣？</h2><ul><li>webpack 适⽤于⼤型复杂的前端站点构建: webpack 有强⼤的 loader 和插件⽣态,打包后的⽂件实际上就是⼀个⽴即 执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执 ⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发.</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><ul><li>Rollup</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式，这些标准都包含在 JavaScript 的 ES6 版本中，而不是以前的特殊解决方案，如 CommonJS 和 AMD。ES6 模块可以使你自由、无缝地使用你最喜爱的 library 中那些最有用独立函数，而你的项目不必携带其他未使用的代码。ES6 模块最终还是要由浏览器原生实现，但当前 Rollup 可以使你提前体验。</p></blockquote><ul><li>parcel 极速零配置 Web 应用打包工具</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>🚀 <code>极速打包</code>: Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。<br>📦 <code>将你所有的资源打包</code>: Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。<br>🐠 <code>自动转换</code>: 如若有需要，Babel, PostCSS, 和 PostHTML 甚至 node_modules 包会被用于自动转换代码.<br>✂️ <code>零配置代码分拆</code>: 使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。<br>🔥 <code>热模块替换</code>: Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。<br>🚨 <code>友好的错误日志</code>:当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题。</p></blockquote><ul><li>vite 下一代前端开发与构建工具</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>📦 <code>极速的服务启动</code>: 使用原生 ESM 文件，无需打包!<br>⚡️ <code>轻量快速的热重载</code>: 无论应用程序大小如何，都始终极快的模块热重载（HMR）<br>🛠️ <code>丰富的功能</code>: 对 TypeScript、JSX、CSS 等支持开箱即用。<br>📦 <code>优化的构建</code>: 可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建<br>🔩 <code>通用的插件</code>: 在开发和构建之间共享 Rollup-superset 插件接口。<br>🔑 <code>完全类型化的 API</code>: 灵活的 API 和完整 TypeScript 类型。</p></blockquote><h2 id="有哪些常⻅的-Loader？"><a href="#有哪些常⻅的-Loader？" class="headerlink" title="有哪些常⻅的 Loader？"></a>有哪些常⻅的 Loader？</h2><p><a href="https://www.webpackjs.com/loaders/url-loader/" target="_blank" >更多</a></p><p><strong>文件相关的</strong></p><!-- - `raw-loader`：加载文件原始内容（utf-8） --><ul><li><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li><li><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li><li><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</li><li><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</li><li><code>image-loader</code>：加载并且压缩图片文件</li><li><code>json-loader</code> 加载 JSON 文件（默认包含）</li><li><code>handlebars-loader</code>: 将 Handlebars 模版编译成函数并返回</li></ul><p><strong>脚本相关的</strong></p><ul><li><code>babel-loader</code>：把 ES6 转换成 ES5</li><li><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</li><li><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li></ul><p><strong>样式相关的</strong></p><ul><li><code>sass-loader</code>：将 SCSS&#x2F;SASS 代码转换成 CSS</li><li><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</li><li><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li></ul><p><strong>校验相关的</strong></p><ul><li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</li><li><code>tslint-loader</code>：通过 TSLint 检查 TypeScript 代码</li></ul><p><strong>测试相关的</strong></p><ul><li><code>mocha-loader</code>：加载 Mocha 测试用例的代码</li><li><code>coverjs-loader</code>：计算测试的覆盖率</li></ul><p><strong>框架相关的</strong></p><ul><li><code>vue-loader</code>：加载 Vue.js 单文件组件</li></ul><p><strong>语言相关的</strong></p><ul><li><code>i18n-loader</code>: 国际化</li></ul><p><strong>性能相关的</strong></p><ul><li><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li></ul><p><a href="https://webpack.docschina.org/loaders/cache-loader/#getting-started" target="_blank" >见 webpack cache-loader</a></p><h2 id="有哪些常⻅的-Plugin？"><a href="#有哪些常⻅的-Plugin？" class="headerlink" title="有哪些常⻅的 Plugin？"></a>有哪些常⻅的 Plugin？</h2><p><strong>基本</strong></p><ul><li><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li><li><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</li><li><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li><li><code>clean-webpack-plugin</code>: 目录清理</li></ul><p><strong>编译范围优化相关</strong></p><ul><li><code>ignore-plugin</code>：忽略部分文件</li></ul><p><strong>压缩优化相关</strong></p><ul><li><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</li><li><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</li><li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</li></ul><p><strong>其他优化相关</strong></p><ul><li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)</li><li><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</li><li><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</li></ul><p><strong>分析相关</strong></p><ul><li><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li><li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li></ul><h2 id="分别介绍-bundle，chunk，module-是什么"><a href="#分别介绍-bundle，chunk，module-是什么" class="headerlink" title="分别介绍 bundle，chunk，module 是什么"></a>分别介绍 bundle，chunk，module 是什么</h2><ul><li><code>bundle</code>：是由 webpack 打包出来的⽂件</li><li><code>chunk</code>：代码块，⼀个 chunk 由多个模块组合⽽成，⽤于代码的合并和分割</li><li><code>module</code>：是开发中的单个模块，在 webpack 的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块</li></ul><h2 id="Loader-和-Plugin-的不同？"><a href="#Loader-和-Plugin-的不同？" class="headerlink" title="Loader 和 Plugin 的不同？"></a>Loader 和 Plugin 的不同？</h2><p><strong>作用</strong></p><ul><li><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。<br>因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</li><li><code>Plugin</code> 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><strong>使用</strong></p><ul><li><code>Loader</code> 在 <code>module.rules</code> 中配置，作为模块的解析规则，类型为数组。<code>每一项都是一个 Object</code>，内部包含了 <code>test</code>(类型文件)、<code>loader</code>、<code>options</code> (参数)等属性。</li><li><code>Plugin</code> 在 <code>plugins</code> 中单独配置，类型为数组，<code>每一项是一个 Plugin 的实例</code>，参数都通过构造函数传入。</li></ul><h2 id="webpack-的构建流程是什么"><a href="#webpack-的构建流程是什么" class="headerlink" title="webpack 的构建流程是什么?"></a>webpack 的构建流程是什么?</h2><p>Webpack 的运行流程是一个<code>串行的过程</code>，从启动到结束会依次执行以下流程：</p><ul><li><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</li><li><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><code>完成模块编译</code>：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><p>在以上过程中，Webpack <code>会在特定的时间点广播出特定的事件</code>，<code>插件</code>在监听到感兴趣的事件后会执行特定的逻辑，并且<code>插件</code>可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。<br>简单说</p><ul><li><code>初始化</code>：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li><li><code>编译</code>：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li><li><code>输出</code>：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li></ul><h2 id="描述下编写-loader-的思路"><a href="#描述下编写-loader-的思路" class="headerlink" title="描述下编写 loader 的思路"></a>描述下编写 loader 的思路</h2><p>Loader 像⼀个”翻译官”把读到的源⽂件内容转义成新的⽂件内容，并且每个 Loader 通过链式操作，将源⽂件⼀步步翻译 成想要的样⼦。 编写 Loader 时要遵循单⼀原则，每个 Loader 只做⼀种”转义”⼯作。 每个 Loader 的拿到的是源⽂件内容（ source ），可 以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给 webpack。 还可以通过 this.async() ⽣成⼀个 callback 函数，再⽤这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了 开发 loader 的⼯具函数集—— loader-utils 。<br><strong>注意</strong></p><ul><li>Loader 是无状态的，我们不应该在 Loader 中保留状态</li><li>使用 loader-utils 和 schema-utils 为我们提供的实用工具</li><li>加载本地 Loader 方法<code>Npm link</code></li></ul><p><a href="https://www.webpackjs.com/contribute/writing-a-loader/" target="_blank" >编写一个 loader</a></p><p>loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; getOptions &#125; from &quot;loader-utils&quot;;import validateOptions from &quot;schema-utils&quot;;const schema &#x3D; &#123;  type: &quot;object&quot;,  properties: &#123;    test: &#123;      type: &quot;string&quot;,    &#125;,  &#125;,&#125;;export default function (source) &#123;  const options &#x3D; getOptions(this);  validateOptions(schema, options, &quot;Example Loader&quot;);  &#x2F;&#x2F; 对资源应用一些转换……  return &#96;export default $&#123;JSON.stringify(source)&#125;&#96;;&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  test: &#x2F;\.js$&#x2F;;  use: [    &#123;      loader: path.resolve(&quot;path&#x2F;to&#x2F;loader.js&quot;), &#x2F;&#x2F;直接使用本地loader      options: &#123;        &#x2F;* ... *&#x2F;      &#125;,    &#125;,  ];&#125;</code></pre><h2 id="描述下编写-plugin-的思路？"><a href="#描述下编写-plugin-的思路？" class="headerlink" title="描述下编写 plugin 的思路？"></a>描述下编写 plugin 的思路？</h2><p>插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！</p><p>插件目的在于解决 loader 无法实现的其他事。</p><p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; ConsoleLogOnBuildWebpackPlugin.jsconst pluginName &#x3D; &quot;ConsoleLogOnBuildWebpackPlugin&quot;;class ConsoleLogOnBuildWebpackPlugin &#123;  apply(compiler) &#123;    &#x2F;&#x2F; 注意这个compiler    compiler.hooks.run.tap(pluginName, (compilation) &#x3D;&gt; &#123;      &#x2F;&#x2F; 注意这个compilation      console.log(&quot;webpack 构建过程开始！&quot;);    &#125;);  &#125;&#125;</code></pre><p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</p><p><a href="https://www.webpackjs.com/concepts/plugins/#%E5%89%96%E6%9E%90" target="_blank" >见 plugin 剖析</a></p><h2 id="webpack-的热更新原理"><a href="#webpack-的热更新原理" class="headerlink" title="webpack 的热更新原理"></a>webpack 的热更新原理</h2><p>Webpack 的<code>热更新</code>又称<code>热替换</code>（Hot Module Replacement），缩写为 HMR。 这个机制可以做到<code>不用刷新浏览器</code>而将新变更的模块替换掉旧的模块。</p><p>HMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 <code>chunk diff</code> (chunk 需要更新的部分)，实际上 <code>WDS</code> 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，<code>并带上构建时的 hash</code>，让客户端与上一次资源进行对比。</p><p>客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由<code> HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像 <code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><p><a href="https://zhuanlan.zhihu.com/p/30669007" target="_blank" >见</a></p><h2 id="⽤-webpack-来优化前端性能"><a href="#⽤-webpack-来优化前端性能" class="headerlink" title="⽤ webpack 来优化前端性能"></a>⽤ webpack 来优化前端性能</h2><p>原则：<code>更小</code>、<code>更少</code>、<code>更近</code></p><p>⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p><p><strong>更小</strong></p><ul><li><code>压缩代码</code>:删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 <code>UglifyJsPlugin</code> 和 <code>ParallelUglifyPlugin</code> 来压缩 JS ⽂件，</li><li><code>利⽤ cssnano</code> （css-loader?minimize）来压缩 css</li><li><code>Tree Shaking</code>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现</li></ul><p><strong>更少</strong></p><ul><li><code>Code Splitting</code>: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li><li><code>提取公共第三⽅库</code>: SplitChunksPlugin 插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的 公共代码</li></ul><p><strong>更近</strong></p><ul><li><code>利⽤ CDN 加速</code>: 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对 于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li></ul><h2 id="提⾼-webpack-的打包速度"><a href="#提⾼-webpack-的打包速度" class="headerlink" title="提⾼ webpack 的打包速度"></a>提⾼ webpack 的打包速度</h2><p><strong>打个比方：</strong></p><p>一期需求时间紧任务重，领导来了，说要明天上线。<br>如何做到更快上线？（需要：<code>更多的研发资源</code>（并行）；<code>之前有的功能组件直接用</code>（不重复做事）；<code>砍几个需求吧</code>（更小的范围））</p><p><strong>用更厉害的</strong></p><ul><li>高版本<code>node</code>和<code>webpack</code></li></ul><p><strong>并行</strong></p><ul><li><code>happypack</code>: 利⽤进程并⾏编译 loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类 似的替代者是<code>thread-loader</code></li></ul><p><strong>不重复做事</strong></p><ul><li><code>外部扩展(externals)</code>: 将不怎么需要更新的第三⽅库脱离 webpack 打包，不被打⼊ bundle 中，从⽽减少打包时间,⽐ 如 jQuery <code>⽤ script 标签引⼊</code></li><li><code>dll</code>: 采⽤ webpack 的 <code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 引⼊ dll，让⼀些基本不会改动的代码先打包成静态资源,避免 反复编译浪费时间</li><li><code>利⽤缓存</code>: <code>webpack.cache</code> 、<code>babel-loader.cacheDirectory</code>、 <code>HappyPack.cache</code> 都可以利⽤缓存提⾼ rebuild 效率</li></ul><p><strong>更小的范围</strong></p><ul><li><code>缩⼩⽂件搜索范围</code>: ⽐如 babel-loader 插件,如果你的⽂件仅存在于 src 中,那么可以 include: path.resolve(__dirname, ‘src’) ,当然绝⼤多数情况下这种操作的提升有限,除⾮不⼩⼼ build 了 node_modules ⽂件</li></ul><h2 id="提⾼-webpack-的构建速度"><a href="#提⾼-webpack-的构建速度" class="headerlink" title="提⾼ webpack 的构建速度"></a>提⾼ webpack 的构建速度</h2><ul><li>高版本<code>node</code>和<code>webpack</code></li><li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li><li>通过 <code>externals</code> 配置来提取常⽤库</li><li>利⽤ <code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的 npm 包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li><li>使⽤ <code>Happypack</code> 实现多线程加速编译</li><li>使⽤ <code>webpack-uglify-parallel</code> 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏ 压缩来提升压缩速度</li><li>使⽤ <code>Tree-shaking</code> 和 <code>Scope Hoisting</code> 来剔除多余代码</li></ul><h2 id="怎么配置单⻚应⽤？怎么配置多⻚应⽤？"><a href="#怎么配置单⻚应⽤？怎么配置多⻚应⽤？" class="headerlink" title="怎么配置单⻚应⽤？怎么配置多⻚应⽤？"></a>怎么配置单⻚应⽤？怎么配置多⻚应⽤？</h2><ul><li><p><code>单⻚应⽤</code>可以理解为 webpack 的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述</p><br/><br/></li><li><p><code>多⻚应⽤</code>的话，可以使⽤ webpack 的 <code>AutoWebPlugin</code> 来完成简单⾃动化的构建，但是前提是项⽬的<code>⽬录结构必须遵守他预设的规范</code>。 多⻚应⽤中要注意的是： <code>每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载</code>。⽐如，每个⻚⾯都引⽤了同⼀套 css 样式表随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让<code>⼊⼝的配置⾜够灵活</code>，避免每次添加新⻚⾯还需要修改构建配置</p></li></ul><h2 id="source-map-是什么？生产环境怎么用？"><a href="#source-map-是什么？生产环境怎么用？" class="headerlink" title="source map 是什么？生产环境怎么用？"></a>source map 是什么？生产环境怎么用？</h2><p><code>source map</code> 是将编译、打包、压缩后的代码映射回源代码的过程。</p><ul><li><code>打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map</code>。</li><li>map 文件只要不打开开发者工具，浏览器是不会加载的。</li></ul><p><strong>线上环境一般有三种处理方案：</strong></p><ul><li><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</li><li><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li><li><code>sourcemap</code>：通过<code>nginx</code> 设置将 <code>.map</code> 文件<code>只对白名单开放</code>(公司内网)</li></ul><p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p><p><a href="https://juejin.cn/post/6844903450644316174" target="_blank" >[webpack] devtool 里的 7 种 SourceMap 模式是什么鬼？</a></p><p>sourcemap 关键字如下</p><p><strong>eval</strong></p><p>使用 eval 包裹代码模块（这个代码块是转译后的代码，并未进行打包和压缩）<br>eval 包裹每个代码块时候，会在后面增加”sourceURL”（和 sourcemap 里的”sourceMappingURL”不同）用来定位到原文件。</p><p>eval 模式优势在于，它是将每个模块单独 eval 执行，因此如果配合 source-map 使用，就可以单独缓存每个模块的 sourcemap，这样就可以在重新构建时候实现增量修改 sourcemap，节省时间。</p><p>如果不使用 eval 模式，就是一个文件（chunk）对应一个 sourcemap，重新构建时候需要将整个 chunk 的 sourcemap 重新生成，更耗费时间。</p><p>因此 eval 模式的优势就在于重新构建的速度更快</p><p><strong>source-map</strong></p><p>产生 source map</p><p><strong>cheap</strong></p><p>用来修饰 source-map<br>让 sourcemap 只保存行信息，不保存列信息<br>让 sourcemap 只将打包后的代码映射到转换过的代码，不映射到原始源代码<br>【由于源代码到转译后的代码的映射关系由相应的 loader 提供，因此 cheap 模式应该不需要关心这部分的 sourcemap】</p><p><strong>module</strong></p><p>用来修饰 cheap-source-map<br>让 sourcemap 可以映射到原始源代码<br>【由于源代码到转译后的代码的映射关系由相应的 loader 提供，因此 module 模式应该会处理这部分 sourcemap，以最终得到到原始源代码的映射】</p><p><strong>inline</strong></p><p>用来修饰 source-map<br>将.map 作为 DataURI 嵌入，不单独生成.map 文件</p><p><a href="https://www.jianshu.com/p/b2316aab32bb" target="_blank" >webpack 的 sourcemap 各种参数详解</a></p><table><thead><tr><th>devtool</th><th>构建速度</th><th>重新构建速度</th><th>生产环境</th><th>品质</th></tr></thead><tbody><tr><td>(none)</td><td>+++</td><td>+++</td><td>yes</td><td>打包后的代码</td></tr><tr><td>eval</td><td>+++</td><td>+++</td><td>no</td><td>生成后的代码</td></tr><tr><td>source-map</td><td>–</td><td>–</td><td>yes</td><td>原始源代码</td></tr><tr><td>eval-source-map</td><td>–</td><td>+</td><td>no</td><td>原始源代码</td></tr><tr><td>cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>转换过的代码（仅限行）</td></tr><tr><td>cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>原始源代码（仅限行）</td></tr><tr><td>cheap-eval-source-map</td><td>+</td><td>++</td><td>no</td><td>转换过的代码（仅限行）</td></tr><tr><td>cheap-module-eval-source-map</td><td>o</td><td>++</td><td>no</td><td>原始源代码（仅限行）</td></tr><tr><td>inline-source-map</td><td>–</td><td>–</td><td>no</td><td>原始源代码</td></tr><tr><td>inline-cheap-source-map</td><td>+</td><td>o</td><td>no</td><td>转换过的代码（仅限行）</td></tr><tr><td>inline-cheap-module-source-map</td><td>o</td><td>-</td><td>no</td><td>原始源代码（仅限行）</td></tr><tr><td>hidden-source-map</td><td>–</td><td>–</td><td>yes</td><td>原始源代码</td></tr><tr><td>nosources-source-map</td><td>–</td><td>–</td><td>yes</td><td>无源代码内容</td></tr></tbody></table><h2 id="模块打包原理知道吗？"><a href="#模块打包原理知道吗？" class="headerlink" title="模块打包原理知道吗？"></a>模块打包原理知道吗？</h2><p>Webpack <code>实际上为每个模块创造了一个可以导出和导入的环境</code>，<code>本质上并没有修改 代码的执行逻辑</code>，<code>代码执行顺序与模块加载顺序也完全一致</code>。</p><h2 id="文件指纹是什么？怎么用？"><a href="#文件指纹是什么？怎么用？" class="headerlink" title="文件指纹是什么？怎么用？"></a>文件指纹是什么？怎么用？</h2><p>文件指纹是打包后输出的文件名的后缀。</p><ul><li><code>Hash</code>：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</li><li><code>Chunkhash</code>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash</li><li><code>Contenthash</code>：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</li></ul><h3 id="JS-的文件指纹设置"><a href="#JS-的文件指纹设置" class="headerlink" title="JS 的文件指纹设置"></a>JS 的文件指纹设置</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; &#123;  entry: &#123;    app: &quot;.&#x2F;scr&#x2F;app.js&quot;,    search: &quot;.&#x2F;src&#x2F;search.js&quot;,  &#125;,  output: &#123;    filename: &quot;[name][chunkhash:8].js&quot;,    path: __dirname + &quot;&#x2F;dist&quot;,  &#125;,&#125;;</code></pre><h3 id="CSS-的文件指纹设置"><a href="#CSS-的文件指纹设置" class="headerlink" title="CSS 的文件指纹设置"></a>CSS 的文件指纹设置</h3><p>设置 <code>MiniCssExtractPlugin</code> 的 <code>filename</code>，使用 <code>contenthash</code>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; &#123;  entry: &#123;    app: &quot;.&#x2F;scr&#x2F;app.js&quot;,    search: &quot;.&#x2F;src&#x2F;search.js&quot;,  &#125;,  output: &#123;    filename: &quot;[name][chunkhash:8].js&quot;,    path: __dirname + &quot;&#x2F;dist&quot;,  &#125;,  plugins: [    new MiniCssExtractPlugin(&#123;      filename: &#96;[name][contenthash:8].css&#96;,    &#125;),  ],&#125;;</code></pre><h3 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h3><p>设置<code>file-loader</code>的<code>name</code>，使用<code>hash</code>。<br>占位符名称及含义</p><ul><li><code>ext</code> 资源后缀名</li><li><code>name</code> 文件名称</li><li><code>path</code> 文件的相对路径</li><li><code>folder</code> 文件所在的文件夹</li><li><code>contenthash</code> 文件的内容 hash，默认是 md5 生成</li><li><code>hash</code> 文件内容的 hash，默认是 md5 生成</li><li><code>emoji</code> 一个随机的指代文件内容的 emoj</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const path &#x3D; require(&quot;path&quot;);module.exports &#x3D; &#123;  entry: &quot;.&#x2F;src&#x2F;index.js&quot;,  output: &#123;    filename: &quot;bundle.js&quot;,    path: path.resolve(__dirname, &quot;dist&quot;),  &#125;,  module: &#123;    rules: [      &#123;        test: &#x2F;\.(png|svg|jpg|gif)$&#x2F;,        use: [          &#123;            loader: &quot;file-loader&quot;, &#x2F;&#x2F; 这里            options: &#123;              name: &quot;img&#x2F;[name][hash:8].[ext]&quot;, &#x2F;&#x2F; 这里            &#125;,          &#125;,        ],      &#125;,    ],  &#125;,&#125;;</code></pre><h2 id="如何对-bundle-体积进行监控和分析？"><a href="#如何对-bundle-体积进行监控和分析？" class="headerlink" title="如何对 bundle 体积进行监控和分析？"></a>如何对 bundle 体积进行监控和分析？</h2><ul><li>VSCode 中有一个插件 <code>Import Cost</code> 可以帮助我们对引入模块的大小进行实时监测，</li><li>还可以使用 <code>webpack-bundle-analyzer</code> 生成 bundle 的模块组成图，显示所占体积。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844904094281236487" target="_blank" >吐血整理」再来一打 Webpack 面试题</a></p><p><a href="https://juejin.cn/post/7073869980411887652" target="_blank" >最近两周出去面试遇到的面试题（前端初级、长更）</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-数组</title>
      <link href="//post/2022-07-14js-arr.html"/>
      <url>//post/2022-07-14js-arr.html</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><ul><li>创建</li><li>取值</li><li>查找</li><li>扁平化</li><li>遍历</li><li>返回 boolean</li><li>返回字符串</li><li>增&#x2F;删&#x2F;改&#x2F;拷贝&#x2F;解构</li></ul><details class="custom-details"><summary>详细内容</summary><p><img src="http://t-blog-images.aijs.top/img/202208022304934.png"  style="max-width: 100%; width: 500px"/></p></p></details><h2 id="查看数组-proto"><a href="#查看数组-proto" class="headerlink" title="查看数组 proto"></a>查看数组 <strong>proto</strong></h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3]; &#x2F;&#x2F; 将结果展开后，见下图</code></pre><img src="http://t-blog-images.aijs.top/img/20220714151858.webp" style="max-width: 100%; width: 500px"/><h2 id="哎呦-proto"><a href="#哎呦-proto" class="headerlink" title="哎呦 [].__proto__"></a>哎呦 <code>[].__proto__</code></h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object.getOwnPropertyDescriptors([].__proto__);</code></pre><img src="http://t-blog-images.aijs.top/img/20220714155241.webp"/><details class="custom-details"><summary>查看 json 数据</summary><p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;at&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;concat&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;constructor&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;copyWithin&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;entries&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;every&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;fill&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;filter&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;find&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;findIndex&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;findLast&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;findLastIndex&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;flat&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;flatMap&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;forEach&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;includes&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;indexOf&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;join&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;keys&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;lastIndexOf&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;length&quot;: &#123;    &quot;configurable&quot;: false,    &quot;enumerable&quot;: false,    &quot;value&quot;: 0,    &quot;writable&quot;: true  &#125;,  &quot;map&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;pop&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;push&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;reduce&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;reduceRight&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;reverse&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;shift&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;slice&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;some&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;sort&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;splice&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;toLocaleString&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;toString&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;unshift&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;,  &quot;values&quot;: &#123;    &quot;configurable&quot;: true,    &quot;enumerable&quot;: false,    &quot;writable&quot;: true  &#125;&#125;</code></pre></p></details><h2 id="一点想法"><a href="#一点想法" class="headerlink" title="一点想法"></a>一点想法</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Object.keys(Object.getOwnPropertyDescriptors([].__proto__));</code></pre><img src="http://t-blog-images.aijs.top/img/20220714155944.webp" /><h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><p>at() 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; [1, 2, 3];a[-1]; &#x2F;&#x2F; undefineda.at(-1); &#x2F;&#x2F; 3</code></pre><p><strong>polyfill</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (Array.at) &#123;  Array.proptotype.at &#x3D; function (index) &#123;    if (index &gt;&#x3D; 0) &#123;      return this[index];    &#125; else &#123;      return this.slice(index, index + 1)?.[0];    &#125;  &#125;;&#125;</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 语法var new_array &#x3D; old_array.concat(value1[, value2[, ...[, valueN]]])</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br>数组和&#x2F;或值，将被合并到一个新的数组中。如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个<code>浅拷贝</code></p><ul><li><strong>对象引用</strong>（而不是实际对象）：concat 将对象引用复制到新数组中。 原始数组和新数组都引用相同的对象。 也就是说，如果引用的对象被修改，则更改对于新数组和原始数组都是可见的。 这包括也是数组的数组参数的元素。</li><li><strong>数据类型</strong>如字符串，数字和布尔（不是 String，Number 和 Boolean 对象）：concat 将字符串和数字的值复制到新数组中。</li></ul></blockquote><p>使用：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat#examples" target="_blank" >见 MDN 示例</a></p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>constructor 属性返回 Object 的构造函数（用于创建实例对象）。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" >见</a></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><ol><li><p>注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p></li><li><p>可以为除了 null 和 undefined（因为这两者没有相应的构造函数）之外的任何类型指定</p></li><li><p>每当把这样的基本类型当成对象使用时，其对应的构造函数的实例就会在语句执行后立即被创建和丢弃。</p></li><li><p>任何对象都可以更改 constructor 属性的值，请注意，改变 constructor 的属性不会影响 instanceof 运算符</p></li><li><p>如果对象被密封或冻结，那么更改 constructor 将不会起作用，也不会抛出异常：</p></li></ol></div><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const a &#x3D; new Array();a.constructor &#x3D;&#x3D;&#x3D; Array; &#x2F;&#x2F; true</code></pre><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h2><p><code>左闭右开</code></p><p>copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const array1 &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];&#x2F;&#x2F; 把下标3的元素拷贝到下标为0的位置console.log(array1.copyWithin(0, 3, 4));&#x2F;&#x2F; [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]&#x2F;&#x2F; 把下标从3开始到结束的元素，拷贝到1的位置console.log(array1.copyWithin(1, 3));&#x2F;&#x2F; [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]</code></pre><h2 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h2><p>entries() 方法返回一个新的 Array Iterator 对象，该对象包含数组中每个索引的键&#x2F;值对。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries#%E7%A4%BA%E4%BE%8B" target="_blank" >示例见</a></p><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p><code>左闭右开</code></p><p>fill() 方法用一个固定值填充一个数组中, 从 起始索引 到 终止索引 内的全部元素。不包括 终止索引。</p><p><strong>语法</strong></p><p><code>arr.fill(value[, start[, end]])</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].fill(4); &#x2F;&#x2F; [4, 4, 4][1, 2, 3].fill(4, 1); &#x2F;&#x2F; [1, 4, 4][1, 2, 3].fill(4, 1, 2); &#x2F;&#x2F; [1, 4, 3][1, 2, 3].fill(4, 1, 1); &#x2F;&#x2F; [1, 2, 3][1, 2, 3].fill(4, 3, 3); &#x2F;&#x2F; [1, 2, 3][1, 2, 3].fill(4, -3, -2); &#x2F;&#x2F; [4, 2, 3][1, 2, 3].fill(4, NaN, NaN); &#x2F;&#x2F; [1, 2, 3][1, 2, 3].fill(4, 3, 5); &#x2F;&#x2F; [1, 2, 3]Array(3).fill(4); &#x2F;&#x2F; [4, 4, 4][].fill.call(&#123; length: 3 &#125;, 4); &#x2F;&#x2F; &#123;0: 4, 1: 4, 2: 4, length: 3&#125;</code></pre><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Objects by reference.var arr &#x3D; Array(3).fill(&#123;&#125;); &#x2F;&#x2F; [&#123;&#125;, &#123;&#125;, &#123;&#125;];&#x2F;&#x2F; 需要注意如果 fill 的参数为引用类型，会导致都执行同一个引用类型&#x2F;&#x2F; 如 arr[0] &#x3D;&#x3D;&#x3D; arr[1] 为 truearr[0].hi &#x3D; &quot;hi&quot;; &#x2F;&#x2F; [&#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;, &#123; hi: &quot;hi&quot; &#125;]</code></pre></p></div><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><h2 id="findLast"><a href="#findLast" class="headerlink" title="findLast"></a>findLast</h2><h2 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h2><h2 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h2><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><h2 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h2><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h2><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>左闭右开</code></p><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）。原始数组不会被改变。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 语法arr.slice([begin[, end]])</code></pre><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort() 方法用原地算法对数组的元素进行排序，并返回数组。<code>默认排序顺序是在将元素转换为字符串</code>，然后比较它们的 UTF-16 代码单元值序列时构建的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const months &#x3D; [&quot;March&quot;, &quot;Jan&quot;, &quot;Feb&quot;, &quot;Dec&quot;];months.sort();console.log(months);&#x2F;&#x2F;  [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]const array1 &#x3D; [1, 30, 4, 21, 100000];array1.sort();console.log(array1);&#x2F;&#x2F; [1, 100000, 21, 30, 4]</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>ES10（EcmaScript 2019）以前没有要求稳定性，意味着你<code>可能</code>会得到以下结果：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const students &#x3D; [  &#123; name: &quot;Alex&quot;, grade: 15 &#125;,  &#123; name: &quot;Devlin&quot;, grade: 15 &#125;,  &#123; name: &quot;Eagle&quot;, grade: 13 &#125;,  &#123; name: &quot;Sam&quot;, grade: 14 &#125;,];students.sort((firstItem, secondItem) &#x3D;&gt; firstItem.grade - secondItem.grade);&#x2F;&#x2F; es10 +&#x2F;&#x2F; [&#x2F;&#x2F;   &#123; name: &quot;Eagle&quot;,  grade: 13 &#125;,&#x2F;&#x2F;   &#123; name: &quot;Sam&quot;,    grade: 14 &#125;,&#x2F;&#x2F;   &#123; name: &quot;Alex&quot;,   grade: 15 &#125;, &#x2F;&#x2F; grade 相同时维持原先的顺序 (稳定排序)&#x2F;&#x2F;   &#123; name: &quot;Devlin&quot;, grade: 15 &#125;, &#x2F;&#x2F; grade 相同时维持原先的顺序 (稳定排序)&#x2F;&#x2F; ];&#x2F;&#x2F; - es9&#x2F;&#x2F; [&#x2F;&#x2F;   &#123; name: &quot;Eagle&quot;,  grade: 13 &#125;,&#x2F;&#x2F;   &#123; name: &quot;Sam&quot;,    grade: 14 &#125;,&#x2F;&#x2F;   &#123; name: &quot;Devlin&quot;, grade: 15 &#125;, &#x2F;&#x2F; 没有维持原先的顺序&#x2F;&#x2F;   &#123; name: &quot;Alex&quot;,   grade: 15 &#125;, &#x2F;&#x2F; 没有维持原先的顺序&#x2F;&#x2F; ];</code></pre></div><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法<strong>会改变原数组</strong>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice#%E7%A4%BA%E4%BE%8B" target="_blank" >示例见</a></p><h2 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h2><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift"></a>unshift</h2><h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; [1, 2, 3];Array.from(a.keys()); &#x2F;&#x2F; [0, 1, 2]a.fill(10); &#x2F;&#x2F;  [10, 10, 10]a.fill(1, 0, 1); &#x2F;&#x2F;  [1, 10, 10]Array.from(a.entries()); &#x2F;&#x2F; [[0,1],[1,10],[2,10]]</code></pre><h2 id="几个非原型链上的方法"><a href="#几个非原型链上的方法" class="headerlink" title="几个非原型链上的方法"></a>几个非原型链上的方法</h2><h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray"></a>isArray</h3><ol><li>Array.prototype 也是一个数组</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.isArray(Array.prototype); &#x2F;&#x2F; 鲜为人知的事实：其实 Array.prototype 也是一个数组。</code></pre><ol start="2"><li>instanceof_和_isArray<br>当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能检测 iframes</li><li>polyfill</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (!Array.isArray) &#123;  Array.isArray &#x3D; function (arg) &#123;    return Object.prototype.toString.call(arg) &#x3D;&#x3D;&#x3D; &quot;[object Array]&quot;;  &#125;;&#125;</code></pre><h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.of(7); &#x2F;&#x2F; [7]Array.of(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]Array(7); &#x2F;&#x2F; [ , , , , , , ]Array(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" >MDN Array</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie注入问题</title>
      <link href="//post/2022-07-12cookie.html"/>
      <url>//post/2022-07-12cookie.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>注入的 cookie 怎么没有啦，在<code>vconsole</code>中调试查看，<code>storage</code>有<code>cookie</code>信息,接口调用，发现没有 cookie 被<code>SSO</code>校验拦截住了</p><h2 id="抓包结果"><a href="#抓包结果" class="headerlink" title="抓包结果"></a>抓包结果</h2><p><strong>服务端渲染，中间有代理转发，nextjs 服务端自适应</strong></p><img src="http://t-blog-images.aijs.top/img/20220712110204.webp" /><p><strong>接口请求</strong></p><img src="http://t-blog-images.aijs.top/img/20220712110334.webp" /><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过 chrome,手动注入调试发现正常。手动注入一般情况是默认<code>/</code>,字段不是很多，cookie 注入有问题，问题大概出现在 path</p><img src="http://t-blog-images.aijs.top/img/20220712154936.webp" /><img src="http://t-blog-images.aijs.top/img/20220712154647.webp" /><p>直接搜了下<code>cookie path</code>就把问题解决了</p><h2 id="修改前代码"><a href="#修改前代码" class="headerlink" title="修改前代码"></a>修改前代码</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">(function () &#123;  document.cookie &#x3D; &quot;SSO_USER_TOKEN&#x3D;值;&quot;;&#125;)();</code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><strong><code>默认path</code></strong></p><img src="http://t-blog-images.aijs.top/img/20220712104539.webp" /><p><strong><code>path=/</code></strong></p><img src="http://t-blog-images.aijs.top/img/20220712104801.webp" /><h2 id="cookie-的-path-值的默认规则"><a href="#cookie-的-path-值的默认规则" class="headerlink" title="cookie 的 path 值的默认规则"></a>cookie 的 path 值的默认规则</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.jianshu.com/p/48556e5c44f5" target="_blank" >cookie 的 path 值的默认规则</a><br>当 cookie 的 path 设置了值不为 null 的时候，以设置的值为准。(<strong>满足当前场景需要</strong>)<br>当 cookie 的 path 为 null 时候，获取请求的 URI 的 path 值<br>1). 当 URI 的 path 值是以“&#x2F;”结尾的时候，直接设置为 cookie 的 path 值<br>2). 当 URI 的 path 值不是以“&#x2F;”结尾的时候，查看 path 里面是否有“&#x2F;”<br>2.1). 如果有“&#x2F;”的话，直接截取到最后一个“&#x2F;”，然后设置为 cookie 的 path 值。<br>2.2). 如果没有“&#x2F;”的话，将 cookie 的 path 设置为”&#x2F;”。</p></blockquote><p><strong>对于 1).测试结果如下：</strong>并不满足本次业务需要</p><img src="http://t-blog-images.aijs.top/img/20220712162419.webp" /><h2 id="修改后代码"><a href="#修改后代码" class="headerlink" title="修改后代码"></a>修改后代码</h2><p>将 cookie 注入到<code>/</code>,代码<code>path=/;</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">(function () &#123;  document.cookie &#x3D; &quot;SSO_USER_TOKEN&#x3D;值;path&#x3D;&#x2F;;&quot;;&#125;)();</code></pre><h2 id="各字段含义"><a href="#各字段含义" class="headerlink" title="各字段含义"></a>各字段含义</h2><p><a href="https://baike.baidu.com/item/cookie/1119" target="_blank" >百度百科</a></p><p>Cookie 是一段不超过 4KB 的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成。其中 ：</p><ul><li>(1)<strong>Name&#x2F;Value</strong>：设置 Cookie 的名称及相对应的值，对于认证 Cookie，Value 值包括 Web 服务器所提供的访问令牌 。</li><li>(2)<strong>Expires 属性</strong>：设置 Cookie 的生存期。有两种存储类型的 Cookie：<strong>会话性</strong>与<strong>持久性</strong>。<ul><li><em>Expires 属性缺省时，为会话性 Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效;</em></li><li><em>持久性 Cookie 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</em></li></ul></li><li>(3)<strong>Path 属性</strong>：定义了 Web 站点上可以访问该 Cookie 的目录 。</li><li>(4)<strong>Domain 属性</strong>：指定了可以访问该 Cookie 的 Web 站点或域。<strong>Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie</strong>。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie 受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围 。</li><li>(5)<strong>Secure 属性</strong>：指定是否使用 HTTPS 安全协议发送 Cookie。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。该方法也可用于 Web 站点的身份鉴别，即在 HTTPS 的连接建立阶段，浏览器会检查 Web 网站的 SSL 证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到 SSL 证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。由于许多用户缺乏安全意识，因而仍可能连接到 Pharming 攻击所伪造的网站 。</li><li>(6)<strong>HTTPOnly 属性</strong> ：用于防止客户端脚本通过 document.cookie 属性访问 Cookie，有助于保护 Cookie 不被跨站脚本攻击窃取或篡改。但是，HTTPOnly 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 Cookie 的读操作，但允许写操作；此外大多数浏览器仍允许通过 XMLHTTP 对象读取 HTTP 响应中的 Set-Cookie 头 。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/48556e5c44f5" target="_blank" >cookie 的 path 值的默认规则</a></p><p><a href="https://baike.baidu.com/item/cookie/1119" target="_blank" >百度百科</a></p>]]></content>
      
      
      <categories>
          
          <category> webview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webview </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信文件预览</title>
      <link href="//post/2022-07-05wxfile.html"/>
      <url>//post/2022-07-05wxfile.html</url>
      
        <content type="html"><![CDATA[<h2 id="企业微信文件预览"><a href="#企业微信文件预览" class="headerlink" title="企业微信文件预览"></a>企业微信文件预览</h2><p><strong>试错 1:</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const fileName &#x3D; &quot;xxxxx.jpeg&quot;; &#x2F;&#x2F; 举个例子downloadAttachment(downloadUrl).then((res) &#x3D;&gt; &#123;  var reader &#x3D; new FileReader();  reader.readAsDataURL(res); &#x2F;&#x2F; 转换为base64，可以直接放入a标签href  reader.onload &#x3D; function (e) &#123;    const anchorEle &#x3D; document.createElement(&quot;a&quot;);    document.body.appendChild(anchorEle);    anchorEle.href &#x3D; e?.target?.result as any;    anchorEle.download &#x3D; fileName;    anchorEle.click();    setTimeout(() &#x3D;&gt; &#123;      document.body.removeChild(anchorEle);    &#125;);  &#125;;&#125;);</code></pre><p><strong>试错 2: file-saver</strong></p><p><strong>试错 3: file-saver</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const downloadFile &#x3D; (target, filename &#x3D; &quot;&quot;, type &#x3D; &quot;url&quot;) &#x3D;&gt; &#123;  const link &#x3D; document.createElement(&quot;a&quot;);  const body &#x3D; document.querySelector(&quot;body&quot;);  if (!body) return;  &#x2F;&#x2F; 需下载的文件类型  if (type &#x3D;&#x3D;&#x3D; &quot;url&quot;) &#123;    link.href &#x3D; target;  &#125; else if (type &#x3D;&#x3D;&#x3D; &quot;blob&quot;) &#123;    link.href &#x3D; window.URL.createObjectURL(target);  &#125;  &#x2F;&#x2F; 文件名  if (filename) link.download &#x3D; filename;  link.style.display &#x3D; &quot;none&quot;;  body.appendChild(link);  link.click();  window.URL.revokeObjectURL(link.href); &#x2F;&#x2F; 释放 URL 对象  body.removeChild(link);&#125;;</code></pre><p>在浏览器上没问题，在企业微信上<code>嗝屁～</code>，有人要说了，直接<code>window.open(downloadUrl)</code>,通常来说没毛病。</p><p><strong>可是</strong>，要在请求<code>downloadUrl</code>接口时候要加一个请求头，这尼玛整的～</p><img src="http://t-blog-images.aijs.top/img/20220705223754.webp" /><h2 id="这场景真-🐶"><a href="#这场景真-🐶" class="headerlink" title="这场景真 🐶"></a>这场景真 🐶</h2><p>为什么有这么奇葩的事情呢？—— 继之前，对同一个域名，以请求头区分是<strong>企业微信</strong>、<strong>非企业微信</strong>，两种环境的授权校验方式不同。本身涉及没使用 userAgent,设计缺陷，导致一连串问题。</p><p>问：<code>你怎么不重构？</code> 答：<code>部门都被裁了，我再努力有用吗？</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>方案 1: 按照之前的设计，再申请个域名，按照域名把应用拆分（<code>这个要走审核</code>）</p><p>方案 2: 后端处理用<code>userAgent</code>处理下，其他地方逻辑不动，只处理 a 标签下载的情况（<code>这个要后端改---没权限我觉得我自己改或许更快</code>）</p><p>方案 3: 把 API 改了，哪里出问题改哪里 <code>api/wx/download</code> 给这个增加请求头， 代理到 <code>api/download</code>（<code>这里应该会带过来请求头</code>）</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let fileUrl &#x3D;  &quot;themis&#x2F;attach&#x2F;download?cloudKey&#x3D;&quot; +  attachment.themisCloudKey +  &quot;&amp;fileName&#x3D;&quot; +  encodeURIComponen(attachment.name);&#x2F;&#x2F; 企业微信if (getWechatUserAgent(navigator.userAgent)) &#123;  downloadFile(&#96;&#x2F;api&#x2F;redline&#x2F;wx&#x2F;$&#123;fileUrl&#125;&#96;);  &#x2F;&#x2F; 非企业微信&#125; else &#123;  downloadFile(&#96;&#x2F;api&#x2F;redline&#x2F;$&#123;fileUrl&#125;&#96;);&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/20220706000557.webp" /><img src="http://t-blog-images.aijs.top/img/20220706000652.webp" /><p>哈哈～，开心～</p>]]></content>
      
      
      <categories>
          
          <category> 企业微信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js算法</title>
      <link href="//post/2022-07-04js.html"/>
      <url>//post/2022-07-04js.html</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><img src="https://img-blog.csdnimg.cn/img_convert/afb80e39ce7684d6330fdc66b0873abd.gif" width=300 /><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><img src="https://img-blog.csdnimg.cn/img_convert/76339a259488423b03370e381ca5edb0.gif" width=300/><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><img src="https://img-blog.csdnimg.cn/img_convert/c894e22dcc48b03559e3087627e3dbb8.gif" width=300/><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><img src="https://img-blog.csdnimg.cn/956f63eccd75480791c85edd8ce91658.gif" width=300/><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><img src="http://t-blog-images.aijs.top/img/1940317-acc6c6f16b096794.gif" /><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><img src="https://img-blog.csdnimg.cn/img_convert/4ad3b539bee9bfe9a6acdba476ceed78.gif" width=300 /><img src="http://t-blog-images.aijs.top/img/20220704153839.webp" /><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;*快排是冒泡的一种改进，基于分治思想*&#x2F;const arr2 &#x3D; [2, 44, 1, 0, -22, 56, -78];function quickSort2(arr) &#123;  if (arr.length &#x3D;&#x3D;&#x3D; 0) return arr;  const pivot &#x3D; arr.pop(); &#x2F;&#x2F; 使用最后一个元素当作基准数  const left &#x3D; [],    right &#x3D; [];  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;    if (arr[i] &lt; pivot) left.push(arr[i]); &#x2F;&#x2F; 小于基准数则放到left    else right.push(arr[i]); &#x2F;&#x2F; 大于基准数则放到right  &#125;  &#x2F;&#x2F; 合并left的快排结果，基准数和右侧的快排结果  return quickSort2(left).concat(pivot, quickSort2(right));&#125;console.log(quickSort2(arr2));</code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function deepClone(obj) &#123;  let result;  if (typeof obj &#x3D;&#x3D; &quot;object&quot;) &#123;    &#x2F;&#x2F; 非基本数据类型，遍历赋值    result &#x3D; isArray(obj) ? [] : &#123;&#125;; &#x2F;&#x2F; 空对象接收    for (let i in obj) &#123;      result[i] &#x3D;        isObject(obj[i]) || isArray(obj[i]) ? deepClone(obj[i]) : obj[i];    &#125;  &#125; else &#123;    &#x2F;&#x2F;基本数据类型，直接赋值    result &#x3D; obj;  &#125;  return result;&#125;function isObject(obj) &#123;  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Object]&quot;;&#125;function isArray(obj) &#123;  return Object.prototype.toString.call(obj) &#x3D;&#x3D; &quot;[object Array]&quot;;&#125;</code></pre><h2 id="深比较"><a href="#深比较" class="headerlink" title="深比较"></a>深比较</h2><p>实现一个 compare 函数，比较两个对象是否相同<a href="https://www.jianshu.com/p/0828ded57b19#:~:text=%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83-,%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A,-//%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6" target="_blank" >见</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * 原理： * 1. 基本数据类型比较 * 2. 复合类型，递归每个值依次比较 **&#x2F;function deepCompare(a, b) &#123;  if (    a &#x3D;&#x3D;&#x3D; null ||    typeof a !&#x3D;&#x3D; &quot;object&quot; ||    b &#x3D;&#x3D;&#x3D; null ||    typeof b !&#x3D;&#x3D; &quot;object&quot; &#x2F;&#x2F; 基础类型&#x2F;null的数据类型，可以直接比较  ) &#123;    &#x2F;&#x2F; 基本数据类型    return a &#x3D;&#x3D;&#x3D; b;  &#125;  const propsA &#x3D; Object.getOwnPropertyDescriptors(a);  &#x2F;&#x2F; Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。  const propsB &#x3D; Object.getOwnPropertyDescriptors(b);  &#x2F;&#x2F; 键是否长度一致  if (Object.keys(propsA).length !&#x3D;&#x3D; Object.keys(propsB).length) &#123;    return false;  &#125;  &#x2F;&#x2F; 键长度一致情况，比较值，需要每个都是相等  return Object.keys(propsA).every((key) &#x3D;&gt; deepCompare(a[key], b[key]));&#125;</code></pre><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 去抖动原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时.&#x2F;&#x2F; 方法1const debounce &#x3D; function (fn, delay) &#123;  let timer &#x3D; null; &#x2F;&#x2F; 闭包维护一个timer  return (...args) &#x3D;&gt; &#123;    &#x2F;&#x2F; 柯里化    clearTimeout(timer);    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;      fn?.apply(this, args); &#x2F;&#x2F; this指向window    &#125;, delay);  &#125;;&#125;;&#x2F;&#x2F; 测试let biu &#x3D; function () &#123;  console.log(&quot;biu biu biu&quot;, new Date().getTime());&#125;;let boom &#x3D; function () &#123;  console.log(&quot;boom boom boom&quot;, new Date().getTime());&#125;;var a &#x3D; setInterval(debounce(biu, 500), 1000);var b &#x3D; setInterval(debounce(boom, 2000), 1000);setTimeout(() &#x3D;&gt; &#123;  clearInterval(a);  clearInterval(b);&#125;, 10000);</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const throttle &#x3D; (fn, delay &#x3D; 500) &#x3D;&gt; &#123;  let allow &#x3D; true; &#x2F;&#x2F; 守门员，delay秒钟放进去一个球  return (...args) &#x3D;&gt; &#123;    if (!allow) return;    allow &#x3D; false;    setTimeout(() &#x3D;&gt; &#123;      fn.apply(this, args);      allow &#x3D; true;    &#125;, delay);  &#125;;&#125;;</code></pre><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><ul><li>语法</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function.call(thisArg, arg1, arg2, ...)</code></pre><ul><li>参数<br><code>thisArg</code>可选的。在 function 函数运行时使用的 this 值。请注意，this 可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。<br><code>arg1, arg2, ...</code> 指定的参数列表。</li><li>返回值<br>使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。</li><li>实现原理</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Function.prototype.myCall &#x3D; function (context) &#123;  var context &#x3D; context || window;  context.fn &#x3D; this;  var args &#x3D; [];  for (var i &#x3D; 1, len &#x3D; arguments.length; i &lt; len; i++) &#123;    args.push(&quot;arguments[&quot; + i + &quot;]&quot;);  &#125;  var result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;);  delete context.fn;  return result;&#125;;</code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ul><li>语法</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">apply(thisArg);apply(thisArg, argsArray);</code></pre><ul><li>参数</li></ul><p><code>thisArg</code>在 func 函数运行时使用的 this 值。请注意，this 可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p><p><code>argsArray</code> 可选,一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</p><ul><li>返回值</li></ul><p>调用有指定 this 值和参数的函数的结果。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Function.prototype.myApply &#x3D; function (context, arr) &#123;  var context &#x3D; context || window;  context.fn &#x3D; this;  var result;  if (!arr) &#123;    &#x2F;&#x2F; 没有参数    result &#x3D; context.fn();  &#125; else &#123;    &#x2F;&#x2F; 有参数    var args &#x3D; [];    for (let i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i++) &#123;      args.push(&quot;arr[&quot; + i + &quot;]&quot;);    &#125;    result &#x3D; eval(&quot;context.fn(&quot; + args + &quot;)&quot;);  &#125;  delete context.fn;  return result;&#125;;</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p><a href="https://blog.csdn.net/weixin_45774485/article/details/122462081" target="_blank" >手写 promise 的方法（all、race、allSettled、any、finally）</a></p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ul><li>要么返回全部 resolve 结果，要么返回一个 reject</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise.myAll &#x3D; function (promises) &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    let res &#x3D; [];    promises.forEach((promise, index) &#x3D;&gt; &#123;      Promise.resolve(promise) &#x2F;&#x2F; 防止你不是一个promise        &#x2F;&#x2F; 如果参数是一个原始值,或者是一个不具有then方法的对象,则Promise.resolve方法返回一个新的 Promise 对象,状态为resolved        &#x2F;&#x2F; @link https:&#x2F;&#x2F;wenku.baidu.com&#x2F;view&#x2F;8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html        .then((data) &#x3D;&gt; &#123;          res.push(data);          if (index &#x3D;&#x3D;&#x3D; promises.length - 1) &#123;            &#x2F;&#x2F; 所有的都没有异常            resolve(res);          &#125;        &#125;)        .catch((err) &#x3D;&gt; &#123;          &#x2F;&#x2F; 捕获，直接返回          reject(err);        &#125;);    &#125;);  &#125;);&#125;;</code></pre><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><ul><li>不管 resolve, reject，见到就返回</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise.myRace &#x3D; (promises) &#x3D;&gt;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    promises?.forEach((promise) &#x3D;&gt; &#123;      promise.then(resolve, reject);    &#125;);  &#125;);</code></pre><h3 id="Promise-allSettle"><a href="#Promise-allSettle" class="headerlink" title="Promise.allSettle"></a>Promise.allSettle</h3><ul><li>全部结果，resolve, reject 都要</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise.myAllSettled &#x3D; function (promises) &#123;  let len &#x3D; promises.length;  let result &#x3D; new Array(len);  let count &#x3D; 0;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    for (let p of promises) &#123;      Promise.resolve(p).then(        (res) &#x3D;&gt; &#123;          &#x2F;&#x2F;成功：加入装状态列表          result[count] &#x3D; &#123;            &#x2F;&#x2F;记录当前promise信息            status: &quot;fullfilled&quot;,            result: res,          &#125;;          if (++count &#x3D;&#x3D; len) &#123;            &#x2F;&#x2F;遍历完，走resolve            resolve(result);          &#125;        &#125;,        (err) &#x3D;&gt; &#123;          &#x2F;&#x2F;失败：加入状态列表          result[count] &#x3D; &#123;            &#x2F;&#x2F;记录当前promise状态信息            status: &quot;rejected&quot;,            result: err,          &#125;;          if (++count &#x3D;&#x3D; len) &#123;            &#x2F;&#x2F;遍历完依然走resolve            reject(result);          &#125;        &#125;      );    &#125;  &#125;);&#125;;</code></pre><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><ul><li>要么没有 resolve 的,返回全部 reject 结果，要么有一个 resolve 的返回 resolve 结果(看上去和<code>Promise.all</code>刚好反过来了)</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise.myAny &#x3D; function (promises) &#123;  let res &#x3D; [],    count &#x3D; 0,    len &#x3D; promises.length;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    for (let p of promises) &#123;      Promise.resolve(p).then(        (res) &#x3D;&gt; &#123;          resolve(res); &#x2F;&#x2F; 只要有一个成功，就走resolve        &#125;,        (err) &#x3D;&gt; &#123;          res[count] &#x3D; err; &#x2F;&#x2F; 遇到错误先不管，继续检查          if (++count &#x3D;&#x3D; len) &#123;            &#x2F;&#x2F; 直到遇到成功的或检查完            reject(res);          &#125;        &#125;      );    &#125;  &#125;);&#125;;</code></pre><h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally"></a>Promise.finally</h3><ul><li>无论哪个执行完，回调下</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise.prototype.myFinally &#x3D; function (cb) &#123;  &#x2F;&#x2F;cb就是要共同执行的逻辑  return this.then(    &#x2F;&#x2F;谁调用finally，this就是谁    (value) &#x3D;&gt; Promise.resolve(cb()), &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb    (error) &#x3D;&gt; Promise.resolve(cb()) &#x2F;&#x2F;不管调用finally的promise是什么状态都会执行这个cb  );&#125;;</code></pre><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><ul><li>无论哪个执行完，回调下</li></ul><p><a href="https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html" target="_blank" >见 Promise.resolve（）详解</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Promise.prototype.myResolve &#x3D; function (params) &#123;  return new Promise((resolve) &#x3D;&gt; resolve(params));&#125;;</code></pre><h2 id="使用-Promise-过程中-resolve-或-reject-后，后面代码还会执行，默认加-return-较妥"><a href="#使用-Promise-过程中-resolve-或-reject-后，后面代码还会执行，默认加-return-较妥" class="headerlink" title="使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥"></a>使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥</h2><p><a href="https://www.freesion.com/article/68121031859/" target="_blank" >使用 Promise 过程中 resolve 或 reject 后，后面代码还会执行，默认加 return 较妥</a></p><h2 id="限制并发数量"><a href="#限制并发数量" class="headerlink" title="限制并发数量"></a>限制并发数量</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 原理：将在用数量，限制在最大数量内的异步直接发，&#x2F;&#x2F; 限制外的现存到数组中，当在用数量减少时一个一个取出来运行export class LimitPromise &#123;  private limit: number;        &#x2F;&#x2F; 最大限制数  private count: number;        &#x2F;&#x2F; 目前并发的数量  private taskQueue: any[];     &#x2F;&#x2F; 如果并发数等于最大限制，则把新加的异步操作用数组存起来  constructor(limit: number) &#123;    this.limit &#x3D; limit;    this.count &#x3D; 0;    this.taskQueue &#x3D; [];  &#125;  &#x2F;&#x2F; 管理任务执行  private createTask(    asyncFn: Function,    args: any[],    resolve: (value: unknown) &#x3D;&gt; void,    reject: (reason?: any) &#x3D;&gt; void,  ) &#123;    return () &#x3D;&gt; &#123;      asyncFn(...args)        .then(resolve)        .catch(reject)        .finally(() &#x3D;&gt; &#123;          this.count--; &#x2F;&#x2F; 任务结束后，对任务队列进行出列，执行          if (this.taskQueue.length) &#123;            let task &#x3D; this.taskQueue.shift();            task();          &#125;        &#125;);      this.count++; &#x2F;&#x2F; 在执行的数量    &#125;;  &#125;  &#x2F;&#x2F; 管理队列  public call(asyncFn: Function, ...args: any[]) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F; 这层promise令人费解，主要是为了提供resolve和reject给 limitP.call，这样limitP可以做些其他的事情，理论上没有必要      const task &#x3D; this.createTask(asyncFn, args, resolve, reject); &#x2F;&#x2F; 创建任务      if (this.count &gt;&#x3D; this.limit) &#123; &#x2F;&#x2F; 大于限制的存起来        this.taskQueue.push(task);      &#125; else &#123; &#x2F;&#x2F; 否则直接执行        task();      &#125;    &#125;);  &#125;&#125;let limitP &#x3D; new LimitPromise(3)&#x2F;&#x2F; 测试function sleep(sec: number) &#123;  console.log(&#39;..............&#39;);  return new Promise((resolve, reject) &#x3D;&gt; &#123;    setTimeout(() &#x3D;&gt; &#123;      console.log(&#39;等待了&#39; + sec + &#39;秒&#39;);      resolve(&#39;&#39;);    &#125;, sec * 1000);  &#125;);&#125;limitP.call(sleep, 1);limitP.call(sleep, 2);limitP.call(sleep, 3);limitP.call(sleep, 4);limitP.call(sleep, 5);limitP.call(sleep, 6);&#x2F;&#x2F; https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;typescript-sdhev3?file&#x3D;index.ts</code></pre><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p><a href="https://blog.csdn.net/weixin_45663702/article/details/123504807" target="_blank" >常见前端面试题–数组去重</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 方案1:function unique(arr) &#123;  return Array.from(new Set(arr));&#125;let arr &#x3D; [  1,  1,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));&#x2F;&#x2F; [&#39;1&#39;, &#39;true&#39;, true, 15, undefined, null, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]&#x2F;&#x2F;无法去掉&#39;&#123;&#125;&#39;空对象&#x2F;&#x2F; 方案2:function unique(arr) &#123;  return arr.filter(function (item, index, arr) &#123;    &#x2F;&#x2F; 当前元素，在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，否则返回当前元素    return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;  &#125;);&#125;let arr &#x3D; [  1,  1,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]&#x2F;&#x2F; &#123;&#125;不能去重&#x2F;&#x2F; 方案3:function unique(arr) &#123;  return arr.reduce(    (prev, cur) &#x3D;&gt; (prev.includes(cur) ? prev : [...prev, cur]),    []  );&#125;let arr &#x3D; [  1,  1,  &quot;true&quot;,  true,  true,  15,  15,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &quot;NaN&quot;,  0,  0,  &quot;a&quot;,  &quot;a&quot;,  &#123;&#125;,  &#123;&#125;,];console.log(unique(arr));&#x2F;&#x2F; [1, &#39;true&#39;, true, 15, false, undefined, null, NaN, &#39;NaN&#39;, 0, &#39;a&#39;, &#123;&#125;, &#123;&#125;]</code></pre><h2 id="将奇数排在前面，偶数排在后面。要求时间复杂度-O-n-。空间复杂度-O-1-（不能用-splice）"><a href="#将奇数排在前面，偶数排在后面。要求时间复杂度-O-n-。空间复杂度-O-1-（不能用-splice）" class="headerlink" title="将奇数排在前面，偶数排在后面。要求时间复杂度 O(n)。空间复杂度 O(1)（不能用 splice）"></a>将奇数排在前面，偶数排在后面。要求时间复杂度 O(n)。空间复杂度 O(1)（不能用 splice）</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var testAry &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9];var newAry &#x3D; [];testAry.forEach((item, i) &#x3D;&gt; &#123;  let n &#x3D; Number(item);  if (n % 2 &#x3D;&#x3D; 0) &#123;    newAry.push(n);  &#125; else &#123;    newAry.unshift(n);  &#125;&#125;);console.log(newAry); &#x2F;&#x2F;[&quot;9&quot;,&quot;7&quot;,&quot;5&quot;,&quot;3&quot;,&quot;1&quot;,&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]</code></pre><h2 id="数组转树结构"><a href="#数组转树结构" class="headerlink" title="数组转树结构"></a>数组转树结构</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const arr &#x3D; [    &#123; id: 1, pid: 0 &#125;,    &#123; id: 2, pid: 1 &#125;,    &#123; id: 3, pid: 1 &#125;,    &#123; id: 4, pid: 2 &#125;,    &#123; id: 5, pid: 2 &#125;,    &#123; id: 6, pid: 3 &#125;,];&#x2F;&#x2F; 要求编写一个函数 arr2tree(arr)，得到输出结果如下：&#123;    &quot;id&quot;: 0,    &quot;children&quot;: [        &#123;            &quot;id&quot;: 1,            &quot;children&quot;: [                &#123;                    &quot;id&quot;: 2,                    &quot;children&quot;: [                        &#123;                            &quot;id&quot;: 4                        &#125;,                        &#123;                            &quot;id&quot;: 5                        &#125;                    ]                &#125;,                &#123;                    &quot;id&quot;: 3,                    &quot;children&quot;: [                        &#123;                            &quot;id&quot;: 6                        &#125;                    ]                &#125;            ]        &#125;    ]&#125;</code></pre><p><strong>实现</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function arr2tree(arr) &#123;  let hash &#x3D; &#123;&#125;;  const result &#x3D; [];  &#x2F;&#x2F; 放到对象中  for (let item of arr) &#123;    hash[item.id] &#x3D; item;  &#125;  for (let item of arr) &#123;    const parent &#x3D; hash[item.pid];    if (parent) &#123;      if (!parent.children) &#123;        parent.children &#x3D; [];      &#125;      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除      parent.children.push(item); &#x2F;&#x2F; 之所以能够实现，原因：使用了数组引用    &#125; else &#123;      delete item.pid; &#x2F;&#x2F; 比结果多的字段删除      result.push(item); &#x2F;&#x2F; 只有第一次pid &#x3D; 0的时候，树根节点才走这里    &#125;  &#125;  hash &#x3D; undefined; &#x2F;&#x2F; 这里记得回收  return result;&#125;const res &#x3D; arr2tree(arr);console.log(&quot;res&quot;, JSON.stringify(res, null, 2));</code></pre><h2 id="解析-URL-中所有的部分"><a href="#解析-URL-中所有的部分" class="headerlink" title="解析 URL 中所有的部分"></a>解析 URL 中所有的部分</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function parseParam(url) &#123;  const paramsStr &#x3D; &#x2F;.+\?(.+)$&#x2F;.exec(url)[1]; &#x2F;&#x2F; ?之后部分截取  const paramsArr &#x3D; paramsStr.split(&quot;&amp;&quot;); &#x2F;&#x2F; 拆分kv对  let paramsObj &#x3D; &#123;&#125;;  paramsArr.forEach((param) &#x3D;&gt; &#123;    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;      &#x2F;&#x2F;      let [key, val] &#x3D; param.split(&quot;&#x3D;&quot;);      val &#x3D; decodeURIComponent(val); &#x2F;&#x2F; 解码      val &#x3D; &#x2F;^\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 字符串数值转化      if (paramsObj.hasOwnProperty(key)) &#123;        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 这个没有直接push, 利用concat特性（数组concat,非数组push）      &#125; else &#123;        paramsObj[key] &#x3D; val;      &#125;    &#125; else &#123;      &#x2F;&#x2F; 有些没有&#x3D;号      paramsObj[param] &#x3D; true;    &#125;  &#125;);  return paramsObj;&#125;</code></pre><!-- ## 使用 es5 实现 es6 的 let 关键字<a href="https://blog.csdn.net/weixin_44242181/article/details/124340622" target="_blank" >es5 实现 es6+新特性</a> --><h2 id="中划线转大写"><a href="#中划线转大写" class="headerlink" title="中划线转大写"></a>中划线转大写</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var str &#x3D; &quot;get-user-by-id&quot;;var f &#x3D; function (s) &#123;  return s.replace(&#x2F;-\w&#x2F;g, function (x) &#123;    return x.slice(1).toUpperCase();  &#125;);&#125;;</code></pre><h2 id="金额千分"><a href="#金额千分" class="headerlink" title="金额千分"></a>金额千分</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function parseToMoney(num) &#123;  num &#x3D; parseFloat(num).toFixed(3);  let [integer, decimal] &#x3D; String.prototype.split.call(num, &quot;.&quot;);  integer &#x3D; integer.replace(&#x2F;\d(?&#x3D;(\d&#123;3&#125;)+$)&#x2F;g, &quot;$&amp;,&quot;);  &#x2F;&#x2F; 从右到左“三个数值一组” ?&#x3D; 尽可能多的去匹配  return &#96;$&#123;integer&#125;.$&#123;decimal&#125;&#96;;&#125;console.log(parseToMoney(10000000.0));&#x2F;&#x2F; $&amp; 与regexp相匹配的子串。 &#x2F;&#x2F; https:&#x2F;&#x2F;q.cnblogs.com&#x2F;q&#x2F;63769&#x2F;</code></pre><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><a href="/#/post/2022-06-16interview#:~:text=new%20%E5%92%8C%20Object.create%20%E9%83%BD%E6%98%AF%E5%88%9B%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E6%80%9D%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F" target="_blank" >见</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function myNew() &#123;  let obj &#x3D; &#123;&#125;;  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型  func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数  return obj;&#125;</code></pre><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function myCreate(obj) &#123;  let F &#x3D; function () &#123;&#125;;  F.prototype &#x3D; obj;  return new F();&#125;</code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function instance_of(L, R) &#123;  var O &#x3D; R.prototype; &#x2F;&#x2F; 取R的显示原型  L &#x3D; L.__proto__; &#x2F;&#x2F; 取L的隐式原型  while (true) &#123;    &#x2F;&#x2F; 死循环，结束条件：要么找到，要么没找到    if (L &#x3D;&#x3D;&#x3D; null) return false;    if (O &#x3D;&#x3D;&#x3D; L) &#123;      &#x2F;&#x2F; 这里重点：当O严格等于L时，返回true      return true;    &#125;    L &#x3D; L.__proto__;  &#125;&#125;</code></pre><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p><a href="https://article.itxueyuan.com/46m5K2" target="_blank" >见</a><br>在计算机科学中，柯里化（Currying）<code>是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术</code>。这个技术以逻辑学家 Haskell Curry 命名的。</p><ul><li>柯里化突出一种重要思想：<code>降低适用范围</code>，<code>提高适用性</code></li><li>柯里化的三个作用和特点：<code>参数复用</code>、<code>提前返回</code>、<code>延迟执行</code></li><li>柯里化是闭包的一个典型应用，<code>利用闭包形成了一个保存在内存中的作用域，把接收到的部分参数保存在这个作用域中，等待后续使用</code>。并且返回一个新函数接收剩余参数</li></ul><p><a href="https://juejin.cn/post/6844903814139478030" target="_blank" >函数柯里化和偏函数应用</a></p><ul><li><p>柯里化和偏函数都是用于将多个参数函数，转化为接受更少参数函数的方法。传入部分参数后，处于中间状态的函数可以作为固定值进行复用。但是其中不同之处在于：</p></li><li><p><code>柯里化</code>是将函数转化为多个嵌套的一元函数，也就是每个函数只接受一个参数。</p></li><li><p><code>偏函数</code>可以接受不只一个参数，它被固定了部分参数作为预设，并可以接受剩余的参数</p></li></ul><p>作者：LanceT<br>链接：<a href="https://juejin.cn/post/6844903814139478030">https://juejin.cn/post/6844903814139478030</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const getUniqueID &#x3D; ((id) &#x3D;&gt; () &#x3D;&gt; &#123;  id +&#x3D; 1;  return id;&#125;)(-1);&#x2F;&#x2F; getUniqueID&#x2F;&#x2F; () &#x3D;&gt; &#123;&#x2F;&#x2F;   id +&#x3D; 1;&#x2F;&#x2F;   return id;&#x2F;&#x2F; &#125;</code></pre><h2 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h2><p><a href="https://github.com/841660202/redux/blob/2edd0363271af46e327e118f3d92e78e258bf0cd/src/compose.ts#L46" target="_blank" >redux compose 源码</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function compose(...funcs: Function[]) &#123;  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line    return &lt;T&gt;(arg: T) &#x3D;&gt; arg;  &#125;  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;    return funcs[0];  &#125;  return funcs.reduce(    (a, b) &#x3D;&gt;      (...args: any) &#x3D;&gt;        a(b(...args))  );  &#x2F;&#x2F; return funcs.reduce((a, b) &#x3D;&gt;(...args: any) &#x3D;&gt;a(b(...args)));&#125;</code></pre><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>本质是一个 hack,利用<code>&lt;script&gt;</code>标签不受同源侧露限制的特性进行跨域操作</p><p><a href="https://blog.csdn.net/weixin_42371354/article/details/104651961" target="_blank" >参考链接</a><br><a href="https://blog.csdn.net/qq_38800316/article/details/120440865" target="_blank" >jsonp 函数封装</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1. 生成个函数名&#x2F;&#x2F; 2. 整理参数，生成请求url&#x2F;&#x2F; 3. 动态创建script标签，并挂载&#x2F;&#x2F; 4. 加载完成后移除script标签function jsonP(&#123; url, params, success &#125;) &#123;  &#x2F;&#x2F; 在参数里制定callback的名字  params &#x3D; params || &#123;&#125;;  &#x2F;&#x2F; 预留callback  const funcName &#x3D; &quot;func&quot; + Math.random().toString().replace(&quot;.&quot;, &quot;&quot;);  &#x2F;&#x2F; 这样依赖，服务器端一个req.query.callback就可以获取到动态的函数名  params.callback &#x3D; funcName;  window[funcName] &#x3D; success;  &#x2F;&#x2F; 拼接参数字符串  const paramKeys &#x3D; Object.keys(params);  const paramString &#x3D; paramKeys.map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;).join(&quot;&amp;&quot;);  &#x2F;&#x2F; 插入dom元素  const script &#x3D; document.createElement(&quot;script&quot;);  script.setAttribute(&quot;src&quot;, &#96;$&#123;url&#125;?$&#123;paramString&#125;&#96;);  document.body.appendChild(script);  &#x2F;&#x2F; 监听script标签的onload事件，当script标签执行后将其删除，避免代码结构的冗余  script.onload &#x3D; function () &#123;    &#x2F;&#x2F; 从body的删除掉添加的script标签    document.body.removeChild(script);  &#125;;&#125;&#x2F;&#x2F; 使用jsonP(&#123;  url: &quot;https:&#x2F;&#x2F;example.com&#x2F;ajax&#x2F;jsonp&#x2F;suggestion&quot;,  params: &#123;    key: &quot;test&quot;,  &#125;,  success(result) &#123;    console.log(result.data);  &#125;,&#125;);</code></pre><h2 id="实现-event-bus"><a href="#实现-event-bus" class="headerlink" title="实现 event bus"></a>实现 event bus</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class EventBus &#123;  constructor() &#123;    this.events &#x3D; &#123;&#125;;  &#125;  &#x2F;&#x2F; 监听，给对象添加方法  on(name, callback) &#123;    const &#123; events &#125; &#x3D; this;    if (!events[name]) &#123;      events[name] &#x3D; [];    &#125;    events[name].push(callback);  &#125;  &#x2F;&#x2F; 取出来执行  emit(name, ...args) &#123;    const handlers &#x3D; this.events[name];    handlers &amp;&amp;      handlers.forEach((fn) &#x3D;&gt; &#123;        fn.apply(this, args);      &#125;);  &#125;  &#x2F;&#x2F; 解除  off(name, callback) &#123;    const &#123; events &#125; &#x3D; this;    if (!events[name]) return;    events[name] &#x3D; events[name].filter((fn) &#x3D;&gt; fn !&#x3D;&#x3D; callback); &#x2F;&#x2F; 引用，指向对象，直接改kv键值对  &#125;  &#x2F;&#x2F;  用完立马、解除  once(name, callback) &#123;    const handler &#x3D; function () &#123;      callback.apply(this, arguments); &#x2F;&#x2F; 普通函数参数      this.off(name, handler);    &#125;;    this.on(name, handler);  &#125;  &#x2F;&#x2F; 事件清空  clear() &#123;    this.events &#x3D; &#123;&#125;;  &#125;&#125;</code></pre><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p><a href="https://www.freesion.com/article/47611264830/" target="_blank" >数据劫持|数据代理</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" >MDN</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Proxylet obj &#x3D; &#123;  name: &quot;Eason&quot;,  age: 30,&#125;;let handler &#x3D; &#123;  get(target, key, receiver) &#123;    console.log(&quot;get&quot;, key);    return Reflect.get(target, key, receiver);  &#125;,  set(target, key, value, receiver) &#123;    console.log(&quot;set&quot;, key, value);    return Reflect.set(target, key, value, receiver);  &#125;,&#125;;let proxy &#x3D; new Proxy(&#123; ...obj &#125;, handler);proxy.name &#x3D; &quot;Zoe&quot;; &#x2F;&#x2F; set name Zoeproxy.age &#x3D; 18; &#x2F;&#x2F; set age 18&#x2F;&#x2F; definePropertylet arr &#x3D; [1, 2, 3];let obj &#x3D; &#123;&#125;;Object.defineProperty(obj, &quot;arr&quot;, &#123;  get() &#123;    console.log(&quot;get arr&quot;);    return arr;  &#125;,  set(newVal) &#123;    console.log(&quot;set&quot;, newVal);    arr &#x3D; newVal;  &#125;,&#125;);obj.arr.push(4); &#x2F;&#x2F; 只会打印 get arr, 不会打印 setobj.arr &#x3D; [1, 2, 3, 4]; &#x2F;&#x2F; 这个能正常 set</code></pre><h2 id="a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true"><a href="#a-x3D-x3D-x3D-1-amp-amp-a-x3D-x3D-x3D-2-amp-amp-a-x3D-x3D-x3D-3-x3D-x3D-x3D-true" class="headerlink" title="a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true"></a>a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true</h2><p><a href="https://blog.csdn.net/RedaTao/article/details/107170267" target="_blank" >a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3</a></p><p>什么样的 a 可以满足 (a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D;&#x3D; 3) &#x3D;&#x3D;&#x3D; true 呢？(注意是 3 个 &#x3D;，也就是严格相等)???</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let i &#x3D; 1;Object.defineProperty(window, &quot;a&quot;, &#123;  get: function () &#123;    return i++;  &#125;,&#125;);console.log(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3);</code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>什么是链表</strong></p><p>数据的一种存储结构，一个链表包含若干个节点，每个节点至少包含一个数据域和指针域</p><p><a href="https://wenku.baidu.com/view/33d6ed103a68011ca300a6c30c2259010302f35b.html" target="_blank" >百度文库(收费了，只能看部分)、参考链接</a></p><p><a href="https://blog.csdn.net/m0_47109503/article/details/117566907" target="_blank" >参考链接</a></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类class Node &#123;  constructor(data) &#123;    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员  &#125;&#125;&#x2F;&#x2F; 定义一个单向链表类class singleLinked &#123;  constructor() &#123;    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数    this.head &#x3D; new Node(&quot;head&quot;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址    this.currentNode &#x3D; &quot;&quot;;  &#125;  &#x2F;&#x2F; 获取链表的长度  getLength() &#123;    return this.size;  &#125;  &#x2F;&#x2F; 判断链表是否为空  isEmpty() &#123;    return this.size &#x3D;&#x3D;&#x3D; 0;  &#125;  &#x2F;&#x2F; 遍历链表：不重复访问链表中的每个节点  displayList() &#123;    var list &#x3D; &quot;&quot;;    var currentNode &#x3D; this.head; &#x2F;&#x2F; 指向链表的头指针    while (currentNode) &#123;      &#x2F;&#x2F; 如果当前节点不为空，则表明当前节点中存在数据      list +&#x3D; currentNode.data;      &#x2F;&#x2F; 同时让当前节点的指针指向下一个节点      currentNode &#x3D; currentNode.next;      if (currentNode) &#123;        &#x2F;&#x2F; 如果当前节点的下一个节点不为空        list +&#x3D; &quot;-&gt;&quot;; &#x2F;&#x2F; 拼接后看起来像一个链表      &#125;    &#125;    console.log(list);  &#125;  &#x2F;&#x2F; 获取链表的最后一个节点  findLast() &#123;    var currentNode &#x3D; this.head;    while (currentNode.next) &#123;      currentNode &#x3D; currentNode.next;    &#125;    return currentNode;  &#125;  &#x2F;&#x2F; 采用尾插法在链表尾部添加元素，即创建一个链表  appendNode(element) &#123;    var currentNode &#x3D; this.findLast(); &#x2F;&#x2F; 找到链表的最后一个节点    var newNode &#x3D; new Node(element); &#x2F;&#x2F; 创建一个新节点    currentNode.next &#x3D; newNode; &#x2F;&#x2F; 把新的节点放在链表里去（放在最后一个的后面）    newNode.next &#x3D; null; &#x2F;&#x2F; 因为新节点已经是链表最后一个节点    this.size++; &#x2F;&#x2F; 因为新插入一个节点，让链表的长度+1  &#125;  &#x2F;&#x2F; 删除一个节点  deleteNode(element) &#123;    var currentNode &#x3D; this.head;    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;      currentNode &#x3D; currentNode.next;    &#125;    &#x2F;&#x2F; 将链的节点与另一个节点连上    currentNode.next &#x3D; currentNode.next.next;    this.size--;  &#125;&#125;&#x2F;&#x2F; 上述链表代码的测试&#x2F;&#x2F; 最好使用循环，往里面加数据var slist &#x3D; new singleLinked();var arr &#x3D; [1001, 1234, 1006, 7788, 5512, 6129];for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;  slist.appendNode(arr[i]);&#125;slist.displayList();slist.deleteNode(1001);slist.displayList();</code></pre><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><a href="https://blog.csdn.net/dingshao1114/article/details/105340579" target="_blank" >js 数据结构之双向链表 doublyLinkedList</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"></code></pre><h2 id="leecode"><a href="#leecode" class="headerlink" title="leecode"></a>leecode</h2><h3 id="红包算法"><a href="#红包算法" class="headerlink" title="红包算法"></a>红包算法</h3><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><h3 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h3><p><a href="https://blog.csdn.net/qq_39816673/article/details/88667505" target="_blank" >JS 大数相加</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function add(str1, str2) &#123;  str1 &#x3D; str1.split(&quot;&quot;); &#x2F;&#x2F; 转化成数组  str2 &#x3D; str2.split(&quot;&quot;); &#x2F;&#x2F; 转化成数组  let result &#x3D; &quot;&quot;; &#x2F;&#x2F; 结果  let flag &#x3D; 0; &#x2F;&#x2F; 满10进1标记  while (str1.length || str2.length || flag) &#123;    &#x2F;&#x2F; 计算完    flag &#x3D; flag + ~~str1.pop() + ~~str2.pop(); &#x2F;&#x2F; ~~undefined &#x3D; 0, true + 0 &#x3D;1, false + 0 &#x3D; 0    result &#x3D; (flag % 10) + result; &#x2F;&#x2F; 结果    flag &#x3D; flag &gt; 9; &#x2F;&#x2F; 是否进位  &#125;  return result.replace(&#x2F;^0+&#x2F;, &quot;&quot;); &#x2F;&#x2F; 首部有0去除&#125;add(&quot;00125&quot;, &quot;0131231231232132136&quot;);</code></pre><h3 id="找出出现次数最多的英语单词"><a href="#找出出现次数最多的英语单词" class="headerlink" title="找出出现次数最多的英语单词"></a>找出出现次数最多的英语单词</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var paragraph &#x3D; &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;;function findMaxWord(paragraph) &#123;  var p &#x3D; paragraph    .replace(&#x2F;[\W\s_]&#x2F;g, &quot; &quot;)    .toLowerCase()    .split(&quot; &quot;);  const obj &#x3D; &#123;&#125;;  for (const word of p) &#123;    if (!word) continue;    if (obj[word]) &#123;      obj[word]++;    &#125; else &#123;      obj[word] &#x3D; 1;    &#125;  &#125;  let max &#x3D; 0;  let word &#x3D; &quot;&quot;;  for (const k in obj) &#123;    if (obj[k] &gt; max) &#123;      max &#x3D; obj[k];      word &#x3D; k;    &#125;  &#125;  return &#123;    count: max,    word,  &#125;;&#125;const res &#x3D; findMaxWord(paragraph);console.log(res);</code></pre><h3 id="节点倒序（将-ul-id-x3D-list，将-ul-节点下的-10000-个-li-节点倒序。考虑性能。）"><a href="#节点倒序（将-ul-id-x3D-list，将-ul-节点下的-10000-个-li-节点倒序。考虑性能。）" class="headerlink" title="节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）"></a>节点倒序（将 ul.id&#x3D;list，将 ul 节点下的 10000 个 li 节点倒序。考虑性能。）</h3><h3 id="实现一个函数计算-“1-12-31-100-93”"><a href="#实现一个函数计算-“1-12-31-100-93”" class="headerlink" title="实现一个函数计算 “1+12-31+100-93”"></a>实现一个函数计算 “1+12-31+100-93”</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function calc(str) &#123;  return eval(str);&#125;</code></pre><h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><ul><li><p>快慢指针</p><p><a href="https://www.zhihu.com/question/23208893" target="_blank" >为什么用快慢指针找链表的环，快指针和慢指针一定会相遇？</a></p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Solution &#123;  ...  hasCycle() &#123;    let fast &#x3D; this.head;    let slow &#x3D; this.head;    while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D;&#x3D; null) &#123;      fast &#x3D; fast.next.next      &#x2F;&#x2F; 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6      &#x2F;&#x2F;               fast      &#x2F;&#x2F;               slow      slow &#x3D; slow.next      if(fast &#x3D;&#x3D;&#x3D; slow)&#123;        return true      &#125;    &#125;    return false  &#125;&#125;</code></pre><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><h3 id="删除单向链表中的某个节点"><a href="#删除单向链表中的某个节点" class="headerlink" title="删除单向链表中的某个节点"></a>删除单向链表中的某个节点</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 在创建链表时，需要创建两个类：指针类和节点类class Node &#123;  constructor(data) &#123;    this.data &#x3D; data; &#x2F;&#x2F; 节点的数据域&#x2F;数据成员    this.next &#x3D; null; &#x2F;&#x2F; 节点的指针域&#x2F;指针成员  &#125;&#125;&#x2F;&#x2F; 定义一个单向链表类class singleLinked &#123;  constructor() &#123;    this.size &#x3D; 0; &#x2F;&#x2F; 记录单链表长度或节点个数    this.head &#x3D; new Node(&quot;head&quot;); &#x2F;&#x2F; 记录链表的头指针：主要作用记录链表的起始地址    this.currentNode &#x3D; &quot;&quot;;  &#125;  &#x2F;&#x2F; 删除一个节点  deleteNode(element) &#123;    var currentNode &#x3D; this.head;    while (currentNode.next.data !&#x3D;&#x3D; element) &#123;      currentNode &#x3D; currentNode.next;    &#125;    &#x2F;&#x2F; 将链的节点与另一个节点连上    currentNode.next &#x3D; currentNode.next.next;    this.size--;  &#125;&#125;</code></pre><h2 id="五分钟学习算法"><a href="#五分钟学习算法" class="headerlink" title="五分钟学习算法"></a>五分钟学习算法</h2><p><a href="https://www.jianshu.com/p/d13fcada7c2d" target="_blank" >链接</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/pangqianjin/p/14998643.html" target="_blank" >JavaScript 手写几种常见的排序算法：冒泡、选择、插入、希尔、归并、快排</a><br><a href="https://blog.csdn.net/qq_44433261/article/details/117235740" target="_blank" >排序动画</a><br><a href="https://wenku.baidu.com/view/7f84552a6f85ec3a87c24028915f804d2b16878c.html" target="_blank" >分治思想——精选推荐</a><br><a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B3%95/9763353?fr=aladdin" target="_blank" >归并排序法 百度百科</a><br><a href="https://blog.csdn.net/Sherlook_Holmes/article/details/120584469" target="_blank" >（含动画演示）搞懂归并排序 一学就会</a></p><p><a href="https://www.jianshu.com/u/c6ad3f2ed2d6" target="_blank" >五分钟学算法(PPT 做的 gif)</a><br><a href="https://wenku.baidu.com/view/8bf2d73451d380eb6294dd88d0d233d4b14e3fef.html" target="_blank" >Promise.resolve（）详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>授权与校验场景「简聊」</title>
      <link href="//post/2022-07-01auth.html"/>
      <url>//post/2022-07-01auth.html</url>
      
        <content type="html"><![CDATA[<h2 id="最简单"><a href="#最简单" class="headerlink" title="最简单"></a>最简单</h2><p>用变量，模拟数据</p><h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session + cookie"></a>session + cookie</h2><p>每个用户对应一个会话</p><h2 id="SSO-1"><a href="#SSO-1" class="headerlink" title="SSO 1"></a>SSO 1</h2><ul><li>session + redis + cookie</li></ul><p>觉得有点奇葩，第二份<strong>核心项目</strong>遇到</p><h2 id="jwt-redis"><a href="#jwt-redis" class="headerlink" title="jwt + redis"></a>jwt + redis</h2><p>第二份<strong>非核心项目</strong>遇到</p><p><strong>以下是一般公司常用的方式，面试的时候，大家都在唠这个</strong></p><h2 id="SSO-2"><a href="#SSO-2" class="headerlink" title="SSO 2"></a>SSO 2</h2><ul><li>jwt + redis + cookie</li></ul><h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h2><ul><li>授权 + SSO（ jwt + redis + cookie）</li><li>扫码授权 + SSO（ jwt + redis + cookie）</li></ul><p>第三方使用最多的微信、支付宝、QQ、飞书，第三方授权一般通过回调的形式，把授权结果<code>code</code>返回个开发者</p><h2 id="企业合规"><a href="#企业合规" class="headerlink" title="企业合规"></a>企业合规</h2><ul><li>app 扫码+企业 web + SSO(jwt + redis + cookie)</li></ul><p>大公司需要做<strong>合规</strong>，尤其是上市公司要这些东东，所有用户数据全部来自公司内部系统，面试的时候，大家基本上不会谈这个，如果你给面试官唠了，肯定觉得你在胡说八道，因为下面的很灵活,场景和微信类似，你说扫码，面试官肯定认为你说的是上面<code>第三方</code>那套东西，然而完全不一样</p><p>在扫码登录和确认登陆时候这个点分了多种（长链接、Websocket、MQTT、厂家通道推送，都可以实现）</p><p>以我第三份工作为例：</p><ul><li><code>Flutter桌面端VPN</code> + <code>移动端</code>用了 MQTT</li><li><code>Electron桌面端</code> + <code>移动端</code>, Electron 桌面端用定时器调,<code>移动端</code>MQTT</li><li><code>扫码打开链接</code>，直接注入 cookie，而不是通过<code>回调</code>或者<code>redirect重定向</code></li></ul><p>之所以没用厂家通道，因为公司原生部门的厂家通道需要改造才能用，由于改造成本的存在，不提供。总之麻烦～，换了个 MQTT 方案</p><p>mobile 原生(「<code>RN</code>、<code>Flutter</code>、<code>IOS</code>、<code>安卓</code>、<code>Weex</code>、<code>uniapp</code>、<code>ionic</code>」)分的细点,我遇到过的都列出来了，简单来说就是 IOS 和安卓，至于鸿蒙啥的就不说了</p><p>总结：这个吧，就相当于，公司开发了自己的<code>微信桌面window/mac</code> + <code>微信手机</code></p><h2 id="webview-cookie-注入"><a href="#webview-cookie-注入" class="headerlink" title="webview cookie 注入"></a>webview cookie 注入</h2><p><code>react-native-webview</code>向 h5 应用注入 cookie，<code>走 SSO 验证实现免登</code>， 原生当然也OK的</p>]]></content>
      
      
      <categories>
          
          <category> auth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react hook 使用 bug</title>
      <link href="//post/2022-07-01bug.html"/>
      <url>//post/2022-07-01bug.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Rendered more hooks than during the previous render.</p><img src="http://t-blog-images.aijs.top/img/20220701111839.webp" /><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><img src="http://t-blog-images.aijs.top/img/20220701111740.webp" /><p>两种方式解决：</p><ul><li>勾子前置</li><li>不用这个勾子</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>勾子不能在条件语句中使用</strong> 这个要注意并不是一定这种形式</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (条件) &#123;  &#x2F;&#x2F; 如果条件用于是true，相当于没有外层的if，  勾子;&#125;</code></pre><ul><li>这个勾子放在了 if 的后面 条件语句如果在第一次命中的是提前结束，下次渲染没命中 if，走了后面的代码就会出这个问题</li><li>如果测试不全面，这个 bug 就可能到线上了， 因为你测试的有可能每次命中 if 而不会到 else，<strong>下面这种模式</strong>一不注意就错了</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if () &#123;  return 渲染&#125;勾子</code></pre><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>react 收集勾子的时候，需要保证勾子数量是一致的，不多不少，刚刚好</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Hook 本质就是 JavaScript 函数，但是在使用它时需要遵循两条规则。React官方提供了一个 <code>eslint-plugin-react-hooks</code> 插件来强制执行这些规则：</p></blockquote><p>续。。。源码找这个日志</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation" target="_blank" >Hook 规则</a></p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-native-webview中处理外网链接</title>
      <link href="//post/2022-06-29rn-web.html"/>
      <url>//post/2022-06-29rn-web.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前公司移动端是使用 vpn 连接到内网，由于某些原因，IOS 企业证书即将到期，应用需要上架，vpn 不满足上架要求，所以：</p><ul><li>vpn 要从 iOS 包中移除</li><li>vpn 移除导致不能直接访问内网</li><li>需要通过外网域名访问内网资源</li></ul><p>不同环境的请求</p><ul><li>原生及 RN 代码，接口访问走 ATOP 接口访问</li><li>内网应用嵌入到 react-native-webview 中，使用 cookie 注入的方式进行授权，</li></ul><p>已有的域名：</p><ul><li>之前已经做了企业微信工作台功能，考虑到申请外网域名需要走安全、合规审核比较麻烦</li><li>我们的企业微信授权是根据请求头区分的，同时应用中也有是否是微信环境的判断, 所以：只要在项目中避开微信授权，走 SSO 授权（cookie 注入）</li></ul><img src="http://t-blog-images.aijs.top/img/20220629172711.webp" /><p><em>顺便说句：这里的判断是采用(nextjs)服务端渲染，所以能直接在请求头中判断，如果不是服务端渲染，可能要考虑其他 rn 注入的方式</em></p><h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><p><strong>RN 改造</strong></p><img src="http://t-blog-images.aijs.top/img/20220629173240.webp" /><p><strong>h5 项目改造</strong></p><!-- <img src="http://t-blog-images.aijs.top/img/20220629173017.webp" /> --><img src="http://t-blog-images.aijs.top/img/20220629180554.webp" /><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const lang &#x3D; cookie.parse(req.headers.cookie || &#39;&#39;).gTyPlatLang || &#39;en&#39;const ua &#x3D; parser(req.headers[&#39;user-agent&#39;])CommonModel.actions.setDevice(ua.device.type, req)if (!getWechatUserAgent(req.headers[&#39;user-agent&#39;]) &amp;&amp; req.headers[&#39;x-public&#39;]) &#123;  const isMobile &#x3D; ua.device.type &#x3D;&#x3D;&#x3D; &#39;mobile&#39;  if(!(isMobile &amp;&amp; !!req.headers.tyxz))&#123;  &#x2F;&#x2F; 移动端不是企业微信的    redirect(Config.tyHost + join(&#39;&#x2F;&#39;, req.url), ctx) &#x2F;&#x2F; 移动端是rnxz的重定向到内网  &#125;&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/20220630093816.webp" /><p>本篇文章针对的是非企业微信授权的情况，即：图第一行从左到右（有cookie信息的情况）</p><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><p><strong>按照原有的设计缺陷：</strong></p><ul><li>域名是给企业微信用的，是在nginx那边配置的请求头，这本身不够灵活</li><li>代码中逻辑：<br>1.先获取用户信息，获取不到，<br>2.检测状态码（<code>fetch</code>工具对于后台返回的<code>401状态码</code>，如果是<code>401</code>，默认是走微信授权，后台业务校验授权信息不通过的），<br>3.对于不满足上述条件的，检测客户端是否是企业微信，<br>4.如果不是重定向到内网<br>（还是过于依赖域名配置）</li></ul><p><strong>重新设计：</strong></p><ul><li>正常业务逻辑，应该先判断是环境，决定走哪套授权验证（这样不会因为一套授权，一个域名了）</li></ul><h2 id="vconsole"><a href="#vconsole" class="headerlink" title="vconsole"></a>vconsole</h2><p>对于 react-native-webview 调试，使用了 <code>vconsole</code>调试，可以简单查看一些控制台信息，包括 cookie 相关的查看、复制、编辑操作</p><div style="display:flex;flex-direction:row; flex-wrap:wrap"><img src="http://t-blog-images.aijs.top/img/20220629173944.webp" style="margin-right: 6px" width=300/><img src="http://t-blog-images.aijs.top/img/20220629173856.webp" width=300/></div>]]></content>
      
      
      <categories>
          
          <category> react-native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信授权流程</title>
      <link href="//post/2022-06-29wx-auth.html"/>
      <url>//post/2022-06-29wx-auth.html</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>确保本地已经正确配置了 HOST，能够从工作台入口打开本地的开发服务</li><li>确保已获取到当前企业的唯一 ID：corp_id，在【管理后台】- 【我的企业】-【企业信息】页面，最下面找到【企业 ID】</li><li>已经通过接口调用获取到当前应用的 access_token，请参考 二：<a href="https://developer.work.weixin.qq.com/tutorial/detail/46" target="_blank" >如何获取应用接口凭证</a></li></ul><h2 id="配置可信域名"><a href="#配置可信域名" class="headerlink" title="配置可信域名"></a>配置可信域名</h2><p>企业微信提供了 OAuth 的授权登录方式，可以让从企业微信终端打开的网页获取成员的身份信息，从而免去登录的环节。</p><p>为了保证访问授权的安全性，需要配置授权链接 URL 所在域名为可信域名。<br>在【应用详情】-【开发者接口】-【网页授权及 JS-SDK】，点击【设置可信域名】</p><img src="http://t-blog-images.aijs.top/img/20220629163014.webp" /><p>在【设置可信域名】弹窗，填写网页授权功能的回调域名</p><img src="http://t-blog-images.aijs.top/img/20220629163042.webp" width=300 /><p>网页授权回调域名的配置须与实际访问链接的域名完全一致，详细要求请参考文档 <a href="https://developer.work.weixin.qq.com/document/path/91335#%E5%85%B3%E4%BA%8E%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E7%9A%84%E5%8F%AF%E4%BF%A1%E5%9F%9F%E5%90%8D" target="_blank" >关于网页授权的可信域名</a>。</p><h2 id="构造网页授权链接"><a href="#构造网页授权链接" class="headerlink" title="构造网页授权链接"></a>构造网页授权链接</h2><p>在我们当前的教程中，我们有几个 URL 需要注意和区分：</p><ul><li>应用主页 URL<br>从工作台点击打开的页面 URL ，在创建应用是配置填写的，用来向授权链接 URL 跳转。</li><li>重定向 URL<br>当用户授权成功后，会带着成员授权 code 跳转的 URL，用来接收 code 并获取成员身份。</li><li>授权链接 URL<br>企业微信域名下的 URL，包含了 suite_id、重定向 URL 等信息，当企业微信服务参数验证成功后，会跳转到重定向 URL。</li></ul><p>我们在上节课程中配置企业的主页 URL 为 <a href="http://myapp.com:300/home%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E8%BF%99%E4%B8%AA" target="_blank" >http://myapp.com:300/home，我们在这个 URL</a> 访问逻辑里面根据约定构造授权链接 URL，并向这个链接跳转：</p><p>关于 OAuth 的详细内容，请参考 <a href="https://developer.work.weixin.qq.com/document/path/91119" target="_blank" >网页授权登录</a>。关于授权链接更多的内容，请参考 <a href="https://developer.work.weixin.qq.com/document/path/91022" target="_blank" >构造网页授权链接</a>。</p><h2 id="解析成员授权-code"><a href="#解析成员授权-code" class="headerlink" title="解析成员授权 code"></a>解析成员授权 code</h2><p>企业成员从工作台点击应用，打开应用主页 URL，向授权链接 URL 跳转；企业微信对授权链接上的信息进行校验之后，会重定向 URL 跳转，并以 query 的形式带上当前访问成员的 code 信息。</p><p>在上一步，我们定义了重定向 URL 为 <a href="http://myapp.com/app%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA" target="_blank" > http://myapp.com/app</a>，在这个 URL 的访问里我们解析出 code 参数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 重定向 URLrouter.get(&quot;&#x2F;app&quot;, async function (req, res, next) &#123;  &#x2F;&#x2F; 从 query 参数中解析 code  let &#123; code &#125; &#x3D; req.query;  &#x2F;&#x2F; 展示登录后的页面  res.render(&quot;home&quot;);&#125;);</code></pre><h2 id="获取访问用户身份信息"><a href="#获取访问用户身份信息" class="headerlink" title="获取访问用户身份信息"></a>获取访问用户身份信息</h2><p>在解析出成员授权 code 之后，使用 access_token ，调用 <a href="https://developer.work.weixin.qq.com/document/path/91023" target="_blank" >获取访问用户身份</a> 接口，即可得到访问用户的基本信息 user_id，如果想要访问用户更详细的信息，则需要通过 <a href="https://developer.work.weixin.qq.com/document/path/90196" target="_blank" >读取成员</a> 得到用户的姓名、头像等完整信息。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">router.get(&quot;&#x2F;app&quot;, async function (req, res, next) &#123;  let &#123; code &#125; &#x3D; req.query;  &#x2F;&#x2F; 从缓存中读取出 access_token  let access_token &#x3D; Tool.GetAccessToken();  if (access_token) &#123;    &#x2F;&#x2F; 获取用户基本信息    let &#123; data: user_data &#125; &#x3D; await axios.get(      &#96;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;getuserinfo?access_token&#x3D;$&#123;access_token&#125;&amp;code&#x3D;$&#123;code&#125;&#96;    );    console.log(&quot;获取 user_data 成功&quot;, user_data);    &#x2F;&#x2F; 获得用户的 user_id    let user_id &#x3D; user_data.UserId;    &#x2F;&#x2F; 获取用户的详细信息    let &#123; data: user_detail_data &#125; &#x3D; await axios.get(      &#96;https:&#x2F;&#x2F;qyapi.weixin.qq.com&#x2F;cgi-bin&#x2F;user&#x2F;get?access_token&#x3D;$&#123;access_token&#125;&amp;userid&#x3D;$&#123;user_id&#125;&#96;    );    console.log(&quot;获取成员详细信息成功&quot;, user_detail_data);    &#x2F;&#x2F; 将用户信息展示在页面上    res.render(&quot;home&quot;, user_detail_data);  &#125; else &#123;    res.render(&quot;error&quot;);  &#125;&#125;);</code></pre><p>在前端页面中展示用户的基本信息：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Hello World&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;    &lt;div&gt;      &lt;img src&#x3D;&quot;&lt;%&#x3D;avatar %&gt;&quot; &#x2F;&gt;&lt;span&gt;&lt;%&#x3D;name %&gt;(&lt;%&#x3D;english_name %&gt;) &lt;&#x2F;span&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><img src="http://t-blog-images.aijs.top/img/20220629163741.webp" width=300/><p>关于获取用户的详细信息内容以及接口返回的完整字段信息，请参考 <a href="https://developer.work.weixin.qq.com/document/path/90196" target="_blank" >读取成员</a>。如果想要成员在系统浏览器中打开应用时也能进行企业微信授权登录，请参考 <a href="https://developer.work.weixin.qq.com/document/path/91025" target="_blank" >构造扫码登录</a> 。</p><h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p>企业微信官网有授权流程，看上去没那么直接，结合项目画个草图</p><img src="http://t-blog-images.aijs.top/img/20220630093816.webp" /><p>本篇文章针对的是<strong>企业微信授权</strong>的情况，即：<strong>图第一行走到没授权，往下走（没有 cookie 信息的情况）</strong></p><h2 id="更好的方案"><a href="#更好的方案" class="headerlink" title="更好的方案"></a>更好的方案</h2><p><strong>方案 1:</strong> 对于企业微信授权和 SSO 授权，本质上并无区别，最终的目的是注入 cookie,对于我当前所在公司的情况（企业微信授权，单独维护到 redies 中，独立于 SSO,是没有必要的）。</p><p><strong>方案 2:</strong> 如果把企业微信授权的返回用于换取 SSO 的（token）注入 cookie 实现授权，最终每次校验都是 SSO,会节省不少成本。</p><p>我在上家做<strong>钉钉 ISV 第三方供应商开发</strong>时候，实现效果类似方案 2</p><p><strong>更优方案 3:</strong> 在方案 2 的基础，将请求头标记去掉（让后端自行处理）。请求到后端，后端能拿到请求头<code>userAgent</code>字段，可以知道到此请求是从哪个应用过来的，后端自己判断下就好了（完全没必要<code>域名加配置，尤其是那种nginx配置后，代码又乱写的</code>）</p><h2 id="微信环境判断"><a href="#微信环境判断" class="headerlink" title="微信环境判断"></a>微信环境判断</h2><p><strong>前端代码</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * （服务端+客户端）渲染：根据req headers中user-agent判断是否来自微信端（桌面端和手机端） *&#x2F;export default function getWechatUserAgent(userAgent?: string): boolean &#123;  const agent &#x3D;    userAgent || (typeof navigator &#x3D;&#x3D;&#x3D; &quot;undefined&quot; ? &quot;&quot; : navigator.userAgent);  const user_agent &#x3D; agent ? agent.toLowerCase() : &quot;&quot;;  return !!(    user_agent &amp;&amp;    (user_agent.includes(&quot;wechat&quot;) ||      user_agent.includes(&quot;wxwork&quot;) ||      user_agent.includes(&quot;windowswechat&quot;))  );&#125;</code></pre><p><strong>环境判断也放后端</strong></p><p>公司设计的加请求头标记是不是企业微信，完全没必要 服务端接到请求可以拿到<code>user-agent</code></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p><code>&lt;a&gt;标签下载</code></p><p>因为后端是通过前端给的额外标识判断环境的，有个很致命的问题 通过 <code>&lt;a&gt;标签下载</code>的没办法加请求头，需要将<code>&lt;a&gt;标签方式的下载</code>改为 http 请求下载</p></p></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://developer.work.weixin.qq.com/tutorial/detail/47" target="_blank" >如何获取登录用户信息</a></p><p><a href="https://developer.work.weixin.qq.com/document/path/91022" target="_blank" >构造网页授权链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 企业微信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-aurora源码修改</title>
      <link href="//post/2022-06-24aurora.html"/>
      <url>//post/2022-06-24aurora.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>hexo-theme-aurora</code>是一款不错的主题，在使用过程无疑会遇到一些问题。遇到问题首先去 github 上找 issue 来处理，有些问题需要改源码，之前使用<code>patch</code>进行简单的修改，这次遇到了 tag 查不到，本地是有的，发布后找不到了，导致文章在<code>tag</code>情况下不可见，之前作者在详情页留了<code>categories</code>，但是没有入口。等了几周，作者没有 fix,动手改～</p><img src="http://t-blog-images.aijs.top/img/20220624114614.webp" /><p>源码<code>node-sass</code>安装要注意了，可能会报错</p><p>查询 node-sass 对应的 node.js 版本。<br><a href="https://github.com/sass/node-sass/releases?page=1#:~:text=Compare-,v5.0.0,-Breaking%20changes" target="_blank" >见</a></p><p><a href="https://github.com/841660202/hexo-theme-aurora" target="_blank" >源码已经 fork</a></p><p>源码使用：vue3 + pinia + cli，理想组合是：vue3 + pinia + vite</p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><code>hexo-theme-aurora</code>运行起来会开启 <code>http://localhost:9666/</code>端口，会与你的 hexo 打通 <code>9966端口</code> 访问的是<code>你的hexo博客项目4000端口</code>，主题资源是<code>hexo-theme-aurora</code>,厉害～</div><p>主要改 categories 相关功能</p><img src="http://t-blog-images.aijs.top/img/20220624112340.webp" /><img src="http://t-blog-images.aijs.top/img/20220624112640.webp" /><hr/><h2 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h2><pre class="line-numbers language-log" data-language="log"><code class="language-log">Commit:        b1e1d23ed1bf320b1151db3a7708f3ea6078d5baAuthor:        昊天 &lt;haotian.chen@ty.com&gt;AuthorDate:    Fri Jun 24 11:51:04 2022Commit:        昊天 &lt;haotian.chen@ty.com&gt;CommitDate:    Fri Jun 24 11:51:04 2022fix categories----------------------------- _config.yml                                |   1 + 新增部分 src&#x2F;components&#x2F;Category&#x2F;CategoryItem.vue   | 110 +++++++++++++++++++++++++++++ src&#x2F;components&#x2F;Category&#x2F;CategoryList.vue   |  13 ++++ src&#x2F;components&#x2F;Category&#x2F;index.ts           |   2 + 修改为可点击 src&#x2F;components&#x2F;Sidebar&#x2F;src&#x2F;CategoryBox.vue |  47 ++++-------- categories空多语言提示 src&#x2F;locales&#x2F;languages&#x2F;cn.json              |   1 + src&#x2F;locales&#x2F;languages&#x2F;en.json              |   1 + 配置导航 src&#x2F;models&#x2F;ThemeConfig.class.ts            |   8 +++ 增加新的category查询结果 src&#x2F;router&#x2F;index.ts                        |   7 ++ fix 分类展示数据 src&#x2F;views&#x2F;Category.vue                     |  75 ++++++++++++++------ 3中情况，展示不同维度的数据内容 src&#x2F;views&#x2F;Result.vue                       |  10 +++ 11 files changed, 220 insertions(+), 55 deletions(-)</code></pre><img src="http://t-blog-images.aijs.top/img/20220624120506.webp" /><p>具体修改内容<a href="https://github.com/841660202/hexo-theme-aurora/commit/b1e1d23ed1bf320b1151db3a7708f3ea6078d5ba" target="_blank" >见</a></p><hr/><h2 id="Author-信息不展示"><a href="#Author-信息不展示" class="headerlink" title="Author 信息不展示"></a>Author 信息不展示</h2><img src="http://t-blog-images.aijs.top/img/20220624140553.webp" /><img src="http://t-blog-images.aijs.top/img/20220624140458.webp" /><p><a href="https://github.com/auroral-ui/hexo-theme-aurora/commit/e46b36250fa424993e8b0548b37bd0cecf2f0b60" target="_blank" >见 fix author 接口</a></p><hr/><h2 id="代码配色"><a href="#代码配色" class="headerlink" title="代码配色"></a>代码配色</h2><p><a href="https://github.com/auroral-ui/hexo-theme-aurora/commit/6aa84b720220d70242f8ef763e095ef6a9d06d5c" target="_blank" >见 opt 配色</a></p><h2 id="样式错乱"><a href="#样式错乱" class="headerlink" title="样式错乱"></a>样式错乱</h2><img src="http://t-blog-images.aijs.top/img/20220624141103.webp" /><pre class="line-numbers language-css" data-language="css"><code class="language-css">.article .article-content p &#123;  font-size: 1rem;  line-height: 1.5rem;  margin-bottom: 0.5rem;  padding-bottom: 1.5rem;  word-break: break-all; &#x2F;&#x2F; 这里&#125;</code></pre><p><a href="https://github.com/auroral-ui/hexo-theme-aurora/commit/0af1a5a33b6665adbc0038f6310bc07b823698ec" target="_blank" >见 fix p style</a></p><h2 id="a-标签标记"><a href="#a-标签标记" class="headerlink" title="a 标签标记"></a>a 标签标记</h2><p>标签的 target &#x3D; ‘_blank’ 属性的元素</p><img src="http://t-blog-images.aijs.top/img/20220624141924.webp" /><p><a href="https://github.com/auroral-ui/hexo-theme-aurora/commit/7cce635a6cc89e81af0fc934d1cc45265a5a19be" target="_blank" >见 含 a target&#x3D;_blank 属性的增加标记</a></p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>不了解<code>patch</code>，<a href="/#/post/2022-06-09patch-package" target="_blank" >更多</a></p><ol><li>修改后的<code>hexo-theme-aurora</code>项目打包，</li><li>博客中之前补丁移除，之后重新生成新的补丁</li></ol><p><code>package.json</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">-    &quot;patch:hexo-theme-aurora&quot;: &quot;yarn patch-package hexo-theme-aurora&quot;,-    &quot;postinstall&quot;: &quot;yarn patch-package&quot;</code></pre><ol start="3"><li><p>删除 <code>technology-blog/patches/hexo-theme-aurora+1.5.5.patch</code> 补丁</p></li><li><p>拷贝<code>hexo-theme-aurora</code>打包后的代码</p></li></ol><pre class="line-numbers language-none"><code class="language-none">source&#x2F;static 目录source&#x2F;layout 目录（hash改变，这个也要换新的）</code></pre><ol start="5"><li><p>生成补丁, 执行<code>yarn patch-package hexo-theme-aurora</code></p></li><li><p>package.json</p></li></ol><pre class="line-numbers language-json" data-language="json"><code class="language-json">+    &quot;patch:hexo-theme-aurora&quot;: &quot;yarn patch-package hexo-theme-aurora&quot;,+    &quot;postinstall&quot;: &quot;yarn patch-package&quot;</code></pre><h2 id="部分路由刷新后-404"><a href="#部分路由刷新后-404" class="headerlink" title="部分路由刷新后 404"></a>部分路由刷新后 404</h2><img src="http://t-blog-images.aijs.top/img/202207260934046.webp" /><img src="http://t-blog-images.aijs.top/img/202209152159235.png" /><p>404 坑你没话说，本地一切正常，部署后 404 找不到</p><p>网上解决方案是：配置<code> git config ignorecase = true</code>,部分文件没问题，但是部分还是有问题的</p><p>这个问题有点恶心～</p><img src="http://t-blog-images.aijs.top/img/202209152211906.png" /><pre class="line-numbers language-none"><code class="language-none"># 全局配置区分大小写git config core.ignorecase false</code></pre><img src="http://t-blog-images.aijs.top/img/202209152212477.png" /><pre class="line-numbers language-none"><code class="language-none">git push origin --delete gh-pagesgit branch -D gh-pages</code></pre><p>删除分支，再打包发布会报错，按照提示，删除 node_modules，重新安装，然后打包部署，之后，github 会创建新的分支</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git branch -d gh-pageserror: The branch &#39;gh-pages&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D gh-pages&#39;.♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ git branch -D gh-pagesDeleted branch gh-pages (was 7a873693).♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ pn release&gt; hexo-site@0.0.0 release &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&gt; git push &amp;&amp; hexo clean &amp;&amp; hexo deployEverything up-to-dateERROR Cannot find module &#39;hexo&#39; from &#39;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#39;ERROR Local hexo loading failed in ~&#x2F;Desktop&#x2F;841660202.github.ioERROR Try running: &#39;rm -rf node_modules &amp;&amp; npm install --force&#39; ELIFECYCLE  Command failed with exit code 2.♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ hexo cleanERROR Cannot find module &#39;hexo&#39; from &#39;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#39;ERROR Local hexo loading failed in ~&#x2F;Desktop&#x2F;841660202.github.ioERROR Try running: &#39;rm -rf node_modules &amp;&amp; npm install --force&#39;♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ rm -rf node_modules♠ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io $ pn iLockfile is up to date, resolution step is skippedPackages: +437# 。。。。Writing objects: 100% (2320&#x2F;2320), 2.98 MiB | 1.26 MiB&#x2F;s, done.Total 2320 (delta 1870), reused 0 (delta 0)remote: Resolving deltas: 100% (1870&#x2F;1870), done.remote:remote: Create a pull request for &#39;gh-pages&#39; on GitHub by visiting:remote:      https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io&#x2F;pull&#x2F;new&#x2F;gh-pagesremote:To https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io * [new branch]      HEAD -&gt; gh-pagesBranch &#39;master&#39; set up to track remote branch &#39;gh-pages&#39; from &#39;https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io&#39;.INFO  Deploy done: gitINFO Thanks for using Aurora v1.5.5INFO Check out the repo at: https:&#x2F;&#x2F;github.com&#x2F;auroral-ui&#x2F;hexo-theme-aurora</code></pre><img src="http://t-blog-images.aijs.top/img/202209152228582.png" /><img src="http://t-blog-images.aijs.top/img/202209152249538.png" /><h2 id="shell-拷贝打包产物"><a href="#shell-拷贝打包产物" class="headerlink" title="shell 拷贝打包产物"></a>shell 拷贝打包产物</h2><pre class="line-numbers language-none"><code class="language-none">$ cp -rf .&#x2F;hexo-theme-aurora&#x2F;layout .&#x2F;841660202.github.io&#x2F;node_modules&#x2F;hexo-theme-aurora&#x2F;$ cp -rf .&#x2F;hexo-theme-aurora&#x2F;source .&#x2F;841660202.github.io&#x2F;node_modules&#x2F;hexo-theme-aurora&#x2F;</code></pre><h2 id="可以断定是-github-的-bug"><a href="#可以断定是-github-的-bug" class="headerlink" title="可以断定是 github 的 bug"></a>可以断定是 github 的 bug</h2><img src="http://t-blog-images.aijs.top/img/202209162153870.png" /><h2 id="ol-ul-列表顶部对齐"><a href="#ol-ul-列表顶部对齐" class="headerlink" title="ol , ul 列表顶部对齐"></a>ol , ul 列表顶部对齐</h2><img src="http://t-blog-images.aijs.top/img/202210172108326.png" /><pre class="line-numbers language-css" data-language="css"><code class="language-css">vertical-align: top;</code></pre><img src="http://t-blog-images.aijs.top/img/202210172109176.png" /><h2 id="axios-超时时间"><a href="#axios-超时时间" class="headerlink" title="axios 超时时间"></a>axios 超时时间</h2><p>由 5000 改为 10000</p><p>超时情况，请求会被取消</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点</title>
      <link href="//post/2022-06-23%E7%82%B9.html"/>
      <url>//post/2022-06-23%E7%82%B9.html</url>
      
        <content type="html"><![CDATA[<img src="http://t-blog-images.aijs.top/img/20220623175342.webp" /><p>记得之前在哪看到过是js解析时候的问题</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 比如 1.toString() &#x2F;&#x2F; 会被解析认为这个.是数字1的点，即：1. 这个含小数的数Number(1).toString() &#x2F;&#x2F; ok1 .toString() &#x2F;&#x2F; ok&#x2F;&#x2F; 那么 &#123;&#125;.__proto__ &#x2F;&#x2F; 先执行 &#123;&#125;. 就会报错，而且报错一样 如下图(&#123;&#125;).__proto__ &#x2F;&#x2F; ok</code></pre><img src="http://t-blog-images.aijs.top/img/20220623175915.webp" />]]></content>
      
      
      <categories>
          
          <category> javaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios 1.0.0-alpha.1 源码</title>
      <link href="//post/2022-06-23axios.html"/>
      <url>//post/2022-06-23axios.html</url>
      
        <content type="html"><![CDATA[<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://axios-http.com" target="_blank" >官网首页</a><br><a href="https://axios-http.com/docs/intro" target="_blank" >官方文档介绍</a><br><a href="https://axios-http.com/zh/docs/example" target="_blank" >中文文档</a></p><p>Promise based HTTP client for the browser and node.js<br><em>基于 promise 可以用于浏览器和 node.js 的网络请求库</em></p><p>Axios is a promise-based HTTP Client for node.js and the browser. It is isomorphic (&#x3D; it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js http module, while on the client (browser) it uses XMLHttpRequests.<br><em>Axios 是一个基于 promise 网络请求库，作用于 node.js 和浏览器中。 它是 isomorphic「同构」 的(即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</em></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>从浏览器创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF</li></ul><h2 id="使用及-Axios-API"><a href="#使用及-Axios-API" class="headerlink" title="使用及 Axios API"></a>使用及 Axios API</h2><p><a href="https://axios-http.com/zh/docs/example" target="_blank" >get example 使用</a><br><a href="https://axios-http.com/zh/docs/post_example" target="_blank" >post example 使用</a><br><a href="https://axios-http.com/zh/docs/api_intro" target="_blank" >API</a></p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>请求方式别名<br>为了方便起见，已经为所有支持的请求方法提供了别名。</p><p>axios.request(config)<br>axios.get(url[, config])<br>axios.delete(url[, config])<br>axios.head(url[, config]) ?<br>axios.options(url[, config]) 预检<br>axios.post(url[, data[, config]])<br>axios.put(url[, data[, config]])<br>axios.patch(url[, data[, config]])? patch 方法用来更新局部资源<br>注意<br>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p><p>restful 只是标准，标准的意思是如果在大家都依此行事的话，沟通成本会很低，开发效率就高。但并非强制(也没人强制得了)，所以你说在你的程序里把方法名从 put 改成 patch 没有任何影响，那是自然，因为你的后端程序并没有按照标准对两个方法做不同处理，她的表现自然是一样的</p><p>即约定，但并不是所有的人都这么干，具体项目如何实现，还需要前后端一致（打个比方：有的后端用 post 做删除，用 post 做查询，用 post 做更新，再举个例子三脚插头有大有小不知道你晓不晓得？只要对应的插孔是对应的大小也就可以运行，要不然连不上）</p></p></div><p>…</p><p><strong>axios.options(url[, config])</strong></p><p><a href="https://blog.csdn.net/csdnyp/article/details/122651869">axios 中为什么会有 OPTIONS 请求</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>浏览器限制跨域<br>浏览器限制跨域请求一般有两种方式：<br>1、限制发起跨域请求<br>2、跨域请求可以正常发起，但是返回的结果会被浏览器拦截</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>一般情况下，浏览器会以第二种方式限制跨域请求。这种存在一种情况，_请求已经到达服务器并响应了某些操作，改变了数据库数据，但是返回的结果会被浏览器拦截，用户就不能取到相应的结果进行后续的操作_。<strong>所以为了避免这种情况，浏览器就会通过 OPTIONS 方法对请求进行预检，通过询问服务器是否允许这次请求，允许之后，服务器才会响应真实请求，否则就阻止真实请求</strong>。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>项目中需要 OPTIONS 预检吗？<br>用户登陆之后，我们会获取 token 值，在每一次发起请求时，请求头都会携带这个 token 值，所以会触发预检请求。因为目前除了登录，其他请求接口请求头都携带了 token，而且我们的 Content-Type 绝大多数是 application&#x2F;json，所以预检总会存在。如果不想发起 OPTIONS 预检请求，建议后端在请求的返回头部添加：Access-Control-Max-Age:(number)。</p></blockquote><p><a href="https://blog.csdn.net/u011200562/article/details/110431341" target="_blank" >Access-Control-Max-Age 是什么</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>浏览器的同源策略，就是出于安全考虑，浏览器会限制从脚本发起的跨域 HTTP 请求（比如异步请求 GET, POST, PUT, DELETE, OPTIONS 等等），所以浏览器会向所请求的服务器发起两次请求，第一次是浏览器使用 OPTIONS 方法发起一个预检请求，第二次才是真正的异步请求，第一次的预检请求获知服务器是否允许该跨域请求：如果允许，才发起第二次真实的请求；如果不允许，则拦截第二次请求。</p><p>Access-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒，，在此期间不用发出另一条预检请求。</p><p>例如：</p><p>resp.addHeader(“Access-Control-Max-Age”, “0”)，表示每次异步请求都发起预检请求，也就是说，发送两次请求。</p><p>resp.addHeader(“Access-Control-Max-Age”, “1800”)，表示隔 30 分钟才发起预检请求。也就是说，发送两次请求</p></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><p><a href="https://axios-http.com/zh/docs/config_defaults#:~:text=%3D%20AUTH_TOKEN%3B-,%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7,-%E9%85%8D%E7%BD%AE%E5%B0%86%E4%BC%9A%E6%8C%89" target="_blank" >配置的优先级</a><br>配置将会按优先级进行合并。它的顺序是：在 <code>lib/defaults.js</code> 中找到的库默认值，然后是实例的 <code>defaults</code> 属性，最后是<code>请求的 config 参数</code>。后面的优先级要高于前面的。下面有一个例子。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 使用库提供的默认配置创建实例&#x2F;&#x2F; 此时超时配置的默认值是 &#96;0&#96;const instance &#x3D; axios.create();&#x2F;&#x2F; 重写库的超时默认值&#x2F;&#x2F; 现在，所有使用此实例的请求都将等待 2.5 秒，然后才会超时instance.defaults.timeout &#x3D; 2500;&#x2F;&#x2F; 重写此请求的超时时间，因为该请求需要很长时间instance.get(&quot;&#x2F;longRequest&quot;, &#123;  timeout: 5000,&#125;);</code></pre></li><li><p>版本发布没有遵守<code>语义化版本</code></p></li></ol><p>在 redux 章节曾聊过包的版本, 必须有, 要符合<a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning guidelines</a>, 参考 <a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a>, 建议仔细通读<br><img src="http://t-blog-images.aijs.top/img/20220525140247.webp" width=600 style="object-fit: content"/></p><p></p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>已经通过官方文档对 axios 的使用和 api 已经有了初步的了解</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li>了解特性的实现过程</li><li>了解 api 的实现过程</li><li>看看代码靠不靠谱，有没有“彩蛋”(蛙去～，我早上突然冒的想法，竟然在下午真的遇到了，直觉～)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── CHANGELOG.md├── CODE_OF_CONDUCT.md├── COLLABORATOR_GUIDE.md├── CONTRIBUTING.md├── ECOSYSTEM.md├── LICENSE├── README.md├── SECURITY.md├── UPGRADE_GUIDE.md├── bin├── bower.json # 用于bower install├── dist├── examples├── gulpfile.js # gulp任务├── index.d.ts├── index.js├── karma.conf.cjs├── lib├── package-lock.json├── package.json # &quot;build&quot;: &quot;gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m&quot;,├── rollup.config.js # rollup 打包配置├── sandbox # 一个前后端测试demo├── test├── tsconfig.json├── tslint.json└── webpack.config.js # webpack配置，没有使用的样子6 directories, 20 files</code></pre><h2 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h2><p>gulpfile 现在项目很少见，上次见是在 2017 年的时候了，一开始，我看到有 根目录<code>bower.json</code> <code>gulpfile.js</code> <code>rollup.config.js</code> <code>webpack.config.js</code>,有点懵逼～</p><img src="http://t-blog-images.aijs.top/img/20220623135204.webp"/><h2 id="bower-json"><a href="#bower-json" class="headerlink" title="bower.json"></a>bower.json</h2><p><strong>了解下，有这么个东西，以后估计也用不到</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1710656712337561707&wfr=spider&for=pc" target="_blank" >bower 介绍见</a><br><a href="https://github.com/bower/bower" target="_blank" >github 仓库</a></p><p>Bower 是一个客户端的软件包管理器，它可用于搜索、安装和卸载如 JavaScript、HTML、CSS<br>之类的网络资源，Bower 是 Web 开发中的一个前端文件包管理器，类似于 Node 模块的<br>npm 包管理器，bower 依赖于 Git、Node 和 npm。</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>看完上述几个文件有点懵，工具像是重复的样子</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;scripts&quot;: &#123;  &quot;test&quot;: &quot;npm run test:eslint &amp;&amp; npm run test:mocha &amp;&amp; npm run test:karma &amp;&amp; npm run test:dtslint&quot;,  &quot;test:eslint&quot;: &quot;node bin&#x2F;ssl_hotfix.js eslint lib&#x2F;**&#x2F;*.js&quot;,  &quot;test:dtslint&quot;: &quot;node bin&#x2F;ssl_hotfix.js dtslint&quot;,  &quot;test:mocha&quot;: &quot;node bin&#x2F;ssl_hotfix.js mocha test&#x2F;unit&#x2F;**&#x2F;*.js --timeout 30000 --exit&quot;,  &quot;test:karma&quot;: &quot;node bin&#x2F;ssl_hotfix.js cross-env LISTEN_ADDR&#x3D;:: karma start karma.conf.cjs --single-run&quot;,  &quot;test:karma:server&quot;: &quot;node bin&#x2F;ssl_hotfix.js cross-env karma start karma.conf.cjs&quot;,  &quot;start&quot;: &quot;node .&#x2F;sandbox&#x2F;server.js&quot;,  &quot;preversion&quot;: &quot;gulp version &amp;&amp; npm test&quot;,  &quot;version&quot;: &quot;npm run build &amp;&amp; git add dist &amp;&amp; git add package.json&quot;,  &quot;prepublishOnly&quot;: &quot;npm test&quot;,  &quot;postpublish&quot;: &quot;git push &amp;&amp; git push --tags &quot;,  &quot;build&quot;: &quot;gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m&quot;, &#x2F;&#x2F; 打包只用到了gulp 和 rollup，没有用到webpack,webpack.config.js是多余的  &quot;examples&quot;: &quot;node .&#x2F;examples&#x2F;server.js&quot;,  &quot;coveralls&quot;: &quot;cat coverage&#x2F;lcov.info | .&#x2F;node_modules&#x2F;coveralls&#x2F;bin&#x2F;coveralls.js&quot;,  &quot;fix&quot;: &quot;eslint --fix lib&#x2F;**&#x2F;*.js&quot;&#125;,</code></pre><h2 id="rollup-config-js"><a href="#rollup-config-js" class="headerlink" title="rollup.config.js"></a>rollup.config.js</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import resolve from &quot;@rollup&#x2F;plugin-node-resolve&quot;;import commonjs from &quot;@rollup&#x2F;plugin-commonjs&quot;;import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;import json from &quot;@rollup&#x2F;plugin-json&quot;;import &#123; babel &#125; from &quot;@rollup&#x2F;plugin-babel&quot;;import autoExternal from &quot;rollup-plugin-auto-external&quot;;const lib &#x3D; require(&quot;.&#x2F;package.json&quot;);const outputFileName &#x3D; &quot;axios&quot;;const name &#x3D; &quot;axios&quot;;const input &#x3D; &quot;.&#x2F;lib&#x2F;axios.js&quot;; &#x2F;&#x2F; 源码入口&#x2F;&#x2F; minifiedVersion参数最小化，默认true，下面三处调用都没有传，这个文件与webpack.config.js无关const buildConfig &#x3D; (&#123;  es5,  browser &#x3D; true,  minifiedVersion &#x3D; true,  ...config&#125;) &#x3D;&gt; &#123;  const build &#x3D; (&#123; minified &#125;) &#x3D;&gt; (&#123;    input,    ...config,    output: &#123;      ...config.output, &#x2F;&#x2F; 里面有banner信息      file: &#96;$&#123;config.output.file&#125;.$&#123;minified ? &quot;min.js&quot; : &quot;js&quot;&#125;&#96;,    &#125;,    plugins: [      json(),      resolve(&#123; browser &#125;),      commonjs(),      minified &amp;&amp; terser(),      ...(es5        ? [            babel(&#123;              babelHelpers: &quot;bundled&quot;,              presets: [&quot;@babel&#x2F;preset-env&quot;],            &#125;),          ]        : []),      ...(config.plugins || []),    ],  &#125;);  const configs &#x3D; [build(&#123; minified: false &#125;)];  if (minifiedVersion) &#123;    build(&#123; minified: true &#125;);  &#125;  return configs;&#125;;export default async () &#x3D;&gt; &#123;  const year &#x3D; new Date().getFullYear();  const banner &#x3D; &#96;&#x2F;&#x2F; Axios v$&#123;lib.version&#125; Copyright (c) $&#123;year&#125; $&#123;lib.author&#125; and contributors&#96;;  return [    ...buildConfig(&#123;      es5: true,      output: &#123;        file: &#96;dist&#x2F;$&#123;outputFileName&#125;&#96;,        name,        format: &quot;umd&quot;, &#x2F;&#x2F; umd格式        exports: &quot;default&quot;,        banner,      &#125;,    &#125;),    ...buildConfig(&#123;      output: &#123;        file: &#96;dist&#x2F;esm&#x2F;$&#123;outputFileName&#125;&#96;,        format: &quot;esm&quot;, &#x2F;&#x2F; esm格式        preferConst: true,        exports: &quot;named&quot;,        banner,      &#125;,    &#125;),    &#x2F;&#x2F; Node.js commonjs build    &#123;      input,      output: &#123;        file: &#96;dist&#x2F;node&#x2F;$&#123;name&#125;.cjs&#96;,        format: &quot;cjs&quot;, &#x2F;&#x2F; commonjs格式        preferConst: true,        exports: &quot;default&quot;,        banner,      &#125;,      plugins: [autoExternal(), resolve(), commonjs()],    &#125;,  ];&#125;;</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn buildyarn run v1.4.0$ gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m[14:19:33] Using gulpfile ~&#x2F;Desktop&#x2F;axios&#x2F;gulpfile.js[14:19:33] Starting &#39;clear&#39;...[14:19:33] Finished &#39;clear&#39; after 5.74 ms[!] Error: Cannot find module &#39;@babel&#x2F;core&#39;Require stack:- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;@rollup&#x2F;plugin-babel&#x2F;dist&#x2F;index.js- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;rollup.config.js- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;rollup&#x2F;dist&#x2F;shared&#x2F;loadConfigFile.js- &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;node_modules&#x2F;rollup&#x2F;dist&#x2F;bin&#x2F;rollupError: Cannot find module &#39;@babel&#x2F;core&#39;解决：👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn add @babel&#x2F;core -Dyarn add v1.4.0[1&#x2F;4] 🔍  Resolving packages...[2&#x2F;4] 🚚  Fetching packages...warning Pattern [&quot;@definitelytyped&#x2F;typescript-versions@latest&quot;] is trying to unpack in the same destination &quot;&#x2F;Users&#x2F;haotian&#x2F;Library&#x2F;Caches&#x2F;Yarn&#x2F;v1&#x2F;npm-@definitelytyped&#x2F;typescript-versions-0.0.118-de13fb755c5181443860c3c74b6730f47f6541fc&quot; as pattern [&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;,&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;,&quot;@definitelytyped&#x2F;typescript-versions@^0.0.118&quot;]. This could result in non-deterministic behavior, skipping.[3&#x2F;4] 🔗  Linking dependencies...warning &quot; &gt; @rollup&#x2F;plugin-babel@5.3.1&quot; has unmet peer dependency &quot;@types&#x2F;babel__core@^7.1.9&quot;.warning &quot; &gt; istanbul-instrumenter-loader@3.0.1&quot; has unmet peer dependency &quot;webpack@^2.0.0 || ^3.0.0 || ^4.0.0&quot;.warning &quot;karma &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.warning &quot;karma &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.warning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; node-fetch@2.6.7&quot; has unmet peer dependency &quot;encoding@^0.1.0&quot;.warning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; ws@7.5.8&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.warning &quot;karma-sauce-launcher &gt; webdriverio &gt; puppeteer-core &gt; ws@7.5.8&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.warning &quot; &gt; terser-webpack-plugin@4.2.3&quot; has unmet peer dependency &quot;webpack@^4.0.0 || ^5.0.0&quot;.[4&#x2F;4] 📃  Building fresh packages...success Saved lockfile.success Saved 5 new dependencies.├─ @ampproject&#x2F;remapping@2.2.0├─ @babel&#x2F;core@7.18.5├─ @babel&#x2F;helpers@7.18.2├─ gensync@1.0.0-beta.2└─ json5@2.2.1✨  Done in 37.80s.👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn buildyarn run v1.4.0$ gulp clear &amp;&amp; cross-env NODE_ENV&#x3D;production rollup -c -m[14:20:32] Using gulpfile ~&#x2F;Desktop&#x2F;axios&#x2F;gulpfile.js[14:20:32] Starting &#39;clear&#39;...[14:20:32] Finished &#39;clear&#39; after 48 ms.&#x2F;lib&#x2F;axios.js → dist&#x2F;axios.js...created dist&#x2F;axios.js in 3.5s.&#x2F;lib&#x2F;axios.js → dist&#x2F;esm&#x2F;axios.js...created dist&#x2F;esm&#x2F;axios.js in 711ms.&#x2F;lib&#x2F;axios.js → dist&#x2F;node&#x2F;axios.cjs...created dist&#x2F;node&#x2F;axios.cjs in 1.1s✨  Done in 9.39s.👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $</code></pre></p></div><h2 id="打包产物"><a href="#打包产物" class="headerlink" title="打包产物"></a>打包产物</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── axios.js├── axios.js.map├── esm│   ├── axios.js│   └── axios.js.map└── node    ├── axios.cjs    └── axios.cjs.map2 directories, 6 files</code></pre><p>哎？咋滴回事，我们在<code>rollup.config.js</code>见到<code>minifiedVersion</code>默认是<code>true</code>,传给 <code>minified</code>咋的没见<code>min.js</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const configs &#x3D; [build(&#123; minified: false &#125;)];if (minifiedVersion) &#123;  build(&#123; minified: true &#125;); &#x2F;&#x2F; 这么些应该是为了开发调试，在sandbox中 &lt;script src&#x3D;&quot;&#x2F;axios.js&quot;&gt;&lt;&#x2F;script&gt;&#125;return configs;&#x2F;&#x2F; 这里暴露的是configs， build(&#123;minified: true&#125;)完全没搞事情，&#x2F;&#x2F; 这代码应该是用 build(&#123;minified: true&#125;) 替换   build(&#123;minified: false&#125;) 才对</code></pre><p>修改下，然后运行<code>yarn build</code></p><img src="http://t-blog-images.aijs.top/img/20220623143251.webp" /><h2 id="axios-js"><a href="#axios-js" class="headerlink" title="axios.js"></a>axios.js</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&quot;use strict&quot;;import utils from &quot;.&#x2F;utils.js&quot;;import bind from &quot;.&#x2F;helpers&#x2F;bind.js&quot;;import Axios from &quot;.&#x2F;core&#x2F;Axios.js&quot;;import mergeConfig from &quot;.&#x2F;core&#x2F;mergeConfig.js&quot;;import defaults from &quot;.&#x2F;defaults&#x2F;index.js&quot;;import formDataToJSON from &quot;.&#x2F;helpers&#x2F;formDataToJSON.js&quot;;import CanceledError from &quot;.&#x2F;cancel&#x2F;CanceledError.js&quot;;import CancelToken from &quot;.&#x2F;cancel&#x2F;CancelToken.js&quot;;import isCancel from &quot;.&#x2F;cancel&#x2F;isCancel.js&quot;;import &#123; VERSION &#125; from &quot;.&#x2F;env&#x2F;data.js&quot;;import toFormData from &quot;.&#x2F;helpers&#x2F;toFormData.js&quot;;import AxiosError from &quot;..&#x2F;lib&#x2F;core&#x2F;AxiosError.js&quot;;import spread from &quot;.&#x2F;helpers&#x2F;spread.js&quot;;import isAxiosError from &quot;.&#x2F;helpers&#x2F;isAxiosError.js&quot;;&#x2F;** * Create an instance of Axios * * @param &#123;Object&#125; defaultConfig The default config for the instance * * @returns &#123;Axios&#125; A new instance of Axios *&#x2F;function createInstance(defaultConfig) &#123;  const context &#x3D; new Axios(defaultConfig);  const instance &#x3D; bind(Axios.prototype.request, context);  &#x2F;&#x2F; Copy axios.prototype to instance  &#x2F;&#x2F; 拷贝原型到实例  utils.extend(instance, Axios.prototype, context, &#123; allOwnKeys: true &#125;);  &#x2F;&#x2F; Copy context to instance  &#x2F;&#x2F; 拷贝上下文到实例  utils.extend(instance, context, &#123; allOwnKeys: true &#125;);  &#x2F;&#x2F; Factory for creating new instances  &#x2F;&#x2F; 用于创建新实例的工厂  instance.create &#x3D; function create(instanceConfig) &#123;    return createInstance(mergeConfig(defaultConfig, instanceConfig));  &#125;;  return instance;&#125;&#x2F;&#x2F; Create the default instance to be exported&#x2F;&#x2F; 使用默认配置创建实例const axios &#x3D; createInstance(defaults);&#x2F;&#x2F; Expose Axios class to allow class inheritance&#x2F;&#x2F; 暴露Axios类，允许类被继承axios.Axios &#x3D; Axios;&#x2F;&#x2F; Expose Cancel &amp; CancelTokenaxios.CanceledError &#x3D; CanceledError;axios.CancelToken &#x3D; CancelToken;axios.isCancel &#x3D; isCancel;axios.VERSION &#x3D; VERSION; &#x2F;&#x2F; gulp的env任务会将package.json的版本信息读取并写入 .&#x2F;lib&#x2F;env&#x2F;data.js，见下面代码：&#x2F;&#x2F; const env &#x3D; gulp.task(&#39;env&#39;, async function () &#123;&#x2F;&#x2F;   var npm &#x3D; JSON.parse(await fs.readFile(&#39;package.json&#39;));&#x2F;&#x2F;   await fs.writeFile(&#39;.&#x2F;lib&#x2F;env&#x2F;data.js&#39;, Object.entries(&#123;&#x2F;&#x2F;     VERSION: npm.version&#x2F;&#x2F;   &#125;).map(([key, value]) &#x3D;&gt; &#123;&#x2F;&#x2F;     return &#96;export const $&#123;key&#125; &#x3D; $&#123;JSON.stringify(value)&#125;;&#96;&#x2F;&#x2F;   &#125;).join(&#39;\n&#39;));&#x2F;&#x2F; &#125;);axios.toFormData &#x3D; toFormData;&#x2F;&#x2F; Expose AxiosError class&#x2F;&#x2F; 暴露AxuosError错误类axios.AxiosError &#x3D; AxiosError;&#x2F;&#x2F; alias for CanceledError for backward compatibility&#x2F;&#x2F; CanceledError的别名用于向后兼容axios.Cancel &#x3D; axios.CanceledError;&#x2F;&#x2F; Expose all&#x2F;spread&#x2F;&#x2F; 暴露并发axios.all &#x3D; function all(promises) &#123;  return Promise.all(promises);&#125;;&#x2F;&#x2F; 暴露spreadaxios.spread &#x3D; spread; &#x2F;&#x2F; 使用尾部调用柯里化，执行的结果还是一个函数&#x2F;&#x2F; Expose isAxiosError&#x2F;&#x2F; 暴露判断AxiosError的方法axios.isAxiosError &#x3D; isAxiosError;axios.formToJSON &#x3D; (thing) &#x3D;&gt; &#123;  &#x2F;&#x2F; 调用工具，将thing进行json化  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);&#125;;export default axios;</code></pre><p>其他细节不看</p><h2 id="运行-sandbox"><a href="#运行-sandbox" class="headerlink" title="运行 sandbox"></a>运行 sandbox</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn start</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;axios git:(v1.x) ✗ $ yarn startyarn run v1.4.0$ node .&#x2F;sandbox&#x2F;server.jsListening on localhost:3009...[Thu Jun 23 2022 16:16:31 GMT+0800 (中国标准时间)] GET &#x2F;file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:14  fs.createReadStream(path.join(__dirname, file)).pipe(res);                                ^ReferenceError: __dirname is not defined    at pipeFileToResponse (file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:14:33)    at Server.&lt;anonymous&gt; (file:&#x2F;&#x2F;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;sandbox&#x2F;server.js:30:5)    at Server.emit (node:events:390:28)    at parserOnIncoming (node:_http_server:951:12)    at HTTPParser.parserOnHeadersComplete (node:_http_common:128:17)error An unexpected error occurred: &quot;Command failed.\nExit code: 1\nCommand: sh\nArguments: -c node .&#x2F;sandbox&#x2F;server.js\nDirectory: &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios\nOutput:\n&quot;.info If you think this is a bug, please open a bug report with the information provided in &quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;axios&#x2F;yarn-error.log&quot;.info Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;run for documentation about this command.</code></pre><p>修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const __filename &#x3D; url.fileURLToPath(import.meta.url); &#x2F;&#x2F; 增加这行 @see https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;import.metaconst __dirname &#x3D; path.dirname(__filename); &#x2F;&#x2F; 增加这行function pipeFileToResponse(res, file, type) &#123;  if (type) &#123;    res.writeHead(200, &#123;      &quot;Content-Type&quot;: type,    &#125;);  &#125;  fs.createReadStream(path.join(__dirname, file)).pipe(res);&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/20220623162402.webp" /><h2 id="core-目录"><a href="#core-目录" class="headerlink" title="core 目录"></a>core 目录</h2><h2 id="axios-执行流程"><a href="#axios-执行流程" class="headerlink" title="axios 执行流程"></a>axios 执行流程</h2><p>执行流程</p><p>先看看整体执行流程，有大体的概念，后面会细说整体流程有以下几点：</p><ol><li>axios.create 创建单独实例，或直接使用 axios 实例(axios&#x2F;axios.get…)</li><li>request 方法是入口，axios&#x2F;axios.get 等调用都会走进 request 进行处理</li><li>请求拦截器</li><li>请求数据转换器，对传入的参数 data 和 header 做数据处理，比如 JSON.stringify(data)</li><li>适配器，判断是浏览器端还是 node 端，执行不同的方法</li><li>响应数据转换器，对服务端的数据进行处理，比如 JSON.parse(data)</li><li>响应拦截器，对服务端数据做处理，比如 token 失效退出登陆，报错 dialog 提示</li><li>返回数据给开发者</li></ol><img src="http://t-blog-images.aijs.top/img/20220623165311.webp"/><h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p><code>file:lib/axios.js</code></p><p>从下面这段代码可以得出，导出的 axios 就是实例化后的对象，还在其上挂载 create 方法，以供创建独立实例，从而达到实例之间互不影响，互相隔离。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">...&#x2F;&#x2F; 创建实例过程的方法functioncreateInstance(defaultConfig) &#123;return instance;&#125;&#x2F;&#x2F; 实例化var axios &#x3D; createInstance(defaults);&#x2F;&#x2F; 创建独立的实例，隔离作用域axios.create &#x3D; functioncreate(instanceConfig) &#123;return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;;...&#x2F;&#x2F; 导出实例module.exports &#x3D; axios; &#x2F;&#x2F; 可能大家对 createInstance 方法感到好奇，下面一探究竟。functioncreateInstance(defaultConfig) &#123;  &#x2F;&#x2F; 实例化，创建一个上下文var context &#x3D; new Axios(defaultConfig);&#x2F;&#x2F; 平时调用的 get&#x2F;post 等等请求，底层都是调用 request 方法&#x2F;&#x2F; 将 request 方法的 this 指向 context(上下文)，形成新的实例var instance &#x3D; bind(Axios.prototype.request, context);&#x2F;&#x2F; Axios.prototype 上的方法 (get&#x2F;post...)挂载到新的实例 instance 上，&#x2F;&#x2F; 并且将原型方法中 this 指向context utils.extend(instance, Axios.prototype, context);&#x2F;&#x2F; Axios 属性值挂载到新的实例 instance 上&#x2F;&#x2F; 开发中才能使用 axios.default&#x2F;interceptorsutils.extend(instance, context);return instance;&#125;&#x2F;&#x2F; 从上面代码可以看得出，Axios 不是简单的创建实例 context，而且进行一系列的上下文绑定和属性方法挂载，从而去支持 axios()，也支持 axios.get() 等等用法；</code></pre><p>createInstance 函数是一个核心入口，我们在把上面流程梳理一下：</p><ol><li>通过构造函数 Axios 创建实例 context，作为下面 request 方法的上下文（this 指向）</li><li>将 Axios.prototype.request 方法作为实例使用，并把 this 指向 context，形成新的实例 instance</li><li>将构造函数 Axios.prototype 上的方法挂载到新的实例 instance 上，然后将原型各个方法中的 this 指向 context，开发中才能使用 axios.get&#x2F;post… 等等</li><li>将构造函数 Axios 的实例属性挂载到新的实例 instance 上，我们开发中才能使用下面属性 axios.default.baseUrl &#x3D; ‘https:&#x2F;&#x2F;…’axios.interceptors.request.use(resolve,reject)<br>大家可能对上面第 2 点 request 方法感到好奇，createInstance 方法明明可以写一行代码 return new Axios() 即可，为什么大费周章使用 request 方法绑定新实例，其实就只是为了支持 axios() 写法，开发者可以写少几行代码。。。</li></ol><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><p><code>file:lib/defaults.js</code></p><p>从 createInstance 方法调用发现有个默认配置，主要是内置的属性和方法，可对其进行覆盖</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var defaults &#x3D; &#123;  ...  &#x2F;&#x2F; 请求超时时间，默认不超时  timeout: 0,   &#x2F;&#x2F; 请求数据转换器  transformRequest: [functiontransformRequest(data, headers) &#123;...&#125;],  &#x2F;&#x2F; 响应数据转换器  transformResponse: [functiontransformResponse(data) &#123;...&#125;], ...&#125;;  ...</code></pre><p>主要有两点：</p><ol><li>配置：外部传入，可覆盖内部默认配置</li><li>拦截器：实例后，开发者可通过 use 方法注册成功和失败的钩子函数，比如</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">axios.interceptors.request.use((config)&#x3D;&gt;config,(error)&#x3D;&gt;error);functionAxios(instanceConfig) &#123;  &#x2F;&#x2F; 配置  this.defaults &#x3D; instanceConfig;  &#x2F;&#x2F; 拦截器实例  this.interceptors &#x3D; &#123;request: new InterceptorManager(),response: new InterceptorManager() &#125;;&#125;</code></pre><p>在看看原型方法 request 做了什么</p><p>支持多类型传参<br>配置优先级定义<br>通过 promise 链式调用，依次顺序执行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 伪代码Axios.prototype.request &#x3D; functionrequest(config) &#123;  &#x2F;&#x2F; 为了支持  request(url, &#123;...&#125;), request(&#123;url, ...&#125;)if (typeof config &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123; config &#x3D; arguments[1] || &#123;&#125;; config.url &#x3D; arguments[0]; &#125; else &#123; config &#x3D; config || &#123;&#125;; &#125;  &#x2F;&#x2F; 配置优先级： 调用方法的配置 &gt; 实例化 axios 的配置 &gt; 默认配置  &#x2F;&#x2F; 举个例子，类似：  axios.get(url, &#123;&#125;) &gt; axios.create(url, &#123;&#125;) &gt; 内部默认设置 config &#x3D; mergeConfig(this.defaults, config);  &#x2F;&#x2F; 拦截器（请求和响应）  var requestInterceptorChain &#x3D; [&#123;fulfilled: interceptor.request.fulfilled,rejected: interceptor.request.rejected &#125;];  var responseInterceptorChain &#x3D; [&#123;fulfilled: interceptor.response.fulfilled,rejected: interceptor.response.rejected &#125;];  var promise;&#x2F;&#x2F; 形成一个 promise 链条的数组  var chain &#x3D; [].concat(requestInterceptorChain, chain, responseInterceptorChain);  &#x2F;&#x2F; 传入配置  promise &#x3D; Promise.resolve(config);  &#x2F;&#x2F; 形成 promise 链条调用   while (chain.length) &#123; promise &#x3D; promise.then(chain.shift(), chain.shift()); &#125; ... return promise;&#125;;</code></pre><p>通过对数组的遍历，形成一条异步的 promise 调用链，是 axios 对 promise 的巧妙运用，用一张图表示</p><img src="http://t-blog-images.aijs.top/img/20220623165416.webp" /><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><code>file:lib/core/InterceptorManager.js</code></p><p>上面说到的 promise 调用链，里面涉及到拦截器，拦截器比较简单，挂载一个属性和三个原型方法</p><ul><li>handler: 存放 use 注册的回调函数</li><li>use: 注册成功和失败的回调函数</li><li>eject: 删除注册过的函数</li><li>forEach: 遍历回调函数，一般内部使用多，比如：promise 调用链那个方法里，循环遍历回调函数，存放到 promise 调用链的数组中</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class InterceptorManager &#123;  constructor() &#123;    this.handlers &#x3D; [];  &#125;  &#x2F;**   * Add a new interceptor to the stack   * &#x2F;&#x2F; 注册成功和失败的回调函数   * @param &#123;Function&#125; fulfilled The function to handle &#96;then&#96; for a &#96;Promise&#96;   * @param &#123;Function&#125; rejected The function to handle &#96;reject&#96; for a &#96;Promise&#96;   *   * @return &#123;Number&#125; An ID used to remove interceptor later   *&#x2F;  use(fulfilled, rejected, options) &#123;    this.handlers.push(&#123;      fulfilled,      rejected,      synchronous: options ? options.synchronous : false,      runWhen: options ? options.runWhen : null,    &#125;);    return this.handlers.length - 1;  &#125;  &#x2F;**   * Remove an interceptor from the stack   * &#x2F;&#x2F; 删除注册过的函数   * @param &#123;Number&#125; id The ID that was returned by &#96;use&#96;   *   * @returns &#123;Boolean&#125; &#96;true&#96; if the interceptor was removed, &#96;false&#96; otherwise   *&#x2F;  eject(id) &#123;    if (this.handlers[id]) &#123;      this.handlers[id] &#x3D; null;    &#125;  &#125;  &#x2F;**   * Clear all interceptors from the stack   * 调用栈清空所有拦截器   * @returns &#123;void&#125;   *&#x2F;  clear() &#123;    if (this.handlers) &#123;      this.handlers &#x3D; [];    &#125;  &#125;  &#x2F;**   * Iterate over all the registered interceptors   *   * This method is particularly useful for skipping over any   * interceptors that may have become &#96;null&#96; calling &#96;eject&#96;.   * &#x2F;&#x2F; 遍历回调函数，一般内部使用多   * @param &#123;Function&#125; fn The function to call for each interceptor   *   * @returns &#123;void&#125;   *&#x2F;  forEach(fn) &#123;    utils.forEach(this.handlers, function forEachHandler(h) &#123;      if (h !&#x3D;&#x3D; null) &#123;        fn(h);      &#125;    &#125;);  &#125;&#125;export default InterceptorManager;</code></pre><h2 id="dispatchRequest"><a href="#dispatchRequest" class="headerlink" title="dispatchRequest"></a>dispatchRequest</h2><p><code>file: lib/core/dispatchRequest.js</code></p><p>上面说到的 promise 调用链中的 dispatchRequest 方法，主要做了以下操作：<br>以 <code>transformData.call</code>方式调用</p><ul><li>transformRequest: 对 config 中的 data 进行加工，比如对 post 请求的 data 进行字符串化 （JSON.stringify(data)）</li><li>adapter：适配器，包含浏览器端 xhr 和 node 端的 http</li><li>transformResponse: 对服务端响应的数据进行加工，比如 JSON.parse(data)</li></ul><p>dispatchRequest 局部图</p><img src="http://t-blog-images.aijs.top/img/20220623165506.webp" width=300 height=/><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; functiondispatchRequest(config) &#123;  ...  &#x2F;&#x2F; transformRequest 方法，上下文绑定 config，对 data 和 headers 进行加工  config.data &#x3D; transformData.call( config,  &#x2F;&#x2F; 上下文环境，即 this 指向 config.data,  &#x2F;&#x2F; 请求 body 参数 config.headers,  &#x2F;&#x2F; 请求头 config.transformRequest  &#x2F;&#x2F; 转换数据方法  );  &#x2F;&#x2F; adapter 是一个适配器，包含浏览器端 xhr 和 node 端的 http  &#x2F;&#x2F; 内置有 adapter，也可外部自定义去发起 ajax 请求  var adapter &#x3D; config.adapter || defaults.adapter;return adapter(config).then(    functiononAdapterResolution(response) &#123;    &#x2F;&#x2F; transformResponse 方法，上下文绑定 config，对 data 和 headers 进行加工      response.data &#x3D; transformData.call( config,      &#x2F;&#x2F; 上下文环境，即 this 指向      response.data, &#x2F;&#x2F; 服务端响应的 data      config.transformResponse &#x2F;&#x2F; 转换数据方法      );      response.headers, &#x2F;&#x2F; 服务端响应的 headers      return response;     &#125;,    functiononAdapterRejection(reason) &#123;     ...     return Promise.reject(reason);    &#125;);  &#125;;</code></pre><h2 id="数据转换器"><a href="#数据转换器" class="headerlink" title="数据转换器"></a>数据转换器</h2><p><code>file:lib/core/transformData.js</code></p><p>上面说到的数据转换器，比较好理解，源码如下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; fns 方法即（请求或响应）数据转换器方法，在刚开始 defaults 文件里定义的默认配置，也可外部自定义方法，源码如下：&#x2F;** * Transform the data for a request or a response * 转换请求或响应的数据 * @param &#123;Array|Function&#125; fns 一个数组，包含一个或多个方法转换器方法 * @param &#123;?Object&#125; response The response object * * @returns &#123;*&#125; The resulting transformed data *&#x2F;export default function transformData(fns, response) &#123;  const config &#x3D; this || defaults;  const context &#x3D; response || config;  const headers &#x3D; AxiosHeaders.from(context.headers);  let data &#x3D; context.data;  utils.forEach(fns, function transform(fn) &#123;    data &#x3D; fn.call(      config,      data,      headers.normalize(),      response ? response.status : undefined    );  &#125;);  headers.normalize();  return data;&#125;</code></pre><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p><code>file: lib/defaults.js</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const defaults &#x3D; &#123;  ...  &#x2F;&#x2F; 返回转化后的请求参数  transformRequest: [function transformRequest(data, headers) &#123;    const contentType &#x3D; headers.getContentType() || &#39;&#39;;    const hasJSONContentType &#x3D; contentType.indexOf(&#39;application&#x2F;json&#39;) &gt; -1;    const isObjectPayload &#x3D; utils.isObject(data);    if (isObjectPayload &amp;&amp; utils.isHTMLForm(data)) &#123;      data &#x3D; new FormData(data);    &#125;    const isFormData &#x3D; utils.isFormData(data);    if (isFormData) &#123;      if (!hasJSONContentType) &#123;        return data;      &#125;      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;    &#125;    if (utils.isArrayBuffer(data) ||      utils.isBuffer(data) ||      utils.isStream(data) ||      utils.isFile(data) ||      utils.isBlob(data)    ) &#123;      return data;    &#125;    if (utils.isArrayBufferView(data)) &#123;      return data.buffer;    &#125;    if (utils.isURLSearchParams(data)) &#123;      headers.setContentType(&#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8&#39;, false);      return data.toString();    &#125;    let isFileList;    if (isObjectPayload) &#123;      if (contentType.indexOf(&#39;application&#x2F;x-www-form-urlencoded&#39;) &gt; -1) &#123;        return toURLEncodedForm(data, this.formSerializer).toString();      &#125;      if ((isFileList &#x3D; utils.isFileList(data)) || contentType.indexOf(&#39;multipart&#x2F;form-data&#39;) &gt; -1) &#123;        const _FormData &#x3D; this.env &amp;&amp; this.env.FormData;        return toFormData(          isFileList ? &#123;&#39;files[]&#39;: data&#125; : data,          _FormData &amp;&amp; new _FormData(),          this.formSerializer        );      &#125;    &#125;    if (isObjectPayload || hasJSONContentType ) &#123;      headers.setContentType(&#39;application&#x2F;json&#39;, false);      return stringifySafely(data);    &#125;    return data;  &#125;],  &#x2F;&#x2F; 返回转化后的响应数据  transformResponse: [function transformResponse(data) &#123;    const transitional &#x3D; this.transitional || defaults.transitional;    const forcedJSONParsing &#x3D; transitional &amp;&amp; transitional.forcedJSONParsing;    const JSONRequested &#x3D; this.responseType &#x3D;&#x3D;&#x3D; &#39;json&#39;;    if (data &amp;&amp; utils.isString(data) &amp;&amp; ((forcedJSONParsing &amp;&amp; !this.responseType) || JSONRequested)) &#123;      const silentJSONParsing &#x3D; transitional &amp;&amp; transitional.silentJSONParsing;      const strictJSONParsing &#x3D; !silentJSONParsing &amp;&amp; JSONRequested;      try &#123;        return JSON.parse(data); &#x2F;&#x2F; 解析数据      &#125; catch (e) &#123;        if (strictJSONParsing) &#123;          if (e.name &#x3D;&#x3D;&#x3D; &#39;SyntaxError&#39;) &#123;            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);          &#125;          throw e;        &#125;      &#125;    &#125;    return data;  &#125;],&#125;;</code></pre><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p><code>file:lib/defaults.js</code></p><p>主要包含两部分源码，即浏览器端 xhr 和 node 端的 http 请求，通过判断环境，执行不同端的 api。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import utils from &quot;..&#x2F;utils.js&quot;;import httpAdapter from &quot;.&#x2F;http.js&quot;;import xhrAdapter from &quot;.&#x2F;xhr.js&quot;;const adapters &#x3D; &#123;  http: httpAdapter,  xhr: xhrAdapter,&#125;;export default &#123;  getAdapter: (nameOrAdapter) &#x3D;&gt; &#123;    if (utils.isString(nameOrAdapter)) &#123;      const adapter &#x3D; adapters[nameOrAdapter];      if (!nameOrAdapter) &#123;        throw Error(          utils.hasOwnProp(nameOrAdapter)            ? &#96;Adapter &#39;$&#123;nameOrAdapter&#125;&#39; is not available in the build&#96;            : &#96;Can not resolve adapter &#39;$&#123;nameOrAdapter&#125;&#39;&#96;        );      &#125;      return adapter;    &#125;    if (!utils.isFunction(nameOrAdapter)) &#123;      throw new TypeError(&quot;adapter is not a function&quot;);    &#125;    return nameOrAdapter;  &#125;,  adapters,&#125;;&#x2F;&#x2F; 注：&#x2F;axios&#x2F;lib&#x2F;core&#x2F;dispatchRequest.js&#x2F;&#x2F; const adapter &#x3D; config.adapter || defaults.adapter; 中调用 defaults.adapter&#x2F;&#x2F; file: &#x2F;axios&#x2F;lib&#x2F;defaults&#x2F;index.js&#x2F;&#x2F; export const default &#x3D; &#123;&#x2F;&#x2F;   adapter: getDefaultAdapter(),&#x2F;&#x2F; &#125;</code></pre><p>对外提供统一 api，但底层兼容浏览器端和 node 端，类似 sdk，底层更改不影响上层 api，保持向后兼容</p><h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><p><code>file: lib/adapters/xhr.js</code><br>平时用得比较多的是浏览器端，这里只讲 XMLHttpRequest 的封装，node 端有兴趣的同学自行查看源码(lib&#x2F;adapters&#x2F;http.js)</p><p>简易版流程图表示大致内容：</p><p><a href="http://t-blog-images.aijs.top/img/20220623172736.webp" target="_blank" ></a></p><p>注意：新版本有改动</p><ul><li>setCancelToken 没啦，有 cancelToken 和 signal</li><li>isSetCookie 没有这个</li><li><code>onreadystatechange</code> 不一定有, <code>onloadend</code>方法一定会被调用</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (&quot;onloadend&quot; in request) &#123;  &#x2F;&#x2F; Use onloadend if available  request.onloadend &#x3D; onloadend;&#125; else &#123;  &#x2F;&#x2F; Listen for ready state to emulate onloadend  request.onreadystatechange &#x3D; function handleLoad() &#123;    if (!request || request.readyState !&#x3D;&#x3D; 4) &#123;      return;    &#125;    &#x2F;&#x2F; The request errored out and we didn&#39;t get a response, this will be    &#x2F;&#x2F; handled by onerror instead    &#x2F;&#x2F; With one exception: request that using file: protocol, most browsers    &#x2F;&#x2F; will return status as 0 even though it&#39;s a successful request    if (      request.status &#x3D;&#x3D;&#x3D; 0 &amp;&amp;      !(request.responseURL &amp;&amp; request.responseURL.indexOf(&quot;file:&quot;) &#x3D;&#x3D;&#x3D; 0)    ) &#123;      return;    &#125;    &#x2F;&#x2F; readystate handler is calling before onerror or ontimeout handlers,    &#x2F;&#x2F; so we should call onloadend on the next &#39;tick&#39;    setTimeout(onloadend);  &#125;;&#125;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://baijiahao.baidu.com/s?id=1704404768648603231&wfr=spider&for=pc&searchword=axios%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" >Axios 源码解析-完整篇</a></p><p><a href="https://blog.csdn.net/qq_27053493/article/details/97462300" target="_blank" >一步一步解析 Axios 源码，从入门到原理</a></p><p><a href="https://www.codingsky.com/doc/2022/4/2/433.html" target="_blank" >axios源码中的10多个工具函数，值得一学~</a></p>]]></content>
      
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router v0.6.4 依赖 history 5.0.0-beta.5源码</title>
      <link href="//post/2022-06-22.history.html"/>
      <url>//post/2022-06-22.history.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Documentation for version 5 can be found in the docs directory. This is the current stable release. Version 5 is used in React Router version 6.<br><em>history 5 对应 React Router 6</em></p><p>Documentation for version 4 can be found on the v4 branch. Version 4 is used in React Router versions 4 and 5.<br><em>history 4 对应 React Router 4 和 5</em></p><p>The history library provides history tracking and navigation primitives for JavaScript applications that run in browsers and other stateful environments.<br><em>历史库为在浏览器和其他有状态环境中运行的 JavaScript 应用程序提供历史跟踪和导航。</em><br>If you haven’t yet, please take a second to read through the Installation guide to get the library installed and running on your system.<br><em>如果尚未安装，请花几秒钟阅读安装指南，以便在系统上安装并运行库。</em></p><p>We provide 3 different methods for working with history, depending on your environment:<br><em>根据您的环境，我们提供了 3 种不同的历史处理方法：</em></p><ul><li><p>A “browser history” is for use in modern web browsers that support the HTML5 history API (see cross-browser compatibility)<br><em>“浏览器历史记录”用于支持 HTML5 历史记录 API 的现代 web 浏览器（请参阅跨浏览器兼容性）</em></p></li><li><p>A “hash history” is for use in web browsers where you want to store the location in the hash portion of the current URL to avoid sending it to the server when the page reloads<br><em>“哈希历史记录”用于 web 浏览器中，您希望将位置存储在当前 URL 的哈希部分中，以避免在页面重新加载时将其发送到服务器</em></p></li><li><p>A “memory history” is used as a reference implementation that may be used in non-browser environments, like React Native or tests<br><em>“内存历史记录”用作参考实现，可在非浏览器环境中使用，如 React Native 或 tests</em></p></li></ul><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>常用的是 “browser history” ，使用 “hash history”，会有用户反馈怎么有#号，要你去除，除此之外，有时候需要用到<code>hash</code>滚动到页面具体某个位置，所以为了<code>hash</code>只做定位，通常用 browser history，进行导航</p><p>以 github 为例：</p><p><code>https://github.com/841660202/history/blob/dev/docs/getting-started.md#basic-usage</code></p><p>“memory history” 这个基本上没见到过有用的，<code>react-native</code>使用<code>react-navigation</code>进行导航,<code>react-navigation</code>的<code>package.json</code>种未见到<code>history</code>依赖</p></div><p>The main bundle exports one method for each environment: createBrowserHistory for browsers, createHashHistory for using hash history in browsers, and createMemoryHistory for creating an in-memory history.</p><p><em>主捆绑包为每个环境导出一个方法：createBrowserHistory 用于浏览器，CreateBhashHistory 用于在浏览器中使用哈希历史，createMemoryHistory 用于创建内存中的历史。</em></p><p>In addition to the main bundle, the library also includes history&#x2F;browser and history&#x2F;hash bundles that export singletons you can use to quickly get a history instance for the current document (web page).<br><em>除了主捆绑包之外，该库还包括 history&#x2F;browser 和 history&#x2F;hash 包，这些捆绑包导出可以用于快速获取当前文档（网页）的历史实例的单例。</em></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><a href="https://github.com/841660202/history/blob/dev/docs/getting-started.md#basic-usage" target="_blank" >见</a></p><h2 id="api-参考"><a href="#api-参考" class="headerlink" title="api 参考"></a>api 参考</h2><p><a href="https://github.com/841660202/history/blob/dev/docs/api-reference.md" target="_blank" >见</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><code>package.json</code>种 workspaces 格式错误，无法 <code>yarn</code></li></ol><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; 改前&quot;workspaces&quot;: &#123;    &quot;packages&quot;: [      &quot;packages&#x2F;history&quot;    ]  &#125;&#x2F;&#x2F; 改后&quot;workspaces&quot;: [  &quot;packages&#x2F;*&quot;]</code></pre><ol start="2"><li>在<code>yarn test</code>前，需要<code>yarn build</code>,执行打包输出，因为 test 会引用 build 的产物</li></ol><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;node .&#x2F;scripts&#x2F;build.js&quot;,    &quot;size&quot;: &quot;filesize&quot;,    &quot;clean&quot;: &quot;git clean -fdX .&quot;,    &quot;lint&quot;: &quot;eslint .&quot;,    &quot;prepublishOnly&quot;: &quot;yarn build&quot;,    &quot;test&quot;: &quot;node .&#x2F;scripts&#x2F;test.js&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@ampproject&#x2F;filesize&quot;: &quot;^2.1.1&quot;,    &quot;@ampproject&#x2F;rollup-plugin-closure-compiler&quot;: &quot;0.21.0&quot;,    &quot;@babel&#x2F;core&quot;: &quot;^7.1.2&quot;,    &quot;@babel&#x2F;plugin-transform-runtime&quot;: &quot;^7.7.6&quot;,    &quot;@babel&#x2F;preset-env&quot;: &quot;^7.1.0&quot;,    &quot;@babel&#x2F;preset-modules&quot;: &quot;^0.1.1&quot;,    &quot;@rollup&#x2F;plugin-replace&quot;: &quot;^2.2.1&quot;,    &quot;babel-core&quot;: &quot;^7.0.0-bridge.0&quot;,    &quot;babel-eslint&quot;: &quot;^7.0.0&quot;,    &quot;babel-loader&quot;: &quot;^8.0.4&quot;,    &quot;babel-plugin-dev-expression&quot;: &quot;^0.2.1&quot;,    &quot;eslint&quot;: &quot;^3.3.0&quot;,    &quot;eslint-plugin-import&quot;: &quot;^2.0.0&quot;,    &quot;expect&quot;: &quot;^21.0.0&quot;,    &quot;express&quot;: &quot;^4.17.1&quot;,    &quot;jest-mock&quot;: &quot;^21.0.0&quot;,    &quot;karma&quot;: &quot;^3.1.3&quot;,    &quot;karma-browserstack-launcher&quot;: &quot;^1.3.0&quot;,    &quot;karma-chrome-launcher&quot;: &quot;^2.2.0&quot;,    &quot;karma-firefox-launcher&quot;: &quot;^1.1.0&quot;,    &quot;karma-mocha&quot;: &quot;^1.3.0&quot;,    &quot;karma-mocha-reporter&quot;: &quot;^2.2.5&quot;,    &quot;karma-sourcemap-loader&quot;: &quot;^0.3.7&quot;,    &quot;karma-webpack&quot;: &quot;^3.0.5&quot;,    &quot;mocha&quot;: &quot;^5.2.0&quot;,    &quot;rollup&quot;: &quot;^1.27.9&quot;,    &quot;rollup-plugin-babel&quot;: &quot;^4.0.3&quot;,    &quot;rollup-plugin-copy&quot;: &quot;^3.1.0&quot;,    &quot;rollup-plugin-prettier&quot;: &quot;^0.6.0&quot;,    &quot;rollup-plugin-terser&quot;: &quot;^5.1.2&quot;,    &quot;webpack&quot;: &quot;^3.12.0&quot;  &#125;,  &quot;filesize&quot;: &#123;    &quot;build&#x2F;history&#x2F;history.production.min.js&quot;: &#123;      &quot;none&quot;: &quot;5 kB&quot;    &#125;,    &quot;build&#x2F;history&#x2F;umd&#x2F;history.production.min.js&quot;: &#123;      &quot;none&quot;: &quot;6 kB&quot;    &#125;  &#125;,  &quot;workspaces&quot;: [&quot;packages&#x2F;*&quot;]&#125;</code></pre><p>查看文件我们可以了解到,该项目依赖种没有<code>history</code>包，由于是<code>yarn</code> workspaces 项目，test 下引入<code>history</code>的都是产物</p><ol start="3"><li>测试 <code>yarn test</code>, 浏览器会运行开启，页面历史栈 进栈 出栈 操作，最终浏览器历史会完全出栈。大概是使用了<code>karma-chrome-launcher</code></li></ol><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>使用 rollup</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import babel from &quot;rollup-plugin-babel&quot;;import compiler from &quot;@ampproject&#x2F;rollup-plugin-closure-compiler&quot;;import copy from &quot;rollup-plugin-copy&quot;; &#x2F;&#x2F; 有些不需要改变的直接拷贝import prettier from &quot;rollup-plugin-prettier&quot;;import replace from &quot;@rollup&#x2F;plugin-replace&quot;;import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;; &#x2F;&#x2F; deadcodeconst PRETTY &#x3D; !!process.env.PRETTY;console.log(&quot;PRETTY&quot;, PRETTY); &#x2F;&#x2F; falseconst SOURCE_DIR &#x3D; &quot;packages&#x2F;history&quot;;const OUTPUT_DIR &#x3D; &quot;build&#x2F;history&quot;;&#x2F;&#x2F; 模块化，应该是按需的东西，产出esm格式, 产出 browser、hashconst modules &#x3D; [  &#123;    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,    output: &#123;      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;history.js&#96;,      format: &quot;esm&quot;,      sourcemap: !PRETTY,    &#125;,    external: [&quot;@babel&#x2F;runtime&#x2F;helpers&#x2F;esm&#x2F;extends&quot;],    plugins: [      babel(&#123;        exclude: &#x2F;node_modules&#x2F;,        presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],        plugins: [          &quot;babel-plugin-dev-expression&quot;,          [&quot;@babel&#x2F;plugin-transform-runtime&quot;, &#123; useESModules: true &#125;],        ],        runtimeHelpers: true,      &#125;),      compiler(),      copy(&#123;        targets: [          &#123; src: &quot;README.md&quot;, dest: OUTPUT_DIR &#125;,          &#123; src: &quot;LICENSE&quot;, dest: OUTPUT_DIR &#125;,          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;package.json&#96;, dest: OUTPUT_DIR &#125;,          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.d.ts&#96;, dest: OUTPUT_DIR &#125;,          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;browser.d.ts&#96;, dest: OUTPUT_DIR &#125;,          &#123; src: &#96;$&#123;SOURCE_DIR&#125;&#x2F;hash.d.ts&#96;, dest: OUTPUT_DIR &#125;,        ],        verbose: true,      &#125;),    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),  &#125;,  ...[&quot;browser&quot;, &quot;hash&quot;].map((env) &#x3D;&gt; &#123;    return &#123;      input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;$&#123;env&#125;.js&#96;,      output: &#123;        file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;$&#123;env&#125;.js&#96;,        format: &quot;esm&quot;,        sourcemap: !PRETTY,      &#125;,      plugins: [        babel(&#123;          exclude: &#x2F;node_modules&#x2F;,          presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],          plugins: [&quot;babel-plugin-dev-expression&quot;],        &#125;),        compiler(),      ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),    &#125;;  &#125;),];&#x2F;&#x2F; web浏览器esm结构，只处理historyconst webModules &#x3D; [  &#123;    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,    output: &#123;      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;history.development.js&#96;,      format: &quot;esm&quot;,      sourcemap: !PRETTY,    &#125;,    plugins: [      babel(&#123;        exclude: &#x2F;node_modules&#x2F;,        presets: [&quot;@babel&#x2F;preset-modules&quot;],        plugins: [&quot;babel-plugin-dev-expression&quot;],      &#125;),      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;),      compiler(),    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),  &#125;,  &#123;    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,    output: &#123;      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;history.production.min.js&#96;,      format: &quot;esm&quot;,      sourcemap: !PRETTY,    &#125;,    plugins: [      babel(&#123;        exclude: &#x2F;node_modules&#x2F;,        presets: [&quot;@babel&#x2F;preset-modules&quot;],        plugins: [&quot;babel-plugin-dev-expression&quot;],      &#125;),      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;),      compiler(),      terser(&#123; ecma: 8, safari10: true &#125;),    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),  &#125;,];&#x2F;&#x2F; 浏览器、服务端 umd格式const globals &#x3D; [  &#123;    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,    output: &#123;      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;umd&#x2F;history.development.js&#96;,      format: &quot;umd&quot;,      sourcemap: !PRETTY,      name: &quot;HistoryLibrary&quot;,    &#125;,    plugins: [      babel(&#123;        exclude: &#x2F;node_modules&#x2F;,        presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],        plugins: [&quot;babel-plugin-dev-expression&quot;],      &#125;),      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;),      compiler(),    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),  &#125;,  &#123;    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;history.js&#96;,    output: &#123;      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;umd&#x2F;history.production.min.js&#96;,      format: &quot;umd&quot;,      sourcemap: !PRETTY,      name: &quot;HistoryLibrary&quot;,    &#125;,    plugins: [      babel(&#123;        exclude: &#x2F;node_modules&#x2F;,        presets: [[&quot;@babel&#x2F;preset-env&quot;, &#123; loose: true &#125;]],        plugins: [&quot;babel-plugin-dev-expression&quot;],      &#125;),      replace(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;),      compiler(),      terser(),    ].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),  &#125;,];&#x2F;&#x2F; 服务端common.jsconst node &#x3D; [  &#123;    input: &#96;$&#123;SOURCE_DIR&#125;&#x2F;node-main.js&#96;,    output: &#123;      file: &#96;$&#123;OUTPUT_DIR&#125;&#x2F;main.js&#96;,      format: &quot;cjs&quot;,    &#125;,    plugins: [compiler()].concat(PRETTY ? prettier(&#123; parser: &quot;babel&quot; &#125;) : []),  &#125;,];export default [...modules, ...webModules, ...globals, ...node];</code></pre><h2 id="history-js"><a href="#history-js" class="headerlink" title="history.js"></a>history.js</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; history&#x2F;packages&#x2F;history&#x2F;history.js&#x2F;&#x2F; 取中间值function clamp(n, lowerBound, upperBound) &#123;  return Math.min(Math.max(n, lowerBound), upperBound);&#125;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; UTILS&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 卸载前提示function promptBeforeUnload(event) &#123;  &#x2F;&#x2F; Cancel the event.  event.preventDefault();  &#x2F;&#x2F; Chrome (and legacy IE) requires returnValue to be set.  event.returnValue &#x3D; &quot;&quot;;&#125;&#x2F;&#x2F; 创建事件function createEvents() &#123;  let handlers &#x3D; [];  return &#123;    get length() &#123;      return handlers.length;    &#125;,    push(fn) &#123;      handlers.push(fn);      return function () &#123;        handlers &#x3D; handlers.filter((handler) &#x3D;&gt; handler !&#x3D;&#x3D; fn);      &#125;;    &#125;,    call(arg) &#123;      handlers.forEach((fn) &#x3D;&gt; fn &amp;&amp; fn(arg));    &#125;,  &#125;;&#125;&#x2F;&#x2F; 创建唯一keyfunction createKey() &#123;  return Math.random().toString(36).substr(2, 8);&#125;&#x2F;&#x2F; 生成pathexport function createPath(&#123; pathname &#x3D; &quot;&#x2F;&quot;, search &#x3D; &quot;&quot;, hash &#x3D; &quot;&quot; &#125;) &#123;  return pathname + search + hash;&#125;&#x2F;&#x2F; 解析pathexport function parsePath(path) &#123;  &#x2F;&#x2F; &#39;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;?aldtype&#x3D;16047#ast&#x2F;zh&#x2F;promptBeforeUnload&#39;  let pieces &#x3D; &#123;&#125;;  if (path) &#123;    let hashIndex &#x3D; path.indexOf(&quot;#&quot;);    if (hashIndex &gt;&#x3D; 0) &#123;      pieces.hash &#x3D; path.substr(hashIndex); &#x2F;&#x2F; #ast&#x2F;zh&#x2F;promptBeforeUnload      path &#x3D; path.substr(0, hashIndex); &#x2F;&#x2F; https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;?aldtype&#x3D;16047    &#125;    let searchIndex &#x3D; path.indexOf(&quot;?&quot;);    if (searchIndex &gt;&#x3D; 0) &#123;      pieces.search &#x3D; path.substr(searchIndex); &#x2F;&#x2F; ?aldtype&#x3D;16047      path &#x3D; path.substr(0, searchIndex); &#x2F;&#x2F; https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;    &#125;    if (path) &#123;      pieces.pathname &#x3D; path;    &#125;  &#125;  return pieces;&#125;</code></pre><h2 id="createBrowserHistory"><a href="#createBrowserHistory" class="headerlink" title="createBrowserHistory"></a>createBrowserHistory</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 对象只读const readOnly &#x3D; __DEV__ ? (obj) &#x3D;&gt; Object.freeze(obj) : (obj) &#x3D;&gt; obj;&#x2F;** * Browser history stores the location in regular URLs. This is the * standard for most web apps, but it requires some configuration on * the server to ensure you serve the same app at multiple URLs. * 浏览器历史记录将位置存储在常规URL中。这是 * 大多数web应用程序的标准配置，但它需要在 * 确保您在多个URL上为同一应用程序提供服务的服务器。 *&#x2F;export function createBrowserHistory(&#123; window &#x3D; document.defaultView &#125; &#x3D; &#123;&#125;) &#123;  let globalHistory &#x3D; window.history;  &#x2F;&#x2F; 获取第几个，和 location 信息  function getIndexAndLocation() &#123;    let &#123; pathname, search, hash &#125; &#x3D; window.location;    let state &#x3D; globalHistory.state || &#123;&#125;;    return [      state.idx,      readOnly(&#123;        &#x2F;&#x2F; 对象只读        pathname,        search,        hash,        state: state.usr || null,        key: state.key || &quot;default&quot;,      &#125;),    ];  &#125;  let blockedPopTx &#x3D; null;  function handlePop() &#123;    &#x2F;&#x2F; 出栈    if (blockedPopTx) &#123;      blockers.call(blockedPopTx);      blockedPopTx &#x3D; null;    &#125; else &#123;      let nextAction &#x3D; PopAction;      let [nextIndex, nextLocation] &#x3D; getIndexAndLocation();      if (blockers.length) &#123;        if (nextIndex !&#x3D; null) &#123;          let n &#x3D; index - nextIndex;          if (n) &#123;            &#x2F;&#x2F; Revert the POP 还原POP            blockedPopTx &#x3D; &#123;              action: nextAction,              location: nextLocation,              retry() &#123;                go(n * -1);              &#125;,            &#125;;            go(n);          &#125;        &#125; else &#123;          &#x2F;&#x2F; Trying to POP to a location with no index. We did not create          &#x2F;&#x2F; this location, so we can&#39;t effectively block the navigation.          &#x2F;&#x2F; 正在尝试弹出到没有索引的位置。我们没有创建此位置，因此无法有效阻止导航。          warning(            false,            &#x2F;&#x2F; TODO: Write up a doc that explains our blocking strategy in            &#x2F;&#x2F; detail and link to it here so people can understand better            &#x2F;&#x2F; what is going on and how to avoid it.            &#96;You are trying to block a POP navigation to a location that was not &#96; +              &#96;created by the history library. The block will fail silently in &#96; +              &#96;production, but in general you should do all navigation with the &#96; +              &#96;history library (instead of using window.history.pushState directly) &#96; +              &#96;to avoid this situation.&#96;          );        &#125;      &#125; else &#123;        applyTx(nextAction);      &#125;    &#125;  &#125;  window.addEventListener(PopStateEventType &#x2F;* popstate *&#x2F;, handlePop);  let action &#x3D; PopAction;  let [index, location] &#x3D; getIndexAndLocation();  let blockers &#x3D; createEvents();  let listeners &#x3D; createEvents();  if (index &#x3D;&#x3D; null) &#123;    index &#x3D; 0;    globalHistory.replaceState(&#123; ...globalHistory.state, idx: index &#125;, null);  &#125;  function createHref(to) &#123;    return typeof to &#x3D;&#x3D;&#x3D; &quot;string&quot; ? to : createPath(to);  &#125;  function getNextLocation(to, state &#x3D; null) &#123;    return readOnly(&#123;      ...location,      ...(typeof to &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(to) : to),      state,      key: createKey(),    &#125;);  &#125;  &#x2F;&#x2F; 获取history state 和 url  function getHistoryStateAndUrl(nextLocation, index) &#123;    return [      &#123;        usr: nextLocation.state,        key: nextLocation.key,        idx: index,      &#125;,      createHref(nextLocation),    ];  &#125;  &#x2F;&#x2F; 执行观察者  function allowTx(action, location, retry) &#123;    return (      !blockers.length || (blockers.call(&#123; action, location, retry &#125;), false)    );  &#125;  &#x2F;&#x2F; 执行观察者  function applyTx(nextAction) &#123;    action &#x3D; nextAction;    [index, location] &#x3D; getIndexAndLocation();    listeners.call(&#123; action, location &#125;);  &#125;  &#x2F;&#x2F; 进栈  function push(to, state) &#123;    let nextAction &#x3D; PushAction;    let nextLocation &#x3D; getNextLocation(to, state);    function retry() &#123;      push(to, state);    &#125;    if (allowTx(nextAction, nextLocation, retry)) &#123;      let [historyState, url] &#x3D; getHistoryStateAndUrl(nextLocation, index + 1);      &#x2F;&#x2F; TODO: Support forced reloading      &#x2F;&#x2F; try...catch because iOS limits us to 100 pushState calls :&#x2F;      try &#123;        globalHistory.pushState(historyState, null, url);      &#125; catch (error) &#123;        &#x2F;&#x2F; They are going to lose state here, but there is no real        &#x2F;&#x2F; way to warn them about it since the page will refresh...        window.location.assign(url);      &#125;      applyTx(nextAction);    &#125;  &#125;  &#x2F;&#x2F; 替换  function replace(to, state) &#123;    let nextAction &#x3D; ReplaceAction;    let nextLocation &#x3D; getNextLocation(to, state);    function retry() &#123;      replace(to, state);    &#125;    if (allowTx(nextAction, nextLocation, retry)) &#123;      let [historyState, url] &#x3D; getHistoryStateAndUrl(nextLocation, index);      &#x2F;&#x2F; TODO: Support forced reloading      globalHistory.replaceState(historyState, null, url);      applyTx(nextAction);    &#125;  &#125;  function go(n) &#123;    globalHistory.go(n);  &#125;  let history &#x3D; &#123;    get action() &#123;      return action;    &#125;,    get location() &#123;      return location;    &#125;,    createHref,    push,    replace,    go,    back() &#123;      go(-1);    &#125;,    forward() &#123;      go(1);    &#125;,    listen(fn) &#123;      &#x2F;&#x2F; react-router使用listen监听变化，并进行匹配渲染      return listeners.push(fn);    &#125;,    block(fn) &#123;      let unblock &#x3D; blockers.push(fn);      if (blockers.length &#x3D;&#x3D;&#x3D; 1) &#123;        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);      &#125;      return function () &#123;        unblock();        &#x2F;&#x2F;页面undload之前清空监听，避免内存泄漏        &#x2F;&#x2F; Remove the beforeunload listener so the document may        &#x2F;&#x2F; still be salvageable in the pagehide event.        &#x2F;&#x2F; See https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;#unloading-documents        if (!blockers.length) &#123;          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);        &#125;      &#125;;    &#125;,  &#125;;  &#x2F;&#x2F; 最终返回一个history对象，有一系列方法  return history;&#125;</code></pre><h2 id="createHashHistory"><a href="#createHashHistory" class="headerlink" title="createHashHistory"></a>createHashHistory</h2><p>先不看了…</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/remix-run/history" target="_blank" >remix-run&#x2F;history</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 源码 </tag>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云COS,docx无法在浏览器预览</title>
      <link href="//post/2022-06-22cos.html"/>
      <url>//post/2022-06-22cos.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>其他部门项目接入我们部门 wfc 审批流，有附件需要预览，附件种类非常多：图片、office(doc、ppt…)、代码文件（css、html、js…）</p><ul><li><p>图片预览：使用第三方插件&#x2F;自己开发</p></li><li><p>pdf: 使用第三方插件&#x2F;iframe 具备浏览器预览 pdf 功能</p></li><li><p>office 预览：<code>office预览地址 + iframe</code></p></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getOfficeUrl(fileUrl: string) &#123;  if(!fileUrl) &#123;    throw new Error(&quot;fileUrl is required&quot;);  &#125;  return &#96;https:&#x2F;&#x2F;view.officeapps.live.com&#x2F;op&#x2F;view.aspx?src&#x3D;$&#123;encodeURIComponent(fileUrl))&#125;&#96;;&#125;getOfficeUrl(&#39;https:&#x2F;&#x2F;hello-1257881288.cos.ap-shanghai.myqcloud.com&#x2F;demo.docx&#39;)&#x2F;&#x2F; 结果&#x2F;&#x2F; https:&#x2F;&#x2F;view.officeapps.live.com&#x2F;op&#x2F;view.aspx?src&#x3D;https%3A%2F%2Fhello-1257881288.cos.ap-shanghai.myqcloud.com%2Fdemo.docx</code></pre><p>注意：一个月内有效（仅买了一个月）</p><iframe src="https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fhello-1257881288.cos.ap-shanghai.myqcloud.com%2Fdemo.docx" height=300 width='100%'></iframe><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>顺便提句: 使用 <code>https://view.officeapps.live.com/op/view.aspx?src=</code>预览失败后返回的是一个新的url错误地址，这并不意味着是iframe加载错误</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;iframe src&#x3D;&quot;https:&#x2F;&#x2F;view.officeapps.live.com&#x2F;op&#x2F;view.aspx?src&#x3D;https%3A%2F%2Fhello-1257881288.cos.ap-shanghai.myqcloud.com%2Fdemo.docx&quot; height&#x3D;300 width&#x3D;&#39;100%&#39;&gt;  加载失败了，提醒我（这个永远不会走到，除非&#96;https:&#x2F;&#x2F;view.officeapps.live.com&#96;挂了）&lt;&#x2F;iframe&gt;</code></pre></p></div><h2 id="遇到坑"><a href="#遇到坑" class="headerlink" title="遇到坑"></a>遇到坑</h2><p><strong>通过 fileKey 获取预览地址</strong></p><p style="color: red">汗～,文件存储同学给的解释</p><p>在通过 fileKey 获取预览地址时候，由于业务方的 pdf 类型 fileKey 有两种情况：</p><ol><li>fileKey<strong>有.pdf 结尾</strong>：获取到的临时预览地址是<strong>可以预览</strong></li><li>fileKey<strong>无.pdf 结尾</strong>：获取到的临时预览地址是<strong>不可以预览</strong>，仅支持下载</li></ol><p><strong>腾讯云文档</strong></p><ol><li><p><a href="https://cloud.tencent.com/document/product/436/13361" target="_blank" >Content-Disposition</a>: attachment; filename*&#x3D;”abc.txt”， 中有 attachment 即下载</p></li><li><p>每个文件详情<strong>自定义 Headers</strong>部分</p></li></ol><img src="http://t-blog-images.aijs.top/img/20220622100858.webp"/><p>文档的意思是：要想浏览器预览：上传文件需满足响应头正确</p><ol><li><p>方式 1: 上传文件带后缀，自动生成响应头</p></li><li><p>方式 1: 上传文件，需要配置文件的 content-type</p></li></ol><p><strong>通过 fileKey 获取预览地址为 office 类型文件</strong></p><p>前面说了，office 预览借助<code>iframe</code>,仅此即可实现，阿里云 OSS，妥妥滴没问题（阿里云我不贴图了，测试文件已被删除）</p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>阿里云上上传文件，测试后，删除，几分钟内，文件还可以访问，第二天再访问不可访问了</p><p>贴下不可访问的地址：（想着能访问，就不贴了，原因是：这是公司的一个模版文件，敏不敏感，我不晓得，我只是用来测试）</p><p><code>https://view.officeapps.live.com/op/view.aspx?src=http%3A%2F%2Ft-blog-images.aijs.top%2FTYZN-XPPZ-04-006%252B%25E4%25BE%259B%25E5%25BA%2594%25E5%2595%2586%25E4%25BA%25A7%25E5%2593%2581%25E8%25B4%25A8%25E9%2587%258F%25E4%25BF%259D%25E8%25AF%2581%25E5%258D%258F%25E8%25AE%25AE_B1.docx</code></p><p>如果是非常敏感的数据，不建议拿来测试，<strong>因为即使你删除文件，短时间内该文件地址还是可以访问的</strong></p></div><p>对于腾讯 COS，我特地花了 0.85RMB 买了一个月</p><img src="http://t-blog-images.aijs.top/img/20220622094259.webp"/><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; https:&#x2F;&#x2F;hello-1257881288.cos.ap-shanghai.myqcloud.com&#x2F;demo.docx</code></pre><img src="http://t-blog-images.aijs.top/img/20220622094131.webp" /><p>可到了腾讯云可就不一样了，昨天腾讯云，慢的要死，官网打开速度竟然比简书一篇文章还慢</p><p>第二天询问公司附件存储方我们 wfc 项目 office 预览怎么又可以了，之前 6（预发环境）6 个文件 1 个可以预览，（线上环境）6 个都不能预览</p><p>回答：</p><img src="http://t-blog-images.aijs.top/img/20220622093847.webp" width=300/><p>汗～， 我说昨天访问怎么那么慢</p><p>复测昨天买的 COS，docx 文件预览,今天确实又可以了</p><img src="http://t-blog-images.aijs.top/img/20220622094517.webp"/><p>昨天确实不行，我测了几百遍</p><img src="http://t-blog-images.aijs.top/img/20220622094640.webp"/><p>期间怀疑过响应头,<code>网上各种乱七八糟的内容还需要自己辨别</code></p><img src="http://t-blog-images.aijs.top/img/20220622094640.webp"/><h2 id="续-数据万象解绑"><a href="#续-数据万象解绑" class="headerlink" title="续 数据万象解绑"></a>续 数据万象解绑</h2><p>我测试一下，继续扣费，关掉</p><img src="http://t-blog-images.aijs.top/img/20220701115515.webp" width=300 /><img src="http://t-blog-images.aijs.top/img/20220701115411.webp" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有时后真的不是你的方式错误，第三方出的问题，奇葩的一笔，（预发环境）6 个文件 1 个可以预览，（线上环境）6 个都不能预览,备注：<strong>相同的数据</strong>.</p><p>这个问题搞了大半天，下午收到内部系统反馈工单，到晚上近 8 点，问题一直存在。 由于盲目相信腾讯，一直以为是内部系统文件或是项目代码书写问题，排查了那么久测试了那么长时间（每次都要发到预发测试，因为日常公司存储服务不支持 office 预览，两周前已反馈了没给解决）。这么严重的问题，腾讯内部竟然也那么久才解决吗？<br><img src="https://img2.baidu.com/it/u=164072396,1121091430&fm=253&fmt=auto&app=138&f=JPEG?w=440&h=492" width=100/><br>没有黑任何平台的意思，我被腾讯 COS 害苦了～</p>]]></content>
      
      
      <categories>
          
          <category> 对象存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router v6.4.0 源码</title>
      <link href="//post/2022-06-21react-router-code.html"/>
      <url>//post/2022-06-21react-router-code.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>整了半天上一篇看的竟然是概念，我还以为是原理呢</p><p>最近看到了，面试题 react-router 原理，查了下答案，内容不是很多</p><p><a href="https://blog.csdn.net/weixin_39907713/article/details/111237885" target="_blank" >React Router 原理</a><br><a href="https://blog.csdn.net/qingfeng2020/article/details/121136648" target="_blank" >浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理</a></p><p><a href="https://blog.csdn.net/Android_boom/article/details/125200222" target="_blank" >React Router 源码解析</a></p><p>之前没看过实现原理，现在看到也没那么难 <code>从小被吓大的</code>， 带着好奇心看下仓库代码：<code>4+1（index.ts）个文件</code>没看错</p><img src="http://t-blog-images.aijs.top/img/20220621091016.webp" width=300 /><h2 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 暴露出的apiexport &#123;  MemoryRouter,  Navigate,  NavigationType,  Outlet,  Route,  Router,  Routes,  createPath,  createRoutesFromChildren,  generatePath,  matchPath,  matchRoutes,  parsePath,  renderMatches,  resolvePath,  useHref,  useInRouterContext,  useLocation,  useMatch,  useNavigate,  useNavigationType,  useOutlet,  useOutletContext,  useParams,  useResolvedPath,  useRoutes,&#125;;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; DANGER! PLEASE READ ME! 危险！请读这个！&#x2F;&#x2F; We provide these exports as an escape hatch in the event that you need any&#x2F;&#x2F; routing data that we don&#39;t provide an explicit API for. With that said, we&#x2F;&#x2F; want to cover your use case if we can, so if you feel the need to use these&#x2F;&#x2F; we want to hear from you. Let us know what you&#39;re building and we&#39;ll do our&#x2F;&#x2F; best to make sure we can support you!&#x2F;&#x2F; 我们提供这些导出作为一个逃逸引用，以防你需要我们没有提供明确 API 的任何路由数据。也就是说，&#x2F;&#x2F; 如果你需要这些，我们希望能够为你提供支持，所以如果你有需要，请告诉我们你的需求，我们会尽可能地为你提供支持。&#x2F;&#x2F; We consider these exports an implementation detail and do not guarantee&#x2F;&#x2F; against any breaking changes, regardless of the semver release. Use with&#x2F;&#x2F; extreme caution and only if you understand the consequences. Godspeed.&#x2F;&#x2F; 我们考虑这些导出是一个实现细节，并且不保证对任何变更不会有任何影响，无论是在 semver 版本发布前或者后。&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</code></pre><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>源码中使用了一个 <a href="https://github.com/remix-run/history" target="_blank" >history 库</a></p><p>The history library lets you easily manage session history anywhere JavaScript runs. A history object abstracts away the differences in various environments and provides a minimal API that lets you manage the history stack, navigate, and persist state between sessions.<br><em>这个库让你在任何 JavaScript 运行的地方都能方便地管理会话历史记录。一个历史对象抽象了不同环境的差异，并提供了一个最小的 API，让你管理历史堆栈，导航，并在会话间保持状态。</em></p><h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>对<code>react-router</code>进行了扩展，</p></blockquote><p><code>react-router-dom</code>,在<code>react-router</code>的核心基础上，添加了用于跳转的<code>Link</code>组件，和<code>histoy</code>模式下的<code>BrowserRouter</code>和 hash 模式下的<code>HashRouter</code>组件等。所谓 B<code>rowserRouter</code>和<code>HashRouter</code>，也只不过用了<code>history</code>库中<code>createBrowserHistory</code>和<code>createHashHistory</code>方法</p><h2 id="找个-demo-从头看"><a href="#找个-demo-从头看" class="headerlink" title="找个 demo 从头看"></a>找个 demo 从头看</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;import &quot;.&#x2F;index.css&quot;;import App from &quot;.&#x2F;App&quot;;ReactDOM.render(  &lt;React.StrictMode&gt;    &lt;BrowserRouter&gt; &#x2F;&#x2F; react-router-dom      &lt;App &#x2F;&gt;    &lt;&#x2F;BrowserRouter&gt;  &lt;&#x2F;React.StrictMode&gt;,  document.getElementById(&quot;root&quot;)</code></pre><h2 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">export function BrowserRouter(&#123;  basename,  children,  window,&#125;: BrowserRouterProps) &#123;  let historyRef &#x3D; React.useRef&lt;BrowserHistory&gt;();  if (historyRef.current &#x3D;&#x3D; null) &#123;    historyRef.current &#x3D; createBrowserHistory(&#123; window &#125;);  &#125;  let history &#x3D; historyRef.current;  let [state, setState] &#x3D; React.useState(&#123;    action: history.action,    location: history.location,  &#125;);  &#x2F;&#x2F; 监听url变化， 改变state，更新Router的location，location更新后会触发Router内部重新渲染  React.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);  return (    &lt;Router &#x2F;&#x2F; react-router &quot;.&#x2F;lib&#x2F;components&quot;      basename&#x3D;&#123;basename&#125;      children&#x3D;&#123;children&#125;      location&#x3D;&#123;state.location&#125;      navigationType&#x3D;&#123;state.action&#125;      navigator&#x3D;&#123;history&#125;    &#x2F;&gt;  );&#125;</code></pre><p><strong>react-router “.&#x2F;lib&#x2F;components”</strong></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Provides location context for the rest of the app. * 为应用程序的其余部分提供位置上下文。 * Note: You usually won&#39;t render a &lt;Router&gt; directly. Instead, you&#39;ll render a * router that is more specific to your environment such as a &lt;BrowserRouter&gt; * in web browsers or a &lt;StaticRouter&gt; for server rendering. * 注意：通常不会直接渲染&lt;Router&gt;。相反，您将渲染 * 更特定于您的环境的路由器，如&lt;BrowserRouter&gt; * 在web浏览器中或用于服务器渲染的&lt;StaticRouter&gt;。 * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;routers&#x2F;router *&#x2F;export function Router(&#123;  basename: basenameProp &#x3D; &quot;&#x2F;&quot;,  children &#x3D; null,  location: locationProp, &#x2F;&#x2F; Location  navigationType &#x3D; NavigationType.Pop,  navigator,  static: staticProp &#x3D; false,&#125;: RouterProps): React.ReactElement | null &#123;  invariant(    !useInRouterContext(),    &#96;You cannot render a &lt;Router&gt; inside another &lt;Router&gt;.&#96; +      &#96; You should never have more than one in your app.&#96;  );  let basename &#x3D; normalizePathname(basenameProp);  let navigationContext &#x3D; React.useMemo(    () &#x3D;&gt; (&#123; basename, navigator, static: staticProp &#125;),    [basename, navigator, staticProp]  );  if (typeof locationProp &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    locationProp &#x3D; parsePath(locationProp);  &#125;  let &#123;    pathname &#x3D; &quot;&#x2F;&quot;,    search &#x3D; &quot;&quot;,    hash &#x3D; &quot;&quot;,    state &#x3D; null,    key &#x3D; &quot;default&quot;,  &#125; &#x3D; locationProp;  let location &#x3D; React.useMemo(() &#x3D;&gt; &#123;    let trailingPathname &#x3D; stripBasename(pathname, basename);    if (trailingPathname &#x3D;&#x3D; null) &#123;      return null;    &#125;    return &#123;      pathname: trailingPathname,      search,      hash,      state,      key,    &#125;;  &#125;, [basename, pathname, search, hash, state, key]);  warning(    location !&#x3D; null,    &#96;&lt;Router basename&#x3D;&quot;$&#123;basename&#125;&quot;&gt; is not able to match the URL &#96; +      &#96;&quot;$&#123;pathname&#125;$&#123;search&#125;$&#123;hash&#125;&quot; because it does not start with the &#96; +      &#96;basename, so the &lt;Router&gt; won&#39;t render anything.&#96;  );  if (location &#x3D;&#x3D; null) &#123;    return null;  &#125;  return (    &lt;NavigationContext.Provider value&#x3D;&#123;navigationContext&#125;&gt;      &#123;&quot; &quot;&#125;      &#x2F;&#x2F; React.createContext使用， 一般情况这里会单独抽取 NavigationContext， 并写成useNavigationContext      &lt;LocationContext.Provider &#x2F;&#x2F; 一般情况这里会单独抽取 LocationContext, 并写成useLocationContext        children&#x3D;&#123;children&#125; &#x2F;&#x2F; 是这种以属性形式写入的，不是在标签中包裹的， 即example&#x2F;basic &lt;App &#x2F;&gt;        value&#x3D;&#123;&#123; location, navigationType &#125;&#125;      &#x2F;&gt;    &lt;&#x2F;NavigationContext.Provider&gt;  );&#125;</code></pre><p><strong>NavigationContext</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * A Navigator is a &quot;location changer&quot;; it&#39;s how you get to different locations. * * Every history instance conforms to the Navigator interface, but the * distinction is useful primarily when it comes to the low-level &lt;Router&gt; API * where both the location and a navigator must be provided separately in order * to avoid &quot;tearing&quot; that may occur in a suspense-enabled app if the action * and&#x2F;or location were to be read directly from the history instance. *&#x2F;export type Navigator &#x3D; Pick&lt;History, &quot;go&quot; | &quot;push&quot; | &quot;replace&quot; | &quot;createHref&quot;&gt;;interface NavigationContextObject &#123;  basename: string;  navigator: Navigator;  static: boolean;&#125;export const NavigationContext &#x3D; React.createContext&lt;NavigationContextObject&gt;(  null!);</code></pre><p><strong>LocationContext</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface LocationContextObject &#123;  location: Location;  navigationType: NavigationType;&#125;export const LocationContext &#x3D; React.createContext&lt;LocationContextObject&gt;(  null!);</code></pre><p><strong>App.tsx</strong></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import * as React from &quot;react&quot;;import &#123; Routes, Route, Outlet, Link &#125; from &quot;react-router-dom&quot;;export default function App() &#123;  return (    &lt;div&gt;      &lt;h1&gt;Basic Example&lt;&#x2F;h1&gt;      &lt;p&gt;        This example demonstrates some of the core features of React Router        including nested &lt;code&gt;&lt;Route&gt;&lt;&#x2F;code&gt;s,&#123;&quot; &quot;&#125;        &lt;code&gt;&lt;Outlet&gt;&lt;&#x2F;code&gt;s, &lt;code&gt;&lt;Link&gt;&lt;&#x2F;code&gt;s, and using a        &quot;*&quot; route (aka &quot;splat route&quot;) to render a &quot;not found&quot; page when someone        visits an unrecognized URL.      &lt;&#x2F;p&gt;      &#123;&#x2F;* Routes nest inside one another. Nested route paths build upon            parent route paths, and nested route elements render inside            parent route elements. See the note about &lt;Outlet&gt; below. *&#x2F;&#125;      &#123;&#x2F;* 管线相互嵌套。嵌套布线路径基于      线路径和嵌套管线元素在内部渲染      父管线元素。请参见下面关于&lt;Outlet&gt;的注释。*&#x2F;&#125;      &lt;Routes&gt;        &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;Layout &#x2F;&gt;&#125;&gt;          &#123;&quot; &quot;&#125;          &#x2F;&#x2F; Route在createRoutesFromChildren中进行处理 element.type &#x3D;&#x3D;&#x3D; Route          &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;          &lt;Route path&#x3D;&quot;about&quot; element&#x3D;&#123;&lt;About &#x2F;&gt;&#125; &#x2F;&gt;          &lt;Route path&#x3D;&quot;dashboard&quot; element&#x3D;&#123;&lt;Dashboard &#x2F;&gt;&#125; &#x2F;&gt;          &#123;&#x2F;* Using path&#x3D;&quot;*&quot;&quot; means &quot;match anything&quot;, so this route                acts like a catch-all for URLs that we don&#39;t have explicit                routes for. *&#x2F;&#125;          &#123;&#x2F;* 啥都没捞着，走匹配*&#x2F;&#125;          &lt;Route path&#x3D;&quot;*&quot; element&#x3D;&#123;&lt;NoMatch &#x2F;&gt;&#125; &#x2F;&gt;        &lt;&#x2F;Route&gt;      &lt;&#x2F;Routes&gt;    &lt;&#x2F;div&gt;  );&#125;function Layout() &#123;  return (    &lt;div&gt;      &#123;&#x2F;* A &quot;layout route&quot; is a good place to put markup you want to          share across all the pages on your site, like navigation. *&#x2F;&#125;      &lt;nav&gt;        &lt;ul&gt;          &lt;li&gt;            &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;          &lt;&#x2F;li&gt;          &lt;li&gt;            &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;About&lt;&#x2F;Link&gt;          &lt;&#x2F;li&gt;          &lt;li&gt;            &lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;Dashboard&lt;&#x2F;Link&gt;          &lt;&#x2F;li&gt;          &lt;li&gt;            &lt;Link to&#x3D;&quot;&#x2F;nothing-here&quot;&gt;Nothing Here&lt;&#x2F;Link&gt;          &lt;&#x2F;li&gt;        &lt;&#x2F;ul&gt;      &lt;&#x2F;nav&gt;      &lt;hr &#x2F;&gt;      &#123;&#x2F;* An &lt;Outlet&gt; renders whatever child route is currently active,          so you can think about this &lt;Outlet&gt; as a placeholder for          the child routes we defined above. *&#x2F;&#125;      &lt;Outlet &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;function Home() &#123;  return (    &lt;div&gt;      &lt;h2&gt;Home&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;  );&#125;function About() &#123;  return (    &lt;div&gt;      &lt;h2&gt;About&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;  );&#125;function Dashboard() &#123;  return (    &lt;div&gt;      &lt;h2&gt;Dashboard&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;  );&#125;function NoMatch() &#123;  return (    &lt;div&gt;      &lt;h2&gt;Nothing to see here!&lt;&#x2F;h2&gt;      &lt;p&gt;        &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Go to the home page&lt;&#x2F;Link&gt;      &lt;&#x2F;p&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p><strong><code>import &#123; Routes, Route, Outlet, Link &#125; from &quot;react-router-dom&quot;;</code></strong></p><h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><p>传入一个路由的数组，返回对应要展示的组件，有点类似于 vue 的路由的配置，可以在别的文件夹配置好路由，然后传入 APP.tsx 中</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * A container for a nested tree of &lt;Route&gt; elements that renders the branch * that best matches the current location. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;routes *&#x2F;export function Routes(&#123;  children,  location,&#125;: RoutesProps): React.ReactElement | null &#123;  return useRoutes(createRoutesFromChildren(children), location);&#125;</code></pre><h3 id="createRoutesFromChildren"><a href="#createRoutesFromChildren" class="headerlink" title="createRoutesFromChildren"></a>createRoutesFromChildren</h3><p>看大概意思，怎么实现不管</p><p>大意是从 Children 中创建路由</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Creates a route config from a React &quot;children&quot; object, which is usually * either a &#96;&lt;Route&gt;&#96; element or an array of them. Used internally by * &#96;&lt;Routes&gt;&#96; to create a route config from its children. * 从React“children”对象创建路由配置，通常 * 一个&#96;&lt;路由&gt;&#96;元素或它们的数组。内部使用人 * &#96;&lt;路由&gt;&#96;从其子级创建路由配置。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;create-routes-from-children *&#x2F;export function createRoutesFromChildren(  children: React.ReactNode): RouteObject[] &#123;  let routes: RouteObject[] &#x3D; [];  React.Children.forEach(children, (element) &#x3D;&gt; &#123;    if (!React.isValidElement(element)) &#123;      &#x2F;&#x2F; Ignore non-elements. This allows people to more easily inline      &#x2F;&#x2F; conditionals in their route config.      return;    &#125;    if (element.type &#x3D;&#x3D;&#x3D; React.Fragment) &#123;      &#x2F;&#x2F; Transparently support React.Fragment and its children.      &#x2F;&#x2F; 递归      routes.push.apply(        routes,        createRoutesFromChildren(element.props.children)      );      return;    &#125;    invariant(      element.type &#x3D;&#x3D;&#x3D; Route,      &#96;[$&#123;        typeof element.type &#x3D;&#x3D;&#x3D; &quot;string&quot; ? element.type : element.type.name      &#125;] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;&#96;    );    let route: RouteObject &#x3D; &#123;      caseSensitive: element.props.caseSensitive,      element: element.props.element,      index: element.props.index,      path: element.props.path,    &#125;;    if (element.props.children) &#123;      &#x2F;&#x2F; 递归      route.children &#x3D; createRoutesFromChildren(element.props.children);    &#125;    routes.push(route);  &#125;);  return routes;&#125;</code></pre><h3 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes"></a>useRoutes</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Returns the element of the route that matched the current location, prepared * with the correct context to render the remainder of the route tree. Route * elements in the tree must render an &lt;Outlet&gt; to render their child route&#39;s * element. * 返回与当前位置匹配的路由元素，已准备就绪 * 使用正确的上下文渲染路由树的其余部分。路线 * 树中的元素必须渲染一个&lt;Outlet&gt;，才能渲染其子路由的 * 元素。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-routes *&#x2F;export function useRoutes(  routes: RouteObject[],  locationArg?: Partial&lt;Location&gt; | string): React.ReactElement | null &#123;  &#x2F;&#x2F; invariant(  &#x2F;&#x2F;   useInRouterContext(),  &#x2F;&#x2F;   &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the  &#x2F;&#x2F;   &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.  &#x2F;&#x2F;   &#96;useRoutes() may be used only in the context of a &lt;Router&gt; component.&#96;  &#x2F;&#x2F; );  let &#123; matches: parentMatches &#125; &#x3D; React.useContext(RouteContext);  let routeMatch &#x3D; parentMatches[parentMatches.length - 1];  let parentParams &#x3D; routeMatch ? routeMatch.params : &#123;&#125;;  let parentPathname &#x3D; routeMatch ? routeMatch.pathname : &quot;&#x2F;&quot;;  let parentPathnameBase &#x3D; routeMatch ? routeMatch.pathnameBase : &quot;&#x2F;&quot;;  let parentRoute &#x3D; routeMatch &amp;&amp; routeMatch.route;  &#x2F;&#x2F; if (__DEV__) &#123;  &#x2F;&#x2F;   &#x2F;&#x2F; You won&#39;t get a warning about 2 different &lt;Routes&gt; under a &lt;Route&gt;  &#x2F;&#x2F;   &#x2F;&#x2F; without a trailing *, but this is a best-effort warning anyway since we  &#x2F;&#x2F;   &#x2F;&#x2F; cannot even give the warning unless they land at the parent route.  &#x2F;&#x2F;   &#x2F;&#x2F;  &#x2F;&#x2F;   &#x2F;&#x2F; Example:  &#x2F;&#x2F;   &#x2F;&#x2F;  &#x2F;&#x2F;   &#x2F;&#x2F; &lt;Routes&gt;  &#x2F;&#x2F;   &#x2F;&#x2F;   &#123;&#x2F;* This route path MUST end with &#x2F;* because otherwise  &#x2F;&#x2F;   &#x2F;&#x2F;       it will never match &#x2F;blog&#x2F;post&#x2F;123 *&#x2F;&#125;  &#x2F;&#x2F;   &#x2F;&#x2F;   &lt;Route path&#x3D;&quot;blog&quot; element&#x3D;&#123;&lt;Blog &#x2F;&gt;&#125; &#x2F;&gt;  &#x2F;&#x2F;   &#x2F;&#x2F;   &lt;Route path&#x3D;&quot;blog&#x2F;feed&quot; element&#x3D;&#123;&lt;BlogFeed &#x2F;&gt;&#125; &#x2F;&gt;  &#x2F;&#x2F;   &#x2F;&#x2F; &lt;&#x2F;Routes&gt;  &#x2F;&#x2F;   &#x2F;&#x2F;  &#x2F;&#x2F;   &#x2F;&#x2F; function Blog() &#123;  &#x2F;&#x2F;   &#x2F;&#x2F;   return (  &#x2F;&#x2F;   &#x2F;&#x2F;     &lt;Routes&gt;  &#x2F;&#x2F;   &#x2F;&#x2F;       &lt;Route path&#x3D;&quot;post&#x2F;:id&quot; element&#x3D;&#123;&lt;Post &#x2F;&gt;&#125; &#x2F;&gt;  &#x2F;&#x2F;   &#x2F;&#x2F;     &lt;&#x2F;Routes&gt;  &#x2F;&#x2F;   &#x2F;&#x2F;   );  &#x2F;&#x2F;   &#x2F;&#x2F; &#125;  &#x2F;&#x2F;   let parentPath &#x3D; (parentRoute &amp;&amp; parentRoute.path) || &quot;&quot;;  &#x2F;&#x2F;   warningOnce(  &#x2F;&#x2F;     parentPathname,  &#x2F;&#x2F;     !parentRoute || parentPath.endsWith(&quot;*&quot;),  &#x2F;&#x2F;     &#96;You rendered descendant &lt;Routes&gt; (or called \&#96;useRoutes()\&#96;) at &#96; +  &#x2F;&#x2F;       &#96;&quot;$&#123;parentPathname&#125;&quot; (under &lt;Route path&#x3D;&quot;$&#123;parentPath&#125;&quot;&gt;) but the &#96; +  &#x2F;&#x2F;       &#96;parent route path has no trailing &quot;*&quot;. This means if you navigate &#96; +  &#x2F;&#x2F;       &#96;deeper, the parent won&#39;t match anymore and therefore the child &#96; +  &#x2F;&#x2F;       &#96;routes will never render.\n\n&#96; +  &#x2F;&#x2F;       &#96;Please change the parent &lt;Route path&#x3D;&quot;$&#123;parentPath&#125;&quot;&gt; to &lt;Route &#96; +  &#x2F;&#x2F;       &#96;path&#x3D;&quot;$&#123;parentPath &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ? &quot;*&quot; : &#96;$&#123;parentPath&#125;&#x2F;*&#96;&#125;&quot;&gt;.&#96;  &#x2F;&#x2F;   );  &#x2F;&#x2F; &#125;  let locationFromContext &#x3D; useLocation();  let location;  if (locationArg) &#123;    let parsedLocationArg &#x3D;      typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;    &#x2F;&#x2F; invariant(    &#x2F;&#x2F;   parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ||    &#x2F;&#x2F;     parsedLocationArg.pathname?.startsWith(parentPathnameBase),    &#x2F;&#x2F;   &#96;When overriding the location using \&#96;&lt;Routes location&gt;\&#96; or \&#96;useRoutes(routes, location)\&#96;, &#96; +    &#x2F;&#x2F;     &#96;the location pathname must begin with the portion of the URL pathname that was &#96; +    &#x2F;&#x2F;     &#96;matched by all parent routes. The current pathname base is &quot;$&#123;parentPathnameBase&#125;&quot; &#96; +    &#x2F;&#x2F;     &#96;but pathname &quot;$&#123;parsedLocationArg.pathname&#125;&quot; was given in the \&#96;location\&#96; prop.&#96;    &#x2F;&#x2F; );    location &#x3D; parsedLocationArg;  &#125; else &#123;    location &#x3D; locationFromContext;  &#125;  let pathname &#x3D; location.pathname || &quot;&#x2F;&quot;;  let remainingPathname &#x3D;    parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;      ? pathname      : pathname.slice(parentPathnameBase.length) || &quot;&#x2F;&quot;;  let matches &#x3D; matchRoutes(routes, &#123; pathname: remainingPathname &#125;);  &#x2F;&#x2F; if (__DEV__) &#123;  &#x2F;&#x2F;   warning(  &#x2F;&#x2F;     parentRoute || matches !&#x3D; null,  &#x2F;&#x2F;     &#96;No routes matched location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; &#96;  &#x2F;&#x2F;   );  &#x2F;&#x2F;   warning(  &#x2F;&#x2F;     matches &#x3D;&#x3D; null ||  &#x2F;&#x2F;       matches[matches.length - 1].route.element !&#x3D;&#x3D; undefined,  &#x2F;&#x2F;     &#96;Matched leaf route at location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; does not have an element. &#96; +  &#x2F;&#x2F;       &#96;This means it will render an &lt;Outlet &#x2F;&gt; with a null value by default resulting in an &quot;empty&quot; page.&#96;  &#x2F;&#x2F;   );  &#x2F;&#x2F; &#125;  return _renderMatches(    matches &amp;&amp;      matches.map((match) &#x3D;&gt;        Object.assign(&#123;&#125;, match, &#123;          params: Object.assign(&#123;&#125;, parentParams, match.params),          pathname: joinPaths([parentPathnameBase, match.pathname]),          pathnameBase:            match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;              ? parentPathnameBase              : joinPaths([parentPathnameBase, match.pathnameBase]),        &#125;)      ),    parentMatches  );&#125;</code></pre><h3 id="matchRoutes"><a href="#matchRoutes" class="headerlink" title="matchRoutes"></a>matchRoutes</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Matches the given routes to a location and returns the match data. * 将给定路由匹配到某个位置并返回匹配数据。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;match-routes *&#x2F;export function matchRoutes(  routes: RouteObject[],  locationArg: Partial&lt;Location&gt; | string,  basename &#x3D; &quot;&#x2F;&quot;): RouteMatch[] | null &#123;  let location &#x3D;    typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;  let pathname &#x3D; stripBasename(location.pathname || &quot;&#x2F;&quot;, basename);  if (pathname &#x3D;&#x3D; null) &#123;    return null;  &#125;  let branches &#x3D; flattenRoutes(routes);  rankRouteBranches(branches);  let matches &#x3D; null;  for (let i &#x3D; 0; matches &#x3D;&#x3D; null &amp;&amp; i &lt; branches.length; ++i) &#123;    matches &#x3D; matchRouteBranch(branches[i], pathname);  &#125;  return matches;&#125;</code></pre><h3 id="renderMatches"><a href="#renderMatches" class="headerlink" title="_renderMatches"></a>_renderMatches</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function _renderMatches(  matches: RouteMatch[] | null,  parentMatches: RouteMatch[] &#x3D; []): React.ReactElement | null &#123;  if (matches &#x3D;&#x3D; null) return null;  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;    return (      &lt;RouteContext.Provider        children&#x3D;&#123;          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet        &#125;        value&#x3D;&#123;&#123;          outlet,          matches: parentMatches.concat(matches.slice(0, index + 1)),        &#125;&#125;      &#x2F;&gt;    );  &#125;, null as React.ReactElement | null);&#125;</code></pre><h3 id="RouteContext"><a href="#RouteContext" class="headerlink" title="RouteContext"></a>RouteContext</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface RouteContextObject &#123;  outlet: React.ReactElement | null;  matches: RouteMatch[];&#125;export const RouteContext &#x3D; React.createContext&lt;RouteContextObject&gt;(&#123;  outlet: null,  matches: [],&#125;);if (__DEV__) &#123;  RouteContext.displayName &#x3D; &quot;Route&quot;;&#125;</code></pre><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">export interface LinkProps  extends Omit&lt;React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt;, &quot;href&quot;&gt; &#123;  &#x2F;&#x2F; 剔除 href 属性，代码中内部使用useHref(to)生成  reloadDocument?: boolean;  replace?: boolean;  state?: any;  to: To;&#125;&#x2F;** * The public API for rendering a history-aware &lt;a&gt;. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;link *&#x2F;export const Link &#x3D; React.forwardRef&lt;HTMLAnchorElement, LinkProps&gt;(  function LinkWithRef(    &#123; onClick, reloadDocument, replace &#x3D; false, state, target, to, ...rest &#125;,    ref  ) &#123;    let href &#x3D; useHref(to);    let internalOnClick &#x3D; useLinkClickHandler(to, &#123; replace, state, target &#125;);    function handleClick(      event: React.MouseEvent&lt;HTMLAnchorElement, MouseEvent&gt;    ) &#123;      if (onClick) onClick(event);      if (!event.defaultPrevented &amp;&amp; !reloadDocument) &#123;        internalOnClick(event);      &#125;    &#125;    return (      &#x2F;&#x2F; eslint-disable-next-line jsx-a11y&#x2F;anchor-has-content      &lt;a        &#123;...rest&#125;        href&#x3D;&#123;href&#125;        onClick&#x3D;&#123;handleClick&#125;        ref&#x3D;&#123;ref&#125;        target&#x3D;&#123;target&#125;      &#x2F;&gt;    );  &#125;);</code></pre><h3 id="useHref"><a href="#useHref" class="headerlink" title="useHref"></a>useHref</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Returns the full href for the given &quot;to&quot; value. This is useful for building * custom links that are also accessible and preserve right-click behavior. * 返回给定“to”值的完整href。这对于构建也可访问并保留右键单击行为的自定义链接非常有用。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-href *&#x2F;export function useHref(to: To): string &#123;  invariant(    useInRouterContext(),    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.    &#96;useHref() may be used only in the context of a &lt;Router&gt; component.&#96;  );  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);  let &#123; hash, pathname, search &#125; &#x3D; useResolvedPath(to);  let joinedPathname &#x3D; pathname;  if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;    let toPathname &#x3D; getToPathname(to);    let endsWithSlash &#x3D; toPathname !&#x3D; null &amp;&amp; toPathname.endsWith(&quot;&#x2F;&quot;);    joinedPathname &#x3D;      pathname &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;        ? basename + (endsWithSlash ? &quot;&#x2F;&quot; : &quot;&quot;)        : joinPaths([basename, pathname]);  &#125;  return navigator.createHref(&#123; pathname: joinedPathname, search, hash &#125;);&#125;</code></pre><h3 id="useLinkClickHandler"><a href="#useLinkClickHandler" class="headerlink" title="useLinkClickHandler"></a>useLinkClickHandler</h3><p><a href="https://blog.csdn.net/m0_52537576/article/details/124901230#:~:text=5-,useLinkClickHandler,-%E8%BF%99%E4%B8%AAhooks%E8%BF%94%E5%9B%9E" target="_blank" >useLinkClickHandler</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Handles the click behavior for router &#96;&lt;Link&gt;&#96; components. This is useful if * you need to create custom &#96;&lt;Link&gt;&#96; components with the same click behavior we * use in our exported &#96;&lt;Link&gt;&#96;. * 处理&#96;&lt;Link&gt;&#96;组件的单击行为。如果 * 您需要创建具有与我们相同的单击行为的自定义&#96;&lt;Link&gt;&#96;组件 * 在导出的&#96;&lt;Link&gt;&#96;中使用。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-link-click-handler *&#x2F;export function useLinkClickHandler&lt;E extends Element &#x3D; HTMLAnchorElement&gt;(  to: To,  &#123;    target,    replace: replaceProp,    state,  &#125;: &#123;    target?: React.HTMLAttributeAnchorTarget;    replace?: boolean;    state?: any;  &#125; &#x3D; &#123;&#125;): (event: React.MouseEvent&lt;E, MouseEvent&gt;) &#x3D;&gt; void &#123;  let navigate &#x3D; useNavigate();  let location &#x3D; useLocation();  let path &#x3D; useResolvedPath(to);  return React.useCallback(    (event: React.MouseEvent&lt;E, MouseEvent&gt;) &#x3D;&gt; &#123;      if (        event.button &#x3D;&#x3D;&#x3D; 0 &amp;&amp; &#x2F;&#x2F; Ignore everything but left clicks        (!target || target &#x3D;&#x3D;&#x3D; &quot;_self&quot;) &amp;&amp; &#x2F;&#x2F; Let browser handle &quot;target&#x3D;_blank&quot; etc.        !isModifiedEvent(event) &#x2F;&#x2F; Ignore clicks with modifier keys      ) &#123;        event.preventDefault();        &#x2F;&#x2F; If the URL hasn&#39;t changed, a regular &lt;a&gt; will do a replace instead of        &#x2F;&#x2F; a push, so do the same here.        &#x2F;&#x2F; url没有改变，做replace操作，而不是push操作        let replace &#x3D;          !!replaceProp || createPath(location) &#x3D;&#x3D;&#x3D; createPath(path);        navigate(to, &#123; replace, state &#125;);      &#125;    &#125;,    [location, navigate, path, replaceProp, state, target, to]  );&#125;</code></pre><h3 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but * may also be used by other elements to change the location. * 返回更改位置的命令式方法。由s使用，但 * 也可由其他元素用于更改位置。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate *&#x2F;export function useNavigate(): NavigateFunction &#123;  invariant(    useInRouterContext(),    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;  );  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();  let routePathnamesJson &#x3D; JSON.stringify(    matches.map((match) &#x3D;&gt; match.pathnameBase)  );  let activeRef &#x3D; React.useRef(false);  React.useEffect(() &#x3D;&gt; &#123;    activeRef.current &#x3D; true;  &#125;);  let navigate: NavigateFunction &#x3D; React.useCallback(    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;      warning(        activeRef.current,        &#96;You should call navigate() in a React.useEffect(), not when &#96; +          &#96;your component is first rendered.&#96;      );      if (!activeRef.current) return;      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;        navigator.go(to);        return;      &#125;      let path &#x3D; resolveTo(        to,        JSON.parse(routePathnamesJson),        locationPathname      );      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;        path.pathname &#x3D; joinPaths([basename, path.pathname]);      &#125;      &#x2F;&#x2F; 这行代码写法，没见过，函数执行      (!!options.replace ? navigator.replace : navigator.push)(        path,        options.state      );    &#125;,    [basename, navigator, routePathnamesJson, locationPathname]  );  return navigate;&#125;</code></pre><h3 id="resolveTo"><a href="#resolveTo" class="headerlink" title="resolveTo"></a>resolveTo</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function resolveTo(  toArg: To,  routePathnames: string[],  locationPathname: string): Path &#123;  let to &#x3D; typeof toArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(toArg) : toArg;  let toPathname &#x3D; toArg &#x3D;&#x3D;&#x3D; &quot;&quot; || to.pathname &#x3D;&#x3D;&#x3D; &quot;&quot; ? &quot;&#x2F;&quot; : to.pathname;  &#x2F;&#x2F; If a pathname is explicitly provided in &#96;to&#96;, it should be relative to the  &#x2F;&#x2F; route context. This is explained in &#96;Note on &#96;&lt;Link to&gt;&#96; values&#96; in our  &#x2F;&#x2F; migration guide from v5 as a means of disambiguation between &#96;to&#96; values  &#x2F;&#x2F; that begin with &#96;&#x2F;&#96; and those that do not. However, this is problematic for  &#x2F;&#x2F; &#96;to&#96; values that do not provide a pathname. &#96;to&#96; can simply be a search or  &#x2F;&#x2F; hash string, in which case we should assume that the navigation is relative  &#x2F;&#x2F; to the current location&#39;s pathname and *not* the route pathname.  &#x2F;&#x2F; 如果在“to”中显式提供了路径名，则它应该相对于路由上下文。这在我们的v5迁移指南中的“关于&#96;&lt;Link&gt;&#96;值&#39;的注释”中有解释，  &#x2F;&#x2F; 作为消除以&#96;&#x2F;&#96;开头的&#96;到&#96;值与不以&#96;&#x2F;&#96;开头的&#96;到&#96;值之间歧义的一种方法。但是，对于不提供路径名的“to”值来说，  &#x2F;&#x2F; 这是有问题的&#96;to &#96;可以是一个搜索或哈希字符串，在这种情况下，我们应该假设导航相对于当前位置的路径名，而不是路径名。  let from: string;  if (toPathname &#x3D;&#x3D; null) &#123;    from &#x3D; locationPathname;  &#125; else &#123;    let routePathnameIndex &#x3D; routePathnames.length - 1;    if (toPathname.startsWith(&quot;..&quot;)) &#123;      let toSegments &#x3D; toPathname.split(&quot;&#x2F;&quot;);      &#x2F;&#x2F; Each leading .. segment means &quot;go up one route&quot; instead of &quot;go up one      &#x2F;&#x2F; URL segment&quot;.  This is a key difference from how &lt;a href&gt; works and a      &#x2F;&#x2F; major reason we call this a &quot;to&quot; value instead of a &quot;href&quot;.      while (toSegments[0] &#x3D;&#x3D;&#x3D; &quot;..&quot;) &#123;        toSegments.shift();        routePathnameIndex -&#x3D; 1;      &#125;      to.pathname &#x3D; toSegments.join(&quot;&#x2F;&quot;);    &#125;    &#x2F;&#x2F; If there are more &quot;..&quot; segments than parent routes, resolve relative to    &#x2F;&#x2F; the root &#x2F; URL.    from &#x3D; routePathnameIndex &gt;&#x3D; 0 ? routePathnames[routePathnameIndex] : &quot;&#x2F;&quot;;  &#125;  let path &#x3D; resolvePath(to, from);  &#x2F;&#x2F; Ensure the pathname has a trailing slash if the original to value had one.  &#x2F;&#x2F; 如果原始to值有斜杠，请确保路径名后面有斜杠。  if (    toPathname &amp;&amp;    toPathname !&#x3D;&#x3D; &quot;&#x2F;&quot; &amp;&amp;    toPathname.endsWith(&quot;&#x2F;&quot;) &amp;&amp;    !path.pathname.endsWith(&quot;&#x2F;&quot;)  ) &#123;    path.pathname +&#x3D; &quot;&#x2F;&quot;;  &#125;  return path;&#125;</code></pre><h3 id="useInRouterContext"><a href="#useInRouterContext" class="headerlink" title="useInRouterContext"></a>useInRouterContext</h3><p>判断是否在某个 React.createContext 的上下文</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function useInRouterContext(): boolean &#123;  return React.useContext(LocationContext) !&#x3D; null;&#125;&#x2F;&#x2F; invariant(&#x2F;&#x2F;   useInRouterContext(),&#x2F;&#x2F;   &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the&#x2F;&#x2F;   &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.&#x2F;&#x2F;   &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;&#x2F;&#x2F; );</code></pre><hr /><p>以上部分，是如何生成路由的源码部分。有个问题，路由生成出来了，如何进行配对渲染？走的太快了，回去看下</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; 这块代码我们上面有看过的&#x2F;&#x2F; BrowserRouterReact.useLayoutEffect(() &#x3D;&gt; history.listen(setState), [history]);&#x2F;&#x2F;  history.listen(setState) 去找下history的api&#x2F;&#x2F; @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;blob&#x2F;dev&#x2F;docs&#x2F;api-reference.md#historylistenlistener-listenerreturn (  &lt;Router &#x2F;&#x2F; react-router &quot;.&#x2F;lib&#x2F;components&quot;    basename&#x3D;&#123;basename&#125;    children&#x3D;&#123;children&#125;    location&#x3D;&#123;state.location&#125;    navigationType&#x3D;&#123;state.action&#125;    navigator&#x3D;&#123;history&#125;  &#x2F;&gt;);&#x2F;&#x2F; 直接在这里堆积下，上文是有的let &#123;  pathname &#x3D; &quot;&#x2F;&quot;,  search &#x3D; &quot;&quot;,  hash &#x3D; &quot;&quot;,  state &#x3D; null,  key &#x3D; &quot;default&quot;,&#125; &#x3D; locationProp;&lt;LocationContext.Provider &#x2F;&#x2F; 一般情况这里会单独抽取 LocationContext, 并写成useLocationContext  children&#x3D;&#123;children&#125; &#x2F;&#x2F; 是这种以属性形式写入的，不是在标签中包裹的， 即example&#x2F;basic &lt;App &#x2F;&gt;  value&#x3D;&#123;&#123; location, navigationType &#125;&#125;&#x2F;&gt;;</code></pre><p>文档内容</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Listener &#123;  (update: Update): void;&#125;interface Update &#123;  action: Action;  location: Location; &#x2F;&#x2F; 由 Location,结合Router&#125;</code></pre><h2 id="Location-类型"><a href="#Location-类型" class="headerlink" title="Location 类型"></a>Location 类型</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * A URL pathname, beginning with a &#x2F;. * * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname *&#x2F;export type Pathname &#x3D; string;&#x2F;** * A URL search string, beginning with a ?. * * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search *&#x2F;export type Search &#x3D; string;&#x2F;** * The pathname, search, and hash values of a URL. *&#x2F;export interface Path &#123;  &#x2F;**   * A URL pathname, beginning with a &#x2F;.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname   *&#x2F;  pathname: Pathname;  &#x2F;**   * A URL search string, beginning with a ?.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search   *&#x2F;  search: Search;  &#x2F;**   * A URL fragment identifier, beginning with a #.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash   *&#x2F;  hash: Hash;&#125;&#x2F;** * An entry in a history stack. A location contains information about the * URL path, as well as possibly some arbitrary state and a key. * * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location *&#x2F;export interface Location extends Path &#123;  &#x2F;**   * A value of arbitrary data associated with this location.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.state   *&#x2F;  state: unknown;  &#x2F;**   * A unique string associated with this location. May be used to safely store   * and retrieve data in some other storage API, like &#96;localStorage&#96;.   *   * Note: This value is always &quot;default&quot; on the initial location.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.key   *&#x2F;  key: Key;&#125;</code></pre><h2 id="history-x2F-index-ts-源码"><a href="#history-x2F-index-ts-源码" class="headerlink" title="history&#x2F;index.ts 源码"></a>history&#x2F;index.ts 源码</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * A function that receives notifications about location changes. *&#x2F;export interface Listener &#123;  (update: Update): void;&#125;</code></pre><p>Starts listening for location changes and calls the given callback with an Update when it does.<br>开始侦听位置更改，并在更改时使用更新调用给定回调。</p><h2 id="阶段性总结"><a href="#阶段性总结" class="headerlink" title="阶段性总结"></a>阶段性总结</h2><p>BrowserRouter + App.tsx（Routes、Route 生成路由组件关系）</p><p>BrowserRouter：内部 history 监听路由变化，将 location 进行结构，并使用 useMemo 进行环境，传递给 LocationContext.Provider 的 value，驱动子组件 children 渲染，<strong>代码 1</strong></p><p>LocationContext.Provider 子组件 &#x3D; 也就是 BrowserRouter 的子组件 &#x3D; App.tsx， 内部，获取 locationFromContext，进行匹配渲染 <strong>代码 2</strong>（见下述堆积代码<code>「上文以贴过源码，再贴一遍」</code>）</p><p>这里要注意下：useRoutes TOC 写法，最终应该是</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Returns the current location object, which represents the current URL in web * browsers. * * Note: If you&#39;re using this it may mean you&#39;re doing some of your own * &quot;routing&quot; in your app, and we&#39;d like to know what your use case is. We may * be able to provide something higher-level to better suit your needs. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-location *&#x2F;export function useLocation(): Location &#123;  invariant(    useInRouterContext(),    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.    &#96;useLocation() may be used only in the context of a &lt;Router&gt; component.&#96;  );  return React.useContext(LocationContext).location;&#125;</code></pre><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; hooks.ts useRoutes中let locationFromContext &#x3D; useLocation(); &#x2F;&#x2F; 这里let location;if (locationArg) &#123;  let parsedLocationArg &#x3D;    typeof locationArg &#x3D;&#x3D;&#x3D; &quot;string&quot; ? parsePath(locationArg) : locationArg;  invariant(    parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot; ||      parsedLocationArg.pathname?.startsWith(parentPathnameBase),    &#96;When overriding the location using \&#96;&lt;Routes location&gt;\&#96; or \&#96;useRoutes(routes, location)\&#96;, &#96; +      &#96;the location pathname must begin with the portion of the URL pathname that was &#96; +      &#96;matched by all parent routes. The current pathname base is &quot;$&#123;parentPathnameBase&#125;&quot; &#96; +      &#96;but pathname &quot;$&#123;parsedLocationArg.pathname&#125;&quot; was given in the \&#96;location\&#96; prop.&#96;  );  location &#x3D; parsedLocationArg;&#125; else &#123;  location &#x3D; locationFromContext; &#x2F;&#x2F; 这里&#125;let pathname &#x3D; location.pathname || &quot;&#x2F;&quot;;let remainingPathname &#x3D;  parentPathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;    ? pathname    : pathname.slice(parentPathnameBase.length) || &quot;&#x2F;&quot;;let matches &#x3D; matchRoutes(routes, &#123; pathname: remainingPathname &#125;);&#x2F;&#x2F; 开发提醒 跳过&#x2F;&#x2F; if (__DEV__) &#123;&#x2F;&#x2F;   warning(&#x2F;&#x2F;     parentRoute || matches !&#x3D; null,&#x2F;&#x2F;     &#96;No routes matched location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; &#96;&#x2F;&#x2F;   );&#x2F;&#x2F;   warning(&#x2F;&#x2F;     matches &#x3D;&#x3D; null || matches[matches.length - 1].route.element !&#x3D;&#x3D; undefined,&#x2F;&#x2F;     &#96;Matched leaf route at location &quot;$&#123;location.pathname&#125;$&#123;location.search&#125;$&#123;location.hash&#125;&quot; does not have an element. &#96; +&#x2F;&#x2F;       &#96;This means it will render an &lt;Outlet &#x2F;&gt; with a null value by default resulting in an &quot;empty&quot; page.&#96;&#x2F;&#x2F;   );&#x2F;&#x2F; &#125;&#x2F;&#x2F; 渲染return _renderMatches(  matches &amp;&amp;    matches.map((match) &#x3D;&gt;      Object.assign(&#123;&#125;, match, &#123;        params: Object.assign(&#123;&#125;, parentParams, match.params),        pathname: joinPaths([parentPathnameBase, match.pathname]),        pathnameBase:          match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;            ? parentPathnameBase            : joinPaths([parentPathnameBase, match.pathnameBase]),      &#125;)    ),  parentMatches);&#x2F;&#x2F; _renderMatchesexport function _renderMatches(  matches: RouteMatch[] | null,  parentMatches: RouteMatch[] &#x3D; []): React.ReactElement | null &#123;  if (matches &#x3D;&#x3D; null) return null;  &#x2F;&#x2F; 这是一个递归 reduceRight，与reduce类似，不过reduceRight是从右到左  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;    return (      &lt;RouteContext.Provider &#x2F;&#x2F; 需要看下 RouteContext在什么地方使用的，为什要看它，因为这个Context距离渲染组件的chilren最近，看他是如何驱动组件更新的【element、outlet】        children&#x3D;&#123;          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet        &#125;        value&#x3D;&#123;&#123;          outlet,          matches: parentMatches.concat(matches.slice(0, index + 1)),        &#125;&#125;      &#x2F;&gt;    );  &#125;, null as React.ReactElement | null);&#125;</code></pre><h2 id="RouteContext-在源码中的使用"><a href="#RouteContext-在源码中的使用" class="headerlink" title="RouteContext 在源码中的使用"></a>RouteContext 在源码中的使用</h2><ul><li>useNavigate</li><li>useOutlet</li><li>useParams</li><li>useResolvedPath</li><li>useRoutes</li></ul><h3 id="useNavigate-1"><a href="#useNavigate-1" class="headerlink" title="useNavigate"></a>useNavigate</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but * may also be used by other elements to change the location. * 返回更改位置的命令式方法。由&lt;Link&gt;s使用，但也可由其他元素用于更改位置。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate *&#x2F;export function useNavigate(): NavigateFunction &#123;  invariant(    useInRouterContext(),    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;  );  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);  let &#123; matches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();  let routePathnamesJson &#x3D; JSON.stringify(    matches.map((match) &#x3D;&gt; match.pathnameBase)  );  let activeRef &#x3D; React.useRef(false);  React.useEffect(() &#x3D;&gt; &#123;    activeRef.current &#x3D; true;  &#125;);  let navigate: NavigateFunction &#x3D; React.useCallback(    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;      warning(        activeRef.current,        &#96;You should call navigate() in a React.useEffect(), not when &#96; +          &#96;your component is first rendered.&#96;      );      if (!activeRef.current) return;      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;        navigator.go(to);        return;      &#125;      let path &#x3D; resolveTo(        to,        JSON.parse(routePathnamesJson),        locationPathname      );      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;        path.pathname &#x3D; joinPaths([basename, path.pathname]);      &#125;      (!!options.replace ? navigator.replace : navigator.push)(        path,        options.state      );    &#125;,    [basename, navigator, routePathnamesJson, locationPathname]  );  return navigate;&#125;&#x2F;** * Returns the element for the child route at this level of the route * hierarchy. Used internally by &lt;Outlet&gt; to render child routes. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-outlet *&#x2F;export function useOutlet(context?: unknown): React.ReactElement | null &#123;  let outlet &#x3D; React.useContext(RouteContext).outlet; &#x2F;&#x2F; 这里  if (outlet) &#123;    return (      &lt;OutletContext.Provider value&#x3D;&#123;context&#125;&gt;&#123;outlet&#125;&lt;&#x2F;OutletContext.Provider&gt;    );  &#125;  return outlet;&#125;export function useParams&lt;  ParamsOrKey extends string | Record&lt;string, string | undefined&gt; &#x3D; string&gt;(): Readonly&lt;  [ParamsOrKey] extends [string] ? Params&lt;ParamsOrKey&gt; : Partial&lt;ParamsOrKey&gt;&gt; &#123;  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);&#x2F;&#x2F; 这里  let routeMatch &#x3D; matches[matches.length - 1];  return routeMatch ? (routeMatch.params as any) : &#123;&#125;;&#125;&#x2F;** * Resolves the pathname of the given &#96;to&#96; value against the current location. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;api#useresolvedpath *&#x2F;export function useResolvedPath(to: To): Path &#123;  let &#123; matches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();  let routePathnamesJson &#x3D; JSON.stringify(    matches.map((match) &#x3D;&gt; match.pathnameBase)  );  return React.useMemo(    () &#x3D;&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),    [to, routePathnamesJson, locationPathname]  );&#125;&#x2F;** * Returns the element of the route that matched the current location, prepared * with the correct context to render the remainder of the route tree. Route * elements in the tree must render an &lt;Outlet&gt; to render their child route&#39;s * element. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-routes *&#x2F;export function useRoutes(  routes: RouteObject[],  locationArg?: Partial&lt;Location&gt; | string): React.ReactElement | null &#123;  invariant(    useInRouterContext(),    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.    &#96;useRoutes() may be used only in the context of a &lt;Router&gt; component.&#96;  );  let &#123; matches: parentMatches &#125; &#x3D; React.useContext(RouteContext); &#x2F;&#x2F; 这里  let routeMatch &#x3D; parentMatches[parentMatches.length - 1];  let parentParams &#x3D; routeMatch ? routeMatch.params : &#123;&#125;;  let parentPathname &#x3D; routeMatch ? routeMatch.pathname : &quot;&#x2F;&quot;;  let parentPathnameBase &#x3D; routeMatch ? routeMatch.pathnameBase : &quot;&#x2F;&quot;;  let parentRoute &#x3D; routeMatch &amp;&amp; routeMatch.route;</code></pre><p>最终发现，又回到 useRoutes，也确实是在尾部调用 TOC,如下抽取部分代码片段</p><h2 id="代码-2-1"><a href="#代码-2-1" class="headerlink" title="代码 2"></a>代码 2</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; 1 useRoutes尾部调用let locationFromContext &#x3D; useLocation(); &#x2F;&#x2F; 这里return _renderMatches(  matches &amp;&amp;    matches.map((match) &#x3D;&gt;      Object.assign(&#123;&#125;, match, &#123;        params: Object.assign(&#123;&#125;, parentParams, match.params),        pathname: joinPaths([parentPathnameBase, match.pathname]),        pathnameBase:          match.pathnameBase &#x3D;&#x3D;&#x3D; &quot;&#x2F;&quot;            ? parentPathnameBase            : joinPaths([parentPathnameBase, match.pathnameBase]),      &#125;)    ),  parentMatches);&#x2F;&#x2F; 2export function _renderMatches(  matches: RouteMatch[] | null,  parentMatches: RouteMatch[] &#x3D; []): React.ReactElement | null &#123;  if (matches &#x3D;&#x3D; null) return null;  &#x2F;&#x2F; 这是一个递归 reduceRight，与reduce类似，不过reduceRight是从右到左  return matches.reduceRight((outlet, match, index) &#x3D;&gt; &#123;    return (      &lt;RouteContext.Provider &#x2F;&#x2F; 需要看下 RouteContext在什么地方使用的，为什要看它，因为这个Context距离渲染组件的chilren最近，看他是如何驱动组件更新的【element、outlet】        children&#x3D;&#123;          match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet &#x2F;&#x2F; 这里的return相当于将 上述1的代码全部塞在RouteContext.Provider中  注意：因为react.context只能在对应的provider中使用          &#x2F;&#x2F; 这里拿了 Route的element的属性（组件渲染）据说，Route的形式有好多种，下面看看去        &#125;        value&#x3D;&#123;&#123;          outlet,          matches: parentMatches.concat(matches.slice(0, index + 1)),        &#125;&#125;      &#x2F;&gt;    );  &#125;, null as React.ReactElement | null);&#125;</code></pre><h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Declares an element that should be rendered at a certain URL path. * 声明在某个URL路径渲染的元素 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;route *&#x2F;export function Route( &#x2F;&#x2F; 这个看上去就一个函数声明，啥都没有  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps): React.ReactElement | null &#123;  invariant(    false,    &#96;A &lt;Route&gt; is only ever to be used as the child of &lt;Routes&gt; element, &#96; +      &#96;never rendered directly. Please wrap your &lt;Route&gt; in a &lt;Routes&gt;.&#96;  );&#125;</code></pre><h2 id="createRoutesFromChildren-1"><a href="#createRoutesFromChildren-1" class="headerlink" title="createRoutesFromChildren"></a>createRoutesFromChildren</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Creates a route config from a React &quot;children&quot; object, which is usually * either a &#96;&lt;Route&gt;&#96; element or an array of them. Used internally by * &#96;&lt;Routes&gt;&#96; to create a route config from its children. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;utils&#x2F;create-routes-from-children *&#x2F;export function createRoutesFromChildren(  children: React.ReactNode): RouteObject[] &#123;  let routes: RouteObject[] &#x3D; [];  React.Children.forEach(children, (element) &#x3D;&gt; &#123;    if (!React.isValidElement(element)) &#123;      &#x2F;&#x2F; 不是react组件返回undefined,结束      &#x2F;&#x2F; Ignore non-elements. This allows people to more easily inline      &#x2F;&#x2F; conditionals in their route config.      return;    &#125;    if (element.type &#x3D;&#x3D;&#x3D; React.Fragment) &#123;      &#x2F;&#x2F; React.Fragment      &#x2F;&#x2F; Transparently support React.Fragment and its children.      &#x2F;&#x2F; 支持React.Fragment及其子级。      routes.push.apply(        routes,        createRoutesFromChildren(element.props.children)      );      return;    &#125;    invariant(      element.type &#x3D;&#x3D;&#x3D; Route,      &#96;[$&#123;        typeof element.type &#x3D;&#x3D;&#x3D; &quot;string&quot; ? element.type : element.type.name      &#125;] is not a &lt;Route&gt; component. All component children of &lt;Routes&gt; must be a &lt;Route&gt; or &lt;React.Fragment&gt;&#96;    );    let route: RouteObject &#x3D; &#123;      caseSensitive: element.props.caseSensitive,      element: element.props.element, &#x2F;&#x2F; 这里直接把组件给了route，上面   match.route.element !&#x3D;&#x3D; undefined ? match.route.element : outlet  渲染时候渲染就是它      index: element.props.index,      path: element.props.path,    &#125;;    if (element.props.children) &#123;      &#x2F;&#x2F; 有children      route.children &#x3D; createRoutesFromChildren(element.props.children);    &#125;    routes.push(route);  &#125;);  return routes;&#125;</code></pre><h2 id="至此"><a href="#至此" class="headerlink" title="至此"></a>至此</h2><p>我们了解到了，react-router 监听，渲染整个过程</p><h2 id="余下的勾子"><a href="#余下的勾子" class="headerlink" title="余下的勾子"></a>余下的勾子</h2><ul><li>useNavigate</li><li>useOutlet</li><li>useParams</li><li>useResolvedPath</li></ul><h3 id="useNavigate-2"><a href="#useNavigate-2" class="headerlink" title="useNavigate"></a>useNavigate</h3><p>独立功能块，提供 navigate 用于跳转两个参数，第一个参数接受数字和路径</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Returns an imperative method for changing the location. Used by &lt;Link&gt;s, but * may also be used by other elements to change the location. * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-navigate *&#x2F;export function useNavigate(): NavigateFunction &#123;  invariant(    useInRouterContext(),    &#x2F;&#x2F; TODO: This error is probably because they somehow have 2 versions of the    &#x2F;&#x2F; router loaded. We can help them understand how to avoid that.    &#96;useNavigate() may be used only in the context of a &lt;Router&gt; component.&#96;  );  let &#123; basename, navigator &#125; &#x3D; React.useContext(NavigationContext);  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();  let routePathnamesJson &#x3D; JSON.stringify(    matches.map((match) &#x3D;&gt; match.pathnameBase)  );  let activeRef &#x3D; React.useRef(false);  React.useEffect(() &#x3D;&gt; &#123;    activeRef.current &#x3D; true;  &#125;);  &#x2F;&#x2F; 声明一个函数  let navigate: NavigateFunction &#x3D; React.useCallback(    (to: To | number, options: NavigateOptions &#x3D; &#123;&#125;) &#x3D;&gt; &#123;      warning(        activeRef.current,        &#96;You should call navigate() in a React.useEffect(), not when &#96; +          &#96;your component is first rendered.&#96;      );      if (!activeRef.current) return;      if (typeof to &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;        &#x2F;&#x2F; 支持数字        navigator.go(to);        return;      &#125;      let path &#x3D; resolveTo(        to,        JSON.parse(routePathnamesJson),        locationPathname      );      if (basename !&#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;        path.pathname &#x3D; joinPaths([basename, path.pathname]);      &#125;      (!!options.replace ? navigator.replace : navigator.push)(        path, &#x2F;&#x2F; 支持路径跳转        options.state      );    &#125;,    [basename, navigator, routePathnamesJson, locationPathname]  );  &#x2F;&#x2F; 返回这个函数  return navigate;&#125;</code></pre><h3 id="useOutlet"><a href="#useOutlet" class="headerlink" title="useOutlet"></a>useOutlet</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Returns the element for the child route at this level of the route * hierarchy. Used internally by &lt;Outlet&gt; to render child routes. * 返回路由层次结构此级别的子路由的元素。由&lt;Outlet&gt;内部使用以渲染子路由。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-outlet *&#x2F;export function useOutlet(context?: unknown): React.ReactElement | null &#123;  let outlet &#x3D; React.useContext(RouteContext).outlet;  if (outlet) &#123;    return (      &lt;OutletContext.Provider value&#x3D;&#123;context&#125;&gt;&#123;outlet&#125;&lt;&#x2F;OutletContext.Provider&gt;    );  &#125;  return outlet;&#125;&#x2F;&#x2F; 使用&#x2F;** * Renders the child route&#39;s element, if there is one. * 渲染子路由的元素（如果有）。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;components&#x2F;outlet *&#x2F;export function Outlet(props: OutletProps): React.ReactElement | null &#123;  return useOutlet(props.context);&#125;</code></pre><h3 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Returns an object of key&#x2F;value pairs of the dynamic params from the current * URL that were matched by the route path. * 返回由路由路径匹配的当前URL中的动态参数的键&#x2F;值对组成的对象。 * * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;hooks&#x2F;use-params *&#x2F;export function useParams&lt;  ParamsOrKey extends string | Record&lt;string, string | undefined&gt; &#x3D; string&gt;(): Readonly&lt;  [ParamsOrKey] extends [string] ? Params&lt;ParamsOrKey&gt; : Partial&lt;ParamsOrKey&gt;&gt; &#123;  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);  let routeMatch &#x3D; matches[matches.length - 1];  &#x2F;&#x2F; 最后一个就是当前页面对应参数：怎么理解  &#x2F;&#x2F; 1. push情况，最后一个是当前页面  &#x2F;&#x2F; 2. replace情况，最后一个是当前页面  &#x2F;&#x2F; 3. pop 返回情况，最后一个是当前页面  &#x2F;&#x2F; 所以最后一个就是当前页面  return routeMatch ? (routeMatch.params as any) : &#123;&#125;;&#125;</code></pre><h3 id="useResolvedPath"><a href="#useResolvedPath" class="headerlink" title="useResolvedPath"></a>useResolvedPath</h3><p><a href="https://github.com/841660202/react-router/blob/854f4a41780089ad114fecef1a25111830f5cc0b/examples/custom-link/src/App.tsx#L36">具体使用见</a></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Resolves the pathname of the given &#96;to&#96; value against the current location. * 根据当前位置解析给定“to”值的路径名。 * @see https:&#x2F;&#x2F;reactrouter.com&#x2F;docs&#x2F;en&#x2F;v6&#x2F;api#useresolvedpath *&#x2F;export function useResolvedPath(to: To): Path &#123;  let &#123; matches &#125; &#x3D; React.useContext(RouteContext);  let &#123; pathname: locationPathname &#125; &#x3D; useLocation();  let routePathnamesJson &#x3D; JSON.stringify(    matches.map((match) &#x3D;&gt; match.pathnameBase)  );  return React.useMemo(    () &#x3D;&gt; resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),    [to, routePathnamesJson, locationPathname]  );&#125;&#x2F;&#x2F; Pathexport interface Path &#123;  &#x2F;**   * A URL pathname, beginning with a &#x2F;.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname   *&#x2F;  pathname: Pathname;  &#x2F;**   * A URL search string, beginning with a ?.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search   *&#x2F;  search: Search;  &#x2F;**   * A URL fragment identifier, beginning with a #.   *   * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash   *&#x2F;  hash: Hash;&#125;&#x2F;** * A URL pathname, beginning with a &#x2F;. * * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.pathname *&#x2F;export type Pathname &#x3D; string;&#x2F;** * A URL search string, beginning with a ?. * * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.search *&#x2F;export type Search &#x3D; string;&#x2F;** * A URL fragment identifier, beginning with a #. * * @see https:&#x2F;&#x2F;github.com&#x2F;remix-run&#x2F;history&#x2F;tree&#x2F;main&#x2F;docs&#x2F;api-reference.md#location.hash *&#x2F;export type Hash &#x3D; string;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/841660202/react-router">fork 的 react-router 代码</a><br><a href="https://juejin.cn/post/6886290490640039943">「源码解析 」这一次彻底弄懂 react-router 路由原理</a><br><a href="https://www.lmlphp.com/user/60155/article/item/1561048/">React Router 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router v6.4.0 主要概念</title>
      <link href="//post/2022-06-21react-router.html"/>
      <url>//post/2022-06-21react-router.html</url>
      
        <content type="html"><![CDATA[<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://reactrouter.com/" target="_blank" >React Router v6 is Here</a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>React Router v6 在客户端路由十年的基础上，采用了以前版本及其姐妹项目 Reach Router 的最佳功能，采用了迄今为止最小和最强大的软件包。</p></blockquote><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>或许某一天，再见时，已不是 v6</p></div><p>官网分为两块内容 <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#main-concepts" target="_blank" >核心概念</a> <a href="https://reactrouter.com/docs/en/v6/getting-started/tutorial" target="_blank" >实践指导</a>,本章内容主要是<strong>主要概念</strong></p><p>You might be wondering what exactly React Router does. How can it help you build your app? What exactly is a router, anyway?<br><em>你可能会感到困惑，什么是路由？如何构建你的应用？什么是一个路由？。。。</em><br>If you’ve ever had any of these questions, or you’d just like to dig into the fundamental pieces of routing, you’re in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.<br><em>如果你有过这些问题，或者你想要深入了解路由的核心概念，你就在正确的位置了。本文档包含了 React Router 的实现中所有核心概念的详细解释。</em></p><p>Please don’t let this document overwhelm you! For everyday use, React Router is pretty simple. You don’t need to go this deep to use it.<br><em>请不要让这份文档击败你！对于每日使用，React Router 是非常简单的。你不需要去深入到这里来使用它。</em></p><p>React Router isn’t just about matching a url to a function or component: it’s about building a full user interface that maps to the URL, so it might have more concepts in it than you’re used to. We’ll go into detail on the three main jobs of React Router:<br><em>React Router 不仅仅是匹配一个 url 到一个函数或组件：它是构建一个完整的用户界面，它可能有更多概念在里面，你可能不会感到。我们将从三个主要的工作中去解释 React Router：</em></p><ol><li>Subscribing and manipulating the history stack <em>订阅和操作历史堆栈</em></li><li>Matching the URL to your routes <em>匹配 URL 到你的路由</em></li><li>Rendering a nested UI from the route matches <em>在路由匹配中渲染嵌套的 UI</em></li></ol><h2 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h2><p><em>定义</em></p><p>But first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.<br><em>首先，有一些定义！有很多不同的理念在路由的后端和前端框架。有时一个单词在一个上下文中可能有不同的意思。</em></p><p>Here are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.<br><em>这里有一些我们经常使用的词汇，React Router 的其他部分将会以每个词汇为题来讲述。</em></p><p><strong>URL</strong> - The URL in the address bar. A lot of people use the term “URL” and “route” interchangeably, but this is not a route in React Router, it’s just a URL.<br><em><strong>URL</strong> - 地址栏中的 URL。很多人使用“URL”和“路由”可交换使用，但这不是 React Router 的路由，它只是一个 URL。</em></p><p><strong>Location</strong> - This is a React Router specific object that is based on the built-in browser’s window.location object. It represents “where the user is at”. It’s mostly an object representation of the URL but has a bit more to it than that.<br><em><strong>位置</strong>- 这是一个基于浏览器的 window.location 对象的<code>React Router</code>特定对象。它表示“用户在哪里”。它主要是一个对 URL 的对象表示，但有更多的事情。</em></p><p><strong>Location State</strong> - A value that persists with a location that isn’t encoded in the URL. Much like hash or search params (data encoded in the URL), but stored invisibly in the browser’s memory.<br><em><strong>位置状态</strong> - 一个值，在不在 URL 中编码的位置保持。类似于哈希或搜索参数（在 URL 中编码的数据），但存储在浏览器的内存中。</em></p><p><strong>History Stack</strong> - As the user navigates, the browser keeps track of each location in a stack. If you click and hold the back button in a browser you can see the browser’s history stack right there.<br><em><strong>历史堆栈</strong> - 当用户导航时，浏览器会记录每个位置在一个堆栈中。如果你点击并保持后退按钮在浏览器，你可以看到浏览器的历史堆栈在那里。</em></p><p><strong>Client Side Routing (CSR)</strong> - A plain HTML document can link to other documents and the browser handles the history stack itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.<br><em><strong>客户端端路由 (CSR)</strong> - 只需要一个 HTML 文档，可以链接到其他文档，浏览器会自己处理历史堆栈。客户端端路由使开发人员能够操作浏览器历史堆栈，而不需要请求文档。</em></p><p><strong>History</strong> - An object that allows React Router to subscribe to changes in the URL as well as providing APIs to manipulate the browser history stack programmatically.<br><em><strong>历史</strong> - 一个对象，允许 React Router 订阅 URL 的变化，同时提供一个 API，用于手动操作浏览器历史堆栈。</em></p><p><strong>History Action</strong> - One of POP, PUSH, or REPLACE. Users can arrive at a URL for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.<br><em><strong>历史动作</strong> - POP、PUSH 或 REPLACE 之一。用户可以到达这三个原因的 URL。一个 push 当添加一个新条目到历史堆栈时（通常是链接点击或程序员强制导航）。一个 replace 类似，但它替换当前条目而不是添加一个新的。最后，一个 pop 发生在用户点击浏览器窗口的后退或前进按钮。</em></p><p><strong>Segment</strong> - The parts of a URL or path pattern between the &#x2F; characters. For example, “&#x2F;users&#x2F;123” has two segments.<br><em><strong>分段</strong> - URL 或路径模式中的 &#x2F; 字符之间的部分。例如，”&#x2F;users&#x2F;123” 有两个分段。</em></p><p><strong>Path Pattern</strong> - These look like URLs but can have special characters for matching URLs to routes, like dynamic segments (“&#x2F;users&#x2F;:userId”) or star segments (“&#x2F;docs&#x2F;*“). They aren’t URLs, they’re patterns that React Router will match.<br><em><strong>路径模式</strong> - 这样看起来像 URL，但它们可以包含特殊字符来匹配 URL 到路由，例如动态分段 (“&#x2F;users&#x2F;:userId”) 或星号分段 (“&#x2F;docs&#x2F;*“)。它们不是 URL，它们是 React Router 将匹配的模式。</em></p><p><strong>Dynamic Segment</strong> - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern &#x2F;users&#x2F;:userId will match URLs like &#x2F;users&#x2F;123<br><em><strong>动态分段</strong> - 路径模式中的一个分段，它可以匹配分段中的任何值。例如，路径模式 &#x2F;users&#x2F;:userId 将匹配 URL 类似 &#x2F;users&#x2F;123</em></p><p><strong>URL Params</strong> - The parsed values from the URL that matched a dynamic segment.<br><em><strong>URL 参数</strong> - 从 URL 中解析出的值。</em></p><p><strong>Router</strong> - Stateful, top-level component that makes all the other components and hooks work.<br><em><strong>路由</strong> - 一个状态为组件，用于让所有其他组件和钩子工作。</em></p><p><strong>Route Config</strong> - A tree of routes objects that will be ranked and matched (with nesting) against the current location to create a branch of route matches.<br><em><strong>路由配置</strong> - 一个路由对象的树，将会排序和匹配（包含嵌套）与当前位置来创建一个路由匹配的分支。</em></p><p><strong>Route</strong> - An object or Route Element typically with a shape of { path, element } or <Route path element>. The path is a path pattern. When the path pattern matches the current URL, the element will be rendered.<br><em><strong>路由</strong> - 一个对象或路由元素通常是 { path, element } 或 <Route path element>。路径是路径模式。当路径模式与当前 URL 匹配时，将会渲染该元素。</em></p><p><strong>Route Element</strong> - Or <Route>. This element’s props are read to create a route by <Routes>, but otherwise does nothing.<br><em><strong>路由元素</strong> - 或 <Route>。这个元素的 props 被读取来创建一个路由，但是不做任何事情。</em></p><p><strong>Nested Routes</strong> - Because routes can have children and each route defines a portion of the URL through segments, a single URL can match multiple routes in a nested “branch” of the tree. This enables automatic layout nesting through outlet, relative links, and more.<br><em><strong>嵌套路由</strong> - 因为路由可以有子路由，每个路由都定义一部分 URL 的路径段，一个 URL 可以匹配多个路由在树的嵌套 “分支” 中。这使得通过 outlet、相对链接和更多的功能来实现布局嵌套。</em></p><p><strong>Relative links</strong> - Links that don’t start with &#x2F; will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.<br><em><strong>相对链接</strong> - 不以 &#x2F; 开头的链接会继承最近渲染的路由。这使得它很容易链接到更深的 URL，而不需要知道和建立整个路径。</em></p><p><strong>Match</strong> - An object that holds information when a route matches the URL, like the url params and pathname that matched.<br><em><strong>匹配</strong> - 当路由匹配 URL 时，匹配信息会保存在这个对象中，例如匹配的 URL 参数和路径名。</em></p><p><strong>Matches</strong> - An array of routes (or branch of the route config) that matches the current location. This structure enables nested routes.<br><em><strong>匹配</strong> - 当前位置匹配的路由（或路由配置的分支）的数组。这个结构可以嵌套路由。</em></p><p><strong>Parent Route</strong> - A route with child routes.<br><em><strong>父路由</strong> - 有子路由的路由。</em></p><p><strong>Outlet</strong> - A component that renders the next match in a set of matches.<strong>啥玩意？</strong><br><em><strong>出口</strong> - 一个组件，它渲染一组匹配中的下一个匹配。</em></p><p><strong>Index Route</strong> - A child route with no path that renders in the parent’s outlet at the parent’s URL.<br><em><strong>首页路由</strong> - 一个子路由，没有路径，它渲染在父路由的出口，在父路由的 URL 中。</em></p><p><strong>Layout Route</strong> - A parent route without a path, used exclusively for grouping child routes inside a specific layout.<br><em><strong>布局路由</strong> - 一个没有路径的父路由，用于将子路由分组在特定布局中。</em></p><h2 id="History-and-Locations"><a href="#History-and-Locations" class="headerlink" title="History and Locations"></a>History and Locations</h2><p>Before React Router can do anything, it has to be able to subscribe to changes in the browser history stack.<br><em>在 React Router 可以做任何事情之前，它需要能够订阅浏览器历史堆栈的变化。</em></p><p>Browsers maintain their own history stack as the user navigates around. That’s how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.<br><em>在一个纯粹的网站（没有 JavaScript 的 HTML 文档）中，浏览器会每次点击链接、提交表单或点击后退和前进按钮时，都会向服务器发送请求。</em></p><p>For example, consider the user:<br><em>例如，考虑用户：</em></p><ol><li>clicks a link to &#x2F;dashboard</li><li>clicks a link to &#x2F;accounts</li><li>clicks a link to &#x2F;customers&#x2F;123</li><li>clicks the back button</li><li>clicks a link to &#x2F;dashboard</li></ol><p>The history stack will change as follows where bold entries denote the current URL:<br><em>如下的地方历史堆栈将改变，加粗的条目表示当前 URL：</em></p><ol><li><strong>&#x2F;dashboard</strong></li><li>&#x2F;dashboard, <strong>&#x2F;accounts</strong></li><li>&#x2F;dashboard, &#x2F;accounts**, &#x2F;customers&#x2F;123**</li><li>&#x2F;dashboard, <strong>&#x2F;accounts</strong>, &#x2F;customers&#x2F;123</li><li>&#x2F;dashboard, &#x2F;accounts, <strong>&#x2F;dashboard</strong></li></ol><h3 id="History-Object"><a href="#History-Object" class="headerlink" title="History Object"></a>History Object</h3><p>With client side routing, developers are able to manipulate the browser history stack programmatically. For example, we can write some code like this to change the URL without the browsers default behavior of making a request to the server:<br><em>使用客户端路由，开发人员可以通过编程方式改变浏览器历史堆栈，例如，我们可以这样写，改变 URL，而不会执行浏览器的默认行为，即向服务器发送请求：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;a  href&#x3D;&quot;&#x2F;contact&quot;  onClick&#x3D;&#123;(event) &#x3D;&gt; &#123;    &#x2F;&#x2F; stop the browser from changing the URL and requesting the new document    &#x2F;&#x2F; 阻止浏览器改变 URL 并请求新文档    event.preventDefault();    &#x2F;&#x2F; push an entry into the browser history stack and change the URL    &#x2F;&#x2F; 将一个条目推入浏览器历史堆栈并改变 URL    window.history.pushState(&#123;&#125;, undefined, &quot;&#x2F;contact&quot;);  &#125;&#125;&#x2F;&gt;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>For illustration only, don’t use window.history.pushState directly in React Router<br><em>仅供参考，不要使用 window.history.pushState 直接在 React Router 中使用</em></p></div><p>This code changes the URL but doesn’t do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn’t give us a way to “listen to the URL” and subscribe to changes like this.<br><em>这段代码改变 URL 但不会对 UI 有任何影响。我们需要写一些代码，改变某些状态，使 UI 变为联系页面。问题是，浏览器没有提供这样的方式，“监听 URL”，订阅变化。</em></p><p>Well, that’s not totally true. We can listen for changes to the URL via pop events:<br><em>这不是完全正确的。我们可以监听 URL 变化的事件，通过弹出事件：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.addEventListener(&quot;popstate&quot;, () &#x3D;&gt; &#123;  &#x2F;&#x2F; URL changed!&#125;);</code></pre><p>But that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called window.history.pushState or window.history.replaceState.<br><em>但是，只有当用户点击后退或前进按钮时，才会触发这个事件。没有调用 window.history.pushState 或 window.history.replaceState 的事件。</em><br>That’s where a React Router specific history object comes into play. It provides a way to “listen for URL” changes whether the history action is push, pop, or replace.<br><em>这里是 React Router 特定的历史对象的事件。它提供一种方式，“监听 URL”变化，无论历史操作是 push、pop 或 replace。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let history &#x3D; createBrowserHistory();history.listen((&#123; location, action &#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; this is called whenever new locations come in  &#x2F;&#x2F; the action is POP, PUSH, or REPLACE&#125;);</code></pre><p>Apps don’t need to set up their own history objects–that’s job of <Router>. It sets up one of these objects, subscribe to changes in the history stack, and finally updates its state when the URL changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a location, everything else works from that single object.<br><em>应用不需要设置自己的历史对象，这是 <code>&lt;Router&gt;</code> 的工作。它设置一个这样的对象，订阅历史堆栈的变化，并且最终更新它的状态，当 URL 变化时。这会导致应用重新渲染并显示正确的 UI。它只需要把状态放在状态中，其他都可以从这个单一对象中获取。</em></p><h3 id="Locations"><a href="#Locations" class="headerlink" title="Locations"></a>Locations</h3><p>The browser has a location object on window.location. It tells you information about the URL but also has some methods to change it:<br><em>浏览器有一个 location 对象在 window.location 上。它告诉你关于 URL 的信息，但也有一些方法可以改变它：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.location.pathname; &#x2F;&#x2F; &#x2F;getting-started&#x2F;concepts&#x2F;window.location.hash; &#x2F;&#x2F; #locationwindow.location.reload(); &#x2F;&#x2F; force a refresh w&#x2F; the server&#x2F;&#x2F; and a lot more</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>For illustration. You don’t typically work with window.location in a React Router app<br><em>在 React Router 应用中通常不使用 window.location</em></p></div><p>Instead of using window.location, React Router has the concept of a location that’s patterned after window.location but is much simpler. It looks like this:<br><em>而不是使用 window.location，React Router 有一个像 window.location 一样的<code>location</code>，但更简单。它看起来像这样：</em></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;pathname&quot;: &quot;&#x2F;bbq&#x2F;pig-pickins&quot;,  &quot;search&quot;: &quot;?campaign&#x3D;instagram&quot;,  &quot;hash&quot;: &quot;#menu&quot;,  &quot;state&quot;: null,  &quot;key&quot;: &quot;aefz24ie&quot;&#125;</code></pre><p>The first three: { pathname, search, hash } are exactly like window.location. If you just add up the three you’ll get the URL the user sees in the browser:<br><em>前三个：{ pathname, search, hash } 相当于 window.location。如果把三个加起来就等于用户在浏览器中看到的 URL：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">location.pathname + location.search + location.hash;&#x2F;&#x2F; &#x2F;bbq&#x2F;pig-pickins?campaign&#x3D;instagram#menu</code></pre><p>The last two, { state, key }, are React Router specific.<br><em>最后两个，{ state, key }，是 React Router 特定的。</em></p><p><strong>Location Pathname</strong></p><p>This is the part of URL after the origin, so for <a href="https://example.com/teams/hotspurs">https://example.com/teams/hotspurs</a> the pathname is &#x2F;teams&#x2F;hotspurs. This is the only part of the location that routes match against.<br><em>这是 URL 的部分，在 origin 之后，所以 <a href="https://example.com/teams/hotspurs">https://example.com/teams/hotspurs</a> 的 pathname 是 &#x2F;teams&#x2F;hotspurs。这是 location 的唯一部分，它匹配路由。</em></p><p><strong>Location Search</strong></p><p>People use a lot of different terms for this part of the URL:<br><em>人们使用很多不同的词来表达这部分 URL：</em></p><ul><li>location search</li><li>search params</li><li>URL search params</li><li>query string</li></ul><p>In React Router we call it the “location search”. However, location search is a serialized version of URLSearchParams. So sometimes we might call it “URL search params” as well.<br><em>在 React Router 中我们称它为 “location search”。但是，location search 是一个序列化的 URLSearchParams 的版本。所以有时候我们可能称它 “URL search params”。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; given a location like this:let location &#x3D; &#123;  pathname: &quot;&#x2F;bbq&#x2F;pig-pickins&quot;,  search: &quot;?campaign&#x3D;instagram&amp;popular&#x3D;true&quot;,  hash: &quot;&quot;,  state: null,  key: &quot;aefz24ie&quot;,&#125;;&#x2F;&#x2F; we can turn the location.search into URLSearchParams&#x2F;&#x2F; 我们可以把 location.search 转换成 URLSearchParamslet params &#x3D; new URLSearchParams(location.search);params.get(&quot;campaign&quot;); &#x2F;&#x2F; &quot;instagram&quot;params.get(&quot;popular&quot;); &#x2F;&#x2F; &quot;true&quot;params.toString(); &#x2F;&#x2F; &quot;campaign&#x3D;instagram&amp;popular&#x3D;true&quot;,</code></pre><p>When being precise, refer to the serialized string version as “search” and the parsed version as “search params”, but it’s common to use the terms interchangeably when precision isn’t important.<br><em>当精确时，参考序列化的字符串版本为 “search”，解析版本为 “search params”，但是通常使用时可以使用交换的词来表达。</em></p><p><strong>Location Hash</strong></p><p>Hashes in URLs indicate a scroll position on the current page. Before the window.history.pushState API was introduced, web developers did client side routing exclusively with the hash portion of the URL, it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.<br><em>URL 中的 hash 可以表示当前页面的滚动位置。在 window.history.pushState API 尚未引入前，web 开发者只能在 URL 中的 hash 部分进行客户端路由，它是我们只能在不需要请求服务器的情况下操作它。但是，现在我们可以用它来实现它的提供的功能。</em></p><p><strong>Location State</strong></p><p>You may have wondered why the window.history.pushState() API is called “push state”. State? Aren’t we just changing the URL? Shouldn’t it be history.push? Well, we weren’t in the room when the API was designed, so we’re not sure why “state” was the focus, but it is a cool feature of browsers nonetheless.<br><em>你可能会问为什么 window.history.pushState() API 被称为 “push state”。状态？我们不是改变 URL 吗？应该不是 history.push？我们不是在房间里面，所以我们不知道为什么 “state” 是焦点，但是它是浏览器的一个酷功能。</em><br>Browsers let us persist information about a transition by passing a value to pushState. When the user clicks back, the value on history.state changes to whatever was “pushed” before.<br><em>浏览器让我们保持一个过渡的信息，通过传递一个值来 pushState。当用户点击后，history.state 将变成什么时候 “pushed”。</em></p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">window.history.pushState(&quot;look ma!&quot;, undefined, &quot;&#x2F;contact&quot;);window.history.state; &#x2F;&#x2F; &quot;look ma!&quot;&#x2F;&#x2F; user clicks backwindow.history.state; &#x2F;&#x2F; undefined&#x2F;&#x2F; user clicks forwardwindow.history.state; &#x2F;&#x2F; &quot;look ma!&quot;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>For illustration. You don’t read history.state directly in React Router apps<br><em>为了演示。你不要直接读取 history.state 在 React Router 应用中。</em></p></div><p>React Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the location instead of history.<br><em>React Router 利用这个浏览器功能，抽象它点，而不是把值放在 history 上。</em></p><p>You can think about location.state just like location.hash or location.search except instead of putting the values in the URL it’s hidden–like a super secret piece of the URL only the programmer knows about.<br><em>你可以想象 location.state 像 location.hash 或 location.search，只不过它放在 URL 中是隐藏的–只有程序员知道的秘密。</em></p><p>A couple of great use-cases for location state are:<br><em>一些好的使用场景是 location state：</em></p><p>Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).<br><em>如果用户点击一个 item 在 grid 视图，那么我们可以在 modal 中显示记录，但如果用户直接访问 URL，那么我们可以在它的自己的布局中显示记录（pinterest，旧 instagram）。</em></p><p>Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.<br><em>从列表发送一个部分记录到下一个屏幕，以便它可以立即渲染部分数据，然后再次获取其余的数据。</em></p><p>You set location state in two ways: on <Link> or navigate:<br><em>你可以在 <Link> 或 navigate 中设置 location state：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Link to&#x3D;&quot;&#x2F;pins&#x2F;123&quot; state&#x3D;&#123;&#123; fromDashboard: true &#125;&#125; &#x2F;&gt;;let navigate &#x3D; useNavigate();navigate(&quot;&#x2F;users&#x2F;123&quot;, &#123; state: partialUser &#125;);</code></pre><p>And on the next page you can access it with useLocation:<br><em>在下一个页面中，你可以使用 useLocation 来访问它：</em></p><pre class="line-numbers language-javaScript" data-language="javaScript"><code class="language-javaScript">let location &#x3D; useLocation();location.state;</code></pre><p>Location state values will get serialized, so something like new Date() will be turned into a string.<br><em>Location state 值将会被序列化，所以 something like new Date() 将会被转换成字符串。</em></p><p><strong>Location Key</strong></p><p>Each location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, new Map(), or even locationStorage.<br><em>每个 location 可以获得一个唯一的 key。这是一个高级的情况，比如 location-based scroll management，客户端数据缓存，以及更多。因为每个新的 location 可以获得一个唯一的 key，所以你可以把信息存储在一个普通对象，new Map()，或者 locationStorage。</em></p><p>For example, a very basic client side data cache could store values by location key (and the fetch URL) and skip fetching the data when the user clicks back into it:<br><em>例如，一个非常基础的客户端数据缓存可以通过 location key（和 fetch URL）来存储值，并且当用户点击回到它时跳过 fetch 数据：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let cache &#x3D; new Map();function useFakeFetch(URL) &#123;  let location &#x3D; useLocation();  let cacheKey &#x3D; location.key + URL;  let cached &#x3D; cache.get(cacheKey);  let [data, setData] &#x3D; useState(() &#x3D;&gt; &#123;    &#x2F;&#x2F; initialize from the cache    return cached || null;  &#125;);  let [state, setState] &#x3D; useState(() &#x3D;&gt; &#123;    &#x2F;&#x2F; avoid the fetch if cached    return cached ? &quot;done&quot; : &quot;loading&quot;;  &#125;);  useEffect(() &#x3D;&gt; &#123;    if (state &#x3D;&#x3D;&#x3D; &quot;loading&quot;) &#123;      let controller &#x3D; new AbortController();      fetch(URL, &#123; signal: controller.signal &#125;)        .then((res) &#x3D;&gt; res.json())        .then((data) &#x3D;&gt; &#123;          if (controller.signal.aborted) return;          &#x2F;&#x2F; set the cache          cache.set(cacheKey, data);          setData(data);        &#125;);      return () &#x3D;&gt; controller.abort();    &#125;  &#125;, [state, cacheKey]);  useEffect(() &#x3D;&gt; &#123;    setState(&quot;loading&quot;);  &#125;, [URL]);  return data;&#125;</code></pre><h2 id="Matching"><a href="#Matching" class="headerlink" title="Matching"></a>Matching</h2><p>On the initial render, and when the history stack changes, React Router will match the location against your route config to come up with a set of matches to render.<br><em>在初始渲染和当 history stack 变化时，React Router 将会匹配 location 与你的路由配置来得到一组匹配来渲染。</em></p><h3 id="Defining-Routes"><a href="#Defining-Routes" class="headerlink" title="Defining Routes"></a>Defining Routes</h3><p>A route config is a tree of routes that looks something like this:<br><em>一个路由配置是一个树状结构，比如这样：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Routes&gt;  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;    &lt;&#x2F;Route&gt;  &lt;&#x2F;Route&gt;  &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;    &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;    &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;  &lt;&#x2F;Route&gt;  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;&lt;&#x2F;Routes&gt;</code></pre><p>The <code>&lt;Routes&gt;</code> component recurses through its props.children, strips their props, and generates an object like this:<br><em><Routes> 组件递归遍历其 props.children，并且生成一个像这样的对象：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let routes &#x3D; [  &#123;    element: &lt;App &#x2F;&gt;,    path: &quot;&#x2F;&quot;,    children: [      &#123;        index: true,        element: &lt;Home &#x2F;&gt;,      &#125;,      &#123;        path: &quot;teams&quot;,        element: &lt;Teams &#x2F;&gt;,        children: [          &#123;            index: true,            element: &lt;LeagueStandings &#x2F;&gt;,          &#125;,          &#123;            path: &quot;:teamId&quot;,            element: &lt;Team &#x2F;&gt;,          &#125;,          &#123;            path: &quot;:teamId&#x2F;edit&quot;,            element: &lt;EditTeam &#x2F;&gt;,          &#125;,          &#123;            path: &quot;new&quot;,            element: &lt;NewTeamForm &#x2F;&gt;,          &#125;,        ],      &#125;,    ],  &#125;,  &#123;    element: &lt;PageLayout &#x2F;&gt;,    children: [      &#123;        element: &lt;Privacy &#x2F;&gt;,        path: &quot;&#x2F;privacy&quot;,      &#125;,      &#123;        element: &lt;Tos &#x2F;&gt;,        path: &quot;&#x2F;tos&quot;,      &#125;,    ],  &#125;,  &#123;    element: &lt;Contact &#x2F;&gt;,    path: &quot;&#x2F;contact-us&quot;,  &#125;,];</code></pre><p>In fact, instead of <Routes> you can use the hook useRoutes(routesGoHere) instead. That’s all <Routes> is doing.<br><em>在实际上，<Routes> 的作用是，把 routesGoHere 传递给 useRoutes。</em></p><p>As you can see, routes can define multiple segments like :teamId&#x2F;edit, or just one like :teamId. All of the segments down a branch of the route config are added together to create a final path pattern for a route.<br><em>你可以看到，路由可以定义多个分段，比如 :teamId&#x2F;edit，或者只有一个 :teamId。所有从路由配置的分支下面的分段都会组合在一起，来创建一个最终的路径模式。</em></p><h3 id="Match-Params"><a href="#Match-Params" class="headerlink" title="Match Params"></a>Match Params</h3><p>Note the :teamId segments. This is what we call a dynamic segment of the path pattern, meaning it doesn’t match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for :teamId. Both &#x2F;teams&#x2F;123 or &#x2F;teams&#x2F;cupcakes will match. We call the parsed values URL params. So in this case our teamId param would be “123” or “cupcakes”. We’ll see how to use them in your app in the Rendering section.<br><em>注意，这里有 :teamId 分段。这是一个动态分段，意味着它不是静态的，而是动态的。任何值都可以填充 :teamId。&#x2F;teams&#x2F;123 或 &#x2F;teams&#x2F;cupcakes 均可匹配。我们称这些解析后的值为 URL 参数。所以，在这种情况下，我们的 teamId 参数将是 “123” 或 “cupcakes”。我们会在渲染部分看到如何使用它们。</em></p><h3 id="Ranking-Routes"><a href="#Ranking-Routes" class="headerlink" title="Ranking Routes"></a>Ranking Routes</h3><p>If we add up all the segments of all the branches of our route config, we end up with the following path patterns that our app responds to:<br><em>如果我们把所有路由配置的分支的所有分段相加，我们就会得到以下路径模式，我们的应用程序会响应：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[  &quot;&#x2F;&quot;,  &quot;&#x2F;teams&quot;,  &quot;&#x2F;teams&#x2F;:teamId&quot;,  &quot;&#x2F;teams&#x2F;:teamId&#x2F;edit&quot;,  &quot;&#x2F;teams&#x2F;new&quot;,  &quot;&#x2F;privacy&quot;,  &quot;&#x2F;tos&quot;,  &quot;&#x2F;contact-us&quot;,];</code></pre><p>Now this is where things get really interesting. Consider the URL &#x2F;teams&#x2F;new. Which pattern in that list matches the URL?<br><em>考虑一下这个 URL &#x2F;teams&#x2F;new，它在那个列表中匹配哪个模式？</em><br>That’s right, two of them!<br><em>对的，两个！</em></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;teams&#x2F;new&#x2F;teams&#x2F;:teamId</code></pre><p>React Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match &#x2F; and render the <Home/> component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it’s much smarter.<br><em>React Router 在这里需要做一个决定，只有一个路由器，客户端和服务器端都会简单地处理模式。第一个匹配的优先。在这种情况下，我们会匹配 &#x2F; 并呈现 <Home/> 组件。这不是我们想要的。这种类型的路由器需要我们按照定义的顺序来排列路由，以便得到预期的结果。这是 React Router 的 v6 前的工作，现在它更加智能。</em></p><p>Looking at those patterns, you intuitively know that we want &#x2F;teams&#x2F;new to match the URL &#x2F;teams&#x2F;new. It’s a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You’ll never have to think about ordering your routes.<br><em>看这些模式，你感觉到我们想要 &#x2F;teams&#x2F;new 匹配 URL &#x2F;teams&#x2F;new。这是一个完美的匹配！React Router 也知道。当匹配时，它会按照分段数，静态分段，动态分段，星号模式，等等来排列路由，并选择最有用的匹配。你永远不会必须想象路由的顺序。</em></p><h3 id="Pathless-Routes"><a href="#Pathless-Routes" class="headerlink" title="Pathless Routes"></a>Pathless Routes</h3><p>You may have noticed the weird routes from earlier:<br><em>你可能注意到以前的奇怪路由：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;&lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;&lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125; &#x2F;&gt;</code></pre><p>They don’t even have a path, how can they be a route? This is where the word “route” in React Router is used pretty loosely. <code>&lt;Home/&gt;</code> and <code>&lt;LeagueStandings/&gt;</code> are <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#index-route" target="_blank" >index routes</a> and <code>&lt;PageLayout/&gt;</code> is a <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#layout-route" target="_blank" >layout route</a>. We’ll discuss how they work in the Rendering section. Neither really has much to do with matching.<br><em>它们也没有路径，怎么可能是路由？这是 React Router 中的“路由”词的使用很模糊。<Home/> 和 <LeagueStandings/> 是索引路由，<PageLayout/> 是布局路由。我们会在渲染部分讨论如何使用它们。<Home/> 和 <LeagueStandings/> 不是真正的路由，<PageLayout/> 是真正的路由。</em></p><h3 id="Route-Matches"><a href="#Route-Matches" class="headerlink" title="Route Matches"></a>Route Matches</h3><p>When a route matches the URL, it’s represented by a <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#match" target="_blank" >match</a> object. A match for <code>&lt;Route path=&quot;:teamId&quot; element=&#123;&lt;Team/&gt;&#125;/&gt;</code> would look something like this:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  pathname: &quot;&#x2F;teams&#x2F;firebirds&quot;,  params: &#123;    teamId: &quot;firebirds&quot;  &#125;,  route: &#123;    element: &lt;Team &#x2F;&gt;,    path: &quot;:teamId&quot;  &#125;&#125;</code></pre><p>pathname holds the portion of the URL that matched this route (in our case it’s all of it). params holds the parsed values from any dynamic segments that matched. Note that the param’s object keys map directly to the name of the segment: :teamId becomes params.teamId.<br><em>match.pathname 存放匹配到的 URL 的部分（在我们的例子中它是全部）。params 存放从任何动态分段匹配的解析值。注意，参数的对象键映射到动态分段的名称：:teamId 变成 params.teamId。</em><br>Because our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL &#x2F;teams&#x2F;firebirds, it would be the following route branch:<br><em>因为我们的路由是一棵树，一个 URL 可以匹配整个树的一个分支。考虑 URL &#x2F;teams&#x2F;firebirds，它将是以下路由分支：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Routes&gt;  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt; &#x2F;&#x2F; +    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;      &#123;&quot; &quot;&#125;      &#x2F;&#x2F;+      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt; &#x2F;&#x2F;+      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;    &lt;&#x2F;Route&gt;  &lt;&#x2F;Route&gt;  &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;    &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;    &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;  &lt;&#x2F;Route&gt;  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;&lt;&#x2F;Routes&gt;</code></pre><p>React Router will create an array of matches from these routes and the url so it can render a nested UI that matches the route nesting.<br><em>React Router 将从这些路由创建一个匹配数组，并将 url 传递给它，以便它可以渲染一个嵌套的 UI，匹配路由嵌套。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[  &#123;    pathname: &quot;&#x2F;&quot;,    params: null,    route: &#123;      element: &lt;App &#x2F;&gt;,      path: &quot;&#x2F;&quot;,    &#125;,  &#125;,  &#123;    pathname: &quot;&#x2F;teams&quot;,    params: null,    route: &#123;      element: &lt;Teams &#x2F;&gt;,      path: &quot;teams&quot;,    &#125;,  &#125;,  &#123;    pathname: &quot;&#x2F;teams&#x2F;firebirds&quot;,    params: &#123;      teamId: &quot;firebirds&quot;,    &#125;,    route: &#123;      element: &lt;Team &#x2F;&gt;,      path: &quot;:teamId&quot;,    &#125;,  &#125;,];</code></pre><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><p>The final concept is rendering. Consider that the entry to your app looks like this:<br><em>最后一个概念是渲染。考虑你的应用程序的入口如下：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const root &#x3D; ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;BrowserRouter&gt;    &lt;Routes&gt;      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;        &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;        &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;          &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;          &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;          &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;        &lt;&#x2F;Route&gt;      &lt;&#x2F;Route&gt;      &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;        &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;        &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;      &lt;&#x2F;Route&gt;      &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;    &lt;&#x2F;Routes&gt;  &lt;&#x2F;BrowserRouter&gt;);</code></pre><p>Let’s use the &#x2F;teams&#x2F;firebirds URL as an example again. <Routes> will match the location to your route config, get a set of matches, and then render a React element tree like this:<br><em>使用 <code>/teams/firebirds</code> URL 作为一个例子，<code>&lt;Routes&gt;</code> 将匹配位置到你的路由配置，获取一组匹配，然后渲染一个 React 元素树，如下：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;App&gt;  &lt;Teams&gt;    &lt;Team &#x2F;&gt;  &lt;&#x2F;Teams&gt;&lt;&#x2F;App&gt;</code></pre><p>Each match rendered inside the parent route’s element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.<br><em>每个匹配在父路由的元素中都是一个非常强大的抽象。大多数网站和应用程序都共享这种特性：盒子里面盒子里面盒子，每个盒子都有一个导航区域，它改变页面的子区域。</em></p><h3 id="Outlets"><a href="#Outlets" class="headerlink" title="Outlets"></a>Outlets</h3><p>This nested element tree won’t happen automatically. <Routes> will render the first match’s element for you (In our case that’s <App/>). The next match’s element is <Teams>. In order to render that, App needs to render an outlet.<br><em>这个嵌套元素树不会自动发生。<code>&lt;Routes&gt;</code> 将会渲染第一个匹配的元素（在我们的例子中是 <code>&lt;App/&gt;</code>）。下一个匹配的元素是 <code>&lt;Teams&gt;</code>。为了渲染这个，App 需要渲染一个出口。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function App() &#123;  return (    &lt;div&gt;      &lt;GlobalNav &#x2F;&gt;      &lt;Outlet &#x2F;&gt;      &lt;GlobalFooter &#x2F;&gt;    &lt;&#x2F;div&gt;  );&#125;</code></pre><p>The Outlet component will always render the next match. That means <Teams> also needs an outlet to render <Team/>.<br><em>Outlet 元素将始终渲染下一个匹配。这意味着 <code>&lt;Teams&gt;</code> 需要一个出口来渲染 <code>&lt;Team/&gt;</code>。</em><br>If the URL were &#x2F;contact-us, the element tree would change to:<br><em>如果 URL 是 <code>/contact-us</code>，元素树会变成：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;App&gt;  &lt;Teams&gt;    &lt;EditTeam &#x2F;&gt;  &lt;&#x2F;Teams&gt;&lt;&#x2F;App&gt;</code></pre><p>The outlet swaps out the child for the new child that matches, but the parent layout persists. It’s subtle but very effective at cleaning up your components.<br><em>出口将交换子组件，但父布局仍然存在。它很巧妙，但十分有效地清理你的组件。</em></p><h3 id="Index-Routes"><a href="#Index-Routes" class="headerlink" title="Index Routes"></a>Index Routes</h3><p>Remember the <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config" target="_blank" >route config</a> for &#x2F;teams:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;  &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;  &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;  &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;&lt;&#x2F;Route&gt;</code></pre><p>If the URL were <code>/teams/firebirds</code>, the element tree would be:<br><em>如果 URL 是 <code>/teams/firebirds</code>，元素树会是：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;App&gt;  &lt;Teams&gt;    &lt;Team &#x2F;&gt;  &lt;&#x2F;Teams&gt;&lt;&#x2F;App&gt;</code></pre><p>But if the URL were <code>/teams</code>, the element tree would be:<br><em>如果 URL 是 <code>/teams</code>，元素树会是：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;App&gt;  &lt;Teams&gt;    &lt;LeagueStandings &#x2F;&gt;  &lt;&#x2F;Teams&gt;&lt;&#x2F;App&gt;</code></pre><p>League standings? How the heck did <code>&lt;Route index element=&#123;&lt;LeagueStandings&gt;&#125;/&gt;</code> pop in there? It doesn’t even have a path! The reason is that it’s an index route. Index routes render in their parent route’s outlet at the parent route’s path.<br><em>排名？ 为什么 <code>&lt;Route index element=&#123;&lt;LeagueStandings&gt;&#125;/&gt;</code> 不能出现在它的父路由的出口？ 它不是一个路径！ 原因是它是一个索引路由。 索引路由渲染在它的父路由的出口，在父路由的路径。</em><br>Think of it this way, if you’re not at one of the child routes’ paths, the <Outlet> will render nothing in the UI:<br><em>如果你不在子路由的路径上，<code>&lt;Outlet&gt;</code> 将不会渲染任何 UI：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;App&gt;  &lt;Teams &#x2F;&gt;&lt;&#x2F;App&gt;</code></pre><p>If all the teams are in a list on the left then an empty outlet means you’ve got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.<br><em>如果所有成员都在左边的列表中，空的出口意味着你有一个空白页在右边！ 你的 UI 需要一些东西来填充空白：索引路由。</em><br>Another way to think of an index route is that it’s the default child route when the parent matches but none of its children do.<br><em>另一种思考索引路由是，它是父路由匹配，但没有任何子路由的默认子路由。</em><br>Depending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you’ll most likely want index route to fill the space when the user hasn’t clicked one of the items yet.<br><em>根据用户界面，你可能不需要索引路由，但如果父路由有持久的导航，你将最有可能需要索引路由来填充空白，当用户还没有点击一个项目。</em></p><h3 id="Layout-Routes"><a href="#Layout-Routes" class="headerlink" title="Layout Routes"></a>Layout Routes</h3><p>Here’s a part of our route config we haven’t matched yet: <code>/privacy</code>. Let’s look at the route config again, highlighting the matched routes:<br><em>这里是我们还没有匹配的路由配置的一部分：<code>/privacy</code>。我们再看一下路由配置，高亮匹配的路由：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Routes&gt;  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;    &lt;&#x2F;Route&gt;  &lt;&#x2F;Route&gt;  &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;    &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;    &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;  &lt;&#x2F;Route&gt;  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;&lt;&#x2F;Routes&gt;</code></pre><p>And the resulting element tree rendered will be:<br><em>根据结果，渲染出来的元素树会是：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;App&gt;  &lt;PageLayout&gt;    &lt;Privacy &#x2F;&gt;  &lt;&#x2F;PageLayout&gt;&lt;&#x2F;App&gt;</code></pre><p>The <code>PageLayout</code> route is admittedly weird. We call it a <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#layout-route" target="_blank" >layout route</a> because it doesn’t participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn’t allow this then you’d have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:<br><em>这个<code>PageLayout</code>路由是不友好的。 我们调用它是一个 <a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#layout-route" target="_blank" >layout route</a>，因为它不参与匹配（但它的子路由却是）。 它只是为了让包裹多个子路由在一个布局上更加简单。 如果我们不允许这样做，那么你就需要在你的应用中手动处理布局，有时候你的路由会自动做这件事，有时候你需要手动处理布局，通过重复布局组件来实现：</em></p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>You can do it like this, but we recommend using a layout route<br><em>你可以这样做，但我们建议使用一个布局路由</em></p></div><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Routes&gt;  &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;    &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;    &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;      &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;:teamId&#x2F;edit&quot; element&#x3D;&#123;&lt;EditTeam &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;      &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;    &lt;&#x2F;Route&gt;  &lt;&#x2F;Route&gt;  &lt;Route    path&#x3D;&quot;&#x2F;privacy&quot;    element&#x3D;&#123;      &lt;PageLayout&gt;        &lt;Privacy &#x2F;&gt;      &lt;&#x2F;PageLayout&gt;    &#125;  &#x2F;&gt;  &lt;Route    path&#x3D;&quot;&#x2F;tos&quot;    element&#x3D;&#123;      &lt;PageLayout&gt;        &lt;Tos &#x2F;&gt;      &lt;&#x2F;PageLayout&gt;    &#125;  &#x2F;&gt;  &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;&lt;&#x2F;Routes&gt;</code></pre><p>So, yeah, the semantics of a layout “route” is a bit silly since it has nothing to do with the URL matching, but it’s just too convenient to disallow.<br><em>因此，嘿，布局“路由”的语义是一点点蛋疼，因为它没有什么关系到 URL 匹配，但它是太方便了。</em></p><h2 id="Navigating"><a href="#Navigating" class="headerlink" title="Navigating"></a>Navigating</h2><p>When the URL changes we call that a “navigation”. There are two ways to navigate in React Router:<br><em>在 URL 变化时调用这个方法“navigation”：有两种方式：</em></p><ul><li><code>&lt;Link&gt;</code></li><li><code>navigate</code></li></ul><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>This is the primary means of navigation. Rendering a <Link> allows the user to change the URL when they click it. React Router will prevent the browser’s default behavior and tell the history to push a new entry into the history stack. The location changes and the new matches will render.<br><em>这是主要的导航方式，渲染一个<Link>允许用户点击它时变更 URL。 React Router 将阻止浏览器的默认行为，并告诉历史记录推入一个新条目到历史堆栈中。 地点变化了，新匹配的元素会渲染。</em></p><p>However, links are accessible in that they:<br><em>但是，链接是可访问的，它：</em></p><p>Still render a <code>&lt;a href&gt;</code> so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)<br><em>仍然渲染一个<a href>，这样所有默认的访问性问题都会被满足（如键盘，可聚焦性，SEO 等等）</em></p><p>Don’t prevent the browser’s default behavior if it’s a right click or command&#x2F;control click to “open in new tab”<br><em>如果是右键点击或命令&#x2F;控制点击“在新标签页中打开”，那么不要阻止浏览器的默认行为</em></p><p><a href="https://reactrouter.com/docs/en/v6/getting-started/concepts#nested-routes" target="_blank" >Nested routes</a> aren’t just about rendering layouts; they also enable “relative links”. Consider our teams route from before:<br><em>嵌套路由不仅仅是渲染布局，它也可以启用“相对链接”。 考虑我们的 teams 路由从前面：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;  &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;&lt;&#x2F;Route&gt;</code></pre><p>The <Teams> component can render links like:<br><em><Teams>组件可以渲染链接，如：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;Link to&#x3D;&quot;psg&quot; &#x2F;&gt;&lt;Link to&#x3D;&quot;new&quot; &#x2F;&gt;</code></pre><p>The full path it links to will be <code>/teams/psg</code> and <code>/teams/new</code>. They inherit the route within which they are rendered. This makes it so your route components don’t have to really know anything about the rest of the routes in the app. A very large amount of links just go one more segment deeper. You can rearrange your whole route config and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.<br><em>它们链接到的完整路径是 <code>/teams/psg</code> 和 <code>/teams/new</code>。 它们继承渲染时的路由。 这使得你的路由组件不需要真的知道应用中的其他路由。 一大堆链接只需要一个更深一层。 你可以重新排列你的整个路由配置，这些链接可能仍然能工作。 这在开始建站时非常有用，因为设计和布局会移动。</em></p><h3 id="Navigate-Function"><a href="#Navigate-Function" class="headerlink" title="Navigate Function"></a>Navigate Function</h3><p>This function is returned from the useNavigate hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:<br><em>这个函数是由 useNavigate 钩子返回的，允许你，程序员，在你想要的时候改变 URL。 你可以做一个延迟：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let navigate &#x3D; useNavigate();useEffect(() &#x3D;&gt; &#123;  setTimeout(() &#x3D;&gt; &#123;    navigate(&quot;&#x2F;logout&quot;);  &#125;, 30000);&#125;, []);</code></pre><p>Or after a form is submitted:<br><em>或者，在表单提交后：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;form onSubmit&#x3D;&#123;event &#x3D;&gt; &#123;  event.preventDefault();  let data &#x3D; new FormData(event.target)  let urlEncoded &#x3D; new URLSearchParams(data)  navigate(&quot;&#x2F;create&quot;, &#123; state: urlEncoded &#125;)&#125;&#125;&gt;</code></pre><p>Like <code>Link</code>, <code>navigate</code> works with nested “to” values as well.<br><em>像 Link 一样，navigate 也可以用嵌套的“to”值。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">navigate(&quot;psg&quot;);</code></pre><p>You should have a good reason to use navigate instead of <Link>. This makes us very sad:<br><em>你应该有一个好的理由使用 navigate 而不是 <Link>。 这使我们很伤心：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&lt;li onClick&#x3D;&#123;() &#x3D;&gt; navigate(&quot;&#x2F;somewhere&quot;)&#125; &#x2F;&gt;</code></pre><p>Aside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.<br><em>除了链接和表单之外，很少应该改变 URL，因为它会引入一些关于访问性和用户期望的复杂性。</em></p><h3 id="Data-Access"><a href="#Data-Access" class="headerlink" title="Data Access"></a>Data Access</h3><p>Finally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks<br><em>最后，应用程序需要要求 React 路由来获取一些信息，以便建立完整的 UI。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let location &#x3D; useLocation();let urlParams &#x3D; useParams();let [urlSearchParams] &#x3D; useSearchParams();</code></pre><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>Let’s put it all together from the top!<br><em>从顶部一起来看！</em></p><ol><li>You render your app:</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const root &#x3D; ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;BrowserRouter&gt;    &lt;Routes&gt;      &lt;Route path&#x3D;&quot;&#x2F;&quot; element&#x3D;&#123;&lt;App &#x2F;&gt;&#125;&gt;        &lt;Route index element&#x3D;&#123;&lt;Home &#x2F;&gt;&#125; &#x2F;&gt;        &lt;Route path&#x3D;&quot;teams&quot; element&#x3D;&#123;&lt;Teams &#x2F;&gt;&#125;&gt;          &lt;Route path&#x3D;&quot;:teamId&quot; element&#x3D;&#123;&lt;Team &#x2F;&gt;&#125; &#x2F;&gt;          &lt;Route path&#x3D;&quot;new&quot; element&#x3D;&#123;&lt;NewTeamForm &#x2F;&gt;&#125; &#x2F;&gt;          &lt;Route index element&#x3D;&#123;&lt;LeagueStandings &#x2F;&gt;&#125; &#x2F;&gt;        &lt;&#x2F;Route&gt;      &lt;&#x2F;Route&gt;      &lt;Route element&#x3D;&#123;&lt;PageLayout &#x2F;&gt;&#125;&gt;        &lt;Route path&#x3D;&quot;&#x2F;privacy&quot; element&#x3D;&#123;&lt;Privacy &#x2F;&gt;&#125; &#x2F;&gt;        &lt;Route path&#x3D;&quot;&#x2F;tos&quot; element&#x3D;&#123;&lt;Tos &#x2F;&gt;&#125; &#x2F;&gt;      &lt;&#x2F;Route&gt;      &lt;Route path&#x3D;&quot;contact-us&quot; element&#x3D;&#123;&lt;Contact &#x2F;&gt;&#125; &#x2F;&gt;    &lt;&#x2F;Routes&gt;  &lt;&#x2F;BrowserRouter&gt;);</code></pre><p><code>&lt;BrowserRouter&gt;</code> creates a history, puts the initial location in to state, and subscribes to the URL.<br><em><code>&lt;BrowserRouter&gt;</code> 创建一个历史，将初始位置放入状态，并订阅 URL。</em></p><p><code>&lt;Routes&gt;</code> recurses its child routes to build a route config, matches those routes against the location, creates some route matches, and renders the first match’s route element.<br><em><code>&lt;Routes&gt;</code> 递归子路由来建立路由配置，匹配这些路由与位置，创建一些路由匹配，并呈现第一个匹配的路由元素。</em></p><p>You render an <Outlet/> in each parent route.<br><em>你在每个父路由中渲染一个 <code>&lt;Outlet/&gt;</code>。</em></p><p>The <code>outlets</code> render the next match in the route matches.<br><em>路由匹配中的下一个匹配渲染。</em></p><p>The user clicks a link<br><em>用户点击一个链接</em></p><p>The link calls navigate()<br><em>链接调用 navigate()</em></p><p>The history changes the URL and notifies <code>&lt;BrowserRouter&gt;</code>.<br><em>历史改变 URL，并通知 <code>&lt;BrowserRouter&gt;</code>。</em></p><p><code>&lt;BrowserRouter&gt;</code> rerenders, start over at (2)!<br><em><BrowserRouter> 重新渲染，从 (2) 开始！</em></p><p>That’s it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.<br><em>这就是了！我们希望这个指南有能帮助你深入理解 React 路由的主要概念。</em></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近看到了，面试题 react-router 原理，查了下答案，内容不是很多</p><p><a href="https://blog.csdn.net/weixin_39907713/article/details/111237885" target="_blank" >React Router 原理</a><br><a href="https://blog.csdn.net/qingfeng2020/article/details/121136648" target="_blank" >浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理</a></p><p><a href="https://blog.csdn.net/Android_boom/article/details/125200222" target="_blank" >React Router 源码解析</a></p><p>之前没看过实现原理，现在看到也没那么难 <code>从小被吓大的</code>， 带着好奇心看下仓库代码：<code>4+1（index.ts）个文件</code>没看错</p><img src="http://t-blog-images.aijs.top/img/20220621091016.webp" width=300 /><h2 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 暴露出的apiexport &#123;  MemoryRouter,  Navigate,  NavigationType,  Outlet,  Route,  Router,  Routes,  createPath,  createRoutesFromChildren,  generatePath,  matchPath,  matchRoutes,  parsePath,  renderMatches,  resolvePath,  useHref,  useInRouterContext,  useLocation,  useMatch,  useNavigate,  useNavigationType,  useOutlet,  useOutletContext,  useParams,  useResolvedPath,  useRoutes,&#125;;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; DANGER! PLEASE READ ME! 危险！请读这个！&#x2F;&#x2F; We provide these exports as an escape hatch in the event that you need any&#x2F;&#x2F; routing data that we don&#39;t provide an explicit API for. With that said, we&#x2F;&#x2F; want to cover your use case if we can, so if you feel the need to use these&#x2F;&#x2F; we want to hear from you. Let us know what you&#39;re building and we&#39;ll do our&#x2F;&#x2F; best to make sure we can support you!&#x2F;&#x2F; 我们提供这些导出作为一个逃逸引用，以防你需要我们没有提供明确 API 的任何路由数据。也就是说，&#x2F;&#x2F; 如果你需要这些，我们希望能够为你提供支持，所以如果你有需要，请告诉我们你的需求，我们会尽可能地为你提供支持。&#x2F;&#x2F; We consider these exports an implementation detail and do not guarantee&#x2F;&#x2F; against any breaking changes, regardless of the semver release. Use with&#x2F;&#x2F; extreme caution and only if you understand the consequences. Godspeed.&#x2F;&#x2F; 我们考虑这些导出是一个实现细节，并且不保证对任何变更不会有任何影响，无论是在 semver 版本发布前或者后。&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</code></pre><h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>对<code>react-router</code>进行了扩展，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题汇总</title>
      <link href="//post/2022-06-16interview.html"/>
      <url>//post/2022-06-16interview.html</url>
      
        <content type="html"><![CDATA[<img src="https://img0.baidu.com/it/u=4204937089,859074527&fm=253&fmt=auto&app=138&f=JPEG?w=255&h=255" /><p><a href="https://www.nowcoder.com/discuss/763567" target="_blank" >小红书前端面经</a></p><p><a href="https://juejin.cn/post/7013953652578582558?share_token=ad9faad3-d177-4d34-9228-086d1d192112" target="_blank" >前端两年经验，历时一个月的面经和总结</a></p><p><a href="https://cloud.tencent.com/developer/article/1663670" target="_blank" >【面试题】CSS 知识点整理(附答案)</a></p><h2 id="HTTP-与-TCP"><a href="#HTTP-与-TCP" class="headerlink" title="HTTP 与 TCP"></a>HTTP 与 TCP</h2><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117303320" target="_blank" >HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117248731?spm=1001.2014.3001.5502" target="_blank" >TCP 三次握手</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117251247?spm=1001.2014.3001.5502" target="_blank" >TCP 四次挥手</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117257895?spm=1001.2014.3001.5502" target="_blank" >TCP 重传机制</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117263730?spm=1001.2014.3001.5502" target="_blank" >流量控制</a></p><p><a href="https://www.likecs.com/show-204397172.html" target="_blank" >HTTP 请求和 TCP 链接的对应关系</a></p><p><a href="https://blog.csdn.net/sinat_41696687/article/details/123458338" target="_blank" >彻底搞懂进程与线程之间的联系</a></p><p><a href="https://zhuanlan.zhihu.com/p/420055986" target="_blank" >TLS&#x2F;SSL</a></p><p><a href="https://juejin.cn/post/6871060072936505352" target="_blank" >TLS&#x2F;SSL</a></p><p><a href="https://baijiahao.baidu.com/s?id=1633945802472340217&wfr=spider&for=pc" target="_blank" >CDN</a></p><p><a href="https://www.jianshu.com/p/60cc4ea02971/" target="_blank" >websocket 面试题</a></p><p><a href="https://blog.csdn.net/weixin_42674490/article/details/120647995" target="_blank" >websocket 使用</a></p><p><strong>状态码的含义</strong></p><p><a href="" target="_blank" >101 SwitchingProtocols，表示切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议</a></p><p><a href="https://www.bbsmax.com/A/gGdX3AWm54/" target="_blank" >204 状态码的含义</a></p><p><a href="" target="_blank" >206 partial Content, 进行范围请求，打开 B 站的视频可以看到 206 请求</a></p><h2 id="身份信息"><a href="#身份信息" class="headerlink" title="身份信息"></a>身份信息</h2><!-- <a href="https://zhuanlan.zhihu.com/p/482474619" target="_blank" >JWT 史上最全面试题(大厂常问)</a> --><p><a href="https://www.php.cn/website-design-ask-484695.html" target="_blank" >JWT</a></p><p><a href="https://zhuanlan.zhihu.com/p/66037342" target="_blank" >单站点登录</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><a href="https://blog.csdn.net/Dax1_/article/details/123185260" target="_blank" >总结 ES6 中 Map 和 Set 的特点与比较</a></p><p><a href="https://www.itheima.com/news/20201110/183621.html" target="_blank" >从 async&#x2F;await 面试题看宏观任务和微观任务</a></p><p><a href="https://www.jianshu.com/p/844e293d90a7" target="_blank" >箭头函数和普通函数的区别</a></p><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p><a href="https://zhuanlan.zhihu.com/p/142681436?from_voters_page=true" target="_blank" >js 堆和栈的区别</a><br><a href="https://segmentfault.com/a/1190000039042550" target="_blank" >什么是闭包</a><br><a href="https://blog.csdn.net/z591102/article/details/110634593#:~:text=%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%87%8C%EF%BC%8C-,%E5%B0%BE%E8%B0%83%E7%94%A8,-%E6%98%AF%E6%8C%87%E4%B8%80%E4%B8%AA" target="_blank" >tail 调用:尾调用优化（Tail Call Optimization，TCO）</a></p><p><a href="https://segmentfault.com/a/1190000013396601" target="_blank" >Promise 实现原理</a><br><a href="" target="_blank" >数据劫持 ……^_^</a></p><hr /><p><strong>new 和 Object.create 都是创造一个对象的意思，二者有啥区别呢？</strong></p><p><a href="https://www.jianshu.com/p/5f718f4a9441#:~:text=jack%27))-,Object.create(),-Object.create%E6%98%AF" target="_blank" >new &#x2F; Object.create()的实现原理</a></p><ul><li>用 Object.create()方法创建新对象,并使用现有对象提供新对象的 proto。</li><li>Object.create() 是 es5 组合继承的 es6 api</li><li>Object.create 克隆的对象也只能实现一级对象的深拷贝</li><li><a href="https://blog.csdn.net/qq_48648782/article/details/118498146" target="_blank" >使用：创建子对象，让子对象继承父对象的同时，为子对象添加自有属性</a></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function myNew() &#123;  let obj &#x3D; &#123;&#125;;  let func &#x3D; [].shift.call(arguments); &#x2F;&#x2F;出列，获取第一个参数  obj.__proto__ &#x3D; func.prototype; &#x2F;&#x2F;proto指向原型  func.apply(obj, arguments); &#x2F;&#x2F;让obj执行func函数  return obj;&#125;function myCreate(obj) &#123;  let F &#x3D; function () &#123;&#125;;  F.prototype &#x3D; obj;  return new F();&#125;</code></pre>  <hr />  <p><strong>对着图看</strong></p><!-- ![](http://t-blog-images.aijs.top/img/20220617151244.webp) --><img src="http://t-blog-images.aijs.top/img/202207271745383.webp" /><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p><a href="http://t.zoukankan.com/Zzbj-p-13923489.html" target="_blank" > 强缓存、协商缓存发生在 8 中的哪些阶段</a><br><a href="https://mp.weixin.qq.com/s/0w6aWwpR3MAJnmyLwDnAzA" target="_blank" >JavaScript 内存泄漏防范之道</a></p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p><a href="https://blog.csdn.net/oscar999/article/details/121044091" target="_blank" >HTML 如何禁用缓存</a></p><p><a href="https://www.jianshu.com/p/50c37351f873" target="_blank" >onload、DOMContentLoaded 区别</a></p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p><a href="https://www.jianshu.com/p/274a9b3200b4" target="_blank" >BFC 与清除浮动</a><br>根节点、浮动、定位[]、display[相关]、表格、网格、多列，总之是把一些子元素圈起来形成封闭的盒子，践行 BFC 的原则[独立、对外不影响（不重叠）]</p><p><a href="https://blog.csdn.net/NCZB007/article/details/108440570" target="_blank" >.clearfix::after(清除浮动)中各个属性及值详细解说</a></p><p><a href="https://blog.csdn.net/weixin_43613849/article/details/116561796" target="_blank" >css 中实现单行多行文字截断</a><br><a href="https://blog.csdn.net/qq_39221436/article/details/124450355" target="_blank" > css-modules 来深入理解它的原理</a></p><p><a href="https://blog.csdn.net/xun__xing/article/details/108253723" target="_blank" >css module</a></p><p><a href="/#/post/2022-05-23width0" target="_blank" >flex 布局</a></p><p><a href="https://juejin.cn/post/6844903582370643975" target="_blank" >怎么画一条 0.5px 的边（更新）</a></p><p><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" >总结伪类与伪元素</a></p><div style="display: flex;flex-direction: row;flex-wrap: wrap">  <img src="http://t-blog-images.aijs.top/img/20220625174736.png" width=400 style="margin-right: 4px; margin-bottom: 4px"/>  <img src="http://t-blog-images.aijs.top/img/20220625174712.png" style="boject-fix: none; height: 200px"/></div><p><code>:first-child</code> <code>:first-of-type</code> <code>:nth-child</code> <code>:nth-of-type</code> 区别</p><ul><li><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=2-,%3Afirst%2Dchild,-%E5%8C%B9%E9%85%8D%E5%85%83%E7%B4%A0%E7%9A%84" target="_blank" >:first-child</a> 匹配元素的第一个子元素。</li><li><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%7D-,4%20first%2Dof%2Dtype,-%E5%8C%B9%E9%85%8D%E5%B1%9E%E4%BA%8E%E5%85%B6" target="_blank" >:first-of-type</a> 匹配属于其父元素的首个特定类型的子元素的每个元素。</li><li><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%7D-,6%20%3Anth%2Dchild,-%3Anth%2Dchild%20%E6%A0%B9%E6%8D%AE" target="_blank" >:nth-child </a> 根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素示例如下：<br>1n+0，或 n，匹配每一个子元素。<br>2n+0，或 2n，匹配位置为 2、4、6、8… 的子元素，该表达式与关键字 even 等价。<br>2n+1 匹配位置为 1、3、5、7… 的子元素、该表达式与关键字 odd 等价。<br>3n+4 匹配位置为 4、7、10、13… 的子元素。<br>:nth-of-type</li><li><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/#prettyPhoto:~:text=%E5%BC%80%E5%A7%8B%E8%AE%A1%E6%95%B0%E7%9A%84%E3%80%82-,8%20%3Anth%2Dof%2Dtype,-%3Anth%2Dof%2Dtype" target="_blank" >:nth-of-type</a> 与 nth-child 相似，不同之处在于它是只匹配特定类型的元素。</li></ul><p><a href="https://www.runoob.com/cssref/pr-class-position.html" target="_blank" >position 的几个属性和含义</a></p><p><a href="" target="_blank" >说一下盒模型&gt;_&lt;</a></p><p><a href="https://www.jianshu.com/p/ce7e4a997a2c" target="_blank" >vertical-align 到底怎么用</a></p><p><a href="https://blog.csdn.net/qq_52340302/article/details/119238781" target="_blank" >六种常用的 css 三栏布局方法</a></p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p><a href="https://juejin.cn/post/6844903814332432397" target="_blank" >前端响应式布局原理与方案（详细版）</a></p><p><a href="https://juejin.cn/post/6844903814332432397#:~:text=%E5%AF%B9%E4%BA%8E%E9%9C%80%E8%A6%81%E4%BF%9D%E6%8C%81%E5%AE%BD%E9%AB%98%E6%AF%94%E7%9A%84%E5%9B%BE%EF%BC%8C%E5%BA%94%E8%AF%A5%E7%94%A8padding%2Dtop%E5%AE%9E%E7%8E%B0" target="_blank" >对于需要保持宽高比的图，应该用 padding-top 实现(一种为了解决，图片未加载出来，高度为 0 加载完后，有了内容发生跳变的现象)</a></p><p><a href="https://juejin.cn/post/6844903814332432397#:~:text=1%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0%E7%BA%BF%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%99%AE%E9%80%9A%E5%B1%8F%E5%B9%95%E4%B8%8B1px%2C%E9%AB%98%E6%B8%85%E5%B1%8F%E5%B9%95%E4%B8%8B0.5px%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89%E9%87%87%E7%94%A8transform%E5%B1%9E%E6%80%A7scale%E5%AE%9E%E7%8E%B0" target="_blank" >1 物理像素线</a></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://www.nowcoder.com/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295" target="_blank" >刷算法</a></p><p><a href="https://juejin.cn/post/6844903846779551751" target="_blank" >前端面试之手写代码</a></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><a href="http://bigdata.ctocio.com.cn/bigdata/2022/0506/157700.html" target="_blank" >怎么实现接口防刷</a><br><a href="https://blog.csdn.net/liujiango/article/details/107372364" target="_blank" >怎么实现接口防刷</a></p><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p><a href="https://blog.csdn.net/weixin_45743636/article/details/118100951" target="_blank" >computed 与 watch 的区别</a></p><p>1、<strong>功能上</strong>：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。<br>2、<strong>是否调用 缓存</strong>：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。<br>3、<strong>是否调用 return</strong>：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。<br>4、<strong>computed</strong> 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）<br>5、<strong>使用场景</strong>：computed—-当一个属性受多个属性影响的时候，使用 computed—–购物车商品结算。watch–当一条数据影响多条数据的时候，使用 watch—–搜索框.</p><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p><a href="https://blog.csdn.net/weixin_39907713/article/details/111237885" target="_blank" >React Router 原理</a><br><a href="https://blog.csdn.net/qingfeng2020/article/details/121136648" target="_blank" >浅谈前端路由原理，VueRouter 原理和 ReactRouter 原理</a></p><p><a href="https://blog.csdn.net/Android_boom/article/details/125200222" target="_blank" >React Router 源码解析</a><br><a href="https://wenku.baidu.com/view/dbc762dc740bf78a6529647d27284b73f342365b.html" target="_blank" >React 合成事件机制</a><br><a href="https://baijiahao.baidu.com/s?id=1727882238371627418&wfr=spider&for=pc" target="_blank" >web 前端培训 React 合成事件原理解析</a></p><p><a href="https://www.jianshu.com/p/a68219093f88" target="_blank" >React 事件机制 – 合成事件</a></p><ul><li><strong>原生事件</strong><br>当某个元素触发某个事件（如 onclick ），顶层对象 Document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。</li><li><strong>事件目标</strong><br>当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li><li><strong>事件冒泡</strong><br>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。</li><li><strong>事件委托&#x2F;事件代理</strong><ul><li>简单理解就是将一个响应事件委托到另一个元素。</li><li>当子节点被点击时，click 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。</li></ul></li><li><strong>合成事件与原生事件区别</strong><ul><li>事件名称命名方式不同</li><li>事件处理函数写法不同</li><li>阻止默认行为方式不同</li></ul></li><li><strong>React 合成事件与原生事件执行顺序</strong><!-- - 类似洋葱，  捕获：`document => react 父级 => react 子级 => 父级原生 => 子级原生`  冒泡：`document <= react 父级 <= react 子级 <= 父级原生 <= 子级原生` --></li><li><strong>阻止冒泡</strong></li><li><strong>原生:</strong> 使用 <code>e.stopPropagation()</code> 或者 <code>e.cancelBubble=true</code>（IE）来阻止</li><li><strong>react 中，</strong>阻止冒泡的方式有三种：<ol><li>阻止合成事件与非合成事件（除了 document）之间的冒泡，以上两种方式都不适用，需要用到 e.target 判断。</li><li>阻止合成事件与最外层 document 上的事件间的冒泡，用 <code>e.nativeEvent.stopImmediatePropagation()</code>;</li><li>阻止合成事件间的冒泡，用 <code>e.stopPropagation()</code>;</li></ol></li></ul><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><p>react 阻止事件冒泡</p><ul><li><code>e.stopPropagation</code>用来阻止 React 模拟的事件冒泡</li><li><code>e.stopImmediatePropagation</code> 没这个函数</li><li><code>e.nativeEvent.stopPropagation</code> 原生事件对象的用于阻止 DOM 事件的进一步捕获或者冒泡</li><li><code>e.nativeEvent.stopImmediatePropagation</code> 原生事件对象用于阻止 dom 事件的进一步捕获或者冒泡，且该元素的后续绑定相同事件类型的事件，都会被阻止</li></ul></p></div><p><a href="https://zhuanlan.zhihu.com/p/150993869#:~:text=memo%E5%87%BD%E6%95%B0-,2.4.4.%20%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%9B%E9%87%8F,-%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA" target="_blank" >setState 返回一样的引用，render 会执行吗</a></p><p><a href="" target="_blank" >useEffect 的使用方法？useEffect 的 return 会在什么时候执行？useEffect 原理是什么？</a></p><p><a href="https://blog.csdn.net/leelxp/article/details/108218088#:~:text=%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8BPureComponent%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0" target="_blank" >我们来看看 PureComponent 和 Component 的区别是什么？ </a></p><p><strong>单节点 Diff</strong><br><a href="https://react.iamkasong.com/diff/one.html" target="_blank" >单节点 diff</a></p><p><strong>多节点 Diff</strong><br><a href="https://react.iamkasong.com/diff/multi.html#diff%E7%9A%84%E6%80%9D%E8%B7%AF:~:text=%23-,%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86,-%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D" target="_blank" >第一轮遍历</a></p><p><a href="https://react.iamkasong.com/diff/multi.html#%E7%AC%AC%E4%B8%80%E8%BD%AE%E9%81%8D%E5%8E%86:~:text=%23-,%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86,-%E5%AF%B9%E4%BA%8E%E7%AC%AC%E4%B8%80%E8%BD%AE" target="_blank" >第二轮遍历</a></p><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" >react ⽣命周期</a></p><!-- <div><iframe src="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" height=600 width='100%'></iframe></div> --><p><a href="https://blog.csdn.net/weixin_45654582/article/details/122740125#:~:text=dependencies%20%E5%BB%BA%E7%AB%8B%E8%B5%B7%E5%85%B3%E8%81%94%E3%80%82-,Context%20%E5%8E%9F%E7%90%86,-Provider%20%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B" target="_blank" >Context 原理</a></p><ul><li>Provider 传递流程：Provider 的更新，会 深度遍历子代 fiber，消费 context 的 fiber 和父级链都会 提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。</li><li>Context 订阅流程： contextType ， useContext， Consumer 会内部调用 readContext ，readContext 会把 fiber 上的 dependencies 属性 和 context 对象 建立起关联。</li></ul><p><a href="https://blog.csdn.net/github_37759996/article/details/119187241" target="_blank" >Hooks 的实现原理</a><br><a href="https://blog.csdn.net/XH_jing/article/details/124188256" target="_blank" >类组件和纯函数组件的区别</a></p><p><a href="https://www.php.cn/website-design-ask-491123.html" target="_blank" >React dom 绑定事件和原生事件有什么区别</a></p><p><a href="https://juejin.cn/post/7064444554727915556" target="_blank" >useState 的源码解析</a></p><h2 id="稳操胜券"><a href="#稳操胜券" class="headerlink" title="稳操胜券"></a>稳操胜券</h2><p><a href="http://dljz.nicethemes.cn/news/show-13202.html" target="_blank" >看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇</a></p><p><a href="https://copyfuture.com/blogs-details/20211119150923474f" target="_blank" >看完这篇文章保你面试稳操胜券——基础篇（html&#x2F;css)</a></p><p><a href="https://www.wangt.cc/2021/11/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%BF%9D%E4%BD%A0%E9%9D%A2%E8%AF%95%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8-vue%E7%AF%87/" target="_blank" >看完这篇文章保你面试稳操胜券-vue 篇</a></p><p><a href="https://copyfuture.com/blogs-details/20211118131747765L" target="_blank" >读完这篇保你面试稳操胜券——前端面试题“骨灰级”总结</a></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><a href="https://zhuanlan.zhihu.com/p/472733451" target="_blank" >Webpack | TreeShaking 工作原理</a><br><a href="https://juejin.cn/post/7039547628379439135" target="_blank" >什么是 tree-shaking</a></p><p><a href="https://juejin.cn/post/6844903924806189070" target="_blank" >Webpack 优化——将你的构建效率提速翻倍</a></p><p><a href="https://juejin.cn/post/6844903685407916039" target="_blank" >Webpack 揭秘——走向高阶前端的必经之路</a></p><p><a href="https://www.cnblogs.com/zhilili/p/14721434.html" target="_blank" >webpack（四）——webpack 里面的 plugin 和 loader 的区别</a></p><p><a href="https://zhuanlan.zhihu.com/p/429072485" target="_blank" >跟着源码了解 Webpack 编译流程</a></p><p><a href="https://blog.csdn.net/qq_39207948/article/details/102768659" target="_blank" >说一下对 tree-shaking 的了解，对 CommonJS 和 ESM 都可以用 tree-shaking 吗</a></p><p><a href="https://www.webpackjs.com/contribute/writing-a-loader/" target="_blank" >编写一个 loader</a></p><p><a href="https://www.webpackjs.com/contribute/writing-a-plugin/" target="_blank" >编写一个插件</a></p><p><a href="https://juejin.cn/post/6918998088010956807" target="_blank" >Webpack5 的事件流和插件机制</a></p><p><a href="" target="_blank" >px2rem-loader[9], 或者 pxrem-loader[10]原理 ^_^</a></p><!-- <a href="https://cloud.tencent.com/developer/article/1432511" target="_blank" >Webpack 4 教程 - 第四部分，使用 SplitChunksPlugin 分离代码</a><a href="https://cloud.tencent.com/developer/article/1432714" target="_blank" >Webpack 4 教程 - 第七部分 减少打包体积与 Tree Shaking</a><a href="https://cloud.tencent.com/developer/article/1017015" target="_blank" >优化 Webpack 构建性能的几点建议</a>```js{  体积小： 合适的 source-map、减少代码体积、 webpack-bundle-analyzer进行分析  范围小：目录检索范围、检索路径  缓存：开启 loader、plugin 缓存  不重复打包：DLLPlugin + DLLRefrencePlugin 、 externals}``` --><p><a href="https://javajgs.com/archives/36777" target="_blank" >常见 loader 使用 , 不好看，有乱七八糟图片，img 样式设置 display: none;</a></p><ul><li>文件相关：</li><li>JSON 相关：</li><li>JS&#x2F;TS 转译:</li><li>模版：</li><li>样式：</li><li>lint 校验：</li><li>测试：</li><li>框架：</li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><a href="https://juejin.cn/post/6844903655330562062" target="_blank" >网站性能优化实战——从 12.67s 到 1.06s 的故事</a></p><p><a href="/#/post/2022-05-12performance" target="_blank" >浏览器首屏优化-首屏时间获取</a></p><h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><p><a href="https://blog.csdn.net/JHXL_?type=blog" target="_blank" >几何心凉</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http错误信息</title>
      <link href="//post/2022-06-15http.html"/>
      <url>//post/2022-06-15http.html</url>
      
        <content type="html"><![CDATA[<h2 id="http-错误信息"><a href="#http-错误信息" class="headerlink" title="http 错误信息"></a>http 错误信息</h2><pre class="line-numbers language-none"><code class="language-none">Request URL: http:&#x2F;&#x2F;localhost:8888&#x2F;api&#x2F;redline&#x2F;content_management&#x2F;api&#x2F;kbs&#x2F;search&#x2F;contentListRequest Method: POSTStatus Code: 403 ForbiddenRemote Address: [::1]:8888Referrer Policy: strict-origin-when-cross-origin</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;code&quot;: &quot;102&quot;,  &quot;message&quot;: &quot;ACL not allowed!&quot;,  &quot;rs&quot;: &#123;    &quot;possessionApplyUrl&quot;: &quot;https:&#x2F;&#x2F;acl.fast-inside.xxxxxx:7799&#x2F;#&#x2F;dataPermission&#x2F;roleApplication?projectCode&#x3D;content-management&amp;resourceCode&#x3D;POST:&#x2F;api&#x2F;kbs&#x2F;search&#x2F;contentList&quot;,    &quot;resourceName&quot;: &quot;api_kbs_search_contentList&quot;  &#125;,  &quot;failure&quot;: true,  &quot;success&quot;: false&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">return fetch(API_URL, options)  .then(checkStatus)  .then(parseJSON)  .then((result) &#x3D;&gt; &#123;    const &#123; success &#125; &#x3D; result;    if (!success &amp;&amp; !&#x2F;\&#x2F;api\&#x2F;jira&#x2F;.test(API_URL)) &#123;      return Promise.reject(result);    &#125;    return result;  &#125;)  .catch((e) &#x3D;&gt; &#123;    console.log(&#96;error API_URL :::$&#123;url&#125; $&#123;API_URL&#125;&#96;);    logger.info(&#96;API_URL :::$&#123;url&#125; $&#123;API_URL&#125;&#96;);    logger.info(&#96;Error ::: $&#123;e&#125;&#96;);    &#x2F;&#x2F; 会走到这里，这里只能获取到403相关信息，获取不到响应的内容  &#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia源码</title>
      <link href="//post/2022-06-14vue-pinia.html"/>
      <url>//post/2022-06-14vue-pinia.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>了解了 playground，现在我们来看看 pinia 源码，那些 api 和方法。这么用做了什么事情</p><p><code>this.$patch</code><a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/stores/counter.ts#L49" target="_blank" >playgound</a></p><p><code>defineStore</code></p><ul><li>第一个参数是唯一字符串，用来标识 store，第二个参数是一个函数，返回一个 store 对象 <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/stores/nasa-pod.ts#L6" target="_blank" >playground</a></li><li>第一个参数直接是配置项 <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/stores/jokesUsePromised.ts#L6" target="_blank" >playgound</a></li></ul><p>组件中直接通过<code>useXXStore获取store</code> <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/views/NasaPOD.vue#L52" target="_blank" >playground</a></p><p><code>state</code>怎么就是个函数，而且这个函数可以让我们自定义 store 的初始值<br><code>$dispose</code> <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/views/NasaPOD.vue#L49" target="_blank" >playgound</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">onUnmounted(() &#x3D;&gt; &#123;  userStore.$dispose();  cartStore.$dispose();  counterStore.$dispose();&#125;);</code></pre><p><code>import &#123; storeToRefs &#125; from &#39;pinia&#39;</code></p><p>以及 playground 没没有用到的 api</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const partialStore &#x3D; &#123;  _p: pinia,  &#x2F;&#x2F; _s: scope,  $id,  $onAction: addSubscription.bind(null, actionSubscriptions),  $patch,  $reset,  $subscribe,  $dispose,&#125; as _StoreWithState&lt;Id, S, G, A&gt;;const store: Store&lt;Id, S, G, A&gt; &#x3D; reactive(partialStore); &#x2F;&#x2F; 简化了，不考虑中间任何细节pinia._s.set($id, store);</code></pre><ul><li>$reset:该api是$patch的语法糖，只不过传递的参数是初始的state函数的执行结果，源码中<code>const newState = state? state() : &#123;&#125;</code></li><li>$patch：patch就是一次递归对value覆盖的过程</li><li>$subscribe： 有点类似观察者，当调用subscribe时，会将当前的状态信息保存到subscriptions</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><a href="https://www.jianshu.com/p/2acc2d043d35" target="_blank" >pinia源码解读–实现流程</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/2acc2d043d35" target="_blank" >pinia 源码解读–实现流程</a><br><a href="https://github.com/vuejs/pinia" target="_blank" >pinia</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia中的vue-demi源码</title>
      <link href="//post/2022-06-15vue-demi.html"/>
      <url>//post/2022-06-15vue-demi.html</url>
      
        <content type="html"><![CDATA[<h2 id="pinia-中的-vue-demi"><a href="#pinia-中的-vue-demi" class="headerlink" title="pinia 中的 vue-demi"></a>pinia 中的 vue-demi</h2><p>Vue Demi 是一个让你可以开发同时支持 Vue2 和 3 的通用的 Vue 库的开发工具，而无需担心用户安装的版本。</p><p>当用户要创建一个 Vue 插件&#x2F;库时，只需将 vue-demi 安装为依赖项并将其导入，然后像之前一样发布你的插件&#x2F;库，用户的软件包就会变得通用。</p><p>Vue Demi 使用了 NPM 钩子 postinstall。当用户安装所有包后，脚本将开始检查已安装的 Vue 版本，并根据 Vue 版本返回对应的代码。在使用 Vue 2 时，如果没有安装@vue&#x2F;composition-api，它也会自动安装.</p><p><strong>以前</strong></p><p>以前，要创建支持两个目标版本的 Vue 库，我们会使用不同的分支来分离对每个版本的支持。对于现有库来说，这是一个很好的方法，因为它们的代码库通常更稳定。<br>缺点是，你需要维护两个代码库，这让你的工作量翻倍。对于想要支持 Vue 的两个目标版本的新 Vue 库来说，我不推荐这种方法。实施两次功能请求和错误修复根本就不理想。</p><p><strong>现在</strong></p><p>这就是 Vue Demi 的用武之地。Vue Demi 通过为两个目标版本提供通用支持来解决这个问题，这意味着您只需构建一次即可获得两个目标版本的所有优点，从而获得两全其美的优势。</p><h2 id="核心代码目录"><a href="#核心代码目录" class="headerlink" title="核心代码目录"></a>核心代码目录</h2><pre class="line-numbers language-none"><code class="language-none">├── lib│   ├── index.cjs│   ├── index.d.ts│   ├── index.iife.js│   ├── index.mjs│   ├── v2│   │   ├── index.cjs│   │   ├── index.d.ts│   │   └── index.mjs│   ├── v2.7│   │   ├── index.cjs│   │   ├── index.d.ts│   │   └── index.mjs│   └── v3│       ├── index.cjs│       ├── index.d.ts│       └── index.mjs├── package.json└── scripts    ├── postinstall.js    ├── switch-cli.js    └── utils.js</code></pre><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p><strong>package.json</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;vue-demi&quot;,  &quot;version&quot;: &quot;0.13.1&quot;,  &quot;scripts&quot;: &#123;    &quot;postinstall&quot;: &quot;node .&#x2F;scripts&#x2F;postinstall.js&quot;, &#x2F;&#x2F; 钩子npm install结束后会执行    &quot;release&quot;: &quot;npx bumpp --tag --commit --push &amp;&amp; npm publish&quot;  &#125;,  &quot;peerDependencies&quot;: &#123;    &quot;@vue&#x2F;composition-api&quot;: &quot;^1.0.0-rc.1&quot;,    &quot;vue&quot;: &quot;^3.0.0-0 || ^2.6.0&quot;  &#125;,  &quot;peerDependenciesMeta&quot;: &#123;    &quot;@vue&#x2F;composition-api&quot;: &#123;      &quot;optional&quot;: true    &#125;  &#125;&#125;</code></pre><p><strong>scripts&#x2F;postinstall.js</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123; switchVersion, loadModule &#125; &#x3D; require(&quot;.&#x2F;utils&quot;);const Vue &#x3D; loadModule(&quot;vue&quot;); &#x2F;&#x2F; 加载vue, 通过Vue.version获取版本if (!Vue || typeof Vue.version !&#x3D;&#x3D; &quot;string&quot;) &#123;  console.warn(    &#39;[vue-demi] Vue is not found. Please run &quot;npm install vue&quot; to install.&#39;  );&#125; else if (Vue.version.startsWith(&quot;2.7.&quot;)) &#123;  switchVersion(2.7); &#x2F;&#x2F; 切换到2.7版本，拷贝内容到lib&#x2F;v2.7目录&#125; else if (Vue.version.startsWith(&quot;2.&quot;)) &#123;  switchVersion(2); &#x2F;&#x2F; 切换到2.7版本，拷贝内容到lib&#x2F;v2目录，并执行安装@vue&#x2F;composition-api，更新相关内容,执行v2api更新&#125; else if (Vue.version.startsWith(&quot;3.&quot;)) &#123;  &#x2F;&#x2F; 切换到3.0版本，拷贝内容到lib&#x2F;v3目录  switchVersion(3);&#125; else &#123;  console.warn(&#96;[vue-demi] Vue version v$&#123;Vue.version&#125; is not suppported.&#96;);&#125;</code></pre><p><strong>loadModule</strong>与<strong>switchVersion</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const fs &#x3D; require(&quot;fs&quot;);const path &#x3D; require(&quot;path&quot;);const dir &#x3D; path.resolve(__dirname, &quot;..&quot;, &quot;lib&quot;);&#x2F;&#x2F; loadModulefunction loadModule(name) &#123;  try &#123;    return require(name);  &#125; catch (e) &#123;    return undefined;  &#125;&#125;function copy(name, version, vue) &#123;  vue &#x3D; vue || &quot;vue&quot;;  const src &#x3D; path.join(dir, &#96;v$&#123;version&#125;&#96;, name);  const dest &#x3D; path.join(dir, name);  let content &#x3D; fs.readFileSync(src, &quot;utf-8&quot;);  content &#x3D; content.replace(&#x2F;&#39;vue&#39;&#x2F;g, &#96;&#39;$&#123;vue&#125;&#39;&#96;);  &#x2F;&#x2F; unlink for pnpm, #92  try &#123;    fs.unlinkSync(dest); &#x2F;&#x2F; 删除旧的文件  &#125; catch (error) &#123;&#125;  &#x2F;&#x2F; 写入新的文件  fs.writeFileSync(dest, content, &quot;utf-8&quot;);&#125;&#x2F;&#x2F; 更新vue2apifunction updateVue2API() &#123;  const ignoreList &#x3D; [&quot;version&quot;, &quot;default&quot;];  const VCA &#x3D; loadModule(&quot;@vue&#x2F;composition-api&quot;);  if (!VCA) &#123;    console.warn(      &#39;[vue-demi] Composition API plugin is not found. Please run &quot;npm install @vue&#x2F;composition-api&quot; to install.&#39;    );    return;  &#125;  const exports &#x3D; Object.keys(VCA).filter((i) &#x3D;&gt; !ignoreList.includes(i));  const esmPath &#x3D; path.join(dir, &quot;index.mjs&quot;);  let content &#x3D; fs.readFileSync(esmPath, &quot;utf-8&quot;);  &#x2F;&#x2F;源码仓库结果 @link https:&#x2F;&#x2F;github.com&#x2F;vueuse&#x2F;vue-demi&#x2F;blob&#x2F;813a8dadf3a8f12b3b4a1369ff2b8da6c813d97e&#x2F;lib&#x2F;v2&#x2F;index.mjs#L2  content &#x3D; content.replace(    &#x2F;\&#x2F;\*\*VCA-EXPORTS\*\*\&#x2F;[\s\S]+\&#x2F;\*\*VCA-EXPORTS\*\*\&#x2F;&#x2F;m,    &#96;&#x2F;**VCA-EXPORTS**&#x2F;export &#123; $&#123;exports.join(      &quot;, &quot;    )&#125; &#125; from &#39;@vue&#x2F;composition-api&#x2F;dist&#x2F;vue-composition-api.mjs&#39;&#x2F;**VCA-EXPORTS**&#x2F;&#96;  );  fs.writeFileSync(esmPath, content, &quot;utf-8&quot;);&#125;&#x2F;&#x2F; switchVersion 拷贝入口到对应的版本目录function switchVersion(version, vue) &#123;  copy(&quot;index.cjs&quot;, version, vue);  copy(&quot;index.mjs&quot;, version, vue);  copy(&quot;index.d.ts&quot;, version, vue);  &#x2F;&#x2F; 如果是v2还需要更新api  if (version &#x3D;&#x3D;&#x3D; 2) updateVue2API();&#125;module.exports.loadModule &#x3D; loadModule;module.exports.switchVersion &#x3D; switchVersion;</code></pre><h2 id="再来看下暴露的-api"><a href="#再来看下暴露的-api" class="headerlink" title="再来看下暴露的 api"></a>再来看下暴露的 api</h2><p><strong>pinia 中源码引用</strong></p><p><strong>pinia&#x2F;packages&#x2F;pinia&#x2F;src&#x2F;storeToRefs.ts</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123;  isReactive,  isRef,  isVue2,  toRaw,  toRef,  ToRefs,  toRefs,&#125; from &quot;vue-demi&quot;;</code></pre><p><strong>pinia&#x2F;packages&#x2F;pinia&#x2F;src&#x2F;rootStore.ts</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123;  App,  EffectScope,  getCurrentInstance,  inject,  InjectionKey,  Ref,&#125; from &quot;vue-demi&quot;;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; @link https:&#x2F;&#x2F;github.com&#x2F;vueuse&#x2F;vue-demi&#x2F;blob&#x2F;813a8dadf3a8f12b3b4a1369ff2b8da6c813d97e&#x2F;lib&#x2F;index.mjs#L27export * from &quot;vue&quot;;&#x2F;&#x2F; 除了暴露版本vue-demi产生的api还将vue的api也暴露了出来，在开发第三方包的时候，可以按照不同的版本，调用不同的apiexport &#123; Vue, Vue2, isVue2, isVue3, install &#125;;</code></pre><p>由上面的源码<code>export * from &quot;vue&quot;;</code>,我们可以从vue-demi中获取所有的api，这也是pinia中频繁使用<code>vue-demi</code>，却不见<code>vue</code>的原因</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_40021015/article/details/123658502" target="_blank" >vue Demi 同时支持 vue2 和 vue3</a><br><a href="https://madewith.cn/502" target="_blank" >https://madewith.cn/502</a><br><a href="https://github.com/vueuse/vue-demi" target="_blank" >vue-demi</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia源码分析 playground</title>
      <link href="//post/2022-06-13vue-pinia.html"/>
      <url>//post/2022-06-13vue-pinia.html</url>
      
        <content type="html"><![CDATA[<h2 id="playground-运行"><a href="#playground-运行" class="headerlink" title="playground 运行"></a>playground 运行</h2><p>是一个标准的 vue 项目</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;scripts&quot;: &#123;  &quot;release&quot;: &quot;node scripts&#x2F;release.mjs&quot;,  &quot;size&quot;: &quot;pnpm run -r size&quot;,  &quot;build&quot;: &quot;pnpm run -r build&quot;,  &quot;docs:build&quot;: &quot;pnpm run docs:api &amp;&amp; pnpm run -r docs:build --filter .&#x2F;packages&#x2F;docs&quot;,  &quot;play&quot;: &quot;pnpm run -r play&quot;,  &quot;build:dts&quot;: &quot;pnpm run -r build:dts --parallel&quot;,  &quot;lint&quot;: &quot;prettier -c --parser typescript \&quot;packages&#x2F;*&#x2F;&#123;src,__tests__,e2e&#125;&#x2F;**&#x2F;*.[jt]s?(x)\&quot;&quot;,  &quot;lint:fix&quot;: &quot;pnpm run lint --write&quot;,  &quot;test&quot;: &quot;pnpm run test:types &amp;&amp; pnpm run test:jest &amp;&amp; pnpm run -r test &amp;&amp; pnpm run build &amp;&amp; pnpm run build:dts &amp;&amp; pnpm test:dts&quot;,  &quot;test:jest&quot;: &quot;jest --coverage&quot;,  &quot;test:types&quot;: &quot;tsc --build .&#x2F;tsconfig.json&quot;,  &quot;test:dts&quot;: &quot;pnpm run -r test:dts&quot;,  &quot;docs:api&quot;: &quot;pnpm run -r docs:api --filter .&#x2F;packages&#x2F;docs&quot;&#125;</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>注意 node 版本 <code>The engine &quot;node&quot; is incompatible with this module. Expected version &quot;^12.20.0 || ^14.13.1 || &gt;=16.0.0&quot;.</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;pinia git:(v2) $ yarn yarn install v1.4.0     node&#x2F;14.17.4   ο node&#x2F;15.14.0     node&#x2F;16.13.1 Use up&#x2F;down arrow keys to select a version, return key to install, d to delete, q to quit info No lockfile found. [1&#x2F;4] 🔍  Resolving packages... warning conventional-changelog-cli &gt; tempfile &gt; uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;math-random for details. warning workspace-aggregator-d3702d10-5118-458d-9b17-8c5b340f31d0 &gt; @pinia&#x2F;nuxt &gt; @nuxt&#x2F;types &gt; @types&#x2F;autoprefixer &gt; @types&#x2F;browserslist@4.15.0: This is a stub types definition. browserslist provides its own type definitions, so you do not need this installed. warning workspace-aggregator-d3702d10-5118-458d-9b17-8c5b340f31d0 &gt; @pinia&#x2F;nuxt &gt; @nuxt&#x2F;types &gt; @types&#x2F;webpack &gt; @types&#x2F;anymatch@3.0.0: This is a stub types definition. anymatch provides its own type definitions, so you do not need this installed. [2&#x2F;4] 🚚  Fetching packages... error execa@6.1.0: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;^12.20.0 || ^14.13.1 || &gt;&#x3D;16.0.0&quot;. error An unexpected error occurred: &quot;Found incompatible module&quot;. info If you think this is a bug, please open a bug report with the information provided in &quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;pinia&#x2F;yarn-error.log&quot;. info Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;install for documentation about this command. 👑 ~&#x2F;Desktop&#x2F;pinia git:(v2) $ sudo n Password:   installed : v16.13.1 (with npm 8.1.2)</code></pre></p></div><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 全局安装pnpmnpm install -g pnpm# 根目录yarn</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn build &amp;&amp; yarn play</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>如果不运行 <code>yarn build</code>,你将看到如下报错信息，原因是<code>playgound/vite.config.ts</code>，内部写了<code>copyPiniaPlugin</code></p><p>[plugin:vite:import-analysis] Failed to resolve entry for package “pinia”. The package may have incorrect main&#x2F;module&#x2F;exports specified in its package.json: Failed to resolve entry for package “pinia”. The package may have incorrect main&#x2F;module&#x2F;exports specified in its package.json</div><h2 id="playgound-x2F-vite-config-ts"><a href="#playgound-x2F-vite-config-ts" class="headerlink" title="playgound&#x2F;vite.config.ts"></a>playgound&#x2F;vite.config.ts</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; defineConfig, Plugin &#125; from &quot;vite&quot;;import vue from &quot;@vitejs&#x2F;plugin-vue&quot;;import &#123; promises as fs &#125; from &quot;fs&quot;;import path from &quot;path&quot;;&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;export default defineConfig(&#123;  plugins: [vue(), copyPiniaPlugin()],  define: &#123;    &#x2F;&#x2F; __DEV__: &#39;true&#39;,    &#x2F;&#x2F; __BROWSER__: &#39;true&#39;,    __TEST__: &quot;false&quot;,  &#125;,  resolve: &#123;    &#x2F;&#x2F; alias: &#123;    &#x2F;&#x2F;   &#39;@vue&#x2F;composition-api&#39;: &#39;vue-demi&#39;,    &#x2F;&#x2F; &#125;,    dedupe: [&quot;vue-demi&quot;, &quot;vue&quot;],  &#125;,  optimizeDeps: &#123;    &#x2F;&#x2F; pinia项排除    exclude: [&quot;vue-demi&quot;, &quot;@vueuse&#x2F;shared&quot;, &quot;@vueuse&#x2F;core&quot;, &quot;pinia&quot;],  &#125;,&#125;);&#x2F;&#x2F; 拷贝pinia到项目中，避免编译function copyPiniaPlugin(): Plugin &#123;  return &#123;    name: &quot;copy-pinia&quot;,    async generateBundle() &#123;      const filePath &#x3D; path.resolve(__dirname, &quot;..&#x2F;pinia&#x2F;dist&#x2F;pinia.mjs&quot;); &#x2F;&#x2F; 注意这里，不执行 yarn build 这里是没有数据的，yarn play会报错      &#x2F;&#x2F; throws if file doesn&#39;t exist      await fs.access(filePath);      this.emitFile(&#123;        type: &quot;asset&quot;,        fileName: &quot;pinia.mjs&quot;,        source: await fs.readFile(filePath, &quot;utf-8&quot;),      &#125;);    &#125;,  &#125;;&#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220613184319.webp"></p><h2 id="playground-x2F-index-html"><a href="#playground-x2F-index-html" class="headerlink" title="playground&#x2F;index.html"></a>playground&#x2F;index.html</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!DOCTYPE html&gt;&lt;!-- html解析规则--&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;!-- 关键字符集 --&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;    &lt;!-- 方便手机端调整分辨率 --&gt;    &lt;title&gt;🍍 Pinia playground&lt;&#x2F;title&gt;    &lt;link      rel&#x3D;&quot;stylesheet&quot;      href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;@exampledev&#x2F;new.css@1&#x2F;new.min.css&quot;    &#x2F;&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;fonts.xz.style&#x2F;serve&#x2F;inter.css&quot; &#x2F;&gt;    &lt;!-- 一开始以为是 首屏优化，加载动画 运行后发现，并不是，仅仅是样式而已，代码中使用v-if 或v-else-if渲染加载动画--&gt;    &lt;!--       JokesPromised.vue       NasaPOD.vue       NasaPODwrc.vue     --&gt;    &lt;style&gt;      @keyframes spinner &#123;        to &#123;          transform: rotate(360deg);        &#125;      &#125;      .spinner:before &#123;        content: &quot;&quot;;        box-sizing: border-box;        position: absolute;        top: 50%;        left: 50%;        width: 30px;        height: 30px;        margin-top: -15px;        margin-left: -15px;        border-radius: 50%;        border: 1px solid #ccc;        border-top-color: #07d;        animation: spinner 0.6s linear infinite;      &#125;    &lt;&#x2F;style&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;!-- vue根节点 --&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;    &lt;!-- 模块加载 --&gt;    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.ts&quot;&gt;&lt;&#x2F;script&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="api-目录"><a href="#api-目录" class="headerlink" title="api 目录"></a>api 目录</h2><p>一些小练习，demo 之类的东西，我有点不明白的是，<code>pinia/packages/playground/src/api</code>下使用了<code>mande</code>,不能直接用<code>fetch</code>吗?</p><ul><li><code>mande</code><strong>Requires fetch support.</strong></li><li>Weekly Downloads 530 😓</li><li>Unpacked Size 47.3 kB<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为了炫技而写的，所以我没有用<code>fetch</code>，而是用了<code>mande</code>。——此处 AI 自动生成</p></blockquote></li></ul><h2 id="composables-目录"><a href="#composables-目录" class="headerlink" title="composables 目录"></a>composables 目录</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; useCachedRequest.ts&#x2F;&#x2F; pinia&#x2F;packages&#x2F;playground&#x2F;src&#x2F;composables&#x2F;useCachedRequest.tsexport function useCachedRequest&lt;T, U&gt;(  keySource: Ref&lt;U&gt;,  getter: (key: U) &#x3D;&gt; Promise&lt;T&gt; &#x2F;&#x2F; 这应该是一个接口) &#123;  const data &#x3D; ref&lt;T&gt;(); &#x2F;&#x2F; 存数据  const isLoading &#x3D; ref(false); &#x2F;&#x2F; 加载动画  const isReady &#x3D; ref(false); &#x2F;&#x2F; 是否已加载数据  const error &#x3D; ref&lt;Error | undefined&gt;(); &#x2F;&#x2F; 有没有出错  const cache &#x3D; new Map&lt;U, T&gt;(); &#x2F;&#x2F; 使用map实现缓存  onScopeDispose(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 清理缓存    cache.clear();  &#125;);  watchEffect(async () &#x3D;&gt; &#123;    const key &#x3D; unref(keySource);    isReady.value &#x3D; false; &#x2F;&#x2F; 是不是已拿到数据    isLoading.value &#x3D; true; &#x2F;&#x2F; 加载动画    if (cache.has(key)) &#123;      data.value &#x3D; cache.get(key)!;      isReady.value &#x3D; true;    &#125;    getter(key)      .then((newData) &#x3D;&gt; &#123;        cache.set(key, newData);        data.value &#x3D; newData;        isReady.value &#x3D; true;      &#125;)      .catch((err) &#x3D;&gt; &#123;        error.value &#x3D; err;      &#125;)      .finally(() &#x3D;&gt; &#123;        isLoading.value &#x3D; false;      &#125;);  &#125;);  return &#123; data, error, isLoading, isReady &#125;; &#x2F;&#x2F; 最后将这些值返回&#125;</code></pre><hr/><h2 style="text-aligin:center">小插曲</h2><p><strong>onScopeDispose</strong></p><p>这个 api 没见过，搜下其他人是怎么理解的</p><p>在 vue3.2 中新增了一个属性 EffectScope，官方文档的解释比较简单，只说是一个高级属性，并没有具体的示例。</p><p>antfu 大神的 vueuse 框架源码，里面大量使用 EffectScope，所以研究了一下这个属性的使用方法。</p><h2 id="什么是-EffectScope"><a href="#什么是-EffectScope" class="headerlink" title="什么是 EffectScope?"></a>什么是 EffectScope?</h2><p>下面是官方文档解释，感觉有点敷衍</p><p>Effect scope is an advanced API primarily intended for library authors. For details on how to leverage this API, please consult its corresponding RFC(opens new window).<br>这个 api 是高级的，主要用于库的开发者。更多详情，请参考其对应的 RFC(新窗口打开)。</p><p>RFC 关于 EffectScopeApi 的解释</p><p>在 Vue 的 setup 中，响应会在开始初始化的时候被收集，在实例被卸载的时候，响应就会自动的被取消追踪了，这时一个很方便的特性。但是，当我们在组件外使用或者编写一个独立的包时，这会变得非常麻烦。当在单独的文件中，我们该<strong>如何停止 computed &amp; watch 的响应式依赖呢？</strong></p><p>实际上 EffectScope 按我的理解就是副作用生效的作用域。</p><p>vue3 对响应式的监听是通过 effect 实现的，当我们的组件销毁的时候 vue 会自动取消该组件的 effect。</p><p>那么如果我们想要自己控制 effect 生效与否呢？ 比如我只想在莫种特定情况下才监听摸个 ref，其他情况下不想监听该怎么做？</p><p>vue3.2 之前</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F;（vue-RFC示例代码）const disposables &#x3D; [];const counter &#x3D; ref(0);const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);disposables.push(() &#x3D;&gt; stop(doubled.effect));const stopWatch1 &#x3D; watchEffect(() &#x3D;&gt; &#123;  console.log(&#96;counter: $&#123;counter.value&#125;&#96;);&#125;);disposables.push(stopWatch1);const stopWatch2 &#x3D; watch(doubled, () &#x3D;&gt; &#123;  console.log(doubled.value);&#125;);disposables.push(stopWatch2);</code></pre><h2 id="EffectScope-如何实现"><a href="#EffectScope-如何实现" class="headerlink" title="EffectScope 如何实现"></a>EffectScope 如何实现</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; effect, computed, watch, watchEffect created inside the scope will be collectedconst scope &#x3D; effectScope();scope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  watch(doubled, () &#x3D;&gt; console.log(doubled.value));  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; to dispose all effects in the scopescope.stop();</code></pre><p>示例;</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const scope &#x3D; effectScope();let counter &#x3D; ref(0);setInterval(() &#x3D;&gt; &#123;  counter.value++;&#125;, 1000);scope.run(() &#x3D;&gt; &#123;  watchEffect(() &#x3D;&gt; console.log(&#96;counter: $&#123;counter.value&#125;&#96;));&#125;);&#x2F;*log:counter: 0counter: 1counter: 2counter: 3counter: 4counter: 5*&#x2F;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const scope &#x3D; effectScope();let counter &#x3D; ref(0);setInterval(() &#x3D;&gt; &#123;  counter.value++;&#125;, 1000);scope.run(() &#x3D;&gt; &#123;  watchEffect(() &#x3D;&gt; console.log(&#96;counter: $&#123;counter.value&#125;&#96;));&#125;);scope.stop();&#x2F;*log:counter: 0*&#x2F;</code></pre><p>基本使用<br>新建一个 scope:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const scope &#x3D; effectScope();</code></pre><p>一个 scope 可以执行一个 run 函数（接受一个函数作为参数，并返回该函数的返回值），并且捕获所有在该函数执行过程中创建的 effect ，包括可以创建 effect 的 API，例如 computed , watch , watchEffect :</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">scope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  watch(doubled, () &#x3D;&gt; console.log(doubled.value));  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; the same scope can run multiple timesscope.run(() &#x3D;&gt; &#123;  watch(counter, () &#x3D;&gt; &#123;    &#x2F;*...*&#x2F;  &#125;);&#125;);</code></pre><p>当调用 scope.stop(), 所有被捕获的 effect 都会被取消，包括 nested Scopes 也会被递归取消</p><h2 id="Nested-Scopes"><a href="#Nested-Scopes" class="headerlink" title="Nested Scopes"></a>Nested Scopes</h2><p>嵌套 scope 也会被他们的父级 scope 收集。并且当父级 scope 销毁的时候，所有的后代 scope 也会被递归销毁。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const scope &#x3D; effectScope();scope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  &#x2F;&#x2F; not need to get the stop handler, it will be collected by the outer scope  effectScope().run(() &#x3D;&gt; &#123;    watch(doubled, () &#x3D;&gt; console.log(doubled.value));  &#125;);  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; dispose all effects, including those in the nested scopesscope.stop();</code></pre><h2 id="Detached-Nested-Scopes"><a href="#Detached-Nested-Scopes" class="headerlink" title="Detached Nested Scopes"></a>Detached Nested Scopes</h2><p>effectScope 接受一个参数可以在分离模式（detached mode）下创建。 detached scope 不会被父级 collect。</p><p>这一特性同时解决了一个 Issues lazy Initialization。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let nestedScope;const parentScope &#x3D; effectScope();parentScope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  &#x2F;&#x2F; with the detected flag,  &#x2F;&#x2F; the scope will not be collected and disposed by the outer scope  nestedScope &#x3D; effectScope(true &#x2F;* detached *&#x2F;);  nestedScope.run(() &#x3D;&gt; &#123;    watch(doubled, () &#x3D;&gt; console.log(doubled.value));  &#125;);  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; disposes all effects, but not &#96;nestedScope&#96;parentScope.stop();&#x2F;&#x2F; stop the nested scope only when appropriatenestedScope.stop();</code></pre><p>onScopeDispose<br>全局钩子函数 onScopeDispose 提供了类似于 onUnmounted 的功能，不同的是它工作在 scope 中而不是当前 instance。</p><p>这使得 composable functions 可以通过他们的 scope 清除他们的副作用。</p><p>由于 setup() 默认会为当前 instance 创建一个 scope，所以当没有明确声明一个 scope 的时候，onScopeDispose 等同于 onUnmounted。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; onScopeDispose &#125; from &quot;vue&quot;;const scope &#x3D; effectScope();scope.run(() &#x3D;&gt; &#123;  onScopeDispose(() &#x3D;&gt; &#123;    console.log(&quot;cleaned!&quot;);  &#125;);&#125;);scope.stop(); &#x2F;&#x2F; logs &#39;cleaned!&#39;</code></pre><p>Getting the current Scope</p><p>通过 getCurrentScope() 可以获取当前 scope</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; getCurrentScope &#125; from &quot;vue&quot;;getCurrentScope(); &#x2F;&#x2F; EffectScope | undefined</code></pre><p>实战<br>示例：Shared Composable<br>一些 composables 会设置全局副作用，例如如下的 useMouse() function:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function useMouse() &#123;  const x &#x3D; ref(0);  const y &#x3D; ref(0);  window.addEventListener(&quot;mousemove&quot;, handler);  function handler(e) &#123;    x.value &#x3D; e.x;    y.value &#x3D; e.y;  &#125;  onUnmounted(() &#x3D;&gt; &#123;    window.removeEventListener(&quot;mousemove&quot;, handler);  &#125;);  return &#123; x, y &#125;;&#125;</code></pre><p>如果在多个组件中调用 useMouse () ，则每个组件将附加一个 mouseemove 监听器，并创建自己的 x 和 y refs 副本。我们应该能够通过在多个组件之间共享相同的侦听器集和 refs 来提高效率，但是我们做不到，因为每个 onUnmounted 调用都耦合到一个组件实例。</p><p>我们可以使用分离作用域和 onScopeDispose 来实现这一点, 首先，我们需要用 onScopeDispose 替换 onUnmounted</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">- onUnmounted(() &#x3D;&gt; &#123;* onScopeDispose(() &#x3D;&gt; &#123;  window.removeEventListener(&#39;mousemove&#39;, handler)  &#125;)</code></pre><p>这仍然有效，因为 Vue 组件现在也在作用域内运行其 setup () ，该作用域将在组件卸载时释放。</p><p>然后，我们可以创建一个工具函数来管理父范围订阅:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function createSharedComposable(composable) &#123;  let subscribers &#x3D; 0;  let state, scope;  const dispose &#x3D; () &#x3D;&gt; &#123;    if (scope &amp;&amp; --subscribers &lt;&#x3D; 0) &#123;      scope.stop();      state &#x3D; scope &#x3D; null;    &#125;  &#125;;  &#x2F;&#x2F; 这里只有在第一次运行的时候创建一个 state, 后面所有的组件就不会再创建新的 state，而是共用一个 state  return (...args) &#x3D;&gt; &#123;    subscribers++;    if (!state) &#123;      scope &#x3D; effectScope(true);      state &#x3D; scope.run(() &#x3D;&gt; composable(...args));    &#125;    onScopeDispose(dispose);    return state;  &#125;;&#125;</code></pre><p>现在我们就可以使用这个 shared 版本的 useMouse</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const useSharedMouse &#x3D; createSharedComposable(useMouse);</code></pre><p>通过这个例子，不禁想到，是否可以通过这种模式模拟 vuex 的能力？我们是否可以通过 shared composables 更加灵活的达到全局状态管理的目的呢？</p><p>作者：zifeiyu<br>链接：<a href="https://juejin.cn/post/7019241635942760455">https://juejin.cn/post/7019241635942760455</a></p><p>总结：说了一大堆，大概意思是提供在组件外进行副作用清理的 api，这也是为什么说给库的开发者使用</p><hr/><h2 id="stores-目录，对应-v2-的-vuex"><a href="#stores-目录，对应-v2-的-vuex" class="headerlink" title="stores 目录，对应 v2 的 vuex"></a>stores 目录，对应 v2 的 vuex</h2><p>一个购物车的例子</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; .&#x2F;&#x2F; ├── cart.ts&#x2F;&#x2F; ├── counter.ts&#x2F;&#x2F; ├── counterSetup.ts&#x2F;&#x2F; ├── demo-counter.ts&#x2F;&#x2F; ├── jokes-swrv.ts&#x2F;&#x2F; ├── jokes.ts&#x2F;&#x2F; ├── jokesUsePromised.ts&#x2F;&#x2F; ├── nasa-pod.ts&#x2F;&#x2F; ├── nasa.ts&#x2F;&#x2F; └── user.ts</code></pre><p><strong>user.ts</strong></p><p>定义 useUserStore，id 为‘user’, state 两个字段，<br>actions 1. 登录，调用的是 apiLogin 接口，调用成功后进行数据<code>this.$patch</code>批量更新<br>actions 2. 退出登录</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore &#x3D; defineStore(&quot;user&quot;, &#123;  state: () &#x3D;&gt; (&#123;    name: &quot;Eduardo&quot;,    isAdmin: true,  &#125;),  actions: &#123;    &#x2F;**     * Attempt to login a user     *&#x2F;    async login(user: string, password: string) &#123;      const userData &#x3D; await apiLogin(user, password);      this.$patch(&#123;        name: user,        ...userData,      &#125;);    &#125;,    logout() &#123;      this.$patch(&#123;        name: &quot;&quot;,        isAdmin: false,      &#125;);      &#x2F;&#x2F; we could do other stuff like redirecting the user    &#125;,  &#125;,&#125;);&#x2F;** * Simulate a login 模拟登录 *&#x2F;function apiLogin(a: string, p: string) &#123;  if (a &#x3D;&#x3D;&#x3D; &quot;ed&quot; &amp;&amp; p &#x3D;&#x3D;&#x3D; &quot;ed&quot;) return Promise.resolve(&#123; isAdmin: true &#125;); &#x2F;&#x2F; 管理员  if (p &#x3D;&#x3D;&#x3D; &quot;ed&quot;) return Promise.resolve(&#123; isAdmin: false &#125;); &#x2F;&#x2F; 非管理员  return Promise.reject(new Error(&quot;invalid credentials&quot;)); &#x2F;&#x2F; 游客未认证&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; counter.tsimport &#123; acceptHMRUpdate, defineStore &#125; from &quot;pinia&quot;;const delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t));export const useCounter &#x3D; defineStore(&#123;  id: &quot;counter&quot;,  state: () &#x3D;&gt; (&#123;    n: 2,    incrementedTimes: 0,    decrementedTimes: 0,    numbers: [] as number[],  &#125;),  getters: &#123;    double: (state) &#x3D;&gt; state.n * 2,  &#125;,  actions: &#123;    increment(amount &#x3D; 1) &#123;      if (typeof amount !&#x3D;&#x3D; &quot;number&quot;) &#123;        amount &#x3D; 1;      &#125;      this.incrementedTimes++;      this.n +&#x3D; amount;    &#125;,    changeMe() &#123;      console.log(&quot;change me to test HMR&quot;);    &#125;,    async fail() &#123;      const n &#x3D; this.n;      await delay(1000);      this.numbers.push(n);      await delay(1000);      if (this.n !&#x3D;&#x3D; n) &#123;        throw new Error(&quot;Someone changed n!&quot;);      &#125;      return n;    &#125;,    async decrementToZero(interval: number &#x3D; 300, usePatch &#x3D; true) &#123;      if (this.n &lt;&#x3D; 0) return;      while (this.n &gt; 0) &#123;        if (usePatch) &#123;          this.$patch(&#123;            &#x2F;&#x2F; 这个就比较奇怪了，我严重怀疑这里的(usePatch &#x3D; true 与 usePatch &#x3D; false)数据不一致            n: this.n - 1,            decrementedTimes: this.decrementedTimes + 1,          &#125;);          &#x2F;&#x2F; this.$patch(state &#x3D;&gt; &#123;          &#x2F;&#x2F;   state.n--          &#x2F;&#x2F;   state.decrementedTimes++          &#x2F;&#x2F; &#125;)        &#125; else &#123;          this.n -&#x3D; 1;        &#125;        await delay(interval);      &#125;    &#125;,  &#125;,&#125;);&#x2F;&#x2F; 这个地方没看懂.if (import.meta.hot) &#123;  &#x2F;&#x2F; @link: https:&#x2F;&#x2F;www.jb51.net&#x2F;article&#x2F;244749.htm  &#x2F;&#x2F; import.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象，它包含了这个模块的信息。  &#x2F;&#x2F; Pinia 是 vuex 新替代方案。Pinia 中热更新实现，借助 import.meta。  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot));&#125;</code></pre><p>counterSetup.ts 结合 vue 做了很多操作，最后只返回了一个 state,没有 getters,actions<br>以下为 state 上的方法</p><ul><li>double,</li><li>increment,</li><li>fail,</li><li>changeMe,</li><li>decrementToZero,</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; counterSetupimport &#123; computed, toRefs, reactive &#125; from &quot;vue&quot;;import &#123; acceptHMRUpdate, defineStore &#125; from &quot;pinia&quot;;const delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t));export const useCounter &#x3D; defineStore(&quot;counter-setup&quot;, () &#x3D;&gt; &#123;  const state &#x3D; reactive(&#123;    &#x2F;&#x2F; vue    n: 0,    incrementedTimes: 0,    decrementedTimes: 0,    numbers: [] as number[],  &#125;);  const double &#x3D; computed(() &#x3D;&gt; state.n * 2); &#x2F;&#x2F; vue  function increment(amount &#x3D; 1) &#123;    if (typeof amount !&#x3D;&#x3D; &quot;number&quot;) &#123;      amount &#x3D; 1;    &#125;    state.incrementedTimes++;    state.n +&#x3D; amount;  &#125;  function changeMe() &#123;    console.log(&quot;change me to test HMR&quot;);  &#125;  &#x2F;&#x2F;  async function fail() &#123;    const n &#x3D; state.n;    await delay(1000);    state.numbers.push(n);    await delay(1000);    if (state.n !&#x3D;&#x3D; n) &#123;      throw new Error(&quot;Someone changed n!&quot;);    &#125;    return n;  &#125;  &#x2F;&#x2F; 定时器直到减少到0  async function decrementToZero(interval: number &#x3D; 300) &#123;    if (state.n &lt;&#x3D; 0) return;    while (state.n &gt; 0) &#123;      state.n -&#x3D; 1;      state.decrementedTimes +&#x3D; 1;      await delay(interval);    &#125;  &#125;  return &#123;    ...toRefs(state), &#x2F;&#x2F; vue将 state 转换为 refs， TODO：toRefs这个之后可以看下源码做了怎样的处理    double,    increment,    fail,    changeMe,    decrementToZero,  &#125;;&#125;);if (import.meta.hot) &#123;  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot));&#125;</code></pre><p>demo-counter.ts 只返回一个箭头函数简写的state</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; demo-counter.tsimport &#123; defineStore, acceptHMRUpdate &#125; from &#39;pinia&#39;const delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t))&#x2F;&#x2F; just to ignore the not used errordelay(0)export const useCounter &#x3D; defineStore(&#39;demo-counter&#39;, &#123;  state: () &#x3D;&gt; (&#123;    n: 0,  &#125;),&#125;)if (import.meta.hot) &#123;  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot))&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; jokes-swrv.tsimport &#123; ref, toRaw, watch &#125; from &#39;vue&#39;import &#123; acceptHMRUpdate, defineStore &#125; from &#39;pinia&#39;import &#123; getRandomJoke, Joke &#125; from &#39;..&#x2F;api&#x2F;jokes&#39;import useSWRV from &#39;swrv&#39; &#x2F;&#x2F; @link https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;swrvexport const useJokesSetup &#x3D; defineStore(&#39;jokes-swrv-setup&#39;, () &#x3D;&gt; &#123;  &#x2F;&#x2F; const current &#x3D; ref&lt;null | Joke&gt;(null)  const history &#x3D; ref&lt;Joke[]&gt;([])  &#x2F;&#x2F; useSWRV vue组合式网络请求，之前了解代码&#96;pinia&#x2F;packages&#x2F;playground&#x2F;src&#x2F;api&#96; 中使用了‘mande’，做网络请求，我想这应该是作者为了给开发者提供更多的场景来学习pinia  const &#123; data, error, mutate &#125; &#x3D; useSWRV(&#39;jokes&#39;, getRandomJoke)  &#x2F;&#x2F; 监听data变化  watch(data, (joke) &#x3D;&gt; &#123;    console.log(&#39;changed from within the store&#39;, joke)    if (joke) &#123;      &#x2F;&#x2F; 响应式数据，  history是响应式的，需要用.value来操作      history.value.push(toRaw(joke))    &#125;  &#125;)  return &#123; current: data, error, history, fetchJoke: mutate &#125;&#125;)if (import.meta.hot) &#123;  &#x2F;&#x2F; import.meta.hot.accept(acceptHMRUpdate(useJokes, import.meta.hot))  import.meta.hot.accept(acceptHMRUpdate(useJokesSetup, import.meta.hot))&#125;</code></pre><p> jokes.ts 文件下，写了useJokes 和 useJokesSetup</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; jokes.tsimport &#123; ref, unref &#125; from &#39;vue&#39;import &#123; acceptHMRUpdate, defineStore &#125; from &#39;pinia&#39;import &#123; getRandomJoke, Joke &#125; from &#39;..&#x2F;api&#x2F;jokes&#39;export const useJokes &#x3D; defineStore(&#39;jokes&#39;, &#123;  state: () &#x3D;&gt; (&#123;    current: null as null | Joke,    jokes: [] as Joke[],    &#x2F;&#x2F; hello: true,  &#125;),  actions: &#123;    async fetchJoke() &#123;      if (        this.current &amp;&amp;        &#x2F;&#x2F; if the request below fails, avoid adding it twice        &#x2F;&#x2F; 如果请求失败，就不要添加进历史记录        !this.jokes.includes(this.current)      ) &#123;        this.jokes.push(this.current)      &#125;      &#x2F;&#x2F; NOTE: Avoid patching an object because it&#39;s recursive      &#x2F;&#x2F; 注意：不要更新一个对象，因为它是递归的      &#x2F;&#x2F; this.$patch(&#123; current: await getRandomJoke() &#125;)      this.current &#x3D; await getRandomJoke()    &#125;,  &#125;,&#125;)export const useJokesSetup &#x3D; defineStore(&#39;jokes-setup&#39;, () &#x3D;&gt; &#123;  const current &#x3D; ref&lt;null | Joke&gt;(null)  const history &#x3D; ref&lt;Joke[]&gt;([])  async function fetchJoke() &#123;    const cur &#x3D; unref(current.value)    if (      cur &amp;&amp;      &#x2F;&#x2F; if the request below fails, avoid adding it twice      !history.value.find((joke) &#x3D;&gt; joke.id &#x3D;&#x3D;&#x3D; cur.id)    ) &#123;      history.value.push(cur)    &#125;    current.value &#x3D; await getRandomJoke()    return current.value  &#125;  return &#123; current, history, fetchJoke &#125;&#125;)if (import.meta.hot) &#123;  import.meta.hot.accept(acceptHMRUpdate(useJokes, import.meta.hot))  &#x2F;&#x2F; import.meta.hot.accept(acceptHMRUpdate(useJokesSetup, import.meta.hot))&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript event</title>
      <link href="//post/2022-06-13event.html"/>
      <url>//post/2022-06-13event.html</url>
      
        <content type="html"><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><pre class="line-numbers language-none"><code class="language-none">react_devtools_backend.js:4026 Warning: This synthetic event is reused for performance reasons. If you&#39;re seeing this, you&#39;re accessing the property &#96;target&#96; on a released&#x2F;nullified synthetic event. This is set to null. If you must keep the original synthetic event around, use event.persist(). See https:&#x2F;&#x2F;fb.me&#x2F;react-event-pooling for more information.</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">event.persist();</code></pre><h2 id="代码描述及修改"><a href="#代码描述及修改" class="headerlink" title="代码描述及修改"></a>代码描述及修改</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++const handleConfirmUpload &#x3D; useCallback(async (event, index: number) &#x3D;&gt; &#123;  event.persist(); &#x2F;&#x2F; 不加此处，导致上述问题  setConfirmFileReplace(true);  fileReplaceCache.current &#x3D; &#123;    event,    index,  &#125;;&#125;, []);&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++const handleCloseFileReplace &#x3D; useCallback(async () &#x3D;&gt; &#123;  setConfirmFileReplace(false);  fileReplaceCache.current &#x3D; null;&#125;, []);&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++const handleConfirmFileReplace &#x3D; useCallback(async () &#x3D;&gt; &#123;  if (fileReplaceCache.current) &#123;    handleUploadChange(      fileReplaceCache.current?.event,      fileReplaceCache.current?.index    );  &#125;&#125;, [fileReplaceCache.current]);&#x2F;&#x2F; 为了保证此函数内部不变const handleUploadChange &#x3D; useCallback(async (event, index: number) &#x3D;&gt; &#123;  const files &#x3D; event.target?.files;  if (!files || files?.length &#x3D;&#x3D;&#x3D; 0) return;&#125;, []);</code></pre><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>点击 <a href="https://fb.me/react-event-pooling" target="_blank" >查看链接提示</a></p><p><strong>Event Pooling</strong></p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>This page is only relevant for React 16 and earlier, and for React Native.<br>这个页面只适用于 React 16 和更早的版本，以及 React Native。<br>React 17 on the web does not use event pooling.<br>React17 在web中没有使用事件循环<br>Read more about this change in React 17.</div><p>The SyntheticEvent objects are pooled. This means that the SyntheticEvent object will be reused and all properties will be nullified after the event handler has been called. For example, this won’t work:<br><em>SyntheticEvent对象被合并。这意味着将重用SyntheticEvent对象，并且在调用事件处理程序后，所有属性都将为null。例如，这将不起作用：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function handleChange(e) &#123;  &#x2F;&#x2F; This won&#39;t work because the event object gets reused.  &#x2F;&#x2F; 这不起作用，因为事件对象被重用了。  setTimeout(() &#x3D;&gt; &#123;    console.log(e.target.value); &#x2F;&#x2F; Too late! 太迟了  &#125;, 100);&#125;</code></pre><p>If you need to access event object’s properties after the event handler has run, you need to call e.persist():<br><em>如果需要在事件处理程序运行后访问事件对象的属性，则需要调用<code>e.persist()</code>：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function handleChange(e) &#123;  &#x2F;&#x2F; Prevents React from resetting its properties:  &#x2F;&#x2F; 阻止React重置其属性  e.persist();  setTimeout(() &#x3D;&gt; &#123;    console.log(e.target.value); &#x2F;&#x2F; Works 没问题  &#125;, 100);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Pinia</title>
      <link href="//post/2022-06-10vue-pinia.html"/>
      <url>//post/2022-06-10vue-pinia.html</url>
      
        <content type="html"><![CDATA[<h2 id="Pinia-特点"><a href="#Pinia-特点" class="headerlink" title="Pinia 特点"></a>Pinia 特点</h2><p><strong>💡 Intuitive</strong><br><code>直观的</code><br>Stores are as familiar as components. API designed to let you write well organized stores.<br><code>存储和组件是一样的。API设计了让你写好组织的存储。</code></p><p><strong>🔑 Type Safe</strong><br><code>类型安全的</code><br>Types are inferred, which means stores provide you with autocompletion even in JavaScript!<br><code>类型可推测，这意味着存储提供了你在JavaScript中自动完成的功能！</code></p><p><strong>⚙️ Devtools support</strong><br><code>开发工具支持</code><br>Pinia hooks into Vue devtools to give you an enhanced development experience in both Vue 2 and Vue 3.<br><code>Pinia钩子进入Vue开发工具，让你在Vue 2和Vue 3中获得强化开发经验。</code></p><p><strong>🔌 Extensible</strong><br><code>可扩展的</code><br>React to store changes to extend Pinia with transactions, local storage synchronization, etc.<br><code>通过事务、本地存储同步等来响应存储更改以扩展Pinia。</code></p><p><strong>🏗 Modular by design</strong><br><code>设计模块化</code><br>Build multiple stores and let your bundler code split them automatically.<br><code>构建多个存储，让你的bundler代码分开它们自动。</code></p><p><strong>📦 Extremely light</strong><br><code>非常轻量的</code><br>Pinia weighs around 1kb, you will forget it’s even there!<br><code>Pinia约1kb，你会忘记它在那里！</code></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><code>介绍</code></p><p><VueSchoolLink  href="https://vueschool.io/lessons/introduction-to-pinia"  title="Get started with Pinia"/></p><p>Pinia <a href="https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e">started</a> as an experiment to redesign what a Store for Vue could look like with the <a href="https://github.com/vuejs/composition-api">Composition API</a> around November 2019. Since then, the initial principles are still the same, but Pinia works for both Vue 2 and Vue 3 <strong>and doesn’t require you to use the composition API</strong>. The API is the same for both except for <em>installation</em> and <em>SSR</em>, and these docs are targeted to Vue 3 <strong>with notes about Vue 2</strong> whenever necessary so it can be read by Vue 2 and Vue 3 users!</p><p><em>译：Pinia 从 2019 年 11 月左右开始尝试重新设计 Vue store 的合成 API。从那时起，最初的原则仍然是一样的，但 Pinia 同时适用于 Vue 2 和 Vue 3，不需要您使用合成 API。除了安装和 SSR 之外，这两个 API 都是相同的，这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的说明，以便 Vue 2 和 Vue 3 用户可以阅读！</em></p><p><strong>Why should I use Pinia?</strong></p><p><code>为什么我应该使用Pinia？</code></p><p>Pinia is a store library for Vue, it allows you to share a state across components&#x2F;pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple <code>export const state = reactive(&#123;&#125;)</code>. This is true for single page applications but <strong>exposes your application to <a href="https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution">security vulnerabilities</a></strong> if it is server side rendered. But even in small single page applications, you get a lot from using Pinia:</p><p><em>译：Pinia 是一个 Vue 的存储库，它允许你在组件&#x2F;页面之间共享状态。如果你熟悉合成 API，你可能会认为你可以通过简单的<code>export const state = reactive(&#123;&#125;)</code>共享全局状态。这是对于单页应用的真实情况，但</em> **如果它是服务器端渲染，它会暴露您的应用程序到<a href="https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution">安全漏洞</a>**。<em>但即使是小的单页应用，使用 Pinia 也很多：</em></p><ul><li>Devtools support <em>开发工具支持</em><ul><li>A timeline to track actions, mutations <em>追踪行动、突变的时间表</em></li><li>Stores appear in components where they are used <em>存储出现在使用它们的组件中</em></li><li>Time travel and easier debugging <em>时间旅行和更容易调试</em></li></ul></li><li>Hot module replacement <em>快速更新</em><ul><li>Modify your stores without reloading your page <em>在不重新加载页面的情况下修改你的存储</em></li><li>Keep any existing state while developing <em>在开发时保持任何现有状态</em></li></ul></li><li>Plugins: extend Pinia features with plugins <em>功能扩展：使用插件扩展 Pinia 功能</em></li><li>Proper TypeScript support or <strong>autocompletion</strong> for JS users *对于 JS 用户的正确的 TypeScript 支持或<strong>自动完成*</strong></li><li>Server Side Rendering Support <em>完美的服务器端渲染支持</em></li></ul><p><strong>Basic example</strong></p><p><code>基本示例</code><br>This is what using pinia looks like in terms of API (make sure to check the <a href="./getting-started.md">Getting Started</a> for complete instructions). You start by creating a store:<br><em>译：这是为什么使用 pinia 看起来像 API（请检查<a href="./getting-started.md">开始</a>以获取完整的指令）。你首先创建一个存储：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; stores&#x2F;counter.jsimport &#123; defineStore &#125; from &quot;pinia&quot;;export const useCounterStore &#x3D; defineStore(&quot;counter&quot;, &#123;  state: () &#x3D;&gt; &#123;    return &#123; count: 0 &#125;;  &#125;,  &#x2F;&#x2F; could also be defined as  &#x2F;&#x2F; state: () &#x3D;&gt; (&#123; count: 0 &#125;)  actions: &#123;    increment() &#123;      this.count++;    &#125;,  &#125;,&#125;);</code></pre><p>And then you <em>use</em> it in a component:<br><em>译：然后你在组件中<code>使用</code>它：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useCounterStore &#125; from &quot;@&#x2F;stores&#x2F;counter&quot;;export default &#123;  setup() &#123;    const counter &#x3D; useCounterStore();    counter.count++;    &#x2F;&#x2F; with autocompletion ✨    counter.$patch(&#123; count: counter.count + 1 &#125;);    &#x2F;&#x2F; or using an action instead    counter.increment();  &#125;,&#125;;</code></pre><p>You can even use a function (similar to a component <code>setup()</code>) to define a Store for more advanced use cases:<br><em>译：你也可以使用函数（与组件<code>setup()</code>相似）来定义一个存储以更高级的使用情况：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export const useCounterStore &#x3D; defineStore(&quot;counter&quot;, () &#x3D;&gt; &#123;  const count &#x3D; ref(0);  function increment() &#123;    count.value++;  &#125;  return &#123; count, increment &#125;;&#125;);</code></pre><p>If you are still not into <code>setup()</code> and Composition API, don’t worry, Pinia also support a similar set of <a href="https://vuex.vuejs.org/guide/state.html#the-mapstate-helper"><em>map helpers</em> like Vuex</a>. You define stores the same way but then use <code>mapStores()</code>, <code>mapState()</code>, or <code>mapActions()</code>:<br><em>译：如果你还不是<code>setup()</code>和 Composition API 的熟悉，不用担心，Pinia 也支持<a href="https://vuex.vuejs.org/guide/state.html#the-mapstate-helper">Vuex 的<em>map helpers</em>（如 Vuex）</a>。你定义存储的方式相同，然后使用<code>mapStores()</code>, <code>mapState()</code>,或<code>mapActions()</code>：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const useCounterStore &#x3D; defineStore(&quot;counter&quot;, &#123;  state: () &#x3D;&gt; (&#123; count: 0 &#125;),  getters: &#123;    double: (state) &#x3D;&gt; state.count * 2,  &#125;,  actions: &#123;    increment() &#123;      this.count++;    &#125;,  &#125;,&#125;);const useUserStore &#x3D; defineStore(&quot;user&quot;, &#123;  &#x2F;&#x2F; ...&#125;);export default &#123;  computed: &#123;    &#x2F;&#x2F; other computed properties    &#x2F;&#x2F; ...    &#x2F;&#x2F; gives access to this.counterStore and this.userStore    ...mapStores(useCounterStore, useUserStore),    &#x2F;&#x2F; gives read access to this.count and this.double    ...mapState(useCounterStore, [&quot;count&quot;, &quot;double&quot;]),  &#125;,  methods: &#123;    &#x2F;&#x2F; gives access to this.increment()    ...mapActions(useCounterStore, [&quot;increment&quot;]),  &#125;,&#125;;</code></pre><p>You will find more information about each <em>map helper</em> in the core concepts.<br><em>译：你将找到更多关于每个<em>map helper</em>的信息。</em></p><p><strong>Why <em>Pinia</em></strong></p><p><em>为什么叫 Pinia</em></p><p>Pinia (pronounced <code>/piːnjʌ/</code>, like “peenya” in English) is the closest word to <em>piña</em> (<em>pineapple</em> in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It’s also a delicious tropical fruit indigenous to South America.</p><p><em>Pinia 发音 <code>/piːnjʌ/</code>，类似于英语中的“柠檬”，它是一个有效的包名。一个柠檬是实际上是一组单个花朵结合在一起，以创建多个水果。与存储相似，每一个都是单独出生的，但是他们都是最终连接在一起的。它也是一个在南美洲的美食。</em></p><p><strong>A more realistic example</strong></p><p><em>译：更真实的例子</em><br>Here is a more complete example of the API you will be using with Pinia <strong>with types even in JavaScript</strong>. For some people, this might be enough to get started without reading further but we still recommend checking the rest of the documentation or even skipping this example and coming back once you have read about all of the <em>Core Concepts</em>.<br><em>译：这是一个更完整的例子，你将使用 Pinia<strong>类型在 JavaScript</strong>。对于一些人，这可能是足够开始而不需要阅读更多，但我们仍然建议检查其余的文档或跳过这个例子，然后回来一次你已经阅读了所有的<strong>核心概念</strong>。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; defineStore &#125; from &quot;pinia&quot;;export const todos &#x3D; defineStore(&quot;todos&quot;, &#123;  state: () &#x3D;&gt; (&#123;    &#x2F;** @type &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125; *&#x2F;    todos: [],    &#x2F;** @type &#123;&#39;all&#39; | &#39;finished&#39; | &#39;unfinished&#39;&#125; *&#x2F;    filter: &quot;all&quot;,    &#x2F;&#x2F; type will be automatically inferred to number    &#x2F;&#x2F; 类型将自动推断为number    nextId: 0,  &#125;),  getters: &#123;    finishedTodos(state) &#123;      &#x2F;&#x2F; autocompletion! ✨      &#x2F;&#x2F; 自动完成      return state.todos.filter((todo) &#x3D;&gt; todo.isFinished);    &#125;,    unfinishedTodos(state) &#123;      return state.todos.filter((todo) &#x3D;&gt; !todo.isFinished);    &#125;,    &#x2F;**     * @returns &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125;     *&#x2F;    filteredTodos(state) &#123;      if (this.filter &#x3D;&#x3D;&#x3D; &quot;finished&quot;) &#123;        &#x2F;&#x2F; call other getters with autocompletion ✨        &#x2F;&#x2F; 调用其他getters自动完成        return this.finishedTodos;      &#125; else if (this.filter &#x3D;&#x3D;&#x3D; &quot;unfinished&quot;) &#123;        return this.unfinishedTodos;      &#125;      return this.todos;    &#125;,  &#125;,  actions: &#123;    &#x2F;&#x2F; any amount of arguments, return a promise or not    &#x2F;&#x2F; 任意数量的参数，返回一个promise或不    addTodo(text) &#123;      &#x2F;&#x2F; you can directly mutate the state      &#x2F;&#x2F; 你可以直接修改状态      this.todos.push(&#123; text, id: this.nextId++, isFinished: false &#125;);    &#125;,  &#125;,&#125;);</code></pre><p><strong>Comparison with Vuex</strong></p><p><em>译：与 Vuex 比较</em></p><p>Pinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.<br><em>译：Pinia 开始了一个探索 Vuex 的下一个迭代，并且将大量的想法从 Vuex 5 的核心团队讨论中提取。最终，我们认为 Pinia 已经实现了大部分我们想要的 Vuex 5，并且决定改变它的推荐。</em><br>Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.<br><em>译：与 Vuex 比较，Pinia 提供了更简单的 API，提供了组合 API 的 API，并且在使用 TypeScript 时有实体类型支持。</em></p><p><strong>RFCs</strong></p><p><em>译：RFCs</em></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>RFCs 涵盖了 Vue 的最基本的四个部分，截至目前为止，已经有 38 个 PR 提交（26 个仍在讨论中），这些提议中既有 Vue 作者自己的提议，也有开发者的提议。</p><ul><li>Vue core</li><li>Vue Router</li><li>Vuex</li><li>Vue CLI</li></ul></blockquote><p>Initially Pinia didn’t go through any RFC. I tested out ideas based on my experience developing applications, reading other people’s code, working for clients who use Pinia, and answering questions on Discord.<br>This allowed me to provide a solution that works and is adapted to a variety of cases and application sizes. I used to publish often and made the library evolve while keeping its core API the same.<br><em>译：初始 Pinia 没有通过任何 RFC。我测试了基于我的经验开发应用程序，阅读其他人的代码，为使用 Pinia 的客户工作，并在 Discord 上回答问题。这让我提供了一个解决方案，它工作并适合各种情况和应用程序大小。我经常发布，并在保持核心 API 相同的情况下，使库发展。</em><br>Now that Pinia has become the default state management solution, it is subject to the same RFC process as other core libraries in the Vue ecosystem and its API has entered a stable state.<br><em>译：现在，Pinia 已经成为 Vue 的核心状态管理解决方案，它与 Vue 社区中其他核心库的 RFC 进行了相同的处理，并且它的 API 已经进入了一个稳定状态。</em></p><p><strong>Comparison with Vuex 3.x&#x2F;4.x</strong></p><p><em>译：与 Vuex 3.x&#x2F;4.x 比较</em></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Vuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3<br>Vuex 3.x 是 Vuex 2 的 Vuex，而 Vuex 4.x 是 Vue 3 的 Vuex<br>Pinia API is very different from Vuex ≤4, namely:<br><em>译：Pinia API 与 Vuex 3.x&#x2F;4.x 比较，主要区别是：</em></p></blockquote><ul><li><em>mutations</em> no longer exist. They were very often perceived as <strong><em>extremely</em> verbose</strong>. They initially brought devtools integration but that is no longer an issue.<br><code>- mutations 不再存在。它们初始上抛了开发工具集成，但这不再是问题。</code></li><li>No need to create custom complex wrappers to support TypeScript, everything is typed and the API is designed in a way to leverage TS type inference as much as possible.<br><code>- 没有需要创建自定义复杂的包装来支持TypeScript，所有的都是类型化的，API设计了一个让你最大限度地利用TS类型推断的方式。</code></li><li>No more magic strings to inject, import the functions, call them, enjoy autocompletion!<br><code>- 没有更多的魔法字符串注入，导入函数，调用它们，享受自动完成！</code></li><li>No need to dynamically add stores, they are all dynamic by default and you won’t even notice. Note you can still manually use a store to register it whenever you want but because it is automatic you don’t need to worry about it.<br><code>- 没有需要动态添加存储，它们都是默认的动态的，你也不会发现。请注意，你仍然可以手动使用存储来注册它，但是因为它是自动的，你不需要担心它。</code></li><li>No more nested structuring of <em>modules</em>. You can still nest stores implicitly by importing and <em>using</em> a store inside another but Pinia offers a flat structuring by design while still enabling ways of cross composition among stores. <strong>You can even have circular dependencies of stores</strong>.<br><code>- 没有更多的嵌套结构的_模块_。你仍然可以嵌套存储通过导入并使用存储在另一个存储中，但Pinia提供了一个平面的结构，而且还允许在存储之间跨越组合。**你还可以有圆形依赖的存储**。</code></li><li>No <em>namespaced modules</em>. Given the flat architecture of stores, “namespacing” stores is inherent to how they are defined and you could say all stores are namespaced.<br><code>- 没有_命名空间模块_。给定存储的平面建构，“命名空间”存储是因为它们定义的方式而具有的，你可以说所有的存储都是命名空间。</code><br>For more detailed instructions on how to convert an existing Vuex ≤4 project to use Pinia, see the <a href="./cookbook/migration-vuex.md">Migration from Vuex Guide</a>.<br><em>译：为了更加详细的指导如何将现有的 Vuex ≤4 项目转换为使用 Pinia，请参阅<a href="./cookbook/migration-vuex.md">Migration from Vuex Guide</a>。</em></li></ul><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a><a href="https://pinia.vuejs.org/getting-started.html#installation">起步</a></h2><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>Install <code>pinia</code> with your favorite package manager:<br><em>译：使用你喜欢的包管理器安装 <code>pinia</code> ：</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn add pinia# or with npmnpm install pinia</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>If your app is using Vue 2, you also need to install the composition api: <code>@vue/composition-api</code>. If you are using Nuxt, you should follow <a href="https://pinia.vuejs.org/ssr/nuxt.html">these instructions</a>.<br><em>译：如果你的应用使用 Vue 2，你还需要安装组合 api：<code>@vue/composition-api</code>。如果你使用 Nuxt，你应该遵循<a href="https://pinia.vuejs.org/ssr/nuxt.html">这些指导</a>。</em></p></div><p>If you are using the Vue CLI, you can instead give this <a href="https://github.com/wobsoriano/vue-cli-plugin-pinia"><strong>unofficial plugin</strong></a> a try.<br>_译：如果你使用 Vue CLI，你可以试试这个 [<strong>非官方插件</strong>](</p><p>Create a pinia (the root store) and pass it to the app:<br><em>译：创建一个 pinia （根存储）并将其传递给应用：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createPinia &#125; from &quot;pinia&quot;;app.use(createPinia());</code></pre><p>If you are using Vue 2, you also need to install a plugin and inject the created <code>pinia</code> at the root of the app:<br><em>译：如果你使用 Vue 2，你还需要安装一个插件并将创建的 <code>pinia</code> 注入到应用的根中：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createPinia, PiniaVuePlugin &#125; from &quot;pinia&quot;;Vue.use(PiniaVuePlugin);const pinia &#x3D; createPinia();new Vue(&#123;  el: &quot;#app&quot;,  &#x2F;&#x2F; other options...  &#x2F;&#x2F; ...  &#x2F;&#x2F; note the same &#96;pinia&#96; instance can be used across multiple Vue apps on the same page  &#x2F;&#x2F; 注意，同一个 &#96;pinia&#96; 实例可以在同一个页面上的多个 Vue 应用中使用  pinia,&#125;);</code></pre><p>This will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn’t expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).<br><em>译：这也会添加 devtools 支持。在 Vue 3 中，某些功能（例如时间旅行和编辑）仍然不支持，因为 vue-devtools 不暴露了必要的 API，但是 devtools 有更多的功能，开发者体验整体更优。在 Vue 2 中，Pinia 使用现有的 Vuex 接口（因此不能与它一起使用）。</em></p><h3 id="What-is-a-Store"><a href="#What-is-a-Store" class="headerlink" title="What is a Store?"></a>What is a Store?</h3><p>A Store (like Pinia) is an entity holding state and business logic that isn’t bound to your Component tree. In other words, <strong>it hosts global state</strong>. It’s a bit like a component that is always there and that everybody can read off and write to. It has <strong>three concepts</strong>, the <a href="./core-concepts/state.md">state</a>, <a href="./core-concepts/getters.md">getters</a> and <a href="./core-concepts/actions.md">actions</a> and it’s safe to assume these concepts are the equivalent of <code>data</code>, <code>computed</code> and <code>methods</code> in components.<br><em>译：一个存储（像 Pinia）是一个持有状态和业务逻辑的实体，它不是绑定到你的组件树上的。也就是说，<strong>它持有全局状态</strong>。它是一个总是存在的组件，每个人都可以读取并写入。它有 <strong>三个概念</strong>，<a href="./core-concepts/state.md">state</a>，<a href="./core-concepts/getters.md">getters</a> 和 <a href="./core-concepts/actions.md">actions</a>，并且我们假设这三个概念是组件的 <code>data</code>，<code>computed</code> 和 <code>methods</code> 的等价。</em></p><h3 id="When-should-I-use-a-Store"><a href="#When-should-I-use-a-Store" class="headerlink" title="When should I use a Store"></a>When should I use a Store</h3><p>A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.<br><em>译：一个存储应该包含可以在整个应用程序中访问的数据。这包括在多个地方使用的数据，例如在导航栏中显示的用户信息，以及需要在页面中保留的数据，例如一个复杂的多步骤表单。</em><br>On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.<br><em>译：另一方面，你应该避免在存储中包含在组件中存储的本地数据，例如页面中的一个元素的可见性。</em><br>Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.<br><em>译：不是所有应用都需要访问全局状态，但如果你的应用需要一个，Pinia 将使你的生活更加方便。</em></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><strong>Defining a Store</strong></p><p><VueSchoolLink  href="https://vueschool.io/lessons/define-your-first-pinia-store"  title="Learn how to define and use stores in Pinia"/></p><p>Before diving into core concepts, we need to know that a store is defined using <code>defineStore()</code> and that it requires a <strong>unique</strong> name, passed as the first argument:<br><em>译：在深入核心概念之前，我们需要知道一个存储由 <code>defineStore()</code> 定义并且需要一个 <strong>唯一的</strong> 名称作为第一个参数：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; defineStore &#125; from &quot;pinia&quot;;&#x2F;&#x2F; useStore could be anything like useUser, useCart&#x2F;&#x2F; the first argument is a unique id of the store across your applicationexport const useStore &#x3D; defineStore(&quot;main&quot;, &#123;  &#x2F;&#x2F; other options...&#125;);</code></pre><p>This <em>name</em>, also referred as <em>id</em>, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function <em>use…</em> is a convention across composables to make its usage idiomatic.<br>_译：这个名称，也称为 <em>id_，是必需的并且用于连接存储到 devtools。命名返回的函数 <em>use…</em> 是一个组合使用的惯例，使用它的用法简单易懂。</em><br><strong>Using the store</strong></p><p>We are <em>defining</em> a store because the store won’t be created until <code>useStore()</code> is called inside of <code>setup()</code>:<br><em>译：我们正在定义一个存储，因为只有在<code>setup（）</code>内部调用<code>useStore（）</code>才能创建该存储</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useStore &#125; from &quot;@&#x2F;stores&#x2F;counter&quot;;export default &#123;  setup() &#123;    const store &#x3D; useStore();    return &#123;      &#x2F;&#x2F; you can return the whole store instance to use it in the template      &#x2F;&#x2F; 你可以在模板中返回整个存储实例来使用它      store,    &#125;;  &#125;,&#125;;</code></pre><p>You can define as many stores as you want and <strong>you should define each store in a different file</strong> to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).<br><em>译 ：你可以定义多个存储，你应该在不同的文件中定义每个存储来获得 pinia 的最大效用（例如自动允许你的 bundle 分割和 TypeScript 推断）。</em><br>If you are not using <code>setup</code> components yet, <a href="https://pinia.vuejs.org/cookbook/options-api.html">you can still use Pinia with <em>map helpers</em></a>.<br><em>译：如果你还没有使用 <code>setup</code> 组件，你仍然可以使用 Pinia 与 [map 助手]（<a href="https://pinia.vuejs.org/cookbook/options-api.html%EF%BC%89%E3%80%82">https://pinia.vuejs.org/cookbook/options-api.html）。</a></em><br>Once the store is instantiated, you can access any property defined in <code>state</code>, <code>getters</code>, and <code>actions</code> directly on the store. We will see these in detail in the next pages but autocompletion will help you.<br><em>译：一旦存储被实例化，你可以直接在存储上访问 <code>state</code>，<code>getters</code> 和 <code>actions</code> 中定义的属性。我们将在下一页中详细讲解，但是自动补全将帮助你。</em><br>Note that <code>store</code> is an object wrapped with <code>reactive</code>, meaning there is no need to write <code>.value</code> after getters but, like <code>props</code> in <code>setup</code>, <strong>we cannot destructure it</strong>:<br><em>译：请注意，存储是一个 <code>reactive</code> 包装的对象，因此不需要写 <code>.value</code> 后面的 getters，但是，像 <code>setup</code> 中的 <code>props</code>，我们不能解构它</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default defineComponent(&#123;  setup() &#123;    const store &#x3D; useStore();    &#x2F;&#x2F; ❌ This won&#39;t work because it breaks reactivity it&#39;s the same as destructuring from &#96;props&#96;    &#x2F;&#x2F; 这不会工作，因为它会破坏可观察性，它是相同的为 &#96;props&#96; 构造的    const &#123; name, doubleCount &#125; &#x3D; store;    name; &#x2F;&#x2F; &quot;eduardo&quot;    doubleCount; &#x2F;&#x2F; 2    return &#123;      &#x2F;&#x2F; will always be &quot;eduardo&quot;      &#x2F;&#x2F; 将始终是 &quot;eduardo&quot;      name,      &#x2F;&#x2F; will always be 2      &#x2F;&#x2F; 将始终是 2      doubleCount,      &#x2F;&#x2F; this one will be reactive      &#x2F;&#x2F; 这个将是可观察的      doubleValue: computed(() &#x3D;&gt; store.doubleCount),    &#125;;  &#125;,&#125;);</code></pre><p>In order to extract properties from the store while keeping its reactivity, you need to use <code>storeToRefs()</code>. It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:<br><em>译：为了从存储中提取属性而保持其可观察性，你需要使用 <code>storeToRefs()</code>。它会创建每个可观察属性的 ref。这对于只使用存储中的状态但不调用任何行为时非常有用。请注意，你可以直接从存储中解构 actions，因为它们都是绑定到存储本身的。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; storeToRefs &#125; from &quot;pinia&quot;;export default defineComponent(&#123;  setup() &#123;    const store &#x3D; useStore();    &#x2F;&#x2F; &#96;name&#96; and &#96;doubleCount&#96; are reactive refs    &#x2F;&#x2F; This will also create refs for properties added by plugins    &#x2F;&#x2F; but skip any action or non reactive (non ref&#x2F;reactive) property    const &#123; name, doubleCount &#125; &#x3D; storeToRefs(store);    &#x2F;&#x2F; the increment action can be just extracted    const &#123; increment &#125; &#x3D; store;    return &#123;      name,      doubleCount,      increment,    &#125;;  &#125;,&#125;);</code></pre><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><VueSchoolLink  href="https://vueschool.io/lessons/access-state-from-a-pinia-store"  title="Learn all about state in Pinia"/></p><p>The state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.<br><em>大多数时候，state是你store的中心。人们通常从定义代表其应用程序的状态开始。在Pinia中，状态定义为返回初始状态的函数。这允许Pinia在服务器端和客户端都工作。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; defineStore &#125; from &quot;pinia&quot;;const useStore &#x3D; defineStore(&quot;storeId&quot;, &#123;  &#x2F;&#x2F; arrow function recommended for full type inference  state: () &#x3D;&gt; &#123;    return &#123;      &#x2F;&#x2F; all these properties will have their type inferred automatically      counter: 0,      name: &quot;Eduardo&quot;,      isAdmin: true,    &#125;;  &#125;,&#125;);</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>If you are using Vue 2, the data you create in <code>state</code> follows the same rules as the <code>data</code> in a Vue instance, ie the state object must be plain and you need to call <code>Vue.set()</code> when <strong>adding new</strong> properties to it. <strong>See also: <a href="https://v2.vuejs.org/v2/api/#data">Vue#data</a></strong>.<br><em>如果你使用 Vue 2，在 <code>state</code> 中创建的数据遵循 Vue 实例中的 <code>data</code> 的规则，即 state 对象必须是纯粹的，并且需要在 <strong>添加新的</strong> 属性时调用 <code>Vue.set()</code>。请参见 <a href="https://v2.vuejs.org/v2/api/#data">Vue#data</a>。</em></p></div><p><strong>Accessing the <code>state</code></strong></p><p>By default, you can directly read and write to the state by accessing it through the <code>store</code> instance:<br><em>默认情况下，你可以直接读取和写入状态，通过访问 <code>store</code> 实例来访问它：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const store &#x3D; useStore();store.counter++;</code></pre><p><strong>Resetting the state</strong></p><p>You can <em>reset</em> the state to its initial value by calling the <code>$reset()</code> method on the store:<br><em>你可以通过调用 <code>$reset()</code> 方法来重置状态：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const store &#x3D; useStore();store.$reset();</code></pre><p><strong>Usage with the Options API</strong></p><p><VueSchoolLink  href="https://vueschool.io/lessons/access-pinia-state-in-the-options-api"  title="Access Pinia State via the Options API"/></p><p>For the following examples, you can assume the following store was created:<br><em>为了下面的例子，你可以假设以下的存储已创建：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Example File Path:&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.jsimport &#123; defineStore &#125; from &quot;pinia&quot;;const useCounterStore &#x3D; defineStore(&quot;counterStore&quot;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),&#125;);</code></pre><p>If you are not using the Composition API, and you are using <code>computed</code>, <code>methods</code>, …, you can use the <code>mapState()</code> helper to map state properties as readonly computed properties:<br><em>如果你不使用 Composition API，并且使用 <code>computed</code>、<code>methods</code> 等，你可以使用 <code>mapState()</code> 帮助器来映射状态属性为只读的计算属性：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; mapState &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  computed: &#123;    &#x2F;&#x2F; gives access to this.counter inside the component    &#x2F;&#x2F; same as reading from store.counter    ...mapState(useCounterStore, [&#39;counter&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName    ...mapState(useCounterStore, &#123;      myOwnName: &#39;counter&#39;,      &#x2F;&#x2F; you can also write a function that gets access to the store      double: store &#x3D;&gt; store.counter * 2,      &#x2F;&#x2F; it can have access to &#96;this&#96; but it won&#39;t be typed correctly...      magicValue(store) &#123;        return store.someGetter + this.counter + this.double      &#125;,    &#125;),  &#125;,&#125;</code></pre><p><strong>Modifiable state</strong></p><p>If you want to be able to write to these state properties (e.g. if you have a form), you can use <code>mapWritableState()</code> instead. Note you cannot pass a function like with <code>mapState()</code>:<br><em>如果你想要写入这些状态属性（例如，如果你有一个表单），你可以使用 <code>mapWritableState()</code>。注意，你不能传递一个函数类似于 <code>mapState()</code>：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; mapWritableState &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  computed: &#123;    &#x2F;&#x2F; gives access to this.counter inside the component and allows setting it    &#x2F;&#x2F; this.counter++    &#x2F;&#x2F; same as reading from store.counter    ...mapWritableState(useCounterStore, [&#39;counter&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName    ...mapWritableState(useCounterStore, &#123;      myOwnName: &#39;counter&#39;,    &#125;),  &#125;,&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>You don’t need <code>mapWritableState()</code> for collections like arrays unless you are replacing the whole array with <code>cartItems = []</code>, <code>mapState()</code> still allows you to call methods on your collections.<br><em>注意，你不需要 <code>mapWritableState()</code> 为集合类型（例如数组），除非你想要替换整个数组为 <code>cartItems = []</code>，<code>mapState()</code> 仍然允许你调用集合的方法。</em></p></div><p><strong>Mutating the state</strong></p><!-- TODO: disable this with `strictMode` --><p>Apart from directly mutating the store with <code>store.counter++</code>, you can also call the <code>$patch</code> method. It allows you to apply multiple changes at the same time with a partial <code>state</code> object:<br><em>除了直接通过 <code>store.counter++</code> 来修改存储，你也可以调用 <code>$patch()</code> 方法。它允许你同时使用一个部分 <code>state</code> 对象来应用多个变更：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">store.$patch(&#123;  counter: store.counter + 1,  name: &quot;Abalam&quot;,&#125;);</code></pre><p>However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the <code>$patch</code> method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:<br><em>但是，一些变更非常难或者昂贵地应用，因为它们需要创建一个新的集合。因此，<code>$patch</code> 方法也接受一个函数来组织这种难以应用的变更：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cartStore.$patch((state) &#x3D;&gt; &#123;  state.items.push(&#123; name: &quot;shoes&quot;, quantity: 1 &#125;);  state.hasChanged &#x3D; true;&#125;);</code></pre><!-- TODO: disable this with `strictMode`, `{ noDirectPatch: true }` --><p>The main difference here is that <code>$patch()</code> allows you to group multiple changes into one single entry in the devtools. Note <strong>both, direct changes to <code>state</code> and <code>$patch()</code> appear in the devtools</strong> and can be time travelled (not yet in Vue 3).<br>_主要的区别是，<code>$patch()</code> 允许你将多个变更组成一个单独的条目在 devtools 中。注意 **两者都会在 devtools 中出现，并且可以被时间轴追踪（尚未在 Vue 3 中）。_<br><strong>Replacing the <code>state</code></strong></p><p>You can replace the whole state of a store by setting its <code>$state</code> property to a new object:<br><em>你可以通过设置存储的 <code>$state</code> 属性来替换它的状态：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">store.$state &#x3D; &#123; counter: 666, name: &quot;Paimon&quot; &#125;;</code></pre><p>You can also replace the whole state of your application by changing the <code>state</code> of the <code>pinia</code> instance. This is used during <a href="../ssr/#state-hydration">SSR for hydration</a>.<br><em>你也可以通过更改 <code>pinia</code> 实例的 <code>state</code> 来替换整个应用的状态。这用于 <a href="../ssr/#state-hydration">SSR for hydration</a>。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">pinia.state.value &#x3D; &#123;&#125;;</code></pre><p><strong>Subscribing to the state</strong></p><p>You can watch the state and its changes through the <code>$subscribe()</code> method of a store, similar to Vuex’s <a href="https://vuex.vuejs.org/api/#subscribe">subscribe method</a>. The advantage of using <code>$subscribe()</code> over a regular <code>watch()</code> is that <em>subscriptions</em> will trigger only once after <em>patches</em> (e.g. when using the function version from above).<br><em>你可以通过存储的 <code>$subscribe()</code> 方法来订阅状态，与 Vuex 的 <a href="https://vuex.vuejs.org/api/#subscribe">subscribe 方法</a> 类似。使用 <code>$subscribe()</code> 方法来订阅状态，优势在于它会在变更后只触发一次订阅（例如，使用上面的函数版本）。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">cartStore.$subscribe((mutation, state) &#x3D;&gt; &#123;  &#x2F;&#x2F; import &#123; MutationType &#125; from &#39;pinia&#39;  mutation.type; &#x2F;&#x2F; &#39;direct&#39; | &#39;patch object&#39; | &#39;patch function&#39;  &#x2F;&#x2F; same as cartStore.$id  mutation.storeId; &#x2F;&#x2F; &#39;cart&#39;  &#x2F;&#x2F; only available with mutation.type &#x3D;&#x3D;&#x3D; &#39;patch object&#39;  mutation.payload; &#x2F;&#x2F; patch object passed to cartStore.$patch()  &#x2F;&#x2F; persist the whole state to the local storage whenever it changes  localStorage.setItem(&quot;cart&quot;, JSON.stringify(state));&#125;);</code></pre><p>By default, <em>state subscriptions</em> are bound to the component where they are added (if the store is inside a component’s <code>setup()</code>). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass <code>&#123; detached: true &#125;</code> as the second argument to <em>detach</em> the <em>state subscription</em> from the current component:<br><em>默认情况下，_状态订阅_会绑定到添加它的组件（如果存储在组件的 <code>setup()</code> 中）。意味着，它会在组件卸载后自动删除。如果你想要在组件卸载后保持它们，可以将 <code>&#123; detached: true &#125;</code> 作为第二个参数传递给 <em>detach</em> <em>状态订阅</em> 从当前组件：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  setup() &#123;    const someStore &#x3D; useSomeStore();    &#x2F;&#x2F; this subscription will be kept after the component is unmounted    someStore.$subscribe(callback, &#123; detached: true &#125;);    &#x2F;&#x2F; ...  &#125;,&#125;;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>You can watch the whole state on the <code>pinia</code> instance:<br>你可以监听整个pinia实例的状态，这个状态是一个对象，包含了所有的store的状态。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">watch(  pinia.state,  (state) &#x3D;&gt; &#123;    &#x2F;&#x2F; persist the whole state to the local storage whenever it changes    localStorage.setItem(&quot;piniaState&quot;, JSON.stringify(state));  &#125;,  &#123; deep: true &#125;);</code></pre></p></div><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p><VueSchoolLink  href="https://vueschool.io/lessons/getters-in-pinia"  title="Learn all about getters in Pinia"/></p><p>Getters are exactly the equivalent of <a href="https://v3.vuejs.org/guide/reactivity-computed-watchers.html#computed-values">computed values</a> for the state of a Store. They can be defined with the <code>getters</code> property in <code>defineStore()</code>. They receive the <code>state</code> as the first parameter <strong>to encourage</strong> the usage of arrow function:<br><em>获取器是状态的计算值。它们可以通过 <code>defineStore()</code> 中的 <code>getters</code> 属性来定义。它们会接收 <code>state</code>（使用箭头函数） 作为第一个参数，：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  getters: &#123;    doubleCount: (state) &#x3D;&gt; state.counter * 2,  &#125;,&#125;)</code></pre><p>Most of the time, getters will only rely on the state, however, they might need to use other getters. Because of this, we can get access to the <em>whole store instance</em> through <code>this</code> when defining a regular function <strong>but it is necessary to define the type of the return type (in TypeScript)</strong>. This is due to a known limitation in TypeScript and <strong>doesn’t affect getters defined with an arrow function nor getters not using <code>this</code></strong>:<br><em>大多数情况下，获取器只依赖于状态，但它们可能需要使用其他获取器。因此，我们可以通过 <code>this</code> 访问到整个存储实例（但是需要在TypeScript中定义返回类型），这是因为已知的限制，不影响使用箭头函数或不使用<code>this</code>的获取器：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  getters: &#123;    &#x2F;&#x2F; automatically infers the return type as a number    &#x2F;&#x2F; 自动推断返回类型为数字    doubleCount(state) &#123;      return state.counter * 2    &#125;,    &#x2F;&#x2F; the return type **must** be explicitly set    &#x2F;&#x2F;  返回类型 **必须** 被显式设置    doublePlusOne(): number &#123;      &#x2F;&#x2F; autocompletion and typings for the whole store ✨      &#x2F;&#x2F; 对于整个store自动完成和类型推断 ✨      return this.doubleCount + 1    &#125;,  &#125;,&#125;)</code></pre><p>Then you can access the getter directly on the store instance:<br><em>然后你可以直接在存储实例上访问获取器：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&lt;template&gt;  &lt;p&gt;Double count is &#123;&#123; store.doubleCount &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  setup() &#123;    const store &#x3D; useStore()    return &#123; store &#125;  &#125;,&#125;&lt;&#x2F;script&gt;</code></pre><h2 id="Accessing-other-getters"><a href="#Accessing-other-getters" class="headerlink" title="Accessing other getters"></a>Accessing other getters</h2><p>As with computed properties, you can combine multiple getters. Access any other getter via <code>this</code>. Even if you are not using TypeScript, you can hint your IDE for types with the <a href="https://jsdoc.app/tags-returns.html">JSDoc</a>:<br><em>如同计算属性，你可以将多个获取器组合在一起。通过 <code>this</code> 访问其他获取器。即使你不使用TypeScript，你也可以通过<a href="https://jsdoc.app/tags-returns.html">JSDoc</a>提示你的IDE类型：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  getters: &#123;    &#x2F;&#x2F; type is automatically inferred because we are not using &#96;this&#96;    &#x2F;&#x2F; 类型自动推断，因为我们不使用&#96;this&#96;    doubleCount: (state) &#x3D;&gt; state.counter * 2,    &#x2F;&#x2F; here we need to add the type ourselves (using JSDoc in JS). We can also    &#x2F;&#x2F; use this to document the getter    &#x2F;&#x2F; 在这里我们需要自己添加类型（使用JSDoc在JS）。我们也可以用这个来描述获取器    &#x2F;**     * Returns the counter value times two plus one.     *     * @returns &#123;number&#125;     *&#x2F;    doubleCountPlusOne() &#123;      &#x2F;&#x2F; autocompletion ✨      return this.doubleCount + 1    &#125;,  &#125;,&#125;)</code></pre><h2 id="Passing-arguments-to-getters"><a href="#Passing-arguments-to-getters" class="headerlink" title="Passing arguments to getters"></a>Passing arguments to getters</h2><p><em>Getters</em> are just <em>computed</em> properties behind the scenes, so it’s not possible to pass any parameters to them. However, you can return a function from the <em>getter</em> to accept any arguments:<br><em>获取器是组件的计算属性，因此不能传递任何参数。然而，你可以从获取器返回一个函数，接受任何参数：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  getters: &#123;    getUserById: (state) &#x3D;&gt; &#123;      return (userId) &#x3D;&gt; state.users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)    &#125;,  &#125;,&#125;)</code></pre><p>and use in component:<br><em>在组件中使用：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&lt;script&gt;export default &#123;  setup() &#123;    const store &#x3D; useStore()    return &#123; getUserById: store.getUserById &#125;  &#125;,&#125;&lt;&#x2F;script&gt;&lt;template&gt;  &lt;p&gt;User 2: &#123;&#123; getUserById(2) &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</code></pre><p>Note that when doing this, <strong>getters are not cached anymore</strong>, they are simply functions that you invoke. You can however cache some results inside of the getter itself, which is uncommon but should prove more performant:<br><em>注意，当这做的时候，<strong>获取器不再缓存了</strong>，它们是一个函数，你可以在获取器内部缓存一些结果，这是一种比较常见的情况，但是应该更有效率：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  getters: &#123;    getActiveUserById(state) &#123;      const activeUsers &#x3D; state.users.filter((user) &#x3D;&gt; user.active)      return (userId) &#x3D;&gt; activeUsers.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)    &#125;,  &#125;,&#125;)</code></pre><h2 id="Accessing-other-stores-getters"><a href="#Accessing-other-stores-getters" class="headerlink" title="Accessing other stores getters"></a>Accessing other stores getters</h2><p>To use another store getters, you can directly <em>use it</em> inside of the <em>getter</em>:<br><em>要使用另一个存储获取器，可以直接在获取器中_使用它_：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useOtherStore &#125; from &#39;.&#x2F;other-store&#39;export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    &#x2F;&#x2F; ...  &#125;),  getters: &#123;    otherGetter(state) &#123;      const otherStore &#x3D; useOtherStore()      return state.localData + otherStore.data    &#125;,  &#125;,&#125;)</code></pre><h2 id="Usage-with-setup"><a href="#Usage-with-setup" class="headerlink" title="Usage with setup()"></a>Usage with <code>setup()</code></h2><p>You can directly access any getter as a property of the store (exactly like state properties):<br><em>你可以直接在存储中作为属性访问任何获取器（精准地如同状态属性）：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  setup() &#123;    const store &#x3D; useStore()    store.counter &#x3D; 3    store.doubleCount &#x2F;&#x2F; 6  &#125;,&#125;</code></pre><h2 id="Usage-with-the-Options-API"><a href="#Usage-with-the-Options-API" class="headerlink" title="Usage with the Options API"></a>Usage with the Options API</h2><p><VueSchoolLink  href="https://vueschool.io/lessons/access-pinia-getters-in-the-options-api"  title="Access Pinia Getters via the Options API"/></p><p>For the following examples, you can assume the following store was created:<br><em>对于下面的例子，你可以假设以下存储已创建：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Example File Path:&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.jsimport &#123; defineStore &#125; from &#39;pinia&#39;,const useCounterStore &#x3D; defineStore(&#39;counterStore&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0  &#125;),  getters: &#123;    doubleCounter(state) &#123;      return state.counter * 2    &#125;  &#125;&#125;)</code></pre><h3 id="With-setup"><a href="#With-setup" class="headerlink" title="With setup()"></a>With <code>setup()</code></h3><p>While Composition API is not for everyone, the <code>setup()</code> hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!<br><em>而不是所有人都需要使用组合API，<code>setup()</code>钩子可以让Pinia更容易地在Options API中使用。没有额外的映射助手函数需要！</em></p><h2 id="这是一个优点"><a href="#这是一个优点" class="headerlink" title="这是一个优点"></a>这是一个优点</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  setup() &#123;    const counterStore &#x3D; useCounterStore()    return &#123; counterStore &#125;  &#125;,  computed: &#123;    quadrupleCounter() &#123;      return this.counterStore.doubleCounter * 2    &#125;,  &#125;,&#125;</code></pre><h3 id="Without-setup"><a href="#Without-setup" class="headerlink" title="Without setup()"></a>Without <code>setup()</code></h3><p>You can use the same <code>mapState()</code> function used in the <a href="./state.md#options-api">previous section of state</a> to map to getters:<br><em>你可以使用在<a href="./state.md#options-api">上一节状态</a>中使用的<code>mapState()</code>函数来映射到获取器：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; mapState &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  computed: &#123;    &#x2F;&#x2F; gives access to this.doubleCounter inside the component    &#x2F;&#x2F; same as reading from store.doubleCounter    ...mapState(useCounterStore, [&#39;doubleCount&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName    ...mapState(useCounterStore, &#123;      myOwnName: &#39;doubleCounter&#39;,      &#x2F;&#x2F; you can also write a function that gets access to the store      double: store &#x3D;&gt; store.doubleCount,    &#125;),  &#125;,&#125;</code></pre><h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p><VueSchoolLink  href="https://vueschool.io/lessons/synchronous-and-asynchronous-actions-in-pinia"  title="Learn all about actions in Pinia"/></p><p>Actions are the equivalent of <a href="https://v3.vuejs.org/guide/data-methods.html#methods">methods</a> in components. They can be defined with the <code>actions</code> property in <code>defineStore()</code> and <strong>they are perfect to define business logic</strong>:<br><em>在<code>defineStore()</code>中定义的<code>actions</code>属性是组件的方法，它们可以用来定义业务逻辑：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  actions: &#123;    increment() &#123;      this.counter++    &#125;,    randomizeCounter() &#123;      this.counter &#x3D; Math.round(100 * Math.random())    &#125;,  &#125;,&#125;)</code></pre><p>Like <a href="./getters.md">getters</a>, actions get access to the <em>whole store instance</em> through <code>this</code> with <strong>full typing (and autocompletion ✨) support</strong>. <strong>Unlike getters, <code>actions</code> can be asynchronous</strong>, you can <code>await</code> inside of actions any API call or even other actions! Here is an example using <a href="https://github.com/posva/mande">Mande</a>. Note the library you use doesn’t matter as long as you get a <code>Promise</code>, you could even use the native <code>fetch</code> function (browser only):<br><em>像<a href="./getters.md">获取器</a>一样，actions可以通过<code>this</code>访问整个存储实例，<strong>它们可以是异步的</strong>，你可以在actions中使用<code>await</code>任何API调用或者可以使用其他actions！这里是一个使用[Mande](</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; mande &#125; from &#39;mande&#39;const api &#x3D; mande(&#39;&#x2F;api&#x2F;users&#39;)export const useUsers &#x3D; defineStore(&#39;users&#39;, &#123;  state: () &#x3D;&gt; (&#123;    userData: null,    &#x2F;&#x2F; ...  &#125;),  actions: &#123;    async registerUser(login, password) &#123;      try &#123;        this.userData &#x3D; await api.post(&#123; login, password &#125;)        showTooltip(&#96;Welcome back $&#123;this.userData.name&#125;!&#96;)      &#125; catch (error) &#123;        showTooltip(error)        &#x2F;&#x2F; let the form component display the error        return error      &#125;    &#125;,  &#125;,&#125;)</code></pre><p>You are also completely free to set whatever arguments you want and return anything. When calling actions, everything will be automatically inferred!<br><em>你可以设置任何参数和返回任何东西，当调用actions时，所有的东西都会自动推断！</em><br>Actions are invoked like methods:<br><em>actions像方法被调用：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default defineComponent(&#123;  setup() &#123;    const main &#x3D; useMainStore()    &#x2F;&#x2F; call the action as a method of the store    main.randomizeCounter()    return &#123;&#125;  &#125;,&#125;)</code></pre><h2 id="Accessing-other-stores-actions"><a href="#Accessing-other-stores-actions" class="headerlink" title="Accessing other stores actions"></a>Accessing other stores actions</h2><p>To use another store, you can directly <em>use it</em> inside of the <em>action</em>:<br><em>要使用另一个存储，你可以直接在_action_中使用它：</em></p><h2 id="这比react好用，可以嵌套"><a href="#这比react好用，可以嵌套" class="headerlink" title="这比react好用，可以嵌套"></a>这比react好用，可以嵌套</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useAuthStore &#125; from &#39;.&#x2F;auth-store&#39;export const useSettingsStore &#x3D; defineStore(&#39;settings&#39;, &#123;  state: () &#x3D;&gt; (&#123;    preferences: null,    &#x2F;&#x2F; ...  &#125;),  actions: &#123;    async fetchUserPreferences() &#123;      const auth &#x3D; useAuthStore()      if (auth.isAuthenticated) &#123;        this.preferences &#x3D; await fetchPreferences()      &#125; else &#123;        throw new Error(&#39;User must be authenticated&#39;)      &#125;    &#125;,  &#125;,&#125;)</code></pre><h2 id="Usage-with-setup-1"><a href="#Usage-with-setup-1" class="headerlink" title="Usage with setup()"></a>Usage with <code>setup()</code></h2><p>You can directly call any action as a method of the store:<br><em>你可以直接调用任何action作为store的方法：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  setup() &#123;    const store &#x3D; useStore()    store.randomizeCounter()  &#125;,&#125;</code></pre><h2 id="Usage-with-the-Options-API-1"><a href="#Usage-with-the-Options-API-1" class="headerlink" title="Usage with the Options API"></a>Usage with the Options API</h2><p><VueSchoolLink  href="https://vueschool.io/lessons/access-pinia-actions-in-the-options-api"  title="Access Pinia Getters via the Options API"/></p><p>For the following examples, you can assume the following store was created:<br><em>对于下面的例子，你可以假设以下的存储已经创建：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Example File Path:&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.jsimport &#123; defineStore &#125; from &#39;pinia&#39;,const useCounterStore &#x3D; defineStore(&#39;counterStore&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0  &#125;),  actions: &#123;    increment() &#123;      this.counter++    &#125;  &#125;&#125;)</code></pre><h3 id="With-setup-1"><a href="#With-setup-1" class="headerlink" title="With setup()"></a>With <code>setup()</code></h3><p>While Composition API is not for everyone, the <code>setup()</code> hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!<br><em>Composition API不是所有人都能用，但是<code>setup()</code>钩子可以让Pinia更加简单地使用在Options API中，不需要额外的映射功能！</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  setup() &#123;    const counterStore &#x3D; useCounterStore()    return &#123; counterStore &#125;  &#125;,  methods: &#123;    incrementAndPrint() &#123;      this.counterStore.increment()      console.log(&#39;New Count:&#39;, this.counterStore.count)    &#125;,  &#125;,&#125;</code></pre><h3 id="Without-setup-1"><a href="#Without-setup-1" class="headerlink" title="Without setup()"></a>Without <code>setup()</code></h3><p>If you would prefer not to use Composition API at all, you can use the <code>mapActions()</code> helper to map actions properties as methods in your component:<br><em>如果你想不使用Composition API，你可以使用<code>mapActions()</code>助手来将actions属性映射为组件的方法：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; mapActions &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  methods: &#123;    &#x2F;&#x2F; gives access to this.increment() inside the component    &#x2F;&#x2F; same as calling from store.increment()    ...mapActions(useCounterStore, [&#39;increment&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName()    ...mapActions(useCounterStore, &#123; myOwnName: &#39;doubleCounter&#39; &#125;),  &#125;,&#125;</code></pre><h2 id="Subscribing-to-actions"><a href="#Subscribing-to-actions" class="headerlink" title="Subscribing to actions"></a>Subscribing to actions</h2><p>It is possible to observe actions and their outcome with <code>store.$onAction()</code>. The callback passed to it is executed before the action itself. <code>after</code> handle promises and allows you to execute a function after the action resolves. In a similar way, <code>onError</code> allows you execute a function if the action throws or rejects. These are useful for tracking errors at runtime, similar to <a href="https://v3.vuejs.org/guide/tooling/deployment.html#tracking-runtime-errors">this tip in the Vue docs</a>.<br><em>可以使用<code>store.$onAction()</code>来观察actions和它们的结果。传入的回调会在action自身之前执行。<code>after</code>处理promises，允许你在action解决之后执行一个函数。同样，<code>onError</code>允许你在action抛出或者reject之后执行一个函数。这些是用于跟踪运行时错误的好方法，类似于<a href="https://v3.vuejs.org/guide/tooling/deployment.html#tracking-runtime-errors">这个提示在Vue文档</a>。</em><br>Here is an example that logs before running actions and after they resolve&#x2F;reject.<br><em>这是一个例子，它会在执行actions之前和之后解决&#x2F;reject。</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const unsubscribe &#x3D; someStore.$onAction(  (&#123;    name, &#x2F;&#x2F; name of the action    store, &#x2F;&#x2F; store instance, same as &#96;someStore&#96;    args, &#x2F;&#x2F; array of parameters passed to the action    after, &#x2F;&#x2F; hook after the action returns or resolves    onError, &#x2F;&#x2F; hook if the action throws or rejects  &#125;) &#x3D;&gt; &#123;    &#x2F;&#x2F; a shared variable for this specific action call    &#x2F;&#x2F; 共享变量，这个特定的action调用    const startTime &#x3D; Date.now()    &#x2F;&#x2F; this will trigger before an action on &#96;store&#96; is executed    &#x2F;&#x2F; 这将触发在&#96;store&#96;上执行action之前    console.log(&#96;Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#39;, &#39;)&#125;].&#96;)    &#x2F;&#x2F; this will trigger if the action succeeds and after it has fully run.    &#x2F;&#x2F; 这将触发如果action成功并且完成运行。    &#x2F;&#x2F; it waits for any returned promised    &#x2F;&#x2F;  它等待任何返回的promised    after((result) &#x3D;&gt; &#123;      console.log(        &#96;Finished &quot;$&#123;name&#125;&quot; after $&#123;          Date.now() - startTime        &#125;ms.\nResult: $&#123;result&#125;.&#96;      )    &#125;)    &#x2F;&#x2F; this will trigger if the action throws or returns a promise that rejects    &#x2F;&#x2F;  这将触发如果action抛出或者返回一个promise，reject    onError((error) &#x3D;&gt; &#123;      console.warn(        &#96;Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\nError: $&#123;error&#125;.&#96;      )    &#125;)  &#125;)&#x2F;&#x2F; manually remove the listener&#x2F;&#x2F; 手动移除监听器unsubscribe()</code></pre><p>By default, <em>action subscriptions</em> are bound to the component where they are added (if the store is inside a component’s <code>setup()</code>). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass <code>true</code> as the second argument to <em>detach</em> the <em>action subscription</em> from the current component:<br><em>默认情况下，action订阅是绑定到添加它们的组件（如果store在组件的setup中）。意思是，它们会在组件被卸载后自动移除。如果你想要保持它们在组件被卸载后，将第二个参数传递给_detach_action订阅_从当前组件：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  setup() &#123;    const someStore &#x3D; useSomeStore()    &#x2F;&#x2F; this subscription will be kept after the component is unmounted    someStore.$onAction(callback, true)    &#x2F;&#x2F; ...  &#125;,&#125;</code></pre><h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><p>Pinia stores can be fully extended thanks to a low level API. Here is a list of things you can do:<br><em>Pinia stores可以完全扩展，通过一个低级API。这是一个列表，你可以做的事情：</em></p><ul><li>Add <code>new properties</code> to stores <em>给stores添加新的属性</em></li><li>Add <code>new options</code> when defining stores <em>在定义stores时添加新的选项</em></li><li>Add <code>new methods</code> to stores <em>给stores添加新的方法</em></li><li>Wrap <code>existing methods</code> <em>包装现有的方法</em></li><li>Change or even cancel <code>actions</code> <em>改变或取消actions</em></li><li>Implement side effects like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">Local Storage</a> <em>实现副作用效果，例如localStorage</em></li><li>Apply <strong>only</strong> to specific stores <em>只应用到特定的stores</em></li></ul><p>Plugins are added to the pinia instance with <code>pinia.use()</code>. The simplest example is adding a static property to all stores by returning an object:<br><em>插件是添加到pinia实例的<code>pinia.use()</code>。最简单的例子是添加一个静态属性到所有stores，通过返回一个对象：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createPinia &#125; from &#39;pinia&#39;&#x2F;&#x2F; add a property named &#96;secret&#96; to every store that is created after this plugin is installed&#x2F;&#x2F; this could be in a different filefunction SecretPiniaPlugin() &#123;  return &#123; secret: &#39;the cake is a lie&#39; &#125;&#125;const pinia &#x3D; createPinia()&#x2F;&#x2F; give the plugin to piniapinia.use(SecretPiniaPlugin)&#x2F;&#x2F; in another fileconst store &#x3D; useStore()store.secret &#x2F;&#x2F; &#39;the cake is a lie&#39;</code></pre><p>This is useful to add global objects like the router, modal, or toast managers.<br><em>这是有用的，例如router、modal或toast管理器</em></p><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>A Pinia plugin is a function that optionally returns properties to be added to a store. It takes one optional argument, a <em>context</em>:<br><em>一个Pinia插件是一个可选的返回属性的函数。它只接受一个可选的参数，一个_context_：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export function myPiniaPlugin(context) &#123;  context.pinia &#x2F;&#x2F; the pinia created with &#96;createPinia()&#96;   context.app &#x2F;&#x2F; the current app created with &#96;createApp()&#96; (Vue 3 only)  context.store &#x2F;&#x2F; the store the plugin is augmenting  context.options &#x2F;&#x2F; the options object defining the store passed to &#96;defineStore()&#96;  &#x2F;&#x2F; ...&#125;</code></pre><p>This function is then passed to <code>pinia</code> with <code>pinia.use()</code>:<br><em>这个函数是通过<code>pinia.use()</code>传递给<code>pinia</code>：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">pinia.use(myPiniaPlugin)</code></pre><p>Plugins are only applied to stores <strong>created after <code>pinia</code> is passed to the app</strong>, otherwise they won’t be applied.<br><em>插件只应用到stores <strong>在<code>pinia</code>被传递给app后创建</strong>，否则它们不会应用</em></p><h2 id="Augmenting-a-Store"><a href="#Augmenting-a-Store" class="headerlink" title="Augmenting a Store"></a>Augmenting a Store</h2><p>You can add properties to every store by simply returning an object of them in a plugin:<br><em>你可以通过返回一个对象来给每个store添加属性</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">pinia.use(() &#x3D;&gt; (&#123; hello: &#39;world&#39; &#125;))</code></pre><p>You can also set the property directly on the <code>store</code> but <strong>if possible use the return version so they can be automatically tracked by devtools</strong>:<br><em>你也可以直接给store设置属性，但是<strong>如果可能，请使用返回版本，以便它们可以被自动追踪</strong></em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.hello &#x3D; &#39;world&#39;&#125;)</code></pre><p>Any property <em>returned</em> by a plugin will be automatically tracked by devtools so in order to make <code>hello</code> visible in devtools, make sure to add it to <code>store._customProperties</code> <strong>in dev mode only</strong> if you want to debug it in devtools:<br>_任何插件返回的属性都会被自动追踪被devtools追踪，所以要让hello可见在devtools，请在dev模式下，如果你想要调试它在devtools，请在store.<em>customProperties中添加它：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; from the example abovepinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.hello &#x3D; &#39;world&#39;  &#x2F;&#x2F; make sure your bundler handle this. webpack and vite should do it by default  &#x2F;&#x2F; 确定你的bundler处理这个。默认情况webpack和vite应该做它  if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;    &#x2F;&#x2F; add any keys you set on the store    &#x2F;&#x2F; 在store上添加任何你设置的键    store._customProperties.add(&#39;hello&#39;)  &#125;&#125;)</code></pre><p>Note that every store is wrapped with <a href="https://v3.vuejs.org/api/basic-reactivity.html#reactive"><code>reactive</code></a>, automatically unwrapping any Ref (<code>ref()</code>, <code>computed()</code>, …) it contains:<br><em>注意，每个store都会被包裹在<a href="https://v3.vuejs.org/api/basic-reactivity.html#reactive"><code>reactive</code></a>，自动解开任何Ref（<code>ref()</code>, <code>computed()</code>, …）它包含：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const sharedRef &#x3D; ref(&#39;shared&#39;)pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; each store has its individual &#96;hello&#96; property  &#x2F;&#x2F; 每个store都有它自己的&#96;hello&#96;属性  store.hello &#x3D; ref(&#39;secret&#39;)  &#x2F;&#x2F; it gets automatically unwrapped  &#x2F;&#x2F; 这会被自动解开  store.hello &#x2F;&#x2F; &#39;secret&#39;  &#x2F;&#x2F; all stores are sharing the value &#96;shared&#96; property  &#x2F;&#x2F; 所有store共享&#96;shared&#96;属性  store.shared &#x3D; sharedRef  store.shared &#x2F;&#x2F; &#39;shared&#39;&#125;)</code></pre><p>This is why you can access all computed properties without <code>.value</code> and why they are reactive.<br><em>这是为什么你可以不使用<code>.value</code>来访问所有计算属性，并且它们是反应性的</em></p><h3 id="Adding-new-state"><a href="#Adding-new-state" class="headerlink" title="Adding new state"></a>Adding new state</h3><p>If you want to add new state properties to a store or properties that are meant to be used during hydration, <strong>you will have to add it in two places</strong>:<br><em>如果你想要给store或者想要在同构时使用的属性，你需要在两处添加：</em></p><ul><li>On the <code>store</code> so you can access it with <code>store.myState</code> <em>在store上你可以通过<code>store.myState</code>访问它</em></li><li>On <code>store.$state</code> so it can be used in devtools and, <strong>be serialized during SSR</strong>. <em>在store.$state上你可以访问它在devtools和，<strong>在SSR时会被序列化</strong></em></li></ul><p>On top of that, you will certainly have to use a <code>ref()</code> (or other reactive API) in order to share the value across different accesses:<br><em>在顶部，你必须使用<code>ref()</code>（或其他反应性API）来共享值：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; toRef, ref &#125; from &#39;vue&#39;pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; to correctly handle SSR, we need to make sure we are not overriding an  &#x2F;&#x2F; existing value  &#x2F;&#x2F; 为了正确处理SSR，我们需要确保我们不会覆盖现有值  if (!Object.prototype.hasOwnProperty(store.$state, &#39;hasError&#39;)) &#123;    &#x2F;&#x2F; hasError is defined within the plugin, so each store has their individual    &#x2F;&#x2F; state property    &#x2F;&#x2F; hasError是在插件中定义的，所以每个store都有它自己的状态属性    const hasError &#x3D; ref(false)    &#x2F;&#x2F; setting the variable on &#96;$state&#96;, allows it be serialized during SSR    &#x2F;&#x2F; 设置它在&#96;$state&#96;，这样它可以在SSR时被序列化    store.$state.hasError &#x3D; hasError  &#125;  &#x2F;&#x2F; we need to transfer the ref from the state to the store, this way  &#x2F;&#x2F; both accesses: store.hasError and store.$state.hasError will work  &#x2F;&#x2F; and share the same variable  &#x2F;&#x2F; 我们需要将ref从状态传递给store，这样两个访问：store.hasError和store.$state.hasError都可以使用，并且共享相同的变量  &#x2F;&#x2F; See https:&#x2F;&#x2F;vuejs.org&#x2F;api&#x2F;reactivity-utilities.html#toref  store.hasError &#x3D; toRef(store.$state, &#39;hasError&#39;)  &#x2F;&#x2F; in this case it&#39;s better not to return &#96;hasError&#96; since it  &#x2F;&#x2F; will be displayed in the &#96;state&#96; section in the devtools  &#x2F;&#x2F; anyway and if we return it, devtools will display it twice.  &#x2F;&#x2F; 在这种情况下，我们不应该返回&#96;hasError&#96;，因为它将在devtools的&#96;state&#96;部分显示两次&#125;)</code></pre><p>Note that state changes or additions that occur within a plugin (that includes calling <code>store.$patch()</code>) happen before the store is active and therefore <strong>do not trigger any subscriptions</strong>.<br><em>注意，在插件中（包括调用<code>store.$patch()</code>）发生的状态变化或添加（包括调用<code>store.$patch()</code>）<strong>不会触发任何订阅</strong>。</em><br>:::warning<br>If you are using <strong>Vue 2</strong>, Pinia is subject to the <a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">same reactivity caveats</a> as Vue. You will need to use <code>set</code> from <code>@vue/composition-api</code> when creating new state properties like <code>secret</code> and <code>hasError</code>:<br><em>如果你使用<strong>Vue 2</strong>，Pinia将受到<a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">同类型反应性问题</a>。你需要使用<code>set</code>来创建新的状态属性，如<code>secret</code>和<code>hasError</code>：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; set, toRef &#125; from &#39;@vue&#x2F;composition-api&#39;pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  if (!Object.prototype.hasOwnProperty(store.$state, &#39;hello&#39;)) &#123;    const secretRef &#x3D; ref(&#39;secret&#39;)    &#x2F;&#x2F; If the data is meant to be used during SSR, you should    &#x2F;&#x2F; set it on the &#96;$state&#96; property so it is serialized and    &#x2F;&#x2F; picked up during hydration    &#x2F;&#x2F; 如果数据是在SSR时使用的，你应该将它设置在&#96;$state&#96;属性，这样它将被序列化并在同构时被提取    set(store.$state, &#39;secret&#39;, secretRef)  &#125;  &#x2F;&#x2F; set it directly on the store too so you can access it  &#x2F;&#x2F; both ways: &#96;store.$state.secret&#96; &#x2F; &#96;store.secret&#96;  &#x2F;&#x2F; 在store上直接设置它，这样你可以在两种方式：&#96;store.$state.secret&#96; &#x2F; &#96;store.secret&#96;  set(store, &#39;secret&#39;, toRef(store.$state, &#39;secret&#39;))  store.secret &#x2F;&#x2F; &#39;secret&#39;&#125;)</code></pre><p>:::</p><h2 id="Adding-new-external-properties"><a href="#Adding-new-external-properties" class="headerlink" title="Adding new external properties"></a>Adding new external properties</h2><p>When adding external properties, class instances that come from other libraries, or simply things that are not reactive, you should wrap the object with <code>markRaw()</code> before passing it to pinia. Here is an example adding the router to every store:<br><em>当添加外部属性时，类实例来自其他库，或者只是不反应性的东西，你应该在传递之前使用<code>markRaw()</code>。这是一个例子，将路由添加到每个store：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; markRaw &#125; from &#39;vue&#39;&#x2F;&#x2F; adapt this based on where your router is&#x2F;&#x2F; 基于你的路由在这里适配import &#123; router &#125; from &#39;.&#x2F;router&#39;pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.router &#x3D; markRaw(router)&#125;)</code></pre><h2 id="Calling-subscribe-inside-plugins"><a href="#Calling-subscribe-inside-plugins" class="headerlink" title="Calling $subscribe inside plugins"></a>Calling <code>$subscribe</code> inside plugins</h2><p>You can use <a href="./state.md#subscribing-to-the-state">store.$subscribe</a> and <a href="./actions.md#subscribing-to-actions">store.$onAction</a> inside plugins too:<br><em>你可以在插件中使用<a href="./state.md#subscribing-to-the-state">store.$subscribe</a>和<a href="./actions.md#subscribing-to-actions">store.$onAction</a>：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.$subscribe(() &#x3D;&gt; &#123;    &#x2F;&#x2F; react to store changes    &#x2F;&#x2F; 响应store变化  &#125;)  store.$onAction(() &#x3D;&gt; &#123;    &#x2F;&#x2F; react to store actions    &#x2F;&#x2F; 响应store动作  &#125;)&#125;)</code></pre><h2 id="Adding-new-options"><a href="#Adding-new-options" class="headerlink" title="Adding new options"></a>Adding new options</h2><p>It is possible to create new options when defining stores to later on consume them from plugins. For example, you could create a <code>debounce</code> option that allows you to debounce any action:<br><em>可以在定义store时创建新的选项，以便以后从插件中消费。例如，你可以创建一个<code>debounce</code>选项，允许你将任何动作debounce：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">defineStore(&#39;search&#39;, &#123;  actions: &#123;    searchContacts() &#123;      &#x2F;&#x2F; ...    &#125;,  &#125;,  &#x2F;&#x2F; this will be read by a plugin later on  &#x2F;&#x2F; 将被插件后面读取  debounce: &#123;    &#x2F;&#x2F; debounce the action searchContacts by 300ms    &#x2F;&#x2F; 延迟动作searchContacts 300ms    searchContacts: 300,  &#125;,&#125;)</code></pre><p>The plugin can then read that option to wrap actions and replace the original ones:<br><em>插件可以读取这个选项，以便包装动作并替换原始动作：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; use any debounce libraryimport debounce from &#39;lodash&#x2F;debounce&#39;pinia.use((&#123; options, store &#125;) &#x3D;&gt; &#123;  if (options.debounce) &#123;    &#x2F;&#x2F; we are overriding the actions with new ones    &#x2F;&#x2F; 我们覆盖了动作 compose    return Object.keys(options.debounce).reduce((debouncedActions, action) &#x3D;&gt; &#123;      debouncedActions[action] &#x3D; debounce(        store[action],        options.debounce[action]      )      return debouncedActions    &#125;, &#123;&#125;)  &#125;&#125;)</code></pre><p>Note that custom options are passed as the 3rd argument when using the setup syntax:<br><em>注意，自定义选项会作为第三个参数传递给setup语法：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">defineStore(  &#39;search&#39;,  () &#x3D;&gt; &#123;    &#x2F;&#x2F; ...  &#125;,  &#123;    &#x2F;&#x2F; this will be read by a plugin later on    &#x2F;&#x2F; 将被插件后面读取    debounce: &#123;      &#x2F;&#x2F; debounce the action searchContacts by 300ms      &#x2F;&#x2F; 延迟动作searchContacts 300ms      searchContacts: 300,    &#125;,  &#125;)</code></pre><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>Everything shown above can be done with typing support, so you don’t ever need to use <code>any</code> or <code>@ts-ignore</code>.<br><em>所有上面的都可以使用类型支持，所以你永远不需要使用<code>any</code>或<code>@ts-ignore</code>。</em></p><h3 id="Typing-plugins"><a href="#Typing-plugins" class="headerlink" title="Typing plugins"></a>Typing plugins</h3><p>A Pinia plugin can be typed as follows:<br><em>一个Pinia插件可以如下类型：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; PiniaPluginContext &#125; from &#39;pinia&#39;export function myPiniaPlugin(context: PiniaPluginContext) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><h3 id="Typing-new-store-properties"><a href="#Typing-new-store-properties" class="headerlink" title="Typing new store properties"></a>Typing new store properties</h3><p>When adding new properties to stores, you should also extend the <code>PiniaCustomProperties</code> interface.<br><em>当添加新的属性到store时，你应该同时扩展<code>PiniaCustomProperties</code>接口。</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface PiniaCustomProperties &#123;    &#x2F;&#x2F; by using a setter we can allow both strings and refs    &#x2F;&#x2F; 使用setter，我们可以允许字符串和refs    set hello(value: string | Ref&lt;string&gt;)    get hello(): string    &#x2F;&#x2F; you can define simpler values too    &#x2F;&#x2F; 你也可以定义简单的值    simpleNumber: number  &#125;&#125;</code></pre><p>It can then be written and read safely:<br><em>然后可以安全的写和读：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.hello &#x3D; &#39;Hola&#39;  store.hello &#x3D; ref(&#39;Hola&#39;)  store.simpleNumber &#x3D; Math.random()  &#x2F;&#x2F; @ts-expect-error: we haven&#39;t typed this correctly  store.simpleNumber &#x3D; ref(Math.random())&#125;)</code></pre><p><code>PiniaCustomProperties</code> is a generic type that allows you to reference properties of a store. Imagine the following example where we copy over the initial options as <code>$options</code> (this would only work for option stores):<br><em><code>PiniaCustomProperties</code>是一个泛型类型，允许你引用store的属性。假设我们将初始选项复制到<code>$options</code>（这只对选项store有效）：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pinia.use((&#123; options &#125;) &#x3D;&gt; (&#123; $options: options &#125;))</code></pre><p>We can properly type this by using the 4 generic types of <code>PiniaCustomProperties</code>:<br><em>我们可以通过使用<code>PiniaCustomProperties</code>的4个泛型类型来确定类型：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface PiniaCustomProperties&lt;Id, S, G, A&gt; &#123;    $options: &#123;      id: Id      state?: () &#x3D;&gt; S      getters?: G      actions?: A    &#125;  &#125;&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>When extending types in generics, they must be named <strong>exactly as in the source code</strong>. <code>Id</code> cannot be named <code>id</code> or <code>I</code>, and <code>S</code> cannot be named <code>State</code>. Here is what every letter stands for:<br><em>在泛型中扩展类型时，它们必须与源代码中的名称完全一致。<code>Id</code>不能命名为<code>id</code>或<code>I</code>，<code>S</code>不能命名为<code>State</code>。这里是每个字母的含义：</em></p><ul><li>S: State</li><li>G: Getters</li><li>A: Actions</li><li>SS: Setup Store &#x2F; Store</li></ul></p></div><h3 id="Typing-new-state"><a href="#Typing-new-state" class="headerlink" title="Typing new state"></a>Typing new state</h3><p>When adding new state properties (to both, the <code>store</code> and <code>store.$state</code>), you need to add the type to <code>PiniaCustomStateProperties</code> instead. Differently from <code>PiniaCustomProperties</code>, it only receives the <code>State</code> generic:<br><em>当添加新的状态属性（到store和store.$state）时，你需要添加类型到<code>PiniaCustomStateProperties</code>，不同于<code>PiniaCustomProperties</code>，它只接收<code>State</code>泛型：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface PiniaCustomStateProperties&lt;S&gt; &#123;    hello: string  &#125;&#125;</code></pre><h3 id="Typing-new-creation-options"><a href="#Typing-new-creation-options" class="headerlink" title="Typing new creation options"></a>Typing new creation options</h3><p>When creating new options for <code>defineStore()</code>, you should extend the <code>DefineStoreOptionsBase</code>. Differently from <code>PiniaCustomProperties</code>, it only exposes two generics: the State and the Store type, allowing you to limit what can be defined. For example, you can use the names of the actions:<br><em>当创建新的选项for<code>defineStore()</code>时，你应该扩展<code>DefineStoreOptionsBase</code>。不同于<code>PiniaCustomProperties</code>，它只公开两个泛型：状态和store类型，允许你限制可以定义。例如，你可以使用actions的名称：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface DefineStoreOptionsBase&lt;S, Store&gt; &#123;    &#x2F;&#x2F; allow defining a number of ms for any of the actions    &#x2F;&#x2F; 允许定义任意的ms的任何一个actions    debounce?: Partial&lt;Record&lt;keyof StoreActions&lt;Store&gt;, number&gt;&gt;  &#125;&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>There is also a <code>StoreGetters</code> type to extract the <em>getters</em> from a Store type. You can also extend the options of <em>setup stores</em> or <em>option stores</em> <strong>only</strong> by extending the types <code>DefineStoreOptions</code> and <code>DefineSetupStoreOptions</code> respectively.<br><em>有一个<code>StoreGetters</code>类型来提取store的_getters_。你也可以扩展_setup stores_或_option stores_的选项，只需扩展types<code>DefineStoreOptions</code>和<code>DefineSetupStoreOptions</code>。</em></p></div><h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h2><p>When <a href="../ssr/nuxt.md">using pinia alongside Nuxt</a>, you will have to create a <a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins">Nuxt plugin</a> first. This will give you access to the <code>pinia</code> instance:<br><em>当使用pinia与Nuxt一起使用（ssr&#x2F;nuxt.md），你需要先创建一个<a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins">Nuxt plugin</a>。这将会给你访问pinia实例：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; plugins&#x2F;myPiniaPlugin.jsimport &#123; PiniaPluginContext &#125; from &#39;pinia&#39;import &#123; Plugin &#125; from &#39;@nuxt&#x2F;types&#39;function MyPiniaPlugin(&#123; store &#125;: PiniaPluginContext) &#123;  store.$subscribe((mutation) &#x3D;&gt; &#123;    &#x2F;&#x2F; react to store changes    &#x2F;&#x2F; 响应store变化    console.log(&#96;[🍍 $&#123;mutation.storeId&#125;]: $&#123;mutation.type&#125;.&#96;)  &#125;)  &#x2F;&#x2F; Note this has to be typed if you are using TS  &#x2F;&#x2F; 注意，如果你使用TS，这必须是类型化的  return &#123; creationTime: new Date() &#125;&#125;const myPlugin: Plugin &#x3D; (&#123; $pinia &#125;) &#x3D;&gt; &#123;  $pinia.use(MyPiniaPlugin)&#125;export default myPlugin</code></pre><p>Note the above example is using TypeScript, you have to remove the type annotations <code>PiniaPluginContext</code> and <code>Plugin</code> as well as their imports if you are using a <code>.js</code> file.<br><em>注意，上面的例子使用TypeScript，如果你使用了<code>.js</code>文件,你需要移除类型标注<code>PiniaPluginContext</code>和<code>Plugin</code>。</em></p><h1 id="Using-a-store-outside-of-a-component"><a href="#Using-a-store-outside-of-a-component" class="headerlink" title="Using a store outside of a component"></a>Using a store outside of a component</h1><p>Pinia stores rely on the <code>pinia</code> instance to share the same store instance across all calls. Most of the time, this works out of the box by just calling your <code>useStore()</code> function. For example, in <code>setup()</code>, you don’t need to do anything else. But things are a bit different outside of a component.<br>Behind the scenes, <code>useStore()</code> <em>injects</em> the <code>pinia</code> instance you gave to your <code>app</code>. This means that if the <code>pinia</code> instance cannot be automatically injected, you have to manually provide it to the <code>useStore()</code> function.<br>You can solve this differently depending on the kind of application you are writing.<br><em>Pinia 存储依赖于pinia实例来共享同一个store实例。大多数时候，这是通过调用你的useStore()函数来实现的。例如，在setup()中，你不需要做任何其他事情。但是，在一个组件之外，事情是有所不同的。</em></p><h2 id="Single-Page-Applications"><a href="#Single-Page-Applications" class="headerlink" title="Single Page Applications"></a>Single Page Applications</h2><p>If you are not doing any SSR (Server Side Rendering), any call of <code>useStore()</code> after installing the pinia plugin with <code>app.use(pinia)</code> will work:<br><em>如果你不是做任何SSR（服务器端渲染），在安装pinia插件后调用useStore()后，它将会工作：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;&#x2F;&#x2F; ❌  fails because it&#39;s called before the pinia is created&#x2F;&#x2F; ❌  因为它在pinia创建之前被调用const userStore &#x3D; useUserStore()const pinia &#x3D; createPinia()const app &#x3D; createApp(App)app.use(pinia)&#x2F;&#x2F; ✅ works because the pinia instance is now active&#x2F;&#x2F; ✅ 因为pinia实例现在已经激活const userStore &#x3D; useUserStore()</code></pre><p>The easiest way to ensure this is always applied is to <em>defer</em> calls of <code>useStore()</code> by placing them inside functions that will always run after pinia is installed.<br><em>最简单的方法是通过将useStore()函数放在函数中，来保证它总是在pinia安装后才被调用。</em><br>Let’s take a look at this example of using a store inside of a navigation guard with Vue Router:<br><em>看一下使用store在导航守卫中的例子：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createRouter &#125; from &#39;vue-router&#39;const router &#x3D; createRouter(&#123;  &#x2F;&#x2F; ...&#125;)&#x2F;&#x2F; ❌ Depending on the order of imports this will fail&#x2F;&#x2F; ❌ 取决于导入的顺序，这将会失败const store &#x3D; useStore()router.beforeEach((to, from, next) &#x3D;&gt; &#123;  &#x2F;&#x2F; we wanted to use the store here  &#x2F;&#x2F; 我们想要使用store这里  if (store.isLoggedIn) next()  else next(&#39;&#x2F;login&#39;)&#125;)router.beforeEach((to) &#x3D;&gt; &#123;  &#x2F;&#x2F; ✅ This will work because the router starts its navigation after  &#x2F;&#x2F; the router is installed and pinia will be installed too  &#x2F;&#x2F; ✅ 这将会工作，因为路由开始导航之后，pinia也会被安装  const store &#x3D; useStore()  if (to.meta.requiresAuth &amp;&amp; !store.isLoggedIn) return &#39;&#x2F;login&#39;&#125;)</code></pre><h2 id="SSR-Apps"><a href="#SSR-Apps" class="headerlink" title="SSR Apps"></a>SSR Apps</h2><p>When dealing with Server Side Rendering, you will have to pass the <code>pinia</code> instance to <code>useStore()</code>. This prevents pinia from sharing global state between different application instances.<br><em>在服务器端渲染的应用中，你需要传递pinia实例给useStore()。这将阻止pinia在不同应用实例之间共享全局状态。</em><br>There is a whole section dedicated to it in the <a href="/ssr/index.md">SSR guide</a>, this is just a short explanation:<br><em>在<a href="/ssr/index.md">SSR指南</a>中有一个专门的章节，这只是一个简短的说明：</em></p><h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h1 id="Usage-without-setup"><a href="#Usage-without-setup" class="headerlink" title="Usage without setup()"></a>Usage without <code>setup()</code></h1><p>Pinia can be used even if you are not using the composition API (if you are using Vue 2, you still need to install the <code>@vue/composition-api</code> plugin though). While we recommend you to give the Composition API a try and learn it, it might not be the time for you and your team yet, you might be in the process of migrating an application, or any other reason. There are a few functions:<br><em>Pinia可以被使用，即使你不使用组合API（如果你使用Vue 2，你仍然需要安装<code>@vue/composition-api</code>插件）。但是我们建议你试一试组合API，然后学习它，非团队合作，你可能正在迁移一个应用，或者其他任何原因。有一些函数：</em></p><ul><li><a href="#giving-access-to-the-whole-store">mapStores</a></li><li><a href="../core-concepts/state.md#options-api">mapState</a></li><li><a href="../core-concepts/state.md#modifiable-state">mapWritableState</a></li><li>⚠️ <a href="../core-concepts/getters.md#options-api">mapGetters</a> (just for migration convenience, use <code>mapState()</code> instead)</li><li><a href="../core-concepts/actions.md#options-api">mapActions</a></li></ul><h2 id="Giving-access-to-the-whole-store"><a href="#Giving-access-to-the-whole-store" class="headerlink" title="Giving access to the whole store"></a>Giving access to the whole store</h2><p>If you need to access pretty much everything from the store, it might be too much to map every single property of the store… Instead you can get access to the whole store with <code>mapStores()</code>:<br><em>如果你需要访问整个store，可能会太多了，可以使用mapStores()来访问整个store：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; mapStores &#125; from &#39;pinia&#39;&#x2F;&#x2F; given two stores with the following ids&#x2F;&#x2F; 给定两个store，其id为：const useUserStore &#x3D; defineStore(&#39;user&#39;, &#123;  &#x2F;&#x2F; ...&#125;)const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  &#x2F;&#x2F; ...&#125;)export default &#123;  computed: &#123;    &#x2F;&#x2F; note we are not passing an array, just one store after the other    &#x2F;&#x2F; each store will be accessible as its id + &#39;Store&#39;    &#x2F;&#x2F; 注意我们不传递数组，而是一个store一个store    ...mapStores(useCartStore, useUserStore)  &#125;,  methods: &#123;    async buyStuff() &#123;      &#x2F;&#x2F; use them anywhere!      &#x2F;&#x2F; 使用它们任何地方！      if (this.userStore.isAuthenticated()) &#123;        await this.cartStore.buy()        this.$router.push(&#39;&#x2F;purchased&#39;)      &#125;    &#125;,  &#125;,&#125;</code></pre><p>By default, Pinia will add the <code>&quot;Store&quot;</code> suffix to the <code>id</code> of each store. You can customize this behavior by calling the <code>setMapStoreSuffix()</code>:<br><em>默认情况下，Pinia将添加“Store”后缀到每个store的id。你可以通过调用setMapStoreSuffix()来自定义这个行为：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; createPinia, setMapStoreSuffix &#125; from &#39;pinia&#39;&#x2F;&#x2F; completely remove the suffix: this.user, this.cart&#x2F;&#x2F; 完全删除后缀：this.user, this.cartsetMapStoreSuffix(&#39;&#39;)&#x2F;&#x2F; this.user_store, this.cart_store (it&#39;s okay, I won&#39;t judge you)&#x2F;&#x2F; 这个user_store, this.cart_store（也是可以的）setMapStoreSuffix(&#39;_store&#39;)export const pinia &#x3D; createPinia()</code></pre><h2 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>By default, all map helpers support autocompletion and you don’t need to do anything. If you call <code>setMapStoreSuffix()</code> to change the <code>&quot;Store&quot;</code> suffix, you will need to also add it somewhere in a TS file or your <code>global.d.ts</code> file. The most convenient place would be the same place where you call <code>setMapStoreSuffix()</code>:<br><em>默认情况下，所有map helpers都支持自动完成，你不需要做任何事情。如果你调用setMapStoreSuffix()来改变“Store”后缀，你还需要在TS文件或你的global.d.ts文件中添加它。最方便的地方就是在你调用setMapStoreSuffix()的地方：</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; createPinia, setMapStoreSuffix &#125; from &#39;pinia&#39;&#x2F;&#x2F; completely remove the suffix&#x2F;&#x2F; 完全删除后缀setMapStoreSuffix(&#39;&#39;) export const pinia &#x3D; createPinia()declare module &#39;pinia&#39; &#123;  export interface MapStoresCustomization &#123;    &#x2F;&#x2F; set it to the same value as above    &#x2F;&#x2F; 设置为上面的值    suffix: &#39;&#39;  &#125;&#125;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>If you are using a TypeScript declaration file (like <code>global.d.ts</code>), make sure to <code>import &#39;pinia&#39;</code> at the top of it to expose all existing types.<br><em>如果你使用了一个TypeScript声明文件（例如<code>global.d.ts</code>），请在它的顶部导入<code>pinia</code>来对所有现有类型进行暴露。</em></p></div><h1 id="Composing-Stores"><a href="#Composing-Stores" class="headerlink" title="Composing Stores"></a>Composing Stores</h1><p>Composing stores is about having stores that use each other and there is one rule to follow:<br><em>组合store是关于有store使用另一个store的事情，有一条规则要遵守：</em><br>If <strong>two or more stores use each other</strong>, they cannot create an infinite loop through <em>getters</em> or <em>actions</em>. They cannot <strong>both</strong> directly read each other state in their setup function:<br><em>如果两个或多个store使用了另一个store，那么它们不能通过_getters_或_actions_创建无限循环。它们不能同时直接读取另一个store的状态：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const useX &#x3D; defineStore(&#39;x&#39;, () &#x3D;&gt; &#123;  const y &#x3D; useY()  &#x2F;&#x2F; ❌ This is not possible because y also tries to read x.name  &#x2F;&#x2F; ❌ 这是不可能的，因为y也试图读取x的name  y.name  function doSomething() &#123;    &#x2F;&#x2F; ✅ Read y properties in computed or actions    &#x2F;&#x2F; ✅ 读取y属性在computed或actions    const yName &#x3D; y.name    &#x2F;&#x2F; ...  &#125;  return &#123;    name: ref(&#39;I am X&#39;),  &#125;&#125;)const useY &#x3D; defineStore(&#39;y&#39;, () &#x3D;&gt; &#123;  const x &#x3D; useX()  &#x2F;&#x2F; ❌ This is not possible because x also tries to read y.name  &#x2F;&#x2F; ❌ 这是不可能的，因为x也试图读取y的name  x.name  function doSomething() &#123;    &#x2F;&#x2F; ✅ Read x properties in computed or actions    &#x2F;&#x2F; ✅ 读取x属性在computed或actions    const xName &#x3D; x.name    &#x2F;&#x2F; ...  &#125;  return &#123;    name: ref(&#39;I am Y&#39;),  &#125;&#125;)</code></pre><h2 id="Nested-stores"><a href="#Nested-stores" class="headerlink" title="Nested stores"></a>Nested stores</h2><p>Note that if one store uses another store, <strong>there is no need to create a new store in a separate file</strong>, you can directly import it. Think of it as nesting.<br><em>如果一个store使用另一个store，<strong>不需要在一个单独的文件中创建一个新的store</strong>，你可以直接导入它。记住它是嵌套的。</em><br>You can call <code>useOtherStore()</code> at the top of any getter or action:<br><em>你可以在任何getter或action的顶部调用useOtherStore()：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;export const cartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  getters: &#123;    &#x2F;&#x2F; ... other getters    summary(state) &#123;      const user &#x3D; useUserStore()      return &#96;Hi $&#123;user.name&#125;, you have $&#123;state.list.length&#125; items in your cart. It costs $&#123;state.price&#125;.&#96;    &#125;,  &#125;,  actions: &#123;    purchase() &#123;      const user &#x3D; useUserStore()      return apiPurchase(user.id, this.list)    &#125;,  &#125;,&#125;)</code></pre><h2 id="Shared-Getters"><a href="#Shared-Getters" class="headerlink" title="Shared Getters"></a>Shared Getters</h2><p>You can simply call <code>useOtherStore()</code> inside a <em>getter</em>:<br><em>你可以在_getter_中直接调用useOtherStore()：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; defineStore &#125; from &#39;pinia&#39;import &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;export const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  getters: &#123;    summary(state) &#123;      const user &#x3D; useUserStore()      return &#96;Hi $&#123;user.name&#125;, you have $&#123;state.list.length&#125; items in your cart. It costs $&#123;state.price&#125;.&#96;    &#125;,  &#125;,&#125;)</code></pre><h2 id="Shared-Actions"><a href="#Shared-Actions" class="headerlink" title="Shared Actions"></a>Shared Actions</h2><p>The same applies to <em>actions</em>:<br><em>同样适用于_actions_：</em></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; defineStore &#125; from &#39;pinia&#39;import &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;export const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  actions: &#123;    async orderCart() &#123;      const user &#x3D; useUserStore()      try &#123;        await apiOrderCart(user.token, this.items)        &#x2F;&#x2F; another action        this.emptyCart()      &#125; catch (err) &#123;        displayError(err)      &#125;    &#125;,  &#125;,&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础- 数组对象方法实现原理</title>
      <link href="//post/2022-06-10js-arr.html"/>
      <url>//post/2022-06-10js-arr.html</url>
      
        <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><strong>定义</strong></p><ul><li>map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值</li><li>map()方法按照原始数组元素顺序一次处理元素</li></ul><p><strong>注意</strong></p><ul><li>map()不会对空数组进行检测</li><li>map()方法返回的是一个新数组，而不是原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.proptotype.myMap &#x3D; function (fn) &#123;  let arr &#x3D; [];  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    arr.push(fn(this[i], i, this));  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myMap((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item * 2;&#125;);&#x2F;&#x2F; 1 0  [1, 2, 3]&#x2F;&#x2F; 2 1  [1, 2, 3]&#x2F;&#x2F; 3 2  [1, 2, 3]&#x2F;&#x2F; [2, 4, 6]</code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><strong>定义</strong></p><ul><li>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</li></ul><p><strong>注意</strong></p><ul><li>filter()方法不会对空数组进行遍历</li><li>filter()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myFilter &#x3D; function (fn) &#123;  let arr &#x3D; [];  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (fn(this[i], i, this)) &#123;      arr.push(this[i]);    &#125;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myFilter((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);&#x2F;&#x2F; 1 0  [1, 2, 3]&#x2F;&#x2F; 2 1  [1, 2, 3]&#x2F;&#x2F; 3 2  [1, 2, 3]&#x2F;&#x2F; [2, 3]</code></pre><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><strong>定义</strong></p><ul><li>some()方法用于检测数组中的元素是否满足指定条件</li><li>some()方法会一次执行数组的每个元素，直到找到符合条件的元素为止<ul><li>如果找到符合条件的元素，some()方法就会立即返回 true，剩余的元素不会再执行</li><li>如果没有找到符合条件的元素，some()方法就会返回 false</li></ul></li></ul><p><strong>注意</strong></p><ul><li>some()方法不会对空数组进行遍历</li><li>some()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>some 我们知道是如果找到就返回 true，没有返回 false,那么在 filter 上再改造一下，定义一个遍历为 false,当有一次会回调函数执行的时候返回 true,那么就跳出循环，直接返回。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.mySome &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (fn(this[i], i, this)) &#123;      return true;    &#125;  &#125;  return false;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].mySome((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);</code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><strong>定义</strong></p><ul><li>find()方法返回数组中满足条件的第一个元素</li><li>find()方法会一次执行数组的每个元素，直到找到符合条件的元素为止<ul><li>如果找到符合条件的元素，find()方法就会立即返回该元素，剩余的元素不会再执行</li><li>如果没有找到符合条件的元素，find()方法就会返回 undefined</li></ul></li></ul><p><strong>注意</strong></p><ul><li>find()方法不会对空数组进行遍历</li><li>find()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>当回调函数有一个返回 ture，则赋值并且返回，否则会返回一个未定义的值，undefined。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myFind &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (fn(this[i], i, this)) &#123;      return this[i];    &#125;  &#125;  return undefined;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myFind((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);</code></pre><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><strong>定义</strong></p><ul><li>every()方法用于检测数组中的所有元素是否都满足指定条件</li><li>every()方法会一次执行数组的每个元素，直到找到不符合条件的元素为止<ul><li>如果找到不符合条件的元素，every()方法就会返回 false，剩余的元素不会再执行</li><li>如果没有找到不符合条件的元素，every()方法就会返回 true</li></ul></li></ul><p><strong>注意</strong></p><ul><li>every()方法不会对空数组进行遍历</li><li>every()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>这个跟 some 其实只是反着来，初始化一个值为 true，只要回调函数有一个值返回 false，那么就会成立从而推出循环并且返回。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myEvery &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (!fn(this[i], i, this)) &#123;      return false;    &#125;  &#125;  return true;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myEvery((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);</code></pre><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><strong>定义</strong></p><ul><li>forEach()方法用于遍历数组中的所有元素</li></ul><p><strong>注意</strong></p><ul><li>forEach()方法不会对空数组执行回调函数</li></ul><p><strong>原理</strong></p><ul><li>也是利用 for 循环直接遍历循环执行回调函数即可。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myForEach &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    fn(this[i], i, this);  &#125;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myForEach((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);&#125;);</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><strong>定义</strong></p><ul><li>concat()方法用于连接两个或多个数组</li><li>concat()方法不会改变原始数组</li></ul><p><strong>注意</strong></p><p><strong>原理</strong></p><ul><li>先判断是不是数组，是的话遍历 push，不是的话直接 push，最后返回复制的数组即可。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myConcat &#x3D; function (...args) &#123;  let arr &#x3D; [...this];  for (let i &#x3D; 0; i &lt; args.length; i++) &#123;    if (Array.isArray(args[i])) &#123;      arr &#x3D; arr.concat(args[i]);    &#125; else &#123;      arr.push(args[i]);    &#125;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myConcat([4, 5, 6]);</code></pre><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h2><p><strong>定义</strong></p><ul><li>copyWithin()方法用于将一个数组的元素复制到其他位置</li><li>copyWithin()方法会修改原始数组</li></ul><p><strong>注意</strong></p><ul><li>copyWithin()方法会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>start、 end 元素拷贝到 target 元素（end - start 有几位，会改变 target 及之后的几位）</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myCopyWithin &#x3D; function (target, start &#x3D; 0, end &#x3D; this.length) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  target &#x3D; target &lt; 0 ? len + target : target;  start &#x3D; start &lt; 0 ? len + start : start;  end &#x3D; end &lt; 0 ? len + end : end;  for (let i &#x3D; start; i &lt; end; i++) &#123;    arr[target + i - start] &#x3D; arr[i];  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3, 4, 5].myCopyWithin(0, 3);&#x2F;&#x2F; 拷贝 4, 5，从0开始覆盖&#x2F;&#x2F; [4, 5, 3, 4, 5]</code></pre><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><strong>定义</strong></p><ul><li>reduce()方法用于从一个数组中的元素求和</li><li>reduce()可以作为一个高阶函数使用，用于函数的 compose</li></ul><p><strong>注意</strong></p><ul><li>reduce()方法不会对空数组执行回调函数</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myReduce &#x3D; function (fn, init) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let i &#x3D; 0;  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;    init &#x3D; arr[0];    i &#x3D; 1;  &#125;  for (; i &lt; len; i++) &#123;    init &#x3D; fn(init, arr[i], i, arr);  &#125;  return init;&#125;;</code></pre><p>使用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myReduce((prev, curr) &#x3D;&gt; &#123;  return prev + curr;&#125;, 0);</code></pre><h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p><strong>定义</strong></p><ul><li>reduceRight()方法用于从一个数组中的元素求和</li><li>reduceRight()可以作为一个高阶函数使用，用于函数的 compose<br><strong>注意</strong></li><li>reduceRight()方法不会对空数组执行回调函数<br><strong>原理</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myReduceRight &#x3D; function (fn, init) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let i &#x3D; len - 1;  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;    init &#x3D; arr[len - 1];    i &#x3D; len - 2;  &#125;  for (; i &gt;&#x3D; 0; i--) &#123;    init &#x3D; fn(init, arr[i], i, arr);  &#125;  return init;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3].myReduceRight((prev, curr) &#x3D;&gt; &#123;  return prev + curr;&#125;, 0);</code></pre><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><strong>定义</strong></p><ul><li>splice()方法用于删除数组中的一段，并用新元素替代原来的元素</li><li>splice()方法会改变原始数组</li><li>splice()方法会返回被删除的元素</li><li>splice()方法会返回被删除的元素，并且返回被删除的元素的数组</li></ul><p><strong>注意</strong></p><ul><li>splice()方法会改变原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.mySplice &#x3D; function (start, deleteCount, ...args) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  &#x2F;&#x2F; 找开始的位置  start &#x3D; start &lt; 0 ? len + start : start;  &#x2F;&#x2F; 找删除的数量  &#x2F;&#x2F; 如果deleteCount，没有值，则从start开始删除，直到数组结束  deleteCount &#x3D; deleteCount &#x3D;&#x3D;&#x3D; undefined ? len - start : deleteCount;  let newArr &#x3D; arr.slice(0, start); &#x2F;&#x2F; 左  newArr &#x3D; newArr.concat(args); &#x2F;&#x2F; 新  newArr &#x3D; newArr.concat(arr.slice(start + deleteCount)); &#x2F;&#x2F; 右  return newArr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3, 4, 5].mySplice(2, 2, 6, 7);</code></pre><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><strong>定义</strong></p><ul><li>slice()方法用于返回一个数组的一段，并且不会改变原始数组</li><li>slice()方法会返回一个新数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.mySlice &#x3D; function (start &#x3D; 0, end &#x3D; this.length) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  &#x2F;&#x2F; 找开始的位置  start &#x3D; start &lt; 0 ? len + start : start;  &#x2F;&#x2F; 找结束的位置  end &#x3D; end &lt; 0 ? len + end : end;  return arr.slice(start, end);&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a &#x3D; [1, 2, 3, 4, 5];var b &#x3D; a.splice(2, 2, 6, 7);a;&#x2F;&#x2F; [1, 2, 6, 7, 5]b;&#x2F;&#x2F; [3, 4]</code></pre><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><strong>定义</strong></p><ul><li>sort()方法用于对数组进行排序</li><li>sort()方法会改变原始数组</li><li>sort()方法会返回一个新数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.mySort &#x3D; function (fn) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  &#x2F;&#x2F; 冒泡排序  for (let i &#x3D; 0; i &lt; len; i++) &#123;    for (let j &#x3D; i + 1; j &lt; len; j++) &#123;      if (fn(arr[i], arr[j]) &gt; 0) &#123;        &#x2F;&#x2F; 使用了解构赋值        [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];      &#125;    &#125;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3, 4, 5].mySort((a, b) &#x3D;&gt; &#123;  return a - b;&#125;);</code></pre><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p><strong>定义</strong></p><ul><li>reverse()方法用于反转数组</li><li>reverse()方法会改变原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myReverse &#x3D; function () &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let i &#x3D; 0;  let j &#x3D; len - 1;  while (i &lt; j) &#123;    &#x2F;&#x2F; 使用了解构赋值    [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];    i++;    j--;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3, 4, 5].myReverse();</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p><strong>定义</strong></p><ul><li>includes()方法用于判断数组是否包含某个值</li><li>includes()方法会返回一个布尔值</li><li>includes()方法会返回一个布尔值，如果数组包含某个值，则返回 true，否则返回 false<br><strong>原理</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myIncludes &#x3D; function (value) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  for (let i &#x3D; 0; i &lt; len; i++) &#123;    if (arr[i] &#x3D;&#x3D;&#x3D; value) &#123;      return true;    &#125;  &#125;  return false;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3, 4, 5].myIncludes(3);</code></pre><h2 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h2><p><strong>定义</strong></p><ul><li>flat()方法用于将一个数组展开为多个数组</li><li>flat()方法会返回一个新数组</li><li>flat()方法会返回一个新数组，如果数组中的元素是数组，则将数组中的元素展开为一个数组<br><strong>原理</strong></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Array.prototype.myFlat &#x3D; function (depth &#x3D; 1) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let newArr &#x3D; [];  if (depth &#x3D;&#x3D; 0) return arr; &#x2F;&#x2F; Copilot 这里写的不对  for (let i &#x3D; 0; i &lt; len; i++) &#123;    if (Array.isArray(arr[i])) &#123;      newArr &#x3D; newArr.concat(&#x2F;**&#x2F; arr[i].myFlat(depth - 1) &#x2F;*递归*&#x2F;);    &#125; else &#123;      newArr.push(arr[i]);    &#125;  &#125;  return newArr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[1, 2, 3, 4, 5].myFlat();</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/lin_fightin/article/details/118885988" target="_blank" >js 一些数组对象方法原理实现(手撕 map,filter,every,flat 等)</a> <code>当前文章比此链接代码更精简</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-劫持(函数/数据)</title>
      <link href="//post/2022-06-10js-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81.html"/>
      <url>//post/2022-06-10js-%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数劫持"><a href="#函数劫持" class="headerlink" title="函数劫持"></a>函数劫持</h2><p>函数劫持，在一个函数运行之前就把它劫持下来，添加我们想要的功能。 在函数运行之前，我们可以改变函数的参数，或者改变函数的返回值。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>JavaScript 中的函数劫持是一个增强原有函数的技巧，一般我们用来对原有的 JavaScript 全局方法做一些能力的增强。</p></blockquote><p><strong>函数劫持原理</strong></p><p>函数劫持原理，是在函数运行之前，把函数的原型改变为新的函数，并且把原函数的执行代码放到新函数的执行代码之前。</p><p><strong>函数劫持实现</strong></p><ul><li>使用<code>新的变量</code>保存被劫持函数</li><li><code>新函数中</code>改<code>写被劫持函数</code></li><li><code>新函数中</code> <code>调用原有的函数</code>（保存在变量中的函数）</li></ul><p><strong>基础：两个对象指向同一个地址的时候，修改某个对象的属性，另外一个对象也会随之变化</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let a &#x3D; &#123;&#125;;let b &#x3D; a;a.name &#x3D; &quot;Gopal&quot;;&#x2F;&#x2F; ture &#123;name: &#39;Gopal&#39;&#125;  &#123;name: &#39;Gopal&#39;&#125;console.log(b &#x3D;&#x3D;&#x3D; a, a, b);</code></pre><p><strong>基础：将新的对象赋值给对象变量的时候，该对象变量就指向了新对象的引用地址，跟旧引用切断关联</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let a &#x3D; &#123;&#125;;let b &#x3D; a;a &#x3D; &#123; name: &quot;Gopal&quot; &#125;;&#x2F;&#x2F; false &#123;name: &#39;Gopal&#39;&#125; &#123;&#125;console.log(b &#x3D;&#x3D;&#x3D; a, a, b);</code></pre><p><strong>应用场景</strong></p><ul><li>增强你的函数功能<ul><li>如上面的第一个例子，在原有的函数之上，实现特定的逻辑。</li></ul></li><li>追踪 XSS 攻击<ul><li>一般 XSS 攻击会先利用 alert() 等方法输出信息进行测试，这个时候，我们可以对原先的 alert() 进行劫持，向其输入追踪信息的代码，最后才把原函数执行。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function report(caller) &#123;  var img &#x3D; new Image();  img.src &#x3D; &#96;http:&#x2F;&#x2F;www.site.com&#x2F;getReport.php?caller&#x3D;$&#123;encodeURIComponent(    caller  )&#125;&#96;;&#125;var _alert &#x3D; window.alert;window.alert &#x3D; function (s) &#123;  &#x2F;&#x2F; 拿到攻击者相关信息，并上报  report(alert.caller);  _alert(s);&#125;;alert(&quot;test&quot;);</code></pre></li></ul></li></ul><p><strong>劫持 ajax 请求，实现 mock 功能</strong></p><ul><li>mock.js 中，就是通过对原生的 XMLHttpRequest（或 ActiveXObject）进行劫持，判断有没有找到匹配的数据模板，如果找到，则拦截 XHR 请求逻辑，执行自身规则对应的逻辑。如果未找到匹配的数据模板，则采用原生 XHR 发送请求。详细代码看 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuysoft%2FMock%2Fblob%2Frefactoring%2Fsrc%2Fmock%2Fxhr%2Fxhr.js" target="_blank" >这里</a> 。</li></ul><h2 id="数据劫持-defineProperty"><a href="#数据劫持-defineProperty" class="headerlink" title="数据劫持 defineProperty"></a>数据劫持 defineProperty</h2><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>通过设置对象属性 getter 和 setter 来监听属性的变化，可以实现数据劫持。getter 时候进行依赖收集，setter 时候进行数据变更时通知订阅者更新视图。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function defineReactive(obj, key, value) &#123;  observe(value); &#x2F;&#x2F; 递归子属性  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter() &#123;      collectDeps(); &#x2F;&#x2F; 收集依赖      return value;    &#125;,    set: function reactiveSetter(newVal) &#123;      observe(newVal); &#x2F;&#x2F; 若是新值是对象，则递归子属性      if (value !&#x3D;&#x3D; newVal) &#123;        notify(); &#x2F;&#x2F; 通知订阅者更新视图        console.log(&quot;数据变更了&quot;);        value &#x3D; newVal;      &#125;    &#125;,  &#125;);&#125;function observe(obj) &#123;  if (!obj || typeof obj !&#x3D;&#x3D; &quot;object&quot;) &#123;    return;  &#125;  Object.keys(obj).forEach((key) &#x3D;&gt; &#123;    &#x2F;&#x2F; 有递归    defineReactive(obj, key, obj[key]);  &#125;);&#125;var data &#x3D; &#123;  name: &quot;Gopal&quot;,  sex: &quot;male&quot;,&#125;;</code></pre><p><strong>缺点</strong></p><ul><li>无法检测到对象属性的新增或删除</li></ul><p>由于 js 的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过 Object.defineProperty 方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性 或删除属性，这就需要另外处理。</p><ul><li>无法监听数组的变化</li></ul><p>vue 在实现数组的响应式时，使用了一些 hack,把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的 push&#x2F;pop&#x2F;shift&#x2F;unshift&#x2F;splice&#x2F;sort&#x2F;reverse 7 个方法上，其他方法无法监听。<code>目前没读过源码，不晓得这搬来文章内容是否正确</code></p><h2 id="数据劫持-Proxy"><a href="#数据劫持-Proxy" class="headerlink" title="数据劫持 Proxy"></a>数据劫持 Proxy</h2><p>Proxy,字面意思是代理，是 ES6 提供的一个新的 API,用于修改某些操作的默认行为，可以理解为在目标对象之前做一层拦截，外部所有的访问都必须通过这层拦截，通过这层拦截可以做很多事情，比如对数据进行过滤、修改或者收集信息之类</p><p>ES6 原生提供的 Proxy 构造函数：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var proxy &#x3D; new Proxy(target, handler);</code></pre><p>其中 obj 为 Proxy 要拦截的对象，handler 用来定制拦截的操作，返回一个新的代理对象 proxy；Proxy 代理特点：</p><ul><li>Proxy 的代理针对的是整个对象，而不是像 Object.defineProperty 针对某个属性。只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 也可以监听数组的变化。</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var proxy &#x3D; new Proxy([1, 2, 3], &#123;  get: function (target, property) &#123;    console.log(target, property);    return target[property];  &#125;,&#125;);proxy[0] &#x3D; 4;proxy.push(5);proxy.length;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let handler &#x3D; &#123;  get: function (target, key) &#123;    if (target[key] &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; target[key] !&#x3D;&#x3D; null) &#123;      return new Proxy(target[key], handler);    &#125;    collectDeps(); &#x2F;&#x2F; 收集依赖    return Reflect.get(target, key);  &#125;,  set(target, key, value) &#123;    if (key &#x3D;&#x3D;&#x3D; &quot;length&quot;) return true;    notifyRender(); &#x2F;&#x2F; 通知订阅者更新视图    return Reflect.set(target, key, value);  &#125;,&#125;;let proxy &#x3D; new Proxy(data, handler);proxy.age &#x3D; 18; &#x2F;&#x2F; 支持新增属性let proxy1 &#x3D; new Proxy(&#123; arr: [] &#125;, handler);proxy1.arr[0] &#x3D; &quot;proxy&quot;;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7103837916274622494" target="_blank" >你还不知道 JavaScript 中的函数劫持么？</a><br><a href="https://wenku.baidu.com/view/a78cb667fd4733687e21af45b307e87101f6f8ea.html" target="_blank" >数据劫持</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修补node_modules下源码</title>
      <link href="//post/2022-06-09patch-package.html"/>
      <url>//post/2022-06-09patch-package.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前在简书上记录过，没迁移简书文章，所以重新记录</p><p>由于<code>hexo-theme-aurora</code>代码配色不是很友好，需要自定义配色，又不想改其 github 上代码，直接处理<code>node_modules</code>下的配色文件</p><h2 id="安装-patch-package"><a href="#安装-patch-package" class="headerlink" title="安装 patch-package"></a>安装 patch-package</h2><p>patch-package 包可以通过 npm 进行安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i patch-package --save-dev</code></pre><p>或者也可以通过 yarn 进行安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn add patch-package -D</code></pre><h2 id="修改包代码"><a href="#修改包代码" class="headerlink" title="修改包代码"></a>修改包代码</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;node_modules&#x2F;某包名下，按需修改</code></pre><h2 id="创建补丁"><a href="#创建补丁" class="headerlink" title="创建补丁"></a>创建补丁</h2><p>在修改依赖包内容后，就可以运行 patch-package 创建 patch 文件了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn patch-package 包名 # 使用 yarn</code></pre><p>运行后通常会在项目根目录下的 patches 目录中创建一个名为 包名+version.patch 的文件。将该 patch 文件提交至版本控制中，即可在之后应用该补丁了。<br>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ yarn patch-package hexo-theme-aurorayarn run v1.4.0$ &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;.bin&#x2F;patch-package hexo-theme-aurorapatch-package 6.4.7• Creating temporary folder• Installing hexo-theme-aurora@1.5.5 with yarn• Diffing your files with clean files✔ Created file patches&#x2F;hexo-theme-aurora+1.5.5.patch💡 hexo-theme-aurora is on GitHub! To draft an issue based on your patch run    yarn patch-package hexo-theme-aurora --create-issue✨  Done in 5.48s.</code></pre><h2 id="配置-npm-脚本钩子"><a href="#配置-npm-脚本钩子" class="headerlink" title="配置 npm 脚本钩子"></a>配置 npm 脚本钩子</h2><p>完成上述操作后，最后还需要修改 package.json 的内容，在 scripts 中加入”postinstall”: “patch-package”。</p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;  &quot;postinstall&quot;: &quot;patch-package&quot;&#125;</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h2 id="清理-node-modules"><a href="#清理-node-modules" class="headerlink" title="清理 node_modules"></a>清理 node_modules</h2><p><strong>项目根目录</strong>别搞错了,简单粗暴点，直接全清掉</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf node_modules &amp;&amp; yarn</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ yarnyarn install v1.4.0[1&#x2F;4] 🔍  Resolving packages...[2&#x2F;4] 🚚  Fetching packages...[3&#x2F;4] 🔗  Linking dependencies...warning &quot;hexo &gt; nunjucks@3.2.3&quot; has unmet peer dependency &quot;chokidar@^3.3.0&quot;.warning &quot;hexo-browsersync &gt; browser-sync &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.warning &quot;hexo-browsersync &gt; browser-sync &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.warning &quot;hexo-renderer-marked &gt; jsdom@19.0.0&quot; has unmet peer dependency &quot;canvas@^2.5.0&quot;.warning &quot;hexo-renderer-marked &gt; jsdom &gt; ws@8.5.0&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.warning &quot;hexo-renderer-marked &gt; jsdom &gt; ws@8.5.0&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.warning &quot;hexo-theme-aurora &gt; pinia@2.0.13&quot; has unmet peer dependency &quot;@vue&#x2F;composition-api@^1.4.0&quot;.warning &quot;hexo-theme-aurora &gt; pinia@2.0.13&quot; has unmet peer dependency &quot;typescript@&gt;&#x3D;4.4.4&quot;.warning &quot;hexo-theme-aurora &gt; pinia &gt; vue-demi@0.12.5&quot; has unmet peer dependency &quot;@vue&#x2F;composition-api@^1.0.0-rc.1&quot;.[4&#x2F;4] 📃  Building fresh packages...$ yarn patch-package # 看这里，在运行修补yarn run v1.4.0$ &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;.bin&#x2F;patch-packagepatch-package 6.4.7Applying patches...hexo-theme-aurora@1.5.5 ✔✨  Done in 1.00s.✨  Done in 13.93s.</code></pre><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>将 patches 提交到代码仓库，以后在其他机器上，直接安装依赖包即可。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npx patch-package hexo-theme-aurora</code></pre><p>这个命令使用 npm 运行的，可能不会成功，使用<code>yarn patch-package hexo-theme-aurora</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ npx patch-package  hexo-theme-aurorapatch-package 6.4.7• Creating temporary folder• Installing hexo-theme-aurora@1.5.5 with yarnwarning package.json: No license fieldwarning No license fielderror An unexpected error occurred: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios: ETIMEDOUT&quot;.Error: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;core-js: ETIMEDOUT    at Timeout._onTimeout (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;yarn&#x2F;lib&#x2F;cli.js:132130:19)    at listOnTimeout (node:internal&#x2F;timers:557:17)</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/auroral-ui/hexo-theme-aurora/issues/168">hexo-theme-aurora&#x2F;issues&#x2F;168</a><br><a href="https://www.npmjs.com/package/patch-package">patch-package</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.Typescript 工具类型</title>
      <link href="//post/2022-06-09ts-util-type.html"/>
      <url>//post/2022-06-09ts-util-type.html</url>
      
        <content type="html"><![CDATA[<p>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.<br><code>Typescript提供了一些帮助类型转换的工具类型，这些工具类型可以在全局范围内使用。</code></p><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h2><p>Released: 2.1</p><p>Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.<br><code>构造一个具有所有属性类型的可选属性的类型。这个工具将返回一个表示给定类型的所有子集的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;  description: string;&#125;function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;  return &#123; ...todo, ...fieldsToUpdate &#125;;&#125;const todo1 &#x3D; &#123;  title: &quot;organize desk&quot;,  description: &quot;clear clutter&quot;,&#125;;const todo2 &#x3D; updateTodo(todo1, &#123;  description: &quot;throw out trash&quot;,&#125;);</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p><ul><li>首先通过 keyof T，遍历出类型 T 的所有属性，然后通过 in 操作符进行遍历，最后在属性后加上?，将属性变为可选属性。</li><li>注意 这个 <code>in</code> 不是<code>收缩类型操作符in</code> ,而是<code>映射类型</code>中的<code>in</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;HEAD&#x2F;src&#x2F;lib&#x2F;es5.d.ts#L1517type Partial&lt;T&gt; &#x3D; &#123;  [P in keyof T]?: T[P];&#125;;</code></pre><h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<Type></h2><p>Released:2.8</p><p>Constructs a type consisting of all properties of Type set to required. The opposite of Partial.<br><code>构造一个具有所有属性类型的必需属性的类型。与Partial相反。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleinterface Props &#123;a?: number;b?: string;&#125;const obj: Props &#x3D; &#123; a: 5 &#125;;const obj2: Required&lt;Props&gt; &#x3D; &#123; a: 5 &#125;;Property &#39;b&#39; is missing in type &#39;&#123; a: number; &#125;&#39; but required in type &#39;Required&lt;Props&gt;&#39;.</code></pre><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 用于将 T 类型的所有属性设置为必选状态，首先通过 keyof T，取出类型 T 的所有属性， 然后通过 in 操作符进行遍历，最后在属性后的 ? 前加上 -，将属性变为必选属性。</p><p>这里顺便讲下-这个符号的作用，这是 TypeScript 2.8 为映射类型增加了添加或删除特定修饰符的能力。具体来说，readonly 和?映射类型中的属性修饰符现在可以加上+或-前缀，以指示应该添加或删除该修饰符，当然一般+号是可以省略的。<a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers:~:text=You%20can%20remove%20or%20add%20these%20modifiers%20by%20prefixing%20with%20%2D%20or%20%2B.%20If%20you%20don%E2%80%99t%20add%20a%20prefix%2C%20then%20%2B%20is%20assumed.">ts 官网 类型操作符&#x2F;映射类型</a></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Required&lt;T&gt; &#x3D; &#123;  [P in keyof T]-?: T[P];&#125;;</code></pre><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<Type></h2><p>Released:2.1</p><p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.<br><code>构造一个具有所有属性类型的只读属性的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;&#125;const todo: Readonly&lt;Todo&gt; &#x3D; &#123;  title: &quot;Delete inactive users&quot;,&#125;;todo.title &#x3D; &quot;Hello&quot;;&#x2F;&#x2F; Cannot assign to &#39;title&#39; because it is a read-only property.</code></pre><p>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).<br><code>这个工具是用来表示在运行时将失败的赋值表达式的用途（即尝试重新分配一个冻结对象的属性）。</code><br><strong>Object.freeze</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function freeze&lt;Type&gt;(obj: Type): Readonly&lt;Type&gt;;</code></pre><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;  [P in K]: T;&#125;;</code></pre><h2 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys, Type&gt;"></a>Record&lt;Keys, Type&gt;</h2><p>Released:2.1</p><p>Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleinterface CatInfo &#123;  age: number;  breed: string;&#125;type CatName &#x3D; &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;const cats: Record&lt;CatName, CatInfo&gt; &#x3D; &#123;  miffy: &#123; age: 10, breed: &quot;Persian&quot; &#125;,  boris: &#123; age: 5, breed: &quot;Maine Coon&quot; &#125;,  mordred: &#123; age: 16, breed: &quot;British Shorthair&quot; &#125;,&#125;;cats.boris;const cats: Record&lt;CatName, CatInfo&gt;;</code></pre><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p><p>接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;  [P in K]: T;&#125;;</code></pre><h2 id="Pick-lt-Type-Keys-gt"><a href="#Pick-lt-Type-Keys-gt" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a>Pick&lt;Type, Keys&gt;</h2><p>Released:2.1</p><p>Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;  description: string;  completed: boolean;&#125;type TodoPreview &#x3D; Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;const todo: TodoPreview &#x3D; &#123;  title: &quot;Clean room&quot;,  completed: false,&#125;;todo;&#x2F;&#x2F; const todo: TodoPreview;</code></pre><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>从 T 类型中提取部分属性，作为新的返回类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;  [P in K]: T[P];&#125;;</code></pre><h2 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a>Omit&lt;Type, Keys&gt;</h2><p>Released:3.5</p><p>Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).<br><code>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys(Keys是字符串字面量 或者 字符串字面量的联合类型)</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;  description: string;  completed: boolean;  createdAt: number;&#125;type TodoPreview &#x3D; Omit&lt;Todo, &quot;description&quot;&gt;;const todo: TodoPreview &#x3D; &#123;  title: &quot;Clean room&quot;,  completed: false,  createdAt: 1615544252770,&#125;;todo;&#x2F;&#x2F; const todo: TodoPreview;type TodoInfo &#x3D; Omit&lt;Todo, &quot;completed&quot; | &quot;createdAt&quot;&gt;;const todoInfo: TodoInfo &#x3D; &#123;  title: &quot;Pick up kids&quot;,  description: &quot;Kindergarten closes at 5pm&quot;,&#125;;todoInfo;&#x2F;&#x2F; const todoInfo: TodoInfo</code></pre><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>使用 <strong>keyof 类型操作符号</strong>、<strong>extends</strong>、<strong>类型操作符 Exclude</strong>、 <strong>类型操作符 Pick</strong></p><ul><li>结合 Pick 和 Exclude 方法，提取出不含 K 属性的类型。</li><li>1.keyof T 返回的是联合类型</li><li>2.<a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">extends</a></li><li>3.Exclude&lt;T, K&gt; 返回的是联合类型， 可以接收一个联合类型和一个联合类型，返回一个联合类型</li><li>4.把 K 中的 key, 从 T 中排除掉，剩下的就是 Omit 的类型。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Omit&lt;T, K extends keyof T&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre><h2 id="Exclude-lt-UnionType-ExcludedMembers-gt"><a href="#Exclude-lt-UnionType-ExcludedMembers-gt" class="headerlink" title="Exclude&lt;UnionType, ExcludedMembers&gt;"></a>Exclude&lt;UnionType, ExcludedMembers&gt;</h2><p>Released:2.8</p><p>Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.<br><code>用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Example;type T0 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;&#x2F;&#x2F; type T0 &#x3D; &quot;b&quot; | &quot;c&quot;;type T1 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;;&#x2F;&#x2F; type T1 &#x3D; &quot;c&quot;;type T2 &#x3D; Exclude&lt;string | number | (() &#x3D;&gt; void), Function&gt;;&#x2F;&#x2F; type T2 &#x3D; string | number;</code></pre><h2 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a>extends 关键字</h2><p>不学 extends，Exclude 和 Extract，很难理解</p><p>extends 关键字在 TS 编程中出现的频率挺高的，而且<code>不同场景下代表的含义不一样</code>，特此总结一下：</p><ul><li><p>表示继承&#x2F;拓展的含义</p></li><li><p>表示约束的含义</p></li><li><p>表示分配的含义</p></li></ul><hr/><h3 id="表示继承-x2F-拓展"><a href="#表示继承-x2F-拓展" class="headerlink" title="表示继承&#x2F;拓展"></a><strong>表示继承&#x2F;拓展</strong></h3><p>extends 是 ts 里一个很常见的关键字，同时也是 es6 里引入的一个新的关键字。在 js 里，extends 一般和 class 一起使用</p><ul><li>es6 继承父类的方法和属性</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;  kind &#x3D; &quot;animal&quot;;  constructor(kind) &#123;    this.kind &#x3D; kind;  &#125;  sayHello() &#123;    console.log(&#96;Hello, I am a $&#123;this.kind&#125;!&#96;);  &#125;&#125;class Dog extends Animal &#123;  constructor(kind) &#123;    super(kind);  &#125;  bark() &#123;    console.log(&quot;wang wang&quot;);  &#125;&#125;const dog &#x3D; new Dog(&quot;dog&quot;);dog.name; &#x2F;&#x2F;  &#x3D;&gt; &#39;dog&#39;dog.sayHello(); &#x2F;&#x2F; &#x3D;&gt; Hello, I am a dog!</code></pre><p>这里 Dog 继承了父类的 sayHello 方法，因为可以在 Dog 实例 dog 上调用。</p><ul><li>ts 继承某个类型<br>在 ts 里，extends 除了可以像 js 继承值，还可以继承&#x2F;扩展类型：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  kind: string;&#125;interface Dog extends Animal &#123;  bark(): void;&#125;&#x2F;&#x2F; Dog &#x3D;&gt; &#123; name: string; bark(): void &#125;</code></pre><hr/><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在书写泛型的时候，我们往往需要对类型参数作一定的限制，比如希望传入的参数都有 name 属性的数组我们可以这么写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getCnames&lt;T extends &#123; name: string &#125;&gt;(entities: T[]): string[] &#123;  return entities.map((entity) &#x3D;&gt; entity.cname);&#125;</code></pre><p>这里 extends 对传入的参数作了一个限制，就是 entities 的每一项可以是一个对象，但是必须含有类型为 string 的 cname 属性。</p><p>再比如，redux 里 dispatch 一个 action，必须包含 type 属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;redux&#x2F;blob&#x2F;2edd0363271af46e327e118f3d92e78e258bf0cd&#x2F;src&#x2F;types&#x2F;store.ts#L83&#x2F;&#x2F; Dispatchexport interface Dispatch&lt;A extends Action &#x3D; AnyAction&gt; &#123;  &lt;T extends A&gt;(action: T, ...extraArgs: any[]): T;&#125;&#x2F;&#x2F; AnyActionexport interface AnyAction extends Action &#123;  &#x2F;&#x2F; Allows any extra properties to be defined in an action.  [extraProps: string]: any;&#125;&#x2F;&#x2F; Actionexport interface Action&lt;T &#x3D; any&gt; &#123;  type: T;&#125;&#x2F;&#x2F; 上述代码 简化interface Dispatch&lt;T extends &#123; type: string &#125;&gt; &#123;  (action: T): T;&#125;</code></pre><h3 id="条件类型与高阶类型"><a href="#条件类型与高阶类型" class="headerlink" title="条件类型与高阶类型"></a>条件类型与高阶类型</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">SomeType extends OtherType ? TrueType : FalseType;</code></pre><p>When the type on the left of the extendsis assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).<br><code>当左边的类型可以赋值给右边的类型，那么你就会得到第一个分支的类型，否则你就会得到第二个分支的类型。</code></p><p>extends 还有一大用途就是用来判断一个类型是不是可以分配给另一个类型，这在写高级类型的时候非常有用，举个 ????：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Human &#x3D; &#123;  name: string;&#125;;type Duck &#x3D; &#123;  name: string;&#125;;type Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;yes&#39;</code></pre><p>在 vscode 里或者 ts playground 里输入这段代码，你会发现 Bool 的类型是’yes’。这是因为 Human 和 Duck 的类型完全相同，或者说 Human 类型的一切约束条件，Duck 都具备；换言之，类型为 Human 的值可以分配给类型为 Duck 的值（分配成功的前提是，Duck 里面得的类型得有一样的），反之亦然。需要理解的是，这里 A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。稍微扩展下来详细说明这个问题：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Human &#x3D; &#123;  name: string;  occupation: string;&#125;;type Duck &#x3D; &#123;  name: string;&#125;;type Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;no&#39;</code></pre><p>当我们给 Human 加上一个 occupation 属性，发现此时 Bool 是’no’，这是因为 Duck 没有类型为 string 的 occupation 属性，类型 Duck 不满足类型 Human 的类型约束。因此，A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集，理解 extends 在类型三元表达式里的用法非常重要。</p><p>继续看示例</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type A1 &#x3D; &quot;x&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; stringtype A2 &#x3D; &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; numbertype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; ?</code></pre><p>A1 和 A2 是 extends 条件判断的普通用法，和上面的判断方法一样。</p><p>P 是带参数 T 的泛型类型，其表达式和 A1，A2 的形式完全相同，A3 是泛型类型 P 传入参数’x’ | ‘y’得到的类型，如果将’x’ | ‘y’带入泛型类的表达式，可以看到和 A2 类型的形式是完全一样的，那是不是说明，A3 和 A2 的类型就是完全一样的呢？</p><p>有兴趣可以自己试一试，这里就直接给结论了</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre><p>是不是很反直觉？这个反直觉结果的原因就是所谓的分配条件类型（Distributive Conditional Types）</p><p>When conditional types act on a generic type, they become distributive when given a union type<br><code>当条件类型作用于泛型类型时，它们变成分配条件类型（Distributive Conditional Types）</code></p><p>这句话翻译过来也还是看不懂，大白话</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>对于使用 extends 关键字的条件类型（即上面的三元表达式类型），<strong>如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</strong></p></blockquote><p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br><code>如果将联合类型传入 ToArray，则条件类型将会应用到联合类型的每一个成员。</code></p><p>还是用上面的例子说明</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre><p>该例中，extends 的前参为 T，T 是一个泛型参数。在 A3 的定义中，给 T 传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入 P<T></p><pre class="line-numbers language-none"><code class="language-none">P&lt;&#39;x&#39; | &#39;y&#39;&gt; &#x3D;&gt; P&lt;&#39;x&#39;&gt; | P&lt;&#39;y&#39;&gt;&#39;x&#39;代入得到&#39;x&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; string&#39;y&#39;代入得到&#39;y&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; number然后将每一项代入得到的结果联合起来，得到 string | number</code></pre><p>总之，满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型</p><p>特殊的 never</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; never 是所有类型的子类型type A1 &#x3D; never extends &quot;x&quot; ? string : number; &#x2F;&#x2F; stringtype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; never</code></pre><p>上面的示例中，A2 和 A1 的结果竟然不一样，看起来 never 并不是一个联合类型，所以直接代入条件类型的定义即可，获取的结果应该和 A1 一直才对啊？</p><p>实际上，这里还是条件分配类型在起作用。never 被认为是空的联合类型，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以 P<T>的表达式其实根本就没有执行，所以 A2 的定义也就类似于永远没有返回的函数一样，是 never 类型的。</p><p>防止条件判断中的分配</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type P&lt;T&gt; &#x3D; [T] extends [&quot;x&quot;] ? string : number;type A1 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; numbertype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; string</code></pre><p>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p><hr/><h2 id="原理-注意"><a href="#原理-注意" class="headerlink" title="原理(注意)"></a>原理(注意)</h2><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>需前置学习 extends 关键字</p></div><ul><li>源码很简单，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 never，否则返回 T</li><li>never 是一个特殊的类型，在这里可以表示为空的联合类型，在于与其他类型的联合后，结果为其他类型。</li><li>没有遍历，怎么也能实现呢? <code>这里还涉及到extends条件类型的特殊情况，extends的前参T如果是一个泛型参数。对于使用extends关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，两个类型会成为分配条件类型（Distributive Conditional Types）。分配条件类型是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</code></pre><h2 id="Typescript-中-extends-的作用"><a href="#Typescript-中-extends-的作用" class="headerlink" title="Typescript 中 extends 的作用"></a>Typescript 中 extends 的作用</h2><h4 id="1、接口继承"><a href="#1、接口继承" class="headerlink" title="1、接口继承"></a>1、接口继承</h4><p>可以继承父类接口的方法和属性</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  name: string;&#125;interface Dog extends Animal &#123;  sayHello: () &#x3D;&gt; void;&#125;&#x2F;&#x2F; dog 具有 Animal 的 name 属性。const dog: Dog &#x3D; &#123;  name: &quot;tom&quot;,  sayHello: function () &#123;&#125;,&#125;;</code></pre><h4 id="2、普通条件判断"><a href="#2、普通条件判断" class="headerlink" title="2、普通条件判断"></a>2、普通条件判断</h4><p>用来判断一个类型是否可以分配给另外一个类型</p><p>A extends B，是表示 A 类型能够分配给 B 类型，而不是表示 A 类型是 B 类型的子集。换句话来说，如果条件判断的时候 A extends B 为 true，则说明约束 A 类型的一切约束条件，B 类型都具有。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  name: string;&#125;interface Dog extends Animal &#123;  sayHello: () &#x3D;&gt; void;&#125;const dog: Dog &#x3D; &#123;  name: &quot;tom&quot;,  sayHello: function () &#123;&#125;,&#125;;type bool &#x3D; Animal extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool &#x3D; &#39;no&#39;type bool1 &#x3D; Dog extends Animal ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; bool1 &#x3D; &#39;yes&#39;</code></pre><h4 id="3、泛型条件判断"><a href="#3、泛型条件判断" class="headerlink" title="3、泛型条件判断"></a>3、泛型条件判断</h4><p>对于使用 extends 关键字的条件类型，如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。</p><p>分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</p><p>满足两个要点即可适用分配律：</p><p>参数是泛型类型，</p><p>代入参数的是联合类型<br>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Animal&lt;T&gt; &#x3D; T;type Animal1&lt;T&gt; &#x3D; [T];type Dog &#x3D; Animal&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog &#x3D; &#39;x&#39; | &#39;y&#39;type Dog1 &#x3D; Animal1&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; Dog1 &#x3D; [&#39;x&#39; | &#39;y&#39;]type A &#x3D; &quot;x&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; A&#x3D; &#39;yes&#39;type B &#x3D; &quot;x&quot; extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; B &#x3D; &#39;no&#39;type C &#x3D; [&quot;x&quot; | &quot;y&quot;] extends Dog1 ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; C &#x3D; &#39;yes&#39;type D &#x3D; &quot;x&quot; | &quot;y&quot; extends Dog ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; D &#x3D; &#39;yse&#39;</code></pre><h4 id="4、泛型约束"><a href="#4、泛型约束" class="headerlink" title="4、泛型约束"></a>4、泛型约束</h4><p>在书写泛型时，往往需要对类型参数作一定对限制。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getInfo&lt;T, key extends keyof T&gt;(obj: T, key: key): T[key] &#123;  return obj[key];&#125;const obj &#x3D; &#123;  name: &quot;tom&quot;,  age: 12,&#125;;getInfo(obj, &quot;age&quot;); &#x2F;&#x2F; 这里第二个参数只能传age或者name，传其他的字段都会报错。</code></pre><h2 id="Extract-lt-Type-Union-gt"><a href="#Extract-lt-Type-Union-gt" class="headerlink" title="Extract&lt;Type, Union&gt;"></a>Extract&lt;Type, Union&gt;</h2><p>Released:2.8</p><p>Constructs a type by extracting from Type all union members that are assignable to Union.<br><code>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampletype T0 &#x3D; Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;;&#x2F;&#x2F; type T0 &#x3D; &quot;a&quot;;type T1 &#x3D; Extract&lt;string | number | (() &#x3D;&gt; void), Function&gt;;&#x2F;&#x2F; type T1 &#x3D; () &#x3D;&gt; void;</code></pre><h2 id="原理-注意-1"><a href="#原理-注意-1" class="headerlink" title="原理(注意)"></a>原理(注意)</h2><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><p>需前置学习 extends 关键字</p></p></div><p>原理：与 Exclude 相反，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 T，否则返回 never。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</code></pre><h2 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable<Type></h2><p>Released:2.8</p><p>Constructs a type by excluding null and undefined from Type.<br><code>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampletype T0 &#x3D; NonNullable&lt;string | number | undefined&gt;;&#x2F;&#x2F; type T0 &#x3D; string | number;type T1 &#x3D; NonNullable&lt;string[] | null | undefined&gt;;&#x2F;&#x2F; type T1 &#x3D; string[];</code></pre><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>判断 T 是否可以赋值给 null 或者 undefined 类型，是则返回 never，否则返回 T，如果这段看不明白的可以再看下 Exclude 那段关于 extends 的补充说明。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type NonNullable&lt;T&gt; &#x3D; T extends null | undefined ? never : T;</code></pre><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters<Type></h2><p>Released:3.1</p><p>Constructs a tuple type from the types used in the parameters of a function type Type.<br><code>用于根据所有Type中函数类型的参数构造一个元祖类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampledeclare function f1(arg: &#123; a: number; b: string &#125;): void;type T0 &#x3D; Parameters&lt;() &#x3D;&gt; string&gt;;&#x2F;&#x2F; type T0 &#x3D; []type T1 &#x3D; Parameters&lt;(s: string) &#x3D;&gt; void&gt;;&#x2F;&#x2F; type T1 &#x3D; [s: string]type T2 &#x3D; Parameters&lt;&lt;T&gt;(arg: T) &#x3D;&gt; T&gt;;&#x2F;&#x2F; type T2 &#x3D; [arg: unknown]type T3 &#x3D; Parameters&lt;typeof f1&gt;;&#x2F;&#x2F; type T3 &#x3D; [arg: &#123;&#x2F;&#x2F;   a: number;&#x2F;&#x2F;   b: string;&#x2F;&#x2F; &#125;]type T4 &#x3D; Parameters&lt;any&gt;;&#x2F;&#x2F; type T4 &#x3D; unknown[]type T5 &#x3D; Parameters&lt;never&gt;;&#x2F;&#x2F; type T5 &#x3D; nevertype T6 &#x3D; Parameters&lt;string&gt;;&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; type T6 &#x3D; nevertype T7 &#x3D; Parameters&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.type T7 &#x3D; never;</code></pre><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li><code>Parameters</code> 首先约束参数 <code>T </code>必须是个函数类型</li><li>判断 <code>T</code> 是否是函数类型，如果是则使用 <code>infer P</code> 暂时存一下函数的参数类型，直接用 P 即可得到这个类型并返回，否则就返回 <code>never</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Parameters&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (  ...args: infer P) &#x3D;&gt; any  ? P  : never;</code></pre><p>这里用到了<code>infer</code>，<code>infer P</code>标记一个泛型，表示这个泛型是一个待推断的类型，并且可以直接使用。</p><h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters<Type></h2><p><code>构造参数类型</code><br>Released:3.1</p><p>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).<br><code>构造一个从构造函数类型Type中提取的元组或数组类型。如果Type不是函数，则生成never类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampletype T0 &#x3D; ConstructorParameters&lt;ErrorConstructor&gt;;&#x2F;&#x2F; type T0 &#x3D; [message?: string]type T1 &#x3D; ConstructorParameters&lt;FunctionConstructor&gt;;&#x2F;&#x2F; type T1 &#x3D; string[]type T2 &#x3D; ConstructorParameters&lt;RegExpConstructor&gt;;&#x2F;&#x2F; type T2 &#x3D; [pattern: string | RegExp, flags?: string]type T3 &#x3D; ConstructorParameters&lt;any&gt;;&#x2F;&#x2F; type T3 &#x3D; unknown[]type T4 &#x3D; ConstructorParameters&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.&#x2F;&#x2F; type T4 &#x3D; never</code></pre><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<Type></h2><p>Released:2.8</p><p>Constructs a type consisting of the return type of function Type.<br><code>用于构造一个含有Type函数的返回值的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampledeclare function f1(): &#123; a: number; b: string &#125;;type T0 &#x3D; ReturnType&lt;() &#x3D;&gt; string&gt;;&#x2F;&#x2F; type T0 &#x3D; stringtype T1 &#x3D; ReturnType&lt;(s: string) &#x3D;&gt; void&gt;;&#x2F;&#x2F; type T1 &#x3D; voidtype T2 &#x3D; ReturnType&lt;&lt;T&gt;() &#x3D;&gt; T&gt;;&#x2F;&#x2F; type T2 &#x3D; unknowntype T3 &#x3D; ReturnType&lt;&lt;T extends U, U extends number[]&gt;() &#x3D;&gt; T&gt;;&#x2F;&#x2F; type T3 &#x3D; number[]type T4 &#x3D; ReturnType&lt;typeof f1&gt;;&#x2F;&#x2F; type T4 &#x3D; &#123;&#x2F;&#x2F; a: number;&#x2F;&#x2F; b: string;&#x2F;&#x2F; &#125;type T5 &#x3D; ReturnType&lt;any&gt;;&#x2F;&#x2F; type T5 &#x3D; anytype T6 &#x3D; ReturnType&lt;never&gt;;&#x2F;&#x2F; type T6 &#x3D; nevertype T7 &#x3D; ReturnType&lt;string&gt;;&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; type T7 &#x3D; anytype T8 &#x3D; ReturnType&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.&#x2F;&#x2F; type T8 &#x3D; any</code></pre><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>与 Parameters 类似</p><p>ReturnType 首先约束参数 T 必须是个函数类型<br>判断 T 是否是函数类型，如果是则使用 infer R 暂时存一下函数的返回值类型，后面的语句直接用 R 即可得到这个类型并返回，否则就返回 any</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (  ...args: any) &#x3D;&gt; infer R  ? R  : any;</code></pre><h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType<Type></h2><p>Released:2.8</p><p>Constructs a type consisting of the instance type of a constructor function in Type.<br><code>返回构造函数类型T的实例类型</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampleclass C &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;type T0 &#x3D; InstanceType&lt;typeof C&gt;;&#x2F;&#x2F; type T0 &#x3D; Ctype T1 &#x3D; InstanceType&lt;any&gt;;&#x2F;&#x2F; type T1 &#x3D; anytype T2 &#x3D; InstanceType&lt;never&gt;;&#x2F;&#x2F; type T2 &#x3D; nevertype T3 &#x3D; InstanceType&lt;string&gt;;&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; type T3 &#x3D; anytype T4 &#x3D; InstanceType&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.&#x2F;&#x2F; type T4 &#x3D; any</code></pre><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p><code>type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any</code><br>与 ResultType 类似<br><code>type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code></p><h2 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType<Type></h2><p>Released:3.3</p><p>Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.<br><code>用于提取一个函数类型Type的this (opens new window)参数类型，返回unknown (opens new window)如果这个函数类型没有this参数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Examplefunction toHex(this: Number) &#123;  return this.toString(16);&#125;function numberToString(n: ThisParameterType&lt;typeof toHex&gt;) &#123;  return toHex.apply(n);&#125;</code></pre><h2 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter<Type></h2><p>Released:3.3</p><p>Removes the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.<br><code>用于移除一个函数类型Type的this (opens new window)参数类型。如果Type没有明确的声明this 类型，那么这个返回的结果就是Type，不然的话，就返回一个新的函数类型，基于Type，但不再有this参数。范型会被抹去，只有最后重载的签名被传播进了返回的新的函数类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Examplefunction toHex(this: Number) &#123;  return this.toString(16);&#125;const fiveToHex: OmitThisParameter&lt;typeof toHex&gt; &#x3D; toHex.bind(5);console.log(fiveToHex());</code></pre><h2 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType<Type></h2><p>Released:2.3</p><p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.<br><code>这个类型不返回一个转换过的类型，它被用作标记一个上下文的this类型。注意下如果想使用这个工具类型，noImplicitThis (opens new window)的flag必须启用。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Exampletype ObjectDescriptor&lt;D, M&gt; &#x3D; &#123;  data?: D;  methods?: M &amp; ThisType&lt;D &amp; M&gt;; &#x2F;&#x2F; Type of &#39;this&#39; in methods is D &amp; M&#125;;function makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M &#123;  let data: object &#x3D; desc.data || &#123;&#125;;  let methods: object &#x3D; desc.methods || &#123;&#125;;  return &#123; ...data, ...methods &#125; as D &amp; M;&#125;let obj &#x3D; makeObject(&#123;  data: &#123; x: 0, y: 0 &#125;,  methods: &#123;    moveBy(dx: number, dy: number) &#123;      this.x +&#x3D; dx; &#x2F;&#x2F; Strongly typed this      this.y +&#x3D; dy; &#x2F;&#x2F; Strongly typed this    &#125;,  &#125;,&#125;);obj.x &#x3D; 10;obj.y &#x3D; 20;obj.moveBy(5, 5);</code></pre><p>In the example above, the methods object in the argument to makeObject has a contextual type that includes ThisType&lt;D &amp; M&gt; and therefore the type of this in methods within the methods object is { x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }. Notice how the type of the methods property simultaneously is an inference target and a source for the this type in methods.<br><code>在上面的示例中，makeObject的参数中的methods对象包含了一个上下文类型，该类型包含了ThisType&lt;D &amp; M&gt;，因此methods对象中的this类型是&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;。请注意，methods属性的类型同时是一个推断目标和一个methods对象中的this类型的源。</code><br>The ThisType<T> marker interface is simply an empty interface declared in lib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.<br><code>ThisType&lt;T&gt;标记接口是在lib.d.ts中声明的空接口。它只是在对象字面量的上下文类型中被识别而已，该接口的行为与空接口一样。</code></p><h2 id="Intrinsic-String-Manipulation-Types"><a href="#Intrinsic-String-Manipulation-Types" class="headerlink" title="Intrinsic String Manipulation Types"></a>Intrinsic String Manipulation Types</h2><p><code>内部字符串操作类型</code><br>Uppercase<StringType><br>Lowercase<StringType><br>Capitalize<StringType><br>Uncapitalize<StringType></p><p>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the Template Literal Types documentation.<br><code>为了帮助模板字符串操作，TypeScript包含一组可以在字符串操作中使用的类型。你可以在模板字符串类型文档中找到它们。</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">typescript handbook utility-types</a><br><a href="https://ts.yayujs.com/reference/UtilityTypes.html#intrinsic-string-manipulation-types">工具类型</a><br><a href="https://blog.csdn.net/qq_34998786/article/details/120300361">Typescript 中的 extends 关键字</a>Exclude 与 Extract 前置学习项<br><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses">Typescript Classes extends-clauses</a><br><a href="https://blog.csdn.net/qq_32438227/article/details/125058423">彻底搞懂 typescript 工具类型及其原理</a> 该文有错误内容，要注意哦<br><a href="https://juejin.cn/post/6844904066485583885">TypeScript 的 extends 条件类型</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.Typescript手册 模块</title>
      <link href="//post/2022-06-08ts-modules.html"/>
      <url>//post/2022-06-08ts-modules.html</url>
      
        <content type="html"><![CDATA[<p>JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the import&#x2F;export syntax.<br><code>JavaScript 有很长的历史，不同的方式来处理代码的模块化。TypeScript 从 2012 年开始，就支持了大量的模块化格式，但是，在过去的时间，社区和 JavaScript 规范一致地聚合了一个模块化格式，叫做 ES Modules（或 ES6 模块）。你可能会知道它叫做 import/export 语法。</code></p><p>ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.<br><code>ES Modules 在 2015 年添加到 JavaScript 规范，2020 年已经有广泛的支持在大部分的 web 浏览器和 JavaScript 运行时。</code><br>For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS module.exports &#x3D; syntax, and you can find information about the other module patterns in the reference section under Modules.<br><code>为了获得焦点，本手册将介绍 ES Modules 和其常用的先行模块 CommonJS module.exports = 同义词，并且你可以在 Modules 下的参考节中找到其他模块模式的信息。</code></p><h2 id="How-JavaScript-Modules-are-Defined"><a href="#How-JavaScript-Modules-are-Defined" class="headerlink" title="How JavaScript Modules are Defined"></a>How JavaScript Modules are Defined</h2><p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module.<br><code>在 TypeScript 中，只要文件包含一个顶层的 import 或 export 就被视为一个模块。</code><br>Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).<br><code>反之，一个没有顶层的 import 或 export 声明的文件就被视为一个脚本，其内容可以在全局作用域中使用（并且也可以作为模块使用）。</code><br>Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.<br><code>模块是在自己的作用域中执行的，不是在全局作用域中执行的。这意味着在模块中声明的变量，函数，类，接口等等，只有在显式的使用 export 声明的时候才能在模块外被访问。反之，要从其他模块中消费一个变量，函数，类，接口等等，必须使用 import 声明来导入。</code></p><h2 id="Non-modules"><a href="#Non-modules" class="headerlink" title="Non-modules"></a>Non-modules</h2><p><code>非模块</code><br>Before we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an export or top-level await should be considered a script and not a module.<br><code>在开始之前，我们需要明白 TypeScript 认为什么是模块。JavaScript 规范定义了任何没有 export 或 top-level await 的 JavaScript 文件都被视为脚本而不是模块。</code><br>Inside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the outFile compiler option to join multiple input files into one output file, or use multiple <script> tags in your HTML to load these files (in the correct order!).<br><code>在脚本文件中，变量和类型被声明为共享的全局作用域，并且我们假设你会使用 outFile 编译选项将多个输入文件合并成一个输出文件，或者使用多个 &lt;script&gt; 标签在你的 HTML 中加载这些文件（按照正确的顺序）。</code><br>If you have a file that doesn’t currently have any imports or exports, but you want to be treated as a module, add the line:<br><code>如果你有一个文件，它目前没有任何 import 或 export 声明，但是你想被视为一个模块，那么添加这一行：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export &#123;&#125;;</code></pre><p>which will change the file to be a module exporting nothing. This syntax works regardless of your module target.<br><code>这种语法对于你的模块目标无论如何都是可行的。</code></p><h2 id="Modules-in-TypeScript"><a href="#Modules-in-TypeScript" class="headerlink" title="Modules in TypeScript"></a>Modules in TypeScript</h2><p><code>TypeScript 中的模块</code><br>Additional Reading:<br><code>附加阅读：</code><br>Impatient JS (Modules)<br><code>不知道模块的 TypeScript</code><br>MDN: JavaScript Modules<br><code>MDN：JavaScript 模块</code><br>There are three main things to consider when writing module-based code in TypeScript:<br><code>在 TypeScript 中写模块基础的代码时，要考虑三个主要问题：</code><br>Syntax: What syntax do I want to use to import and export things?<br><code>语法：我想要使用什么语法来导入和导出东西？</code><br>Module Resolution: What is the relationship between module names (or paths) and files on disk?<br><code>模块解析：模块名（或路径）和磁盘上的文件之间的关系是什么？</code><br>Module Output Target: What should my emitted JavaScript module look like?<br><code>模块输出目标：我的输出的 JavaScript 模块应该怎样看？</code></p><h2 id="ES-Module-Syntax"><a href="#ES-Module-Syntax" class="headerlink" title="ES Module Syntax"></a>ES Module Syntax</h2><p><code>ES 模块语法</code><br>A file can declare a main export via export default:<br><code>一个文件可以通过 export default 声明一个主要的导出：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: hello.tsexport default function helloWorld() &#123;  console.log(&quot;Hello, world!&quot;);&#125;</code></pre><p>This is then imported via:<br><code>这是通过以下方式导入的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import helloWorld from &quot;.&#x2F;hello.js&quot;;helloWorld();</code></pre><p>In addition to the default export, you can have more than one export of variables and functions via the export by omitting default:<br><code>除了默认导出，你还可以有多个导出的变量和函数，通过将 default 去掉：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: maths.tsexport var pi &#x3D; 3.14;export let squareTwo &#x3D; 1.41;export const phi &#x3D; 1.61;export class RandomNumberGenerator &#123;&#125;export function absolute(num: number) &#123;if (num &lt; 0) return num \* -1;  return num;&#125;</code></pre><p>These can be used in another file via the import syntax:<br><code>这些可以在另一个文件中通过导入语法使用：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; pi, phi, absolute &#125; from &quot;.&#x2F;maths.js&quot;;console.log(pi);const absPhi &#x3D; absolute(phi);&#x2F;&#x2F; const absPhi: number;</code></pre><h2 id="Additional-Import-Syntax"><a href="#Additional-Import-Syntax" class="headerlink" title="Additional Import Syntax"></a>Additional Import Syntax</h2><p><code>附加导入语法</code><br>An import can be renamed using a format like import {old as new}:<br><code>一个导入可以通过这样的格式：import &#123;old as new&#125;：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; pi as π &#125; from &quot;.&#x2F;maths.js&quot;;console.log(π);&#x2F;&#x2F; (alias) var π: number&#x2F;&#x2F; import π</code></pre><p>You can mix and match the above syntax into a single import:<br><code>你可以混合这些语法到一个单独的导入：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: maths.tsexport const pi &#x3D; 3.14;export default class RandomNumberGenerator &#123;&#125;&#x2F;&#x2F; @filename: app.tsimport RandomNumberGenerator, &#123; pi as π &#125; from &quot;.&#x2F;maths.js&quot;;RandomNumberGenerator;&#x2F;&#x2F; (alias) class RandomNumberGenerator&#x2F;&#x2F; import RandomNumberGeneratorconsole.log(π);&#x2F;&#x2F; (alias) const π: 3.14&#x2F;&#x2F; import π</code></pre><p>You can take all of the exported objects and put them into a single namespace using * as name:<br><code>你可以将所有导出的对象放到一个单独的命名空间，使用 \* as name：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: app.tsimport \* as math from &quot;.&#x2F;maths.js&quot;;console.log(math.pi);const positivePhi &#x3D; math.absolute(math.phi);&#x2F;&#x2F; const positivePhi: number</code></pre><p>You can import a file and not include any variables into your current module via import "./file":<br><code>你可以通过 import &quot;./file&quot; 导入一个文件，并且不包含任何变量到当前模块：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: app.tsimport &quot;.&#x2F;maths.js&quot;;console.log(&quot;3.14&quot;);</code></pre><p>In this case, the import does nothing. However, all of the code in maths.ts was evaluated, which could trigger side-effects which affect other objects.<br><code>在这种情况下，导入并没有什么事情。但是，maths.ts 中的所有代码都会被评估，这可能会触发其他对象的副作用。</code></p><h2 id="TypeScript-Specific-ES-Module-Syntax"><a href="#TypeScript-Specific-ES-Module-Syntax" class="headerlink" title="TypeScript Specific ES Module Syntax"></a>TypeScript Specific ES Module Syntax</h2><p><code>TypeScript 特定的 ES 模块语法</code><br>Types can be exported and imported using the same syntax as JavaScript values:<br><code>类型可以使用相同的语法来导出和导入 JavaScript 值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: animal.tsexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;export interface Dog &#123;  breeds: string[];  yearOfBirth: number;&#125;&#x2F;&#x2F; @filename: app.tsimport &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;type Animals &#x3D; Cat | Dog;</code></pre><p>TypeScript has extended the import syntax with two concepts for declaring an import of a type:<br><code>TypeScript 已经扩展了导入类型的语法，它有两个概念来声明导入类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import type&#x2F;&#x2F; Which is an import statement which can only import types:&#x2F;&#x2F; 只能导入类型的导入语句：&#x2F;&#x2F; @filename: animal.tsexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;&#x2F;&#x2F; &#39;createCatName&#39; cannot be used as a value because it was imported using &#39;import type&#39;.&#x2F;&#x2F; &#39;createCatName&#39; 不能被用作值，因为它被导入使用了 &#39;import type&#39;。export type Dog &#x3D; &#123; breeds: string[]; yearOfBirth: number &#125;;export const createCatName &#x3D; () &#x3D;&gt; &quot;fluffy&quot;;&#x2F;&#x2F; @filename: valid.tsimport type &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;export type Animals &#x3D; Cat | Dog;&#x2F;&#x2F; @filename: app.tsimport type &#123; createCatName &#125; from &quot;.&#x2F;animal.js&quot;;const name &#x3D; createCatName();</code></pre><p>Inline type imports<br><code>内联类型导入</code></p><p>TypeScript 4.5 also allows for individual imports to be prefixed with type to indicate that the imported reference is a type:<br><code>TypeScript 4.5 可以使用 type 前缀来声明导入的引用是一个类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @filename: app.tsimport &#123; createCatName, type Cat, type Dog &#125; from &quot;.&#x2F;animal.js&quot;;export type Animals &#x3D; Cat | Dog;const name &#x3D; createCatName();</code></pre><p>Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.<br><code>这些同时允许一个非 TypeScript 编译器，如 Babel、swc 或 esbuild 知道哪些导入可以安全地移除。</code></p><h2 id="ES-Module-Syntax-with-CommonJS-Behavior"><a href="#ES-Module-Syntax-with-CommonJS-Behavior" class="headerlink" title="ES Module Syntax with CommonJS Behavior"></a>ES Module Syntax with CommonJS Behavior</h2><p><code>ES 模块语法与 CommonJS 行为</code><br>TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD require. Imports using ES Module are for most cases the same as the require from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:<br><code>TypeScript 有 ES 模块语法，它相对于 CommonJS 和 AMD require。使用 ES Module 的导入是为了大多数情况下与这些环境的 require 一致，但这种语法确保了你的 TypeScript 文件与 CommonJS 输出有一个 1 到 1 的匹配。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import fs &#x3D; require(&quot;fs&quot;);const code &#x3D; fs.readFileSync(&quot;hello.ts&quot;, &quot;utf8&quot;);</code></pre><p>You can learn more about this syntax in the modules reference page.<br><code>你可以在模块参考页面了解更多关于这种语法。</code></p><h2 id="CommonJS-Syntax"><a href="#CommonJS-Syntax" class="headerlink" title="CommonJS Syntax"></a>CommonJS Syntax</h2><p><code>CommonJS 语法</code></p><p>CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.<br><code>CommonJS 是 npm 上大多数模块的格式。即使你正在使用上面的 ES 模块语法，也会有一个简单的了解 CommonJS 语法的方式帮助你调试更容易。</code></p><h2 id="Exporting"><a href="#Exporting" class="headerlink" title="Exporting"></a>Exporting</h2><p><code>导出</code></p><p>Identifiers are exported via setting the exports property on a global called module.<br><code>标识符通过设置 module.exports 属性来导出。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function absolute(num: number) &#123;    if (num &lt; 0) return num \* -1;    return num;&#125;module.exports &#x3D; &#123;  pi: 3.14,  squareTwo: 1.41,  phi: 1.61,  absolute,&#125;;</code></pre><p>Then these files can be imported via a require statement:<br><code>然后，这些文件可以通过 require 语句来导入：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const maths &#x3D; require(&quot;maths&quot;);maths.pi;&#x2F;&#x2F; any;</code></pre><p>Or you can simplify a bit using the destructuring feature in JavaScript:<br><code>或者，你可以使用 JavaScript 的解构特性来简化一些：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const &#123; squareTwo &#125; &#x3D; require(&quot;maths&quot;);squareTwo;&#x2F;&#x2F; const squareTwo: any;</code></pre><h2 id="CommonJS-and-ES-Modules-interop"><a href="#CommonJS-and-ES-Modules-interop" class="headerlink" title="CommonJS and ES Modules interop"></a>CommonJS and ES Modules interop</h2><p><code>CommonJS 和 ES 模块的互操作</code></p><p>There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop.<br><code>在 CommonJS 和 ES 模块之间存在不匹配的特性，关于默认导入和模块命名空间对象导入的区别。TypeScript 有一个编译器标志来减少 CommonJS 和 ES 模块之间的摩擦。</code></p><h2 id="TypeScript’s-Module-Resolution-Options"><a href="#TypeScript’s-Module-Resolution-Options" class="headerlink" title="TypeScript’s Module Resolution Options"></a>TypeScript’s Module Resolution Options</h2><p><code>TypeScript 的模块解析选项</code></p><p>Module resolution is the process of taking a string from the import or require statement, and determining what file that string refers to.<br><code>模块解析是从 import 或 require 语句中获取字符串，并确定该字符串所引用的文件。</code></p><p>TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option module is not commonjs, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for .ts and .d.ts.<br><code>TypeScript 包含两种解析策略：经典和 Node。经典，默认情况下，当编译器选项 module 不是 commonjs 时，包含了向后兼容性。Node 策略重复了 Node.js 在 CommonJS 模式下工作的方式，并且添加了 .ts 和 .d.ts 的检查。</code><br>There are many TSConfig flags which influence the module strategy within TypeScript: moduleResolution, baseUrl, paths, rootDirs.<br><code>在 TypeScript 中，有很多 TSConfig 标志影响模块策略：moduleResolution、baseUrl、paths、rootDirs。</code><br>For the full details on how these strategies work, you can consult the Module Resolution.<br><code>关于如何工作的详细信息，你可以参考模块解析。</code></p><h2 id="TypeScript’s-Module-Output-Options"><a href="#TypeScript’s-Module-Output-Options" class="headerlink" title="TypeScript’s Module Output Options"></a>TypeScript’s Module Output Options</h2><p><code>TypeScript 的模块输出选项</code><br>There are two options which affect the emitted JavaScript output:<br><code>有两个影响输出的 JavaScript 的选项：</code></p><ul><li>target which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact<br><code>target 是指定哪些 JS 特性被下游（转换为在旧的 JavaScript 运行时运行），哪些被保留。</code></li><li>module which determines what code is used for modules to interact with each other<br><code>module 是指定哪些代码用于模块交互。</code></li></ul><p>Which target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.<br><code>哪个目标你使用是由你期望在 JavaScript 运行时运行 TypeScript 代码的功能决定的。这可能是：最旧的 web 浏览器，最低版本的 Node.js，或者来自你运行时的唯一约束 - 例如，Electron。</code><br>All communication between modules happens via a module loader, the compiler option module determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.<br><code>模块之间的通信都是通过模块加载器来完成的，编译器选项 module 是指定哪个被使用。在运行时，模块加载器负责定位并执行所有模块的依赖之前执行它。</code><br>For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for module:<br><code>例如，这里是一个使用 ES Modules 语法的 TypeScript 文件，展示了一些模块的选项：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;export const twoPi &#x3D; valueOfPi _ 2;</code></pre><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;export const twoPi &#x3D; valueOfPi _ 2;</code></pre><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&quot;use strict&quot;;Object.defineProperty(exports, &quot;\_\_esModule&quot;, &#123; value: true &#125;);exports.twoPi &#x3D; void 0;const constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);exports.twoPi &#x3D; constants_js_1.valueOfPi \* 2;</code></pre><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">(function (factory) &#123;  if (typeof module &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof module.exports &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;    var v &#x3D; factory(require, exports);    if (v !&#x3D;&#x3D; undefined) module.exports &#x3D; v;  &#125;  else if (typeof define &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; define.amd) &#123;    define([&quot;require&quot;, &quot;exports&quot;, &quot;.&#x2F;constants.js&quot;], factory);  &#125;&#125;)(function (require, exports) &#123;  &quot;use strict&quot;;  Object.defineProperty(exports, &quot;\_\_esModule&quot;, &#123; value: true &#125;);  exports.twoPi &#x3D; void 0;  const constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);  exports.twoPi &#x3D; constants_js_1.valueOfPi \* 2;&#125;);</code></pre><p>Note that ES2020 is effectively the same as the original index.ts.<br><code>ES2020 是一样的于原始 index.ts。</code><br>You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module.<br><code>你可以看到所有可用的选项和他们的输出 JavaScript 代码的样子在 module 的 TSConfig 参考中。</code></p><h2 id="TypeScript-namespaces"><a href="#TypeScript-namespaces" class="headerlink" title="TypeScript namespaces"></a>TypeScript namespaces</h2><p><code>TypeScript 命名空间</code><br>TypeScript has its own module format called namespaces which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in the namespaces reference page.<br><code>TypeScript 有自己的模块格式命名空间，它是先期的 ES Modules 标准。这种语法具有很多有用的功能创建复杂的定义文件，仍然在 DefinitelyTyped 中有活跃使用。尽管不被弃用，大多数的功能在命名空间中存在于 ES Modules，我们建议你使用它与 JavaScript 的方向对齐。你可以在命名空间参考页面上了解更多关于命名空间。</code></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.Typescript手册 类</title>
      <link href="//post/2022-06-08ts-classes.html"/>
      <url>//post/2022-06-08ts-classes.html</url>
      
        <content type="html"><![CDATA[<p>Background Reading:<br><code>背景阅读</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Classes (MDN)</a></p><p>TypeScript offers full support for the class keyword introduced in ES2015.<br><code>typescript 支持 ES2015 的 class 关键字。</code></p><p>As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.<br><code> 像其他 JavaScript 语言特性一样，TypeScript 添加了类型注解和其他语法，以便您可以表达类和其他类型之间的关系。</code></p><h2 id="Class-Members"><a href="#Class-Members" class="headerlink" title="Class Members"></a>Class Members</h2><p><code>类成员</code><br>Here’s the most basic class - an empty one:<br><code>这是最基本的类 - 空的一个：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;&#125;</code></pre><p>This class isn’t very useful yet, so let’s start adding some members.<br><code>这个类还不是很有用，所以我们开始添加一些成员。</code></p><h2 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h2><p><code>字段</code><br>A field declaration creates a public writeable property on a class:<br><code>字段声明创建一个公共可写属性在类上：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x: number;  y: number;&#125;const pt &#x3D; new Point();pt.x &#x3D; 0;pt.y &#x3D; 0;</code></pre><p>As with other locations, the type annotation is optional, but will be an implicit any if not specified.<br><code>与其他地方一样，类型注解是可选的，如果没有指定，将会是任意类型。</code><br>Fields can also have initializers; these will run automatically when the class is instantiated:<br><code>字段也可以有初始值，这会在类被实例化时自动运行：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;const pt &#x3D; new Point();&#x2F;&#x2F; Prints 0, 0console.log(&#96;$&#123;pt.x&#125;, $&#123;pt.y&#125;&#96;);</code></pre><p>Just like with const, let, and var, the initializer of a class property will be used to infer its type:<br><code>和 const，let，var 类型推断的初始值。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const pt &#x3D; new Point();pt.x &#x3D; &quot;0&quot;;&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre><h2 id="–strictPropertyInitialization"><a href="#–strictPropertyInitialization" class="headerlink" title="–strictPropertyInitialization"></a>–strictPropertyInitialization</h2><p>The strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor.<br><code>strictPropertyInitialization 设置控制类字段是否需要在构造函数中初始化。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class BadGreeter &#123;  name: string;  &#x2F;&#x2F; Property &#39;name&#39; has no initializer and is not definitely assigned in the constructor.&#125;class GoodGreeter &#123;  name: string;  constructor() &#123;    this.name &#x3D; &quot;hello&quot;;  &#125;&#125;</code></pre><p>Note that the field needs to be initialized in the constructor itself. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.<br><code>注意，字段需要在构造函数本身中初始化。TypeScript 不会分析调用构造函数的方法来检测初始化，因为继承的子类可能覆盖这些方法并且失败初始化成员。</code><br>If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !:<br><code>如果您愿意通过其他方式来确定初始化一个字段（例如，可能是外部库填充您的类的一部分），您可以使用确定赋值断言运算符：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class OKGreeter &#123;  &#x2F;&#x2F; Not initialized, but no error  name!: string;&#125;</code></pre><h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><p>Fields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor.<br><code>字段可以使用 readonly 前缀。这将阻止在构造函数之外赋值给字段。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Greeter &#123;  readonly name: string &#x3D; &quot;world&quot;;  constructor(otherName?: string) &#123;    if (otherName !&#x3D;&#x3D; undefined) &#123;      this.name &#x3D; otherName;    &#125;  &#125;  err() &#123;    this.name &#x3D; &quot;not ok&quot;;    &#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.  &#125;&#125;const g &#x3D; new Greeter();g.name &#x3D; &quot;also not ok&quot;;&#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.</code></pre><h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p><code>构造函数</code><br>Background Reading:<br><code>背景阅读：</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">Constructor (MDN)</a></p><p>Class constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:<br><code>类构造函数和函数很相似。您可以添加参数，类型注解，默认值和重载。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x: number;  y: number;  &#x2F;&#x2F; Normal signature with defaults  constructor(x &#x3D; 0, y &#x3D; 0) &#123;    this.x &#x3D; x;    this.y &#x3D; y;  &#125;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  &#x2F;&#x2F; Overloads  constructor(x: number, y: string);  constructor(s: string);  constructor(xs: any, y?: any) &#123;    &#x2F;&#x2F; TBD  &#125;&#125;</code></pre><p>There are just a few differences between class constructor signatures and function signatures:<br><code>类构造函数和函数签名有一些不同：</code></p><ul><li>Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later<br><code>- 构造函数不能有类型参数，这些属于外部类声明，我们将会学习其他内容</code></li><li>Constructors can’t have return type annotations - the class instance type is always what’s returned<br><code>- 构造函数不能有返回类型注解，返回的类实例类型始终是返回的</code></li></ul><h2 id="Super-Calls"><a href="#Super-Calls" class="headerlink" title="Super Calls"></a>Super Calls</h2><p><code>超类调用</code><br>Just as in JavaScript, if you have a base class, you’ll need to call super(); in your constructor body before using any this. members:<br><code>在 JavaScript 中，如果您有基类，您需要在构造函数体中调用 super(); 在使用任何 this. 成员之前：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;k &#x3D; 4;&#125;class Derived extends Base &#123;constructor() &#123;&#x2F;&#x2F; Prints a wrong value in ES5; throws exception in ES6console.log(this.k);&#39;super&#39; must be called before accessing &#39;this&#39; in the constructor of a derived class.super();&#125;&#125;</code></pre><p>Forgetting to call super is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.<br><code>在 JavaScript 中，忘记调用 super() 可能是一个很简单的错误，但 TypeScript 将告诉您当必要时。</code></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><code>方法</code><br>Background Reading:<br><code>背景阅读：</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/method">Method (MDN)</a></p><p>A function property on a class is called a method. Methods can use all the same type annotations as functions and constructors:<br><code>类中的函数属性被称为方法。方法可以使用和函数和构造函数一样的类型注解：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x &#x3D; 10;  y &#x3D; 10;  scale(n: number): void &#123;    this.x *&#x3D; n;    this.y *&#x3D; n;  &#125;&#125;</code></pre><p>Other than the standard type annotations, TypeScript doesn’t add anything else new to methods.<br><code>除了标准类型注解之外，TypeScript 不会添加任何其他东西到方法。</code><br>Note that inside a method body, it is still mandatory to access fields and other methods via this.. An unqualified name in a method body will always refer to something in the enclosing scope:<br><code>在方法体中，在方法体内部，您仍然必须通过 this 访问字段和其他方法。在方法体内部，未命名的名称将始终指向包含它的作用域内的东西：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x: number &#x3D; 0;class C &#123;x: string &#x3D; &quot;hello&quot;;  m() &#123;    &#x2F;&#x2F; This is trying to modify &#39;x&#39; from line 1, not the class property    &#x2F;&#x2F; 这是尝试从行 1 修改 &#39;x&#39;，而不是类属性    x &#x3D; &quot;world&quot;;    Type &#39;string&#39; is not assignable to type &#39;number&#39;.  &#125;&#125;</code></pre><h2 id="Getters-x2F-Setters"><a href="#Getters-x2F-Setters" class="headerlink" title="Getters &#x2F; Setters"></a>Getters &#x2F; Setters</h2><p><code>获取器/设置器</code><br>Classes can also have accessors:<br><code>类也可以有访问器：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class C &#123;  _length &#x3D; 0;  get length() &#123;    return this._length;  &#125;  set length(value) &#123;    this._length &#x3D; value;  &#125;&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Note that a field-backed get&#x2F;set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get&#x2F;set operations.<br><code>&gt;注意，没有额外逻辑的字段-获取/设置-对偶在 JavaScript 中很少是有用的。如果您不需要在获取/设置操作期间添加额外逻辑，则可以暴露公共字段。</code></p></blockquote><p>TypeScript has some special inference rules for accessors:<br><code>TypeScript 有一些特殊的推断规则为访问器：</code></p><ul><li>If get exists but no set, the property is automatically readonly<br><code>- 如果 get 存在但没有 set，属性是自动只读的</code></li><li>If the type of the setter parameter is not specified, it is inferred from the return type of the getter<br><code>- 如果设置器参数的类型没有指定，它会从 getter 的返回类型推断</code></li><li>Getters and setters must have the same Member Visibility<br><code>- 获取器和设置器必须具有相同的成员可见性</code><br>Since TypeScript 4.3, it is possible to have accessors with different types for getting and setting.<br><code>从 TypeScript 4.3 开始，可以有不同类型的访问器获取和设置。</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Thing &#123;  _size &#x3D; 0;  get size(): number &#123;    return this._size;  &#125;  set size(value: string | number | boolean) &#123;    let num &#x3D; Number(value);    &#x2F;&#x2F; Don&#39;t allow NaN, Infinity, etc    if (!Number.isFinite(num)) &#123;      this._size &#x3D; 0;      return;    &#125;    this._size &#x3D; num;  &#125;&#125;</code></pre><h2 id="Index-Signatures"><a href="#Index-Signatures" class="headerlink" title="Index Signatures"></a>Index Signatures</h2><p><code>索引签名</code><br>Classes can declare index signatures; these work the same as Index Signatures for other object types:<br><code>类可以声明索引签名；这类似于其他对象类型的索引签名：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MyClass &#123;  [s: string]: boolean | ((s: string) &#x3D;&gt; boolean);  check(s: string) &#123;    return this[s] as boolean;  &#125;&#125;</code></pre><p>Because the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.<br><code>因为索引签名类型也需要捕获方法的类型，这使得并不容易有效的使用这些类型。通常的来说，在其他地方存储索引数据而不是在类实例本身，会更好一些。</code></p><h2 id="Class-Heritage"><a href="#Class-Heritage" class="headerlink" title="Class Heritage"></a>Class Heritage</h2><p><code>类继承</code><br>Like other languages with object-oriented features, classes in JavaScript can inherit from base classes.<br><code>在 JavaScript 中，类可以从基类继承。</code></p><h2 id="implements-Clauses"><a href="#implements-Clauses" class="headerlink" title="implements Clauses"></a>implements Clauses</h2><p><code>implements 语句</code><br>You can use an implements clause to check that a class satisfies a particular interface. An error will be issued if a class fails to correctly implement it:<br><code>你可以使用 implements 语句检查一个类是否满足一个特定的 interface。如果一个类没有正确的实现(implement)它，TypeScript 会报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Pingable &#123;  ping(): void;&#125;class Sonar implements Pingable &#123;  ping() &#123;    console.log(&quot;ping!&quot;);  &#125;&#125;class Ball implements Pingable &#123;  &#x2F;&#x2F; Class &#39;Ball&#39; incorrectly implements interface &#39;Pingable&#39;.  &#x2F;&#x2F; 类 &#39;Ball&#39; 错误地实现了接口 &#39;Pingable&#39;。  &#x2F;&#x2F; Property &#39;ping&#39; is missing in type &#39;Ball&#39; but required in type &#39;Pingable&#39;.  &#x2F;&#x2F; 在类型 &#39;Ball&#39; 中缺少属性 &#39;ping&#39;，但是在类型 &#39;Pingable&#39; 中是必需的。  pong() &#123;    console.log(&quot;pong!&quot;);  &#125;&#125;</code></pre><p>Classes may also implement multiple interfaces, e.g. class C implements A, B {.<br><code>类也可以实现多个接口，比如 class C implements A, B &#123;</code></p><p><strong>Cautions</strong></p><p><code>注意事项</code></p><p><strong>大概意思：这是类型，不是 java 中的接口，不能当 js 类去用,与 js 的类不是一个概念</strong></p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>It’s important to understand that an implements clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods at all. A common source of error is to assume that an implements clause will change the class type - it doesn’t!<br><code>implements 语句仅仅检查类是否按照接口类型实现，但它并不会改变类的类型或者方法的类型。一个常见的错误就是以为 implements 语句会改变类的类型,——然而实际上它并不会：</code></p></div><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Checkable &#123;  check(name: string): boolean;&#125;class NameChecker implements Checkable &#123;  check(s) &#123;    &#x2F;&#x2F; Parameter &#39;s&#39; implicitly has an &#39;any&#39; type.    &#x2F;&#x2F; Notice no error here    return s.toLowercse() &#x3D;&#x3D;&#x3D; &quot;ok&quot;;    &#x2F;&#x2F; any;  &#125;&#125;</code></pre><p>In this example, we perhaps expected that s’s type would be influenced by the name: string parameter of check. It is not - implements clauses don’t change how the class body is checked or its type inferred.<br><code>在这个例子中，我们可能会以为 s 的类型会被 check 的 name: string 参数影响。实际上并没有，implements 语句并不会影响类的内部是如何检查或者类型推断的。</code><br>Similarly, implementing an interface with an optional property doesn’t create that property:<br><code>类似的，实现一个有可选属性的接口，并不会创建这个属性：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface A &#123;  x: number;  y?: number;&#125;class C implements A &#123;  x &#x3D; 0;&#125;const c &#x3D; new C();c.y &#x3D; 10;&#x2F;&#x2F; Property &#39;y&#39; does not exist on type &#39;C&#39;.</code></pre><h2 id="extends-Clauses"><a href="#extends-Clauses" class="headerlink" title="extends Clauses"></a>extends Clauses</h2><p><code>extends 语句</code></p><p>Background Reading: <a href="https://www.typescriptlang.org/docs/handbook/classes.html#class-inheritance">Class Inheritance</a></p><p><code>背景阅读：[类继承](https://www.typescriptlang.org/docs/handbook/classes.html#class-inheritance)</code></p><p>Classes may extend from a base class. A derived class has all the properties and methods of its base class, and also define additional members.<br><code>类可以从基类继承。一个派生类具有基类的所有属性和方法，并且还定义了一些额外的成员。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Animal &#123;  move() &#123;    console.log(&quot;Moving along!&quot;);  &#125;&#125;class Dog extends Animal &#123;  woof(times: number) &#123;    for (let i &#x3D; 0; i &lt; times; i++) &#123;      console.log(&quot;woof!&quot;);    &#125;  &#125;&#125;const d &#x3D; new Dog();&#x2F;&#x2F; Base class methodd.move();&#x2F;&#x2F; Derived class methodd.woof(3);</code></pre><h3 id="Overriding-Methods"><a href="#Overriding-Methods" class="headerlink" title="Overriding Methods"></a>Overriding Methods</h3><p><code>覆写方法</code></p><p>Background Reading: <a href="https://www.typescriptlang.org/docs/handbook/classes.html#overriding-methods">Overriding Methods</a></p><p>A derived class can also override a base class field or property. You can use the super. syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.<br><code>派生类可以覆写基类的属性或方法。可以使用 super. 语句访问基类的方法。注意，因为 JavaScript 的类是简单的查找对象，所以没有基类的“super 字段”。</code><br>TypeScript enforces that a derived class is always a subtype of its base class.<br><code>TypeScript 强制所有派生类都是基类的子类。</code><br>For example, here’s a legal way to override a method:<br><code>这里是一种合法的方式覆写方法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  greet() &#123;    console.log(&quot;Hello, world!&quot;);  &#125;&#125;class Derived extends Base &#123;  greet(name?: string) &#123;    if (name &#x3D;&#x3D;&#x3D; undefined) &#123;      super.greet();    &#125; else &#123;      console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);    &#125;  &#125;&#125;const d &#x3D; new Derived();d.greet();d.greet(&quot;reader&quot;);</code></pre><p>It’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:<br><code>派生类需要遵循着它的基类的实现。而且通过一个基类引用指向一个派生类实例，这是非常常见并合法的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Alias the derived instance through a base class reference&#x2F;&#x2F; 基类引用来访问派生类的实例const b: Base &#x3D; d;&#x2F;&#x2F; No problem&#x2F;&#x2F; 没有问题b.greet();</code></pre><p>What if Derived didn’t follow Base’s contract?<br><code>但是如果 Derived 不遵循 Base 的约定实现呢？</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  greet() &#123;    console.log(&quot;Hello, world!&quot;);  &#125;&#125;class Derived extends Base &#123;  &#x2F;&#x2F; Make this parameter required  greet(name: string) &#123;    &#x2F;&#x2F; Property &#39;greet&#39; in type &#39;Derived&#39; is not assignable to the same property in base type &#39;Base&#39;.    &#x2F;&#x2F; Type &#39;(name: string) &#x3D;&gt; void&#39; is not assignable to type &#39;() &#x3D;&gt; void&#39;.    console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);  &#125;&#125;</code></pre><p>If we compiled this code despite the error, this sample would then crash:<br><code>如果我们编译这段代码，却没有报错，那么这个例子就会崩溃：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const b: Base &#x3D; new Derived();&#x2F;&#x2F; Crashes because &quot;name&quot; will be undefinedb.greet();</code></pre><h3 id="Type-only-Field-Declarations"><a href="#Type-only-Field-Declarations" class="headerlink" title="Type-only Field Declarations"></a>Type-only Field Declarations</h3><p><code>只有字段申明的类型</code><br>When target &gt;&#x3D; ES2022 or useDefineForClassFields is true, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write declare to indicate to TypeScript that there should be no runtime effect for this field declaration.<br><code>当目标版本 &gt;= ES2022 或者 useDefineForClassFields 为 true 时，类字段在父类构造函数完成后初始化，并且会覆盖父类的设置。这种情况下，如果你只想重新定义一个更加准确的类型，你可以使用 declare 来指示给 TypeScript。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  dateOfBirth: any;&#125;interface Dog extends Animal &#123;  breed: any;&#125;class AnimalHouse &#123;  resident: Animal;  constructor(animal: Animal) &#123;    this.resident &#x3D; animal;  &#125;&#125;class DogHouse extends AnimalHouse &#123;  &#x2F;&#x2F; Does not emit JavaScript code,  &#x2F;&#x2F; 不能生成 JavaScript 代码  &#x2F;&#x2F; only ensures the types are correct  &#x2F;&#x2F; 只是确保类型正确  declare resident: Dog;  constructor(dog: Dog) &#123;    super(dog);  &#125;&#125;</code></pre><p><strong>输出</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; .d.tsinterface Animal &#123;  dateOfBirth: any;&#125;interface Dog extends Animal &#123;  breed: any;&#125;declare class AnimalHouse &#123;  resident: Animal;  constructor(animal: Animal);&#125;declare class DogHouse extends AnimalHouse &#123;  resident: Dog;  constructor(dog: Dog);&#125;</code></pre><h3 id="Initialization-Order"><a href="#Initialization-Order" class="headerlink" title="Initialization Order"></a>Initialization Order</h3><p><code>初始化顺序</code><br>The order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:<br><code>这段代码的初始化顺序可能会有些不同。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  name &#x3D; &quot;base&quot;;  constructor() &#123;    console.log(&quot;My name is &quot; + this.name);  &#125;&#125;class Derived extends Base &#123;  name &#x3D; &quot;derived&quot;;&#125;&#x2F;&#x2F; Prints &quot;base&quot;, not &quot;derived&quot;const d &#x3D; new Derived();</code></pre><h3 id="What-happened-here"><a href="#What-happened-here" class="headerlink" title="What happened here?"></a>What happened here?</h3><p><code>这里发生了什么？</code> 先执行基类构造，this.name 值是“base”<br>The order of class initialization, as defined by JavaScript, is:<br><code>JavaScript 的初始化顺序：</code></p><ul><li>The base class fields are initialized<br><code>基类字段初始化</code></li><li>The base class constructor runs<br><code>基类构造函数运行</code></li><li>The derived class fields are initialized<br><code>派生类字段初始化</code></li><li>The derived class constructor runs<br><code>派生类构造函数运行</code><br>This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadn’t run yet.</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  name &#x3D; &quot;base&quot;;  constructor() &#123;    console.log(&quot;My name is &quot; + this.name);  &#125;&#125;class Derived extends Base &#123;  name &#x3D; &quot;derived&quot;;&#125;&#x2F;&#x2F; Prints &quot;base&quot;, not &quot;derived&quot;const d &#x3D; new Derived();console.log(d.name); &#x2F;&#x2F; 加个日志看看</code></pre><p>点击 run 后，返回</p><pre class="line-numbers language-none"><code class="language-none">[LOG]: &quot;My name is base&quot;[LOG]: &quot;derived&quot;</code></pre><h3 id="Inheriting-Built-in-Types"><a href="#Inheriting-Built-in-Types" class="headerlink" title="Inheriting Built-in Types"></a>Inheriting Built-in Types</h3><p><code>继承内置类型</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Note: If you don’t plan to inherit from built-in types like Array, Error, Map, etc. or your compilation target is explicitly set to ES6&#x2F;ES2015 or above, you may skip this section<br><code>注意：如果你不打算继承内置的类型比如 Array、Error、Map 等或者你的编译目标是 ES6/ES2015 或者更新的版本，你可以跳过这个章节。</code></p></blockquote><p>In ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(…). It is necessary for generated constructor code to capture any potential return value of super(…) and replace it with this.<br><code>在 ES2015 中，当调用 super(...) 的时候，如果构造函数返回了一个对象，会隐式替换 this 的值。所以捕获 super() 可能的返回值并用 this 替换它是非常有必要的。</code><br>As a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6’s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.<br><code>这就导致，像 Error、Array 等子类，也许不会再如你期望的那样运行。这是因为 Error、Array 等类似内置对象的构造函数，会使用 ECMAScript 6 的 new.target 调整原型链。然而，在 ECMAScript 5 中，当调用一个构造函数的时候，并没有方法可以确保 new.target 的值。 其他的降级编译器默认也会有同样的限制。</code><br>For a subclass like the following:<br><code>下面的子类：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MsgError extends Error &#123;  constructor(m: string) &#123;    super(m);  &#125;  sayHello() &#123;    return &quot;hello &quot; + this.message;  &#125;&#125;</code></pre><p>you may find that:<br><code>你也许可以发现：</code><br>methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error.<br><code>对象的方法可能是 undefined ，所以调用 sayHello 会导致错误</code><br>instanceof will be broken between instances of the subclass and their instances, so (new MsgError()) instanceof MsgError will return false.<br><code>instanceof 失效， (new MsgError()) instanceof MsgError 会返回 false。</code><br>As a recommendation, you can manually adjust the prototype immediately after any super(…) calls.<br><code>我们推荐，手动的在 super(...) 调用后调整原型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MsgError extends Error &#123;  constructor(m: string) &#123;    super(m);    &#x2F;&#x2F; Set the prototype explicitly.    Object.setPrototypeOf(this, MsgError.prototype);  &#125;  sayHello() &#123;    return &quot;hello &quot; + this.message;  &#125;&#125;</code></pre><p>However, any subclass of MsgError will have to manually set the prototype as well. For runtimes that don’t support Object.setPrototypeOf, you may instead be able to use <code>__proto__</code>.<br><code>不过，任何 MsgError 的子类也不得不手动设置原型。如果运行时不支持 Object.setPrototypeOf，你也许可以使用 __proto__ </code></p><p>Unfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed.<br><code>不幸的是，这些方案并不会能在 IE 10 或者之前的版本正常运行。解决的一个方法是手动拷贝原型中的方法到实例中（就比如 MsgError.prototype 到 this），但是它自己的原型链依然没有被修复</code></p><h2 id="Member-Visibility"><a href="#Member-Visibility" class="headerlink" title="Member Visibility"></a>Member Visibility</h2><p><code>成员可见性</code><br>You can use TypeScript to control whether certain methods or properties are visible to code outside the class.<br><code>你可以使用 TypeScript 控制某个方法或者属性是否对类以外的代码可见。</code></p><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>The default visibility of class members is public. A public member can be accessed anywhere:<br><code>因为 public 是默认的可见性修饰符，所以你不需要写它，除非处于格式或者可读性的原因。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Greeter &#123;  public greet() &#123;    console.log(&quot;hi!&quot;);  &#125;&#125;const g &#x3D; new Greeter();g.greet();</code></pre><p>Because public is already the default visibility modifier, you don’t ever need to write it on a class member, but might choose to do so for style&#x2F;readability reasons.<br><code>因为 public 是默认的可见性修饰符，所以你不需要写它，除非处于格式或者可读性的原因。</code></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected members are only visible to subclasses of the class they’re declared in.<br><code>protected 成员仅仅对子类可见</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Greeter &#123;  public greet() &#123;    console.log(&quot;Hello, &quot; + this.getName());  &#125;  protected getName() &#123;    return &quot;hi&quot;;  &#125;&#125;class SpecialGreeter extends Greeter &#123;  public howdy() &#123;    &#x2F;&#x2F; OK to access protected member here    console.log(&quot;Howdy, &quot; + this.getName());  &#125;&#125;const g &#x3D; new SpecialGreeter();g.greet(); &#x2F;&#x2F; OKg.getName();&#x2F;&#x2F; Property &#39;getName&#39; is protected and only accessible within class &#39;Greeter&#39; and its subclasses.</code></pre><h3 id="Exposure-of-protected-members"><a href="#Exposure-of-protected-members" class="headerlink" title="Exposure of protected members"></a>Exposure of protected members</h3><p><code>受保护成员的公开</code></p><p>Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public:<br><code>派生类需要遵循基类的实现，但是依然可以选择公开拥有更多能力的基类子类型，这就包括让一个 protected 成员变成 public：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  protected m &#x3D; 10;&#125;class Derived extends Base &#123;  &#x2F;&#x2F; No modifier, so default is &#39;public&#39;  m &#x3D; 15;&#125;const d &#x3D; new Derived();console.log(d.m); &#x2F;&#x2F; OK</code></pre><p>Note that Derived was already able to freely read and write m, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the protected modifier if this exposure isn’t intentional.<br><code>这里需要注意的是，如果公开不是故意的，在这个派生类中，我们需要小心的拷贝 protected 修饰符。</code></p><h3 id="Cross-hierarchy-protected-access"><a href="#Cross-hierarchy-protected-access" class="headerlink" title="Cross-hierarchy protected access"></a>Cross-hierarchy protected access</h3><p><code>交叉等级受保护成员访问</code></p><p>Different OOP languages disagree about whether it’s legal to access a protected member through a base class reference:</p><p><code>不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  protected x: number &#x3D; 1;&#125;class Derived1 extends Base &#123;  protected x: number &#x3D; 5;&#125;class Derived2 extends Base &#123;  f1(other: Derived2) &#123;    other.x &#x3D; 10;  &#125;  f2(other: Base) &#123;    other.x &#x3D; 10;    &#x2F;&#x2F; Property &#39;x&#39; is protected and only accessible through an instance of class &#39;Derived2&#39;. This is an instance of class &#39;Base&#39;.    &#x2F;&#x2F; 属性 &#39;x&#39; 受保护并且只能通过类 &#39;Derived2&#39; 的实例访问。这是一个类 &#39;Base&#39; 的实例。  &#125;&#125;</code></pre><p>Java, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.<br><code>在 Java 中，这是合法的，而 C# 和 C++ 认为这段代码是不合法的。</code><br>TypeScript sides with C# and C++ here, because accessing x in Derived2 should only be legal from Derived2’s subclasses, and Derived1 isn’t one of them. Moreover, if accessing x through a Derived1 reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.<br><code>TypeScript 站在 C# 和 C++ 这边。因为 Derived2 的 x 应该只有从 Derived2 的子类访问才是合法的，而 Derived1 并不是它们中的一个。此外，如果通过 Derived1 访问 x 是不合法的，通过一个基类引用访问也应该是不合法的。</code><br>See also Why Can’t I Access A Protected Member From A Derived Class? which explains more of C#‘s reasoning.<br><code>看这篇《Why Can’t I Access A Protected Member From A Derived Class?》 (opens new window)，解释了更多 C# 这样做的原因。</code></p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private is like protected, but doesn’t allow access to the member even from subclasses:<br><code>private 有点像 protected ，但是不允许访问成员，即便是子类。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  private x &#x3D; 0;&#125;const b &#x3D; new Base();&#x2F;&#x2F; Can&#39;t access from outside the class&#x2F;&#x2F; 不能从外部访问console.log(b.x);&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.&#x2F;&#x2F; 属性 &#39;x&#39; 是私有的，只能在类 &#39;Base&#39; 中访问。</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Derived extends Base &#123;  showX() &#123;    &#x2F;&#x2F; Can&#39;t access in subclasses    console.log(this.x);    &#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.    &#x2F;&#x2F; 属性 &#39;x&#39; 是私有的，只能在类 &#39;Base&#39; 中访问。  &#125;&#125;</code></pre><p>Because private members aren’t visible to derived classes, a derived class can’t increase its visibility:<br><code>因为 private 成员对派生类并不可见，所以一个派生类也不能增加它的可见性：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  private x &#x3D; 0;&#125;class Derived extends Base &#123;  &#x2F;&#x2F; Class &#39;Derived&#39; incorrectly extends base class &#39;Base&#39;.  &#x2F;&#x2F; 类 &#39;Derived&#39; 错误地继承了基类 &#39;Base&#39;。  &#x2F;&#x2F; Property &#39;x&#39; is private in type &#39;Base&#39; but not in type &#39;Derived&#39;.  &#x2F;&#x2F; 属性 &#39;x&#39; 在类 &#39;Base&#39; 中，但不在类 &#39;Derived&#39; 中。  x &#x3D; 1;&#125;</code></pre><h3 id="Cross-instance-private-access"><a href="#Cross-instance-private-access" class="headerlink" title="Cross-instance private access"></a>Cross-instance private access</h3><p><code>交叉等级受保护成员访问</code><br>Different OOP languages disagree about whether different instances of the same class may access each others’ private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.<br><code>不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的。在 Java, C#, C++, Swift, and PHP 中，这是合法的，而 Ruby 认为这段代码是不合法的。</code><br>TypeScript does allow cross-instance private access:<br><code>允许交叉实例私有访问</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class A &#123;  private x &#x3D; 10;  public sameAs(other: A) &#123;    &#x2F;&#x2F; No error    return other.x &#x3D;&#x3D;&#x3D; this.x;  &#125;&#125;</code></pre><h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats"></a>Caveats</h3><p><code>警告</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Like other aspects of TypeScript’s type system, private and protected are only enforced during type checking.<br><code>类型检查中，private 和 protected 只是类型检查的一部分。</code></p></blockquote><p>This means that JavaScript runtime constructs like in or simple property lookup can still access a private or protected member:<br><code>这意味着在 JavaScript 运行时，像 in 或者简单的属性查找，依然可以获取 private 或者 protected 成员。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MySafe &#123;  private secretKey &#x3D; 12345;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; In a JavaScript file...const s &#x3D; new MySafe();&#x2F;&#x2F; Will print 12345console.log(s.secretKey);</code></pre><p>private also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy.<br><code>private 也允许使用方括号来访问，这使得 private-declared 字段可以轻松地访问，但是这些字段是软私有的，并不强制私密。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MySafe &#123;private secretKey &#x3D; 12345;&#125;const s &#x3D; new MySafe();&#x2F;&#x2F; Not allowed during type checkingconsole.log(s.secretKey);Property &#39;secretKey&#39; is private and only accessible within class &#39;MySafe&#39;.&#x2F;&#x2F; OKconsole.log(s[&quot;secretKey&quot;]);</code></pre><p>Unlike TypeScripts’s private, JavaScript’s private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.<br><code>不像 TypeScript 的 private，JavaScript 的私有字段 (opens new window)（#）即便是编译后依然保留私有性，并且不会提供像上面这种方括号获取的方法，这让它们变得强私有（hard private）。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Dog &#123;  #barkAmount &#x3D; 0;  personality &#x3D; &quot;happy&quot;;  constructor() &#123;&#125;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&quot;use strict&quot;;class Dog &#123;  #barkAmount &#x3D; 0;  personality &#x3D; &quot;happy&quot;;  constructor() &#123;&#125;&#125;</code></pre><p>When compiling to ES2021 or less, TypeScript will use WeakMaps in place of #.<br><code>在编译到 ES2021 或更低版本时，TypeScript 会使用 WeakMaps 替代 #。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&quot;use strict&quot;;var _Dog_barkAmount;class Dog &#123;  constructor() &#123;    _Dog_barkAmount.set(this, 0);    this.personality &#x3D; &quot;happy&quot;;  &#125;&#125;_Dog_barkAmount &#x3D; new WeakMap();</code></pre><p>If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.<br><code>如果你需要防止恶意攻击，保护类中的值，你应该使用强私有的机制比如闭包，WeakMaps ，或者私有字段。但是注意，这也会在运行时影响性能。</code></p><h2 id="Static-Members"><a href="#Static-Members" class="headerlink" title="Static Members"></a>Static Members</h2><p><code>静态成员</code></p><p>Background Reading: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">Static Members (MDN)</a></p><p>Classes may have static members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:<br><code>类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MyClass &#123;  static x &#x3D; 0;  static printX() &#123;    console.log(MyClass.x);  &#125;&#125;console.log(MyClass.x);MyClass.printX();</code></pre><p>Static members can also use the same public, protected, and private visibility modifiers:<br><code>类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MyClass &#123;  private static x &#x3D; 0;&#125;console.log(MyClass.x);&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;MyClass&#39;.</code></pre><h3 id="Static-members-are-also-inherited"><a href="#Static-members-are-also-inherited" class="headerlink" title="Static members are also inherited:"></a>Static members are also inherited:</h3><p><code>静态成员也可以被继承：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  static getGreeting() &#123;    return &quot;Hello world&quot;;  &#125;&#125;class Derived extends Base &#123;  myGreeting &#x3D; Derived.getGreeting();&#125;</code></pre><h3 id="Special-Static-Names"><a href="#Special-Static-Names" class="headerlink" title="Special Static Names"></a>Special Static Names</h3><p><code>特殊静态类</code><br>It’s generally not safe&#x2F;possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names can’t be used. Function properties like name, length, and call aren’t valid to define as static members:<br><code>类本身是函数，而覆写 Function 原型上的属性通常认为是不安全的，因此不能使用一些固定的静态名称，函数属性像 name、length、call 不能被用来定义 static 成员：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class S &#123;  static name &#x3D; &quot;S!&quot;;  &#x2F;&#x2F; Static property &#39;name&#39; conflicts with built-in property &#39;Function.name&#39; of constructor function &#39;S&#39;.&#125;</code></pre><h3 id="Why-No-Static-Classes"><a href="#Why-No-Static-Classes" class="headerlink" title="Why No Static Classes?"></a>Why No Static Classes?</h3><p><code>为什么没有静态类？</code></p><p>TypeScript (and JavaScript) don’t have a construct called static class the same way as, for example, C# does.<br><code>TypeScript（和 JavaScript） 并没有名为静态类（static class）的结构，但是像 C# 和 Java 有。</code><br>Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript&#x2F;TypeScript.<br><code>所谓静态类，指的是作为类的静态成员存在于某个类的内部的类。比如这种：</code><br>For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:<br><code>静态类之所以存在是因为这些语言强迫所有的数据和函数都要在一个类内部，但这个限制在 TypeScript 中并不存在，所以也没有静态类的需要。一个只有一个单独实例的类，在 JavaScript/TypeScript 中，完全可以使用普通的对象替代。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Unnecessary &quot;static&quot; classclass MyStaticClass &#123;  static doSomething() &#123;&#125;&#125;&#x2F;&#x2F; Preferred (alternative 1)function doSomething() &#123;&#125;&#x2F;&#x2F; Preferred (alternative 2)const MyHelperObject &#x3D; &#123;  dosomething() &#123;&#125;,&#125;;</code></pre><h2 id="static-Blocks-in-Classes"><a href="#static-Blocks-in-Classes" class="headerlink" title="static Blocks in Classes"></a>static Blocks in Classes</h2><p><code>类静态块</code><br>Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.<br><code>静态块允许你写一系列有自己作用域的语句，也可以获取类里的私有字段。这意味着我们可以安心的写初始化代码：正常书写语句，无变量泄漏，还可以完全获取类中的属性和方法。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Foo &#123;  static #count &#x3D; 0;  get count() &#123;    return Foo.#count;  &#125;  static &#123;    try &#123;      const lastInstances &#x3D; loadLastInstances();      Foo.#count +&#x3D; lastInstances.length;    &#125; catch &#123;&#125;  &#125;&#125;</code></pre><h3 id="Generic-Classes"><a href="#Generic-Classes" class="headerlink" title="Generic Classes"></a>Generic Classes</h3><p><code>范型类</code></p><p>Classes, much like interfaces, can be generic. When a generic class is instantiated with new, its type parameters are inferred the same way as in a function call:<br><code>类跟接口一样，也可以写泛型。当使用 new 实例化一个泛型类，它的类型参数的推断跟函数调用是同样的方式：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Box&lt;Type&gt; &#123;  contents: Type;  constructor(value: Type) &#123;    this.contents &#x3D; value;  &#125;&#125;const b &#x3D; new Box(&quot;hello!&quot;);const b: Box&lt;string&gt;;</code></pre><p>Classes can use generic constraints and defaults the same way as interfaces.<br><code>类跟接口一样也可以使用泛型约束以及默认值。</code></p><h3 id="Type-Parameters-in-Static-Members"><a href="#Type-Parameters-in-Static-Members" class="headerlink" title="Type Parameters in Static Members"></a>Type Parameters in Static Members</h3><p><code>静态成员中的类型参数</code><br>This code isn’t legal, and it may not be obvious why:<br><code>这段代码不合法，并且可能不明白为什么：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Box&lt;Type&gt; &#123;static defaultValue: Type;Static members cannot reference class type parameters.&#125;</code></pre><p>Remember that types are always fully erased! At runtime, there’s only one Box.defaultValue property slot. This means that setting Box<string>.defaultValue (if that were possible) would also change Box<number>.defaultValue - not good. The static members of a generic class can never refer to the class’s type parameters.<br><code>记住类型会被完全抹除，运行时，只有一个 Box.defaultValue 属性槽。这也意味着如果设置 Box&lt;string&gt;.defaultValue 是可以的话，这也会改变 Box&lt;number&gt;.defaultValue，而这样是不好的。</code></p><h3 id="this-at-Runtime-in-Classes"><a href="#this-at-Runtime-in-Classes" class="headerlink" title="this at Runtime in Classes"></a>this at Runtime in Classes</h3><p>Background Reading:<br><code>背景阅读：</code><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">this keyword (MDN)</a><br>It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.<br><code>TypeScript 并不会更改 JavaScript 运行时的行为，并且 JavaScript 有时会出现一些奇怪的运行时行为。</code><br>JavaScript’s handling of this is indeed unusual:<br><code>就比如 JavaScript 处理 this 就很奇怪：</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class MyClass &#123;  name &#x3D; &quot;MyClass&quot;;  getName() &#123;    return this.name;  &#125;&#125;const c &#x3D; new MyClass();const obj &#x3D; &#123;  name: &quot;obj&quot;,  getName: c.getName,&#125;;&#x2F;&#x2F; Prints &quot;obj&quot;, not &quot;MyClass&quot;console.log(obj.getName());</code></pre><p>Long story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance.<br><code>长篇大论，默认情况下，函数内部的 this 值取决于函数被调用的方式。在这个例子中，因为函数被 obj 引用调用，它的 this 值是 obj，而不是类实例。</code><br>This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.<br><code>这很少是你想要的！TypeScript 提供了一些方法来解决这种错误。</code></p><h3 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h3><p>Background Reading:<br><code>背景阅读：</code><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions (MDN)</a></p><p>If you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition:<br><code>如果你有一个函数，经常在被调用的时候丢失 this 上下文，使用一个箭头函数或许更好些。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MyClass &#123;  name &#x3D; &quot;MyClass&quot;;  getName &#x3D; () &#x3D;&gt; &#123;    return this.name;  &#125;;&#125;const c &#x3D; new MyClass();const g &#x3D; c.getName;&#x2F;&#x2F; Prints &quot;MyClass&quot; instead of crashingconsole.log(g());</code></pre><p>This has some trade-offs:<br><code>这里有几点需要注意下：</code></p><ul><li>The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript<br><code>- 这个 this 值在运行时是一定的，即使没有 TypeScript 的检查</code></li><li>This will use more memory, because each class instance will have its own copy of each function defined this way<br><code>- 这会使用更多的内存，因为每个类实例都会有自己的拷贝</code></li><li>You can’t use super.getName in a derived class, because there’s no entry in the prototype chain to fetch the base class method from<br><code>- 你不能在子类中使用 super.getName，因为没有基类原型链来获取基类方法</code></li></ul><h3 id="this-parameters"><a href="#this-parameters" class="headerlink" title="this parameters"></a>this parameters</h3><p>In a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation:<br><code>在方法或函数定义中，一个初始参数名为 this 的特殊意义在 TypeScript 中。这些参数在编译期间会被抹除。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; TypeScript input with &#39;this&#39; parameterfunction fn(this: SomeType, x: number) &#123;  &#x2F;* ... *&#x2F;&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; JavaScript outputfunction fn(x) &#123;  &#x2F;* ... *&#x2F;&#125;</code></pre><p>TypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly:<br><code>TypeScript 会检查一个有 this 参数的函数在调用时是否有一个正确的上下文。不像上个例子使用箭头函数，我们可以给方法定义添加一个 this 参数，静态强制方法被正确调用：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MyClass &#123;  name &#x3D; &quot;MyClass&quot;;  getName(this: MyClass) &#123;    return this.name;  &#125;&#125;const c &#x3D; new MyClass();&#x2F;&#x2F; OKc.getName();&#x2F;&#x2F; Error, would crashconst g &#x3D; c.getName;console.log(g());&#x2F;&#x2F; The &#39;this&#39; context of type &#39;void&#39; is not assignable to method&#39;s &#39;this&#39; of type &#39;MyClass&#39;.</code></pre><p>This method makes the opposite trade-offs of the arrow function approach:<br><code>这个方法也有一些注意点，正好跟箭头函数相反：</code></p><ul><li>JavaScript callers might still use the class method incorrectly without realizing it<br><code>JavaScript 调用者依然可能在没有意识到它的时候错误使用类方法</code></li><li>Only one function per class definition gets allocated, rather than one per class instance<br><code>每个类一个函数，而不是每一个类实例一个函数</code></li><li>Base method definitions can still be called via super.<br><code>基类方法定义依然可以通过 super 调用</code></li></ul><h3 id="this-Types"><a href="#this-Types" class="headerlink" title="this Types"></a>this Types</h3><p>In classes, a special type called this refers dynamically to the type of the current class. Let’s see how this is useful:<br><code>在类中，一个特殊的类型叫做 this，它可以动态指向当前类的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Box &#123;  contents: string &#x3D; &quot;&quot;;  set(value: string) &#123;    &#x2F;&#x2F; (method) Box.set(value: string): this    this.contents &#x3D; value;    return this;  &#125;&#125;</code></pre><p>Here, TypeScript inferred the return type of set to be this, rather than Box. Now let’s make a subclass of Box:<br><code>这里，TypeScript 推断 set 的返回类型为 this，而不是 Box。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class ClearableBox extends Box &#123;  clear() &#123;    this.contents &#x3D; &quot;&quot;;  &#125;&#125;const a &#x3D; new ClearableBox();const b &#x3D; a.set(&quot;hello&quot;);&#x2F;&#x2F; const b: ClearableBox</code></pre><p>You can also use this in a parameter type annotation:<br><code>你也可以在参数类型注解中使用 this：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Box &#123;  content: string &#x3D; &quot;&quot;;  sameAs(other: this) &#123;    return other.content &#x3D;&#x3D;&#x3D; this.content;  &#125;&#125;</code></pre><p>This is different from writing other: Box — if you have a derived class, its sameAs method will now only accept other instances of that same derived class:<br><code>这与写其他：Box — 如果你有一个派生类，它的 sameAs 方法将只接受来自同一派生类的其他实例：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Box &#123;  content: string &#x3D; &quot;&quot;;  sameAs(other: this) &#123;    return other.content &#x3D;&#x3D;&#x3D; this.content;  &#125;&#125;class DerivedBox extends Box &#123;  otherContent: string &#x3D; &quot;?&quot;;&#125;const base &#x3D; new Box();const derived &#x3D; new DerivedBox();derived.sameAs(base);&#x2F;&#x2F; Argument of type &#39;Box&#39; is not assignable to parameter of type &#39;DerivedBox&#39;.&#x2F;&#x2F; Property &#39;otherContent&#39; is missing in type &#39;Box&#39; but required in type &#39;DerivedBox&#39;.</code></pre><h3 id="this-based-type-guards"><a href="#this-based-type-guards" class="headerlink" title="this -based type guards"></a>this -based type guards</h3><p>You can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type.<br><code>你可以在类和接口中的方法的返回位置使用 this。当混入一个类型缩小（如 if 语句）的时候，目标对象的类型将被缩小到指定的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class FileSystemObject &#123;  isFile(): this is FileRep &#123;    return this instanceof FileRep;  &#125;  isDirectory(): this is Directory &#123;    return this instanceof Directory;  &#125;  isNetworked(): this is Networked &amp; this &#123;    return this.networked;  &#125;  constructor(public path: string, private networked: boolean) &#123;&#125;&#125;class FileRep extends FileSystemObject &#123;  constructor(path: string, public content: string) &#123;    super(path, false);  &#125;&#125;class Directory extends FileSystemObject &#123;  children: FileSystemObject[];&#125;interface Networked &#123;  host: string;&#125;const fso: FileSystemObject &#x3D; new FileRep(&quot;foo&#x2F;bar.txt&quot;, &quot;foo&quot;);if (fso.isFile()) &#123;  fso.content;  &#x2F;&#x2F; const fso: FileRep;&#125; else if (fso.isDirectory()) &#123;  fso.children;  &#x2F;&#x2F; const fso: Directory;&#125; else if (fso.isNetworked()) &#123;  fso.host;  &#x2F;&#x2F; const fso: Networked &amp; FileSystemObject;&#125;</code></pre><p>A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an undefined from the value held inside box when hasValue has been verified to be true:<br><code>一个常见的基于 this 的类型保护的使用例子，会对一个特定的字段进行懒校验（lazy validation）。举个例子，在这个例子中，当 hasValue 被验证为 true 时，会从类型中移除 undefined：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Box&lt;T&gt; &#123;value?: T;hasValue(): this is &#123; value: T &#125; &#123;return this.value !&#x3D;&#x3D; undefined;&#125;&#125;const box &#x3D; new Box();box.value &#x3D; &quot;Gameboy&quot;;box.value;(property) Box&lt;unknown&gt;.value?: unknownif (box.hasValue()) &#123;box.value;(property) value: unknown&#125;</code></pre><h2 id="Parameter-Properties"><a href="#Parameter-Properties" class="headerlink" title="Parameter Properties"></a>Parameter Properties</h2><p><code>参数属性</code><br>TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s):<br><code>TypeScript 提供了特殊的语法，可以把一个构造函数参数转成一个同名同值的类属性。这些就被称为参数属性（parameter properties）。你可以通过在构造函数参数前添加一个可见性修饰符 public private protected 或者 readonly 来创建参数属性，最后这些类属性字段也会得到这些修饰符：</code></p><p><strong>之后我们 look 一下 flutter,太像</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Params &#123;  constructor(    public readonly x: number,    protected y: number,    private z: number  ) &#123;    &#x2F;&#x2F; No body necessary  &#125;&#125;const a &#x3D; new Params(1, 2, 3);console.log(a.x);&#x2F;&#x2F; (property) Params.x: numberconsole.log(a.z);&#x2F;&#x2F; Property &#39;z&#39; is private and only accessible within class &#39;Params&#39;.</code></pre><h2 id="Class-Expressions"><a href="#Class-Expressions" class="headerlink" title="Class Expressions"></a>Class Expressions</h2><p><code>类表达式</code></p><p>Background Reading:<br><code>背景阅读：</code><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class">Class expressions (MDN)</a></p><p>Class expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:<br><code>类表达式跟类声明非常类似，唯一不同的是类表达式不需要一个名字，尽管我们可以通过绑定的标识符进行引用：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const someClass &#x3D; class&lt;Type&gt; &#123;  content: Type;  constructor(value: Type) &#123;    this.content &#x3D; value;  &#125;&#125;;const m &#x3D; new someClass(&quot;Hello, world&quot;);&#x2F;&#x2F; const m: someClass&lt;string&gt;;</code></pre><h3 id="abstract-Classes-and-Members"><a href="#abstract-Classes-and-Members" class="headerlink" title="abstract Classes and Members"></a>abstract Classes and Members</h3><p><code>抽象类和成员</code><br>Classes, methods, and fields in TypeScript may be abstract.<br><code>TypeScript 中，类、方法、字段都可以是抽象的（abstract）。</code><br>An abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.<br><code>抽象方法或者抽象字段是不提供实现的。这些成员必须存在在一个抽象类中，这个抽象类也不能直接被实例化。</code><br>The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete.<br><code>抽象类的作用是作为子类的基类，让子类实现所有的抽象成员。当一个类没有任何抽象成员，他就会被认为是具体的（concrete）。</code><br>Let’s look at an example:<br><code>让我们看个例子：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">abstract class Base &#123;  abstract getName(): string;  printName() &#123;    console.log(&quot;Hello, &quot; + this.getName());  &#125;&#125;const b &#x3D; new Base();&#x2F;&#x2F; Cannot create an instance of an abstract class.</code></pre><p>We can’t instantiate Base with new because it’s abstract. Instead, we need to make a derived class and implement the abstract members:<br><code>我们不能使用 new 实例 Base 因为它是抽象类。我们需要写一个派生类，并且实现抽象成员。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Derived extends Base &#123;  getName() &#123;    return &quot;world&quot;;  &#125;&#125;const d &#x3D; new Derived();d.printName();</code></pre><p>Notice that if we forget to implement the base class’s abstract members, we’ll get an error:<br><code>注意，如果我们忘记实现基类的抽象成员，我们会得到一个报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Derived extends Base &#123;  &#x2F;&#x2F; Non-abstract class &#39;Derived&#39; does not implement inherited abstract member &#39;getName&#39; from class &#39;Base&#39;.  &#x2F;&#x2F; forgot to do anything&#125;</code></pre><h2 id="Abstract-Construct-Signatures"><a href="#Abstract-Construct-Signatures" class="headerlink" title="Abstract Construct Signatures"></a>Abstract Construct Signatures</h2><p><code>抽象构造签名</code></p><p>Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.<br><code>有的时候，你希望接受传入可以继承一些抽象类产生一个类的实例的类构造函数。</code><br>For example, you might want to write this code:<br><code>举个例子，你也许会写这样的代码：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(ctor: typeof Base) &#123;  const instance &#x3D; new ctor();  &#x2F;&#x2F; Cannot create an instance of an abstract class.  instance.printName();&#125;</code></pre><p>TypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of greet, it’s perfectly legal to write this code, which would end up constructing an abstract class:<br><code>TypeScript 会报错，告诉你正在尝试实例化一个抽象类。毕竟，根据 greet 的定义，这段代码应该是合法的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Bad!greet(Base);</code></pre><p>Instead, you want to write a function that accepts something with a construct signature:<br><code>但如果你写一个函数接受传入一个构造签名：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(ctor: new () &#x3D;&gt; Base) &#123;  const instance &#x3D; new ctor();  instance.printName();&#125;greet(Derived);greet(Base);&#x2F;&#x2F; Argument of type &#39;typeof Base&#39; is not assignable to parameter of type &#39;new () &#x3D;&gt; Base&#39;.&#x2F;&#x2F; 参数类型 &#39;typeof Base&#39; 不能赋值给参数类型 &#39;new () &#x3D;&gt; Base&#39;。&#x2F;&#x2F; Cannot assign an abstract constructor type to a non-abstract constructor type.&#x2F;&#x2F; 不能将一个抽象构造类型赋值给一个非抽象构造类型。</code></pre><p>Now TypeScript correctly tells you about which class constructor functions can be invoked - Derived can because it’s concrete, but Base cannot.<br><code>现在 TypeScript 会正确的告诉你，哪一个类构造函数可以被调用，Derived 可以，因为它是具体的，而 Base 是不能的。</code></p><h2 id="Relationships-Between-Classes"><a href="#Relationships-Between-Classes" class="headerlink" title="Relationships Between Classes"></a>Relationships Between Classes</h2><p><code>类之间的关系</code><br>In most cases, classes in TypeScript are compared structurally, the same as other types.<br><code>大部分时候，TypeScript 的类跟其他类型一样，会被结构性比较。</code><br>For example, these two classes can be used in place of each other because they’re identical:<br><code>举个例子，这两个类可以用于替代彼此，因为它们结构是相等的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point1 &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;class Point2 &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;&#x2F;&#x2F; OKconst p: Point1 &#x3D; new Point2();</code></pre><p>Similarly, subtype relationships between classes exist even if there’s no explicit inheritance:<br><code>类似的还有，类的子类型之间可以建立关系，即使没有明显的继承：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Person &#123;  name: string;  age: number;&#125;class Employee &#123;  name: string;  age: number;  salary: number;&#125;&#x2F;&#x2F; OKconst p: Person &#x3D; new Employee();</code></pre><p>This sounds straightforward, but there are a few cases that seem stranger than others.<br><code>这听起来有些简单，但还有一些例子可以看出奇怪的地方。</code></p><p>Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:</p><p><code>空类没有任何成员。在一个结构化类型系统中，没有成员的类型通常是任何其他类型的父类型。所以如果你写一个空类（只是举例，你可不要这样做），任何东西都可以用来替换它：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Empty &#123;&#125;function fn(x: Empty) &#123;  &#x2F;&#x2F; can&#39;t do anything with &#39;x&#39;, so I won&#39;t&#125;&#x2F;&#x2F; All OK!fn(window);fn(&#123;&#125;);fn(fn);</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#class-members">typescript官网 类</a><br><a href="https://ts.yayujs.com/handbook/Class.html#%E7%B1%BB-classes">类（Classes）</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.Typescript手册 类型操作</title>
      <link href="//post/2022-06-07ts-type-manipulation.html"/>
      <url>//post/2022-06-07ts-type-manipulation.html</url>
      
        <content type="html"><![CDATA[<h2 id="ts-类型如何调试"><a href="#ts-类型如何调试" class="headerlink" title="ts 类型如何调试"></a>ts 类型如何调试</h2><ul><li>不是代码逻辑如何调试，没想到</li></ul><h2 id="ts-自定义类型如何打印"><a href="#ts-自定义类型如何打印" class="headerlink" title="ts 自定义类型如何打印"></a>ts 自定义类型如何打印</h2><ul><li>不是 js 的结果如何打印，没想到</li></ul><h2 id="Creating-Types-from-Types"><a href="#Creating-Types-from-Types" class="headerlink" title="Creating Types from Types"></a>Creating Types from Types</h2><p>从已有类型中创建类型</p><p>TypeScript 的类型系统非常强大，因为它允许表达类型的另一种表达方式。<br>最简单的方式是泛型，我们实际上有一大堆的类型操作符可用。还可以表达类型的另一种表达方式，就是把已有的值作为类型。<br>通过合并多种类型操作符，我们可以表达复杂的操作和值，这里我们将介绍以另一个类型或值为基础如何表达一个新类型。</p><p><code>简单来说：使用 范型 或 6种表达式 来创建新类型</code></p><ul><li><p>范型 - 类型需要参数</p></li><li><p>Keyof Type Operator - 用 keyof 操作去创建新类型</p></li><li><p>Typeof Type Operator - 用 typeof 操作去创建新类型</p></li><li><p>Indexed Access Types - 使用 Type[‘a’]语法去访问一个类型的一部分</p></li><li><p>Conditional Types - 类型行为像 if 语句一样</p></li><li><p>Mapped Types - 通过映射已有类型的每个属性来创建新类型</p></li><li><p>Template Literal Types - 通过模板字符串来改变属性的映射类型</p></li></ul><h2 id="Keyof-Type-Operator"><a href="#Keyof-Type-Operator" class="headerlink" title="Keyof Type Operator"></a>Keyof Type Operator</h2><ul><li>这个操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type P1 &#x3D; keyof any; &#x2F;&#x2F; 提示：type P1 &#x3D; string | number | symbol</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Point &#x3D; &#123; x: number; y: number &#125;;type P &#x3D; keyof Point; &#x2F;&#x2F; 提示：type P &#x3D; keyof Point，这个提示等于没提示</code></pre><ul><li>如果这个类型有字符串或者数字索引，keyof 就会返回这个类型：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Arrayish &#x3D; &#123; [n: number]: unknown &#125;;type A &#x3D; keyof Arrayish; &#x2F;&#x2F;提示：type A &#x3D; numbertype Mapish &#x3D; &#123; [k: string]: boolean &#125;;type M &#x3D; keyof Mapish; &#x2F;&#x2F; 提示：type M &#x3D; string | number&#x2F;&#x2F; --------------------------------------------------------------&#x2F;&#x2F; 对于Arrayish&#x2F;&#x2F; 实例1:okvar a: Arrayish &#x3D; &#123;  1: &quot;string&quot;,  2: false,&#125;;&#x2F;&#x2F; 实例2: okvar a1: Arrayish &#x3D; [1, 2, 3, 4];&#x2F;&#x2F; 对于 Mapishvar b: Mapish &#x3D; &#123;  name: true,  age: false,&#125;;</code></pre><p>注意，这个例子中，M 是 string | number — 这是因为 JavaScript 对象键是总是被强制为字符串，所以 obj[0] 总是和 obj[“0”] 相同。</p><p>keyof 类型操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：</p><h2 id="Typeof-type-operator"><a href="#Typeof-type-operator" class="headerlink" title="Typeof type operator"></a>Typeof type operator</h2><p>JavaScript 也有一个 typeof 操作符，可以用在表达式中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; Prints &quot;string&quot;console.log(typeof &quot;Hello world&quot;);</code></pre><p>TypeScript 增加了一个 typeof 操作符，可以用在类型上：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let s &#x3D; &quot;hello&quot;;let n: typeof s; &#x2F;&#x2F; 提示：let n: string</code></pre><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p>对于基本类型，typeof 操作符没有意义，但是与其他类型操作符结合使用，可以用 typeof 操作符来实现一些模式。例如，我们开始用 ReturnType<T> 来表示函数的返回类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Predicate &#x3D; (x: unknown) &#x3D;&gt; boolean;type K &#x3D; ReturnType&lt;Predicate&gt;; &#x2F;&#x2F; 提示 type K &#x3D; boolean</code></pre><p>如果我们尝试使用 ReturnType 在函数名上，我们会看到一个指示性的错误：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f() &#123;  return &#123; x: 10, y: 3 &#125;;&#125;type P &#x3D; ReturnType&lt;f&gt;;&#x2F;&#x2F; 提示：&#39;f&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof f&#39;?&#x2F;&#x2F; 提示：&#39;f&#39; 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof f&#39; 来代替 &#39;f&#39;？</code></pre><p>记住，值和类型不是一回事。要引用值 f 所拥有的类型，我们使用 typeof：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f() &#123;  return &#123; x: 10, y: 3 &#125;;&#125;type P &#x3D; ReturnType&lt;typeof f&gt;;&#x2F;** * 提示 * type P &#x3D; &#123;    x: number;    y: number;&#125;**&#x2F;</code></pre><p><strong>限制</strong></p><p>typescript 通常限制了 typeof 的表达式的类型。<br>特殊的，typeof 的表达式<code>只能用于标识符（即变量名）其属性</code>。这个限制是为了避免写一些你认为是执行的代码，但实际上并不是的：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Meant to use &#x3D; ReturnType&lt;typeof msgbox&gt;let shouldContinue: typeof msgbox(&quot;Are you sure you want to continue?&quot;);&#x2F;&#x2F; &#39;,&#39; expected.</code></pre><h2 id="Indexed-Access-Types"><a href="#Indexed-Access-Types" class="headerlink" title="Indexed Access Types"></a>Indexed Access Types</h2><p>我们可以使用索引访问类型来查找一个类型的特定属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Person &#x3D; &#123; age: number; name: string; alive: boolean &#125;;type Age &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示：type Age &#x3D; number</code></pre><p>这个索引类型本身是一个类型，所以我们可以使用联合，keyof 或者其他类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type I1 &#x3D; Person[&quot;age&quot; | &quot;name&quot;]; &#x2F;&#x2F; 提示：type I1 &#x3D; string | numbertype I2 &#x3D; Person[keyof Person]; &#x2F;&#x2F; 提示：type I2 &#x3D; string | number | booleantype AliveOrName &#x3D; &quot;alive&quot; | &quot;name&quot;;type I3 &#x3D; Person[AliveOrName]; &#x2F;&#x2F; 提示：type I3 &#x3D; string | boolean</code></pre><p>你会看到一个错误，如果你尝试索引一个不存在的属性：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type I1 &#x3D; Person[&quot;alve&quot;];Property &#39;alve&#39; does not exist on type &#39;Person&#39;.</code></pre><p>另一个例子是使用 number 来获取数组的元素类型。我们可以使用 typeof 来方便地捕获数组字面量的元素类型。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const MyArray &#x3D; [  &#123; name: &quot;Alice&quot;, age: 15 &#125;,  &#123; name: &quot;Bob&quot;, age: 23 &#125;,  &#123; name: &quot;Eve&quot;, age: 38 &#125;,];type Person &#x3D; typeof MyArray[number];&#x2F;&#x2F; 提示：type Person &#x3D; &#123; name: string; age: number; &#125;type Age &#x3D; typeof MyArray[number][&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age &#x3D; number;&#x2F;&#x2F; Ortype Age2 &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age2 &#x3D; number;</code></pre><p>你只能使用类型来索引，意味着你不能使用 const 来创建一个变量引用：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const key &#x3D; &quot;age&quot;;type Age &#x3D; Person[key];&#x2F;&#x2F; Type &#39;key&#39; cannot be used as an index type.&#x2F;&#x2F; 这个错误是因为 key 是一个字面量，而不是一个变量。&#x2F;&#x2F; &#39;key&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof key&#39;?&#x2F;&#x2F; 这个错误是因为 key 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof key&#39; 来代替 &#39;key&#39;？</code></pre><p>然而，你可以使用一个类型别名来替换相同的风格的重构：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type key &#x3D; &quot;age&quot;;type Age &#x3D; Person[key];</code></pre><h2 id="Conditional-Types"><a href="#Conditional-Types" class="headerlink" title="Conditional Types"></a>Conditional Types</h2><p>At the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs.<br>在最常见的程序中，我们需要根据输入来做决策。 JavaScript 程序是不同的，但是给定了这个事实，那些决策是根据输入的类型来做的。条件类型帮助描述输入和输出类型之间的关系。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  live(): void;&#125;interface Dog extends Animal &#123;  woof(): void;&#125;type Example1 &#x3D; Dog extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example1 &#x3D; numbertype Example2 &#x3D; RegExp extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example2 &#x3D; string</code></pre><p>条件类型的表达式像 JavaScript 中的条件表达式一样：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">SomeType extends OtherType ? TrueType : FalseType;</code></pre><p><strong>此段内容，原文保留</strong><br>When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).</p><p>当 extends 左边的类型可以赋值给右边的类型时，你会得到第一个分支的类型（“true”分支）；否则你会得到第二个分支的类型（“false”分支）。</p><p>From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string! But the power of conditional types comes from using them with generics.<br>从上面的例子中可以看到条件类型可能不会立即看起来很有用，我们可以告诉自己 Dog 是否继承了 Animal，然后选择 number 或 string！但是条件类型的力量来自于使用它们与泛型。</p><p>For example, let’s take the following createLabel function:<br>例如，我们可以把下面的 createLabel 函数拿来说说：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface IdLabel &#123;  id: number &#x2F;* some fields *&#x2F;;&#125;interface NameLabel &#123;  name: string &#x2F;* other fields *&#x2F;;&#125;function createLabel(id: number): IdLabel;function createLabel(name: string): NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel &#123;  throw &quot;unimplemented&quot;;&#125;</code></pre><p>These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:<br>这些 createLabel 的重载描述了一个单一的 JavaScript 函数，它根据输入的类型来做决策。请注意一些事情：</p><p>If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.<br>We have to create three overloads: one for each case when we’re sure of the type (one for string and one for number), and one for the most general case (taking a string | number). For every new type createLabel can handle, the number of overloads grows exponentially.<br>如果一个库需要在其 API 中重复使用相同的选择，这就变得非常麻烦。我们需要创建三个重载：一个当我们知道类型时，一个当我们知道类型时，一个当我们不知道类型时。对于每个新的类型 createLabel 可以处理，重载的数量就会指数增长。<br>Instead, we can encode that logic in a conditional type:<br>反之，我们可以使用条件类型来表示逻辑：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type NameOrId&lt;T extends number | string&gt; &#x3D; T extends number  ? IdLabel  : NameLabel;</code></pre><p>We can then use that conditional type to simplify our overloads down to a single function with no overloads.<br>我们可以使用这个条件类型来简化我们的重载，只有一个函数。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; &#123;  throw &quot;unimplemented&quot;;&#125;let a &#x3D; createLabel(&quot;typescript&quot;);&#x2F;&#x2F; 提示：let a: NameLabel;let b &#x3D; createLabel(2.8);&#x2F;&#x2F; 提示：let b: IdLabel;let c &#x3D; createLabel(Math.random() ? &quot;hello&quot; : 42);&#x2F;&#x2F; 提示：let c: NameLabel | IdLabel;</code></pre><ul><li>Conditional Type Constraints</li></ul><p>条件类型约束</p><p>Often, the checks in a conditional type will provide us with some new information. Just like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.<br>通常，在条件类型中的检查会提供我们一些新的信息。像类型检查一样，通过类型约束可以给我们更具体的类型，条件类型的 true 分支将通过我们检查的类型来约束泛型。<br>For example, let’s take the following:<br>例如，我们可以把下面的函数拿来说说：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type MessageOf&lt;T&gt; &#x3D; T[&quot;message&quot;];&#x2F;&#x2F; Type &#39;&quot;message&quot;&#39; cannot be used to index type &#39;T&#39;.</code></pre><p>In this example, TypeScript errors because T isn’t known to have a property called message. We could constrain T, and TypeScript would no longer complain:</p><p>在这个例子中，TypeScript 错误，因为 T 没有一个属性叫 message。我们可以约束 T，TypeScript 不会再报错了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type MessageOf&lt;T extends &#123; message: unknown &#125;&gt; &#x3D; T[&quot;message&quot;];interface Email &#123;  message: string;&#125;type EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string</code></pre><p>However, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available? We can do this by moving the constraint out and introducing a conditional type:<br>然而，如果我们想要 MessageOf 取任意类型，并且默认为没有 message 属性的情况，我们可以这样做：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type MessageOf&lt;T&gt; &#x3D; T extends &#123; message: unknown &#125; ? T[&quot;message&quot;] : never;interface Email &#123;  message: string;&#125;interface Dog &#123;  bark(): void;&#125;type EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string;type DogMessageContents &#x3D; MessageOf&lt;Dog&gt;;&#x2F;&#x2F; 提示：type DogMessageContents &#x3D; never;</code></pre><p>Within the true branch, TypeScript knows that T will have a message property.<br>在 true 分支中，TypeScript 知道 T 有一个 message 属性。</p><p>As another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:<br>作为另一个示例，我们还可以编写一个名为 Flatten 的类型，该类型将数组类型展平为其元素类型，但在其他情况下不使用它们：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Flatten&lt;T&gt; &#x3D; T extends any[] ? T[number] : T;&#x2F;&#x2F; Extracts out the element type. 提取元素类型。type Str &#x3D; Flatten&lt;string[]&gt;;type Str &#x3D; string;&#x2F;&#x2F; Leaves the type alone. 保留该类型。type Num &#x3D; Flatten&lt;number&gt;;type Num &#x3D; number;</code></pre><p>When Flatten is given an array type, it uses an indexed access with number to fetch out string[]’s element type. Otherwise, it just returns the type it was given.<br>当 Flatten 给定一个数组类型，它使用 number 下标得到 string[]元素类型，否则，仅返回所给类型</p><p>Inferring Within Conditional Types<br>在条件类型内推断</p><p>We just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.</p><p>我们只是发现自己使用条件类型来应用约束，然后提取出类型。这最终是一种常见的操作，条件类型使其更容易实现。</p><p>Conditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword. For example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:</p><p>条件类型为我们提供了一种使用 infer 关键字从 true 分支中比较的类型推断的方法。例如，我们可以在 Flatten 中推断元素类型，而不是使用索引访问类型“手动”提取它：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Flatten&lt;Type&gt; &#x3D; Type extends Array&lt;infer Item&gt; ? Item : Type;</code></pre><p>Here, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of T within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.</p><p>在这里，我们使用 infer 关键字声明性地引入一个名为 Item 的新泛型类型变量，而不是指定如何在 true 分支中检索 T 的元素类型。这使我们不必思考如何挖掘和探索我们感兴趣的类型的结构。</p><p>We can write some useful helper type aliases using the infer keyword. For example, for simple cases, we can extract the return type out from function types:</p><p>我们可以使用 infer 关键字编写一些有用的助手类型别名。例如，对于简单的情况，我们可以从函数类型中提取返回类型：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type GetReturnType&lt;Type&gt; &#x3D; Type extends (...args: never[]) &#x3D;&gt; infer Return  ? Return  : never;type Num &#x3D; GetReturnType&lt;() &#x3D;&gt; number&gt;;&#x2F;&#x2F; 提示： type Num &#x3D; numbertype Str &#x3D; GetReturnType&lt;(x: string) &#x3D;&gt; string&gt;;&#x2F;&#x2F; 提示：type Str &#x3D; stringtype Bools &#x3D; GetReturnType&lt;(a: boolean, b: boolean) &#x3D;&gt; boolean[]&gt;;&#x2F;&#x2F; 提示： type Bools &#x3D; boolean[]</code></pre><p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.<br>当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，将从最后一个签名进行推断（这可能是最允许的一网打尽的情况）。无法基于参数类型列表执行重载解析。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare function stringOrNum(x: string): number;declare function stringOrNum(x: number): string;declare function stringOrNum(x: string | number): string | number;type T1 &#x3D; ReturnType&lt;typeof stringOrNum&gt;;&#x2F;&#x2F; 提示：type T1 &#x3D; string | number;</code></pre><h2 id="Distributive-Conditional-Types"><a href="#Distributive-Conditional-Types" class="headerlink" title="Distributive Conditional Types"></a>Distributive Conditional Types</h2><p>分布条件类型</p><p>When conditional types act on a generic type, they become distributive when given a union type. For example, take the following:<br>当条件类型作用于泛型类型时，当给定一个联合类型时，它们将成为分布式的。例如，以以下内容为例：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;</code></pre><p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br>如果我们将一个联合类型插入 ToArray，那么条件类型将应用于该联合的每个成员。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;type StrArrOrNumArr &#x3D; ToArray&lt;string | number&gt;;&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; string[] | number[];</code></pre><p>What happens here is that StrArrOrNumArr distributes on:<br>这里发生了什么？</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">string | number;</code></pre><p>and maps over each member type of the union, to what is effectively:<br>并映射到联合类型每个成员类型</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">ToArray&lt;string&gt; | ToArray&lt;number&gt;;</code></pre><p>which leaves us with:<br>这给我们留下了：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">string[] | number[];</code></pre><p>Typically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets.<br>通常情况下，分布式是所需的行为。要避免这种行为，你可以在每边 extends 关键字之前使用方括号。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type ToArrayNonDist&lt;Type&gt; &#x3D; [Type] extends [any] ? Type[] : never;&#x2F;&#x2F; &#39;StrArrOrNumArr&#39; is no longer a union.type StrArrOrNumArr &#x3D; ToArrayNonDist&lt;string | number&gt;;&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; (string | number)[];</code></pre><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><h2 id="模板字面量类型（Template-Literal-Types）"><a href="#模板字面量类型（Template-Literal-Types）" class="headerlink" title="模板字面量类型（Template Literal Types）"></a>模板字面量类型（Template Literal Types）</h2><p>模板字面量类型以字符串字面量类型为基础，可以通过联合类型扩展成多个字符串。</p><p>它们跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。当使用模板字面量类型时，它会替换模板中的变量，返回一个新的字符串字面量：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type World &#x3D; &quot;world&quot;;type Greeting &#x3D; &#96;hello $&#123;World&#125;&#96;;&#x2F;&#x2F; type Greeting &#x3D; &quot;hello world&quot;</code></pre><ul><li>当模板中的变量是一个联合类型时，每一个可能的字符串字面量都会被表示：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type EmailLocaleIDs &#x3D; &quot;welcome_email&quot; | &quot;email_heading&quot;;type FooterLocaleIDs &#x3D; &quot;footer_title&quot; | &quot;footer_sendoff&quot;;type AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;&#x2F;&#x2F; type AllLocaleIDs &#x3D; &quot;welcome*email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</code></pre><ul><li>如果模板字面量里的多个变量都是联合类型，结果会交叉相乘，比如下面的例子就有 2 * 2 _ 3 一共 12 种结果：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;type Lang &#x3D; &quot;en&quot; | &quot;ja&quot; | &quot;pt&quot;;type LocaleMessageIDs &#x3D; &#96;$&#123;Lang&#125;_$&#123;AllLocaleIDs&#125;&#96;;&#x2F;&#x2F; type LocaleMessageIDs &#x3D; &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;</code></pre><ul><li>如果真的是非常长的字符串联合类型，推荐提前生成，这种还是适用于短一些的情况。</li></ul><h2 id="类型中的字符串联合类型（String-Unions-in-Types）"><a href="#类型中的字符串联合类型（String-Unions-in-Types）" class="headerlink" title="类型中的字符串联合类型（String Unions in Types）"></a>类型中的字符串联合类型（String Unions in Types）</h2><p>模板字面量最有用的地方在于你可以基于一个类型内部的信息，定义一个新的字符串，让我们举个例子：</p><p>有这样一个函数 makeWatchedObject， 它会给传入的对象添加了一个 on 方法。在 JavaScript 中，它的调用看起来是这样：makeWatchedObject(baseObject)，我们假设这个传入对象为：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const passedObject &#x3D; &#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;;</code></pre><p>这个 on 方法会被添加到这个传入对象上，该方法接受两个参数，eventName （ string 类型） 和 callBack （function 类型）：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 伪代码const result &#x3D; makeWatchedObject(baseObject);result.on(eventName, callBack);</code></pre><p>我们希望 eventName 是这种形式：attributeInThePassedObject + “Changed” ，举个例子，</p><ul><li>passedObject 有一个属性 firstName，对应产生的 eventName 为 firstNameChanged，</li><li>同理，lastName 对应的是 lastNameChanged，</li><li>age 对应的是 ageChanged。</li></ul><p>当这个 callBack 函数被调用的时候：</p><ul><li>应该被传入与 attributeInThePassedObject 相同类型的值。比如 passedObject 中，<ul><li>firstName 的值的类型为 string , 对应 firstNameChanged 事件的回调函数，则接受传入一个 string 类型的值。</li><li>age 的值的类型为 number，对应 ageChanged 事件的回调函数，则接受传入一个 number 类型的值。</li></ul></li><li>返回值类型为 void 类型。<br>on() 方法的签名最一开始是这样的：on(eventName: string, callBack: (newValue: any) &#x3D;&gt; void)。 使用这样的签名，我们是不能实现上面所说的这些约束的，这个时候就可以使用模板字面量：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const person &#x3D; makeWatchedObject(&#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;);&#x2F;&#x2F; makeWatchedObject has added &#96;on&#96; to the anonymous Objectperson.on(&quot;firstNameChanged&quot;, (newValue) &#x3D;&gt; &#123;  console.log(&#96;firstName was changed to $&#123;newValue&#125;!&#96;);&#125;);</code></pre><p>注意这个例子里，on 方法添加的事件名为 “firstNameChanged”， 而不仅仅是 “firstName”，而回调函数传入的值 newValue ，我们希望约束为 string 类型。我们先实现第一点。</p><p>在这个例子里，我们希望传入的事件名的类型，是对象属性名的联合，只是每个联合成员都还在最后拼接一个 Changed 字符，在 JavaScript 中，我们可以做这样一个计算：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">Object.keys(passedObject).map(x &#x3D;&gt; $&#123;x&#125;Changed)</code></pre><p>模板字面量提供了一个相似的字符串操作：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;string &amp; keyof Type&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;&#x2F;&#x2F;&#x2F; Create a &quot;watched object&quot; with an &#39;on&#39; method&#x2F;&#x2F;&#x2F; so that you can watch for changes to properties.declare function makeWatchedObject&lt;Type&gt;(  obj: Type): Type &amp; PropEventSource&lt;Type&gt;;</code></pre><p>注意，我们在这里例子中，模板字面量里我们写的是 string &amp; keyof Type，我们可不可以只写成 keyof Type 呢？如果我们这样写，会报错：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;keyof Type&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;&#x2F;&#x2F; Type &#39;keyof Type&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.&#x2F;&#x2F; Type &#39;string | number | symbol&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.&#x2F;&#x2F; ...</code></pre><p>从报错信息中，我们也可以看出报错原因，在 《TypeScript 系列之 Keyof 操作符》里，我们知道</p><ul><li>keyof 操作符会返回 string | number | symbol 类型，</li><li>但是模板字面量的变量要求的类型却是 string | number | bigint | boolean | null | undefined，</li></ul><p>比较一下，多了一个 symbol 类型，所以其实我们也可以这样写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;Exclude&lt;keyof Type, symbol&gt;&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;</code></pre><p>再或者这样写：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;Extract&lt;keyof Type, string&gt;&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;</code></pre><p>使用这种方式，在我们使用错误的事件名时，TypeScript 会给出报错：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const person &#x3D; makeWatchedObject(&#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;);person.on(&quot;firstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);&#x2F;&#x2F; Prevent easy human error (using the key instead of the event name)person.on(&quot;firstName&quot;, () &#x3D;&gt; &#123;&#125;);&#x2F;&#x2F; Argument of type &#39;&quot;firstName&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.&#x2F;&#x2F; It&#39;s typo-resistantperson.on(&quot;frstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);&#x2F;&#x2F; Argument of type &#39;&quot;frstNameChanged&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.</code></pre><h2 id="模板字面量的推断（Inference-with-Template-Literals）"><a href="#模板字面量的推断（Inference-with-Template-Literals）" class="headerlink" title="模板字面量的推断（Inference with Template Literals）"></a>模板字面量的推断（Inference with Template Literals）</h2><p>现在我们来实现第二点，回调函数传入的值的类型与对应的属性值的类型相同。<br>我们现在只是简单的对 callBack 的参数使用 any 类型。实现这个约束的关键在于借助泛型函数：</p><p>捕获泛型函数第一个参数的字面量，生成一个字面量类型</p><ul><li>该字面量类型可以被对象属性构成的联合约束</li><li>对象属性的类型可以通过索引访问获取</li><li>应用此类型，确保回调函数的参数类型与对象属性的类型是同一个类型</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on&lt;Key extends string &amp; keyof Type&gt;(    eventName: &#96;$&#123;Key&#125;Changed&#96;,    callback: (newValue: Type[Key]) &#x3D;&gt; void  ): void;&#125;;declare function makeWatchedObject&lt;Type&gt;(  obj: Type): Type &amp; PropEventSource&lt;Type&gt;;const person &#x3D; makeWatchedObject(&#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;);person.on(&quot;firstNameChanged&quot;, (newName) &#x3D;&gt; &#123;  &#x2F;&#x2F; (parameter) newName: string  console.log(&#96;new name is $&#123;newName.toUpperCase()&#125;&#96;);&#125;);person.on(&quot;ageChanged&quot;, (newAge) &#x3D;&gt; &#123;  &#x2F;&#x2F; (parameter) newAge: number  if (newAge &lt; 0) &#123;    console.warn(&quot;warning! negative age&quot;);  &#125;&#125;);</code></pre><p>这里我们把 on 改成了一个泛型函数。</p><p>当一个用户调用的时候传入 “firstNameChanged”，TypeScript 会尝试着推断 Key 正确的类型。它会匹配 key 和 “Changed” 前的字符串 ，然后推断出字符串 “firstName” ，然后再获取原始对象的 firstName 属性的类型，在这个例子中，就是 string 类型。</p><h2 id="内置字符操作类型（Intrinsic-String-Manipulation-Types）"><a href="#内置字符操作类型（Intrinsic-String-Manipulation-Types）" class="headerlink" title="内置字符操作类型（Intrinsic String Manipulation Types）"></a>内置字符操作类型（Intrinsic String Manipulation Types）</h2><p>TypeScript 的一些类型可以用于字符操作，这些类型处于性能的考虑被内置在编译器中，你不能在 .d.ts 文件里找到它们。</p><h2 id="Uppercase"><a href="#Uppercase" class="headerlink" title="Uppercase"></a>Uppercase</h2><p>把每个字符转为大写形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Greeting &#x3D; &quot;Hello, world&quot;;type ShoutyGreeting &#x3D; Uppercase&lt;Greeting&gt;;&#x2F;&#x2F; type ShoutyGreeting &#x3D; &quot;HELLO, WORLD&quot;type ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;ID-$&#123;Uppercase&lt;Str&gt;&#125;&#96;;type MainID &#x3D; ASCIICacheKey&lt;&quot;my_app&quot;&gt;;&#x2F;&#x2F; type MainID &#x3D; &quot;ID-MY_APP&quot;</code></pre><h2 id="Lowercase"><a href="#Lowercase" class="headerlink" title="Lowercase"></a>Lowercase</h2><p>把每个字符转为小写形式：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Greeting &#x3D; &quot;Hello, world&quot;;type QuietGreeting &#x3D; Lowercase&lt;Greeting&gt;;&#x2F;&#x2F; type QuietGreeting &#x3D; &quot;hello, world&quot;type ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;id-$&#123;Lowercase&lt;Str&gt;&#125;&#96;;type MainID &#x3D; ASCIICacheKey&lt;&quot;MY_APP&quot;&gt;;&#x2F;&#x2F; type MainID &#x3D; &quot;id-my_app&quot;</code></pre><h2 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h2><ul><li>把字符串的第一个字符转为大写形式：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type LowercaseGreeting &#x3D; &quot;hello, world&quot;;type Greeting &#x3D; Capitalize&lt;LowercaseGreeting&gt;;&#x2F;&#x2F; type Greeting &#x3D; &quot;Hello, world&quot;</code></pre><h2 id="Uncapitalize"><a href="#Uncapitalize" class="headerlink" title="Uncapitalize"></a>Uncapitalize</h2><ul><li>把字符串的第一个字符转换为小写形式：</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type UppercaseGreeting &#x3D; &quot;HELLO WORLD&quot;;type UncomfortableGreeting &#x3D; Uncapitalize&lt;UppercaseGreeting&gt;;&#x2F;&#x2F; type UncomfortableGreeting &#x3D; &quot;hELLO WORLD&quot;</code></pre><ul><li>字符操作类型的技术细节<br>从 TypeScript 4.1 起，这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别 (locale aware)。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function applyStringMapping(symbol: Symbol, str: string) &#123;  switch (intrinsicTypeKinds.get(symbol.escapedName as string)) &#123;    case IntrinsicTypeKind.Uppercase:      return str.toUpperCase();    case IntrinsicTypeKind.Lowercase:      return str.toLowerCase();    case IntrinsicTypeKind.Capitalize:      return str.charAt(0).toUpperCase() + str.slice(1);    case IntrinsicTypeKind.Uncapitalize:      return str.charAt(0).toLowerCase() + str.slice(1);  &#125;  return str;&#125;</code></pre><p>作者：冴羽<br>链接：<a href="https://www.imooc.com/article/322215">https://www.imooc.com/article/322215</a><br>来源：慕课网<br>本文原创发布于慕课网 ，转载请注明出处，谢谢合作</p><h2 id="在想一个问题"><a href="#在想一个问题" class="headerlink" title="在想一个问题"></a>在想一个问题</h2><p>为什么别人可以把文档翻译的那么准确，让读者一看就明白</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.Typescript手册 对象类型</title>
      <link href="//post/2022-06-08ts-object-types.html"/>
      <url>//post/2022-06-08ts-object-types.html</url>
      
        <content type="html"><![CDATA[<p>In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.<br><code>在 JavaScript 中，我们通过对象来组织和传递数据。在 TypeScript 中，我们通过对象类型来表示这些对象。</code><br>As we’ve seen, they can be anonymous:<br><code>我们可以看到，它们可以是匿名的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(person: &#123; name: string; age: number &#125;) &#123;  return &quot;Hello &quot; + person.name;&#125;</code></pre><p>or they can be named by using either an interface<br><code>或者，它们可以使用接口来命名</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;  name: string;  age: number;&#125;function greet(person: Person) &#123;  return &quot;Hello &quot; + person.name;&#125;</code></pre><p>or a type alias.<br><code>或者，它们可以使用类型别名</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Person &#x3D; &#123;  name: string;  age: number;&#125;;function greet(person: Person) &#123;  return &quot;Hello &quot; + person.name;&#125;</code></pre><p>In all three examples above, we’ve written functions that take objects that contain the property name (which must be a string) and age (which must be a number).<br><code>在上面三个例子中，我们已经写了一个函数，它接受包含属性 name（必须是字符串）和 age（必须是数字）的对象。</code></p><h2 id="Property-Modifiers"><a href="#Property-Modifiers" class="headerlink" title="Property Modifiers"></a>Property Modifiers</h2><p><code>属性修饰符</code><br>Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.<br><code>对象类型中的每个属性都可以指定一些东西：类型、是否是可选的，以及是否可以写入。</code></p><h2 id="Optional-Properties"><a href="#Optional-Properties" class="headerlink" title="Optional Properties"></a>Optional Properties</h2><p><code>可选属性</code><br>Much of the time, we’ll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names.<br><code>大多数时候，我们会发现我们在对对象进行操作的时候，可能会有属性被设置。在这些情况下，我们可以通过在属性名的末尾添加问号来标记这些属性为可选的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface PaintOptions &#123;  shape: Shape;  xPos?: number;  yPos?: number;&#125;function paintShape(opts: PaintOptions) &#123;  &#x2F;&#x2F; ...&#125;const shape &#x3D; getShape();paintShape(&#123; shape &#125;);paintShape(&#123; shape, xPos: 100 &#125;);paintShape(&#123; shape, yPos: 100 &#125;);paintShape(&#123; shape, xPos: 100, yPos: 100 &#125;);</code></pre><p>In this example, both xPos and yPos are considered optional. We can choose to provide either of them, so every call above to paintShape is valid. All optionality really says is that if the property is set, it better have a specific type.<br><code>在这个例子中，xPos和yPos都被认为是可选的。我们可以选择提供其中一个，因此每次调用paintShape都是有效的。所有的可选性都说是，如果属性被设置，它应该有一个特定的类型。</code><br>We can also read from those properties - but when we do under strictNullChecks, TypeScript will tell us they’re potentially undefined.<br><code>我们也可以读取这些属性，但是在严格的 null 检查下，TypeScript 将会告诉我们这些属性可能是 undefined。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function paintShape(opts: PaintOptions) &#123;  let xPos &#x3D; opts.xPos;  &#x2F;&#x2F; (property) PaintOptions.xPos?: number | undefined  let yPos &#x3D; opts.yPos;  &#x2F;&#x2F; (property) PaintOptions.yPos?: number | undefined  &#x2F;&#x2F; ...&#125;</code></pre><p>In JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value undefined. We can just handle undefined specially.<br><code>在 JavaScript 中，即使属性没有被设置，我们仍然可以访问它，它只是给我们一个值 undefined。我们可以特别处理 undefined。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function paintShape(opts: PaintOptions) &#123;  let xPos &#x3D; opts.xPos &#x3D;&#x3D;&#x3D; undefined ? 0 : opts.xPos;  &#x2F;&#x2F; let xPos: number;  let yPos &#x3D; opts.yPos &#x3D;&#x3D;&#x3D; undefined ? 0 : opts.yPos;  &#x2F;&#x2F; let yPos: number;  &#x2F;&#x2F; ...&#125;</code></pre><p>Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.<br><code>注意，这种设置默认值的方式很常见，因此 JavaScript 有一种语法来支持它。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function paintShape(&#123; shape, xPos &#x3D; 0, yPos &#x3D; 0 &#125;: PaintOptions) &#123;  console.log(&quot;x coordinate at&quot;, xPos);  &#x2F;&#x2F; (parameter) xPos: number  console.log(&quot;y coordinate at&quot;, yPos);  &#x2F;&#x2F; (parameter) yPos: number  &#x2F;&#x2F; ...&#125;</code></pre><p>Here we used a destructuring pattern for paintShape’s parameter, and provided default values for xPos and yPos. Now xPos and yPos are both definitely present within the body of paintShape, but optional for any callers to paintShape.<br><code>在这里，我们使用了 paintShape 的参数的析构模式，并为 xPos 和 yPos 提供了默认值。现在 xPos 和 yPos 在 paintShape 的主体中都是必须的，但是任何调用者调用 paintShape 的值都是可选的。</code><br>Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.<br><code>注意，目前没有办法在析构模式中放置类型标注。因为这个语法已经在 JavaScript 中表示了不同的意思。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function draw(&#123; shape: Shape, xPos: number &#x3D; 100 &#x2F;_..._&#x2F; &#125;) &#123;render(shape);&#x2F;&#x2F; Cannot find name &#39;shape&#39;. Did you mean &#39;Shape&#39;?render(xPos);&#x2F;&#x2F; Cannot find name &#39;xPos&#39;.&#125;</code></pre><p>In an object destructuring pattern, shape: Shape means “grab the property shape and redefine it locally as a variable named Shape. Likewise xPos: number creates a variable named number whose value is based on the parameter’s xPos.<br><code>在一个对象析构模式中，shape: Shape 表示“抓取属性 shape 并重新定义它作为名为 Shape 的变量。同样的，xPos: number 创建了一个名为 number 的变量，其值是基于参数的 xPos。</code><br>Using mapping modifiers, you can remove optional attributes.<br><code>使用映射修饰符，你可以移除可选属性。</code></p><h2 id="Readonly-Properties"><a href="#Readonly-Properties" class="headerlink" title="Readonly Properties"></a>Readonly Properties</h2><p><code>只读属性</code><br>Properties can also be marked as readonly for TypeScript. While it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking.<br><code>只读属性</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface SomeType &#123;  readonly prop: string;&#125;function doSomething(obj: SomeType) &#123;  &#x2F;&#x2F; We can read from &#39;obj.prop&#39;.  console.log(&#96;prop has the value &#39;$&#123;obj.prop&#125;&#39;.&#96;);  &#x2F;&#x2F; But we can&#39;t re-assign it.  obj.prop &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; Cannot assign to &#39;prop&#39; because it is a read-only property.&#125;</code></pre><p>Using the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.<br><code>使用 readonly 修饰符并不意味着一个值是完全不可变的，也就是说，它的内部内容不能被改变。它只是说，属性本身不能被重写。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Home &#123;  readonly resident: &#123; name: string; age: number &#125;;&#125;function visitForBirthday(home: Home) &#123;  &#x2F;&#x2F; We can read and update properties from &#39;home.resident&#39;.  &#x2F;&#x2F; 我们可以从 &#39;home.resident&#39; 中读取和更新属性。  console.log(&#96;Happy birthday $&#123;home.resident.name&#125;!&#96;);  home.resident.age++;&#125;function evict(home: Home) &#123;  &#x2F;&#x2F; But we can&#39;t write to the &#39;resident&#39; property itself on a &#39;Home&#39;.  &#x2F;&#x2F; 但是，我们不能在 &#39;Home&#39; 上写入 &#39;resident&#39; 属性。  home.resident &#x3D; &#123;    &#x2F;&#x2F; Cannot assign to &#39;resident&#39; because it is a read-only property.    name: &quot;Victor the Evictor&quot;,    age: 42,  &#125;;&#125;</code></pre><p>It’s important to manage expectations of what readonly implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing.</p><p><strong>注意</strong></p><p><code>TypeScript 在检查两个类型是否兼容的时候，并不会考虑两个类型里的属性是否是 readonly，这就意味着，readonly 的值是可以通过别名修改的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;  name: string;  age: number;&#125;interface ReadonlyPerson &#123;  readonly name: string;  readonly age: number;&#125;let writablePerson: Person &#x3D; &#123;  name: &quot;Person McPersonface&quot;,  age: 42,&#125;;&#x2F;&#x2F; workslet readonlyPerson: ReadonlyPerson &#x3D; writablePerson;console.log(readonlyPerson.age); &#x2F;&#x2F; prints &#39;42&#39;writablePerson.age++;console.log(readonlyPerson.age); &#x2F;&#x2F; prints &#39;43&#39;</code></pre><p>Using mapping modifiers, you can remove readonly attributes.</p><h2 id="Index-Signatures"><a href="#Index-Signatures" class="headerlink" title="Index Signatures"></a>Index Signatures</h2><p><code>索引签名</code><br>Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.<br><code>有时候，你不知道一个类型的所有属性的名字，但是你知道值的形状。</code></p><p>In those cases you can use an index signature to describe the types of possible values, for example:<br><code>在这些情况下，你可以使用索引签名来描述可能的值的类型，例如：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface StringArray &#123;  [index: number]: string;&#125;const myArray: StringArray &#x3D; getStringArray();const secondItem &#x3D; myArray[1];const secondItem: string;</code></pre><p>Above, we have a StringArray interface which has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string.<br><code>上面，我们有一个 StringArray 接口，它有一个索引签名。这个索引签名说明，当一个 StringArray 被索引为一个数字时，它会返回一个字符串。</code><br>An index signature property type must be either ‘string’ or ‘number’.<br><code>索引签名属性类型必须是‘string’或‘number’。</code><br>It is possible to support both types of indexers…<br><code>可以支持两种类型的索引器...</code></p><p>While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj[“property”]. In the following example, name’s type does not match the string index’s type, and the type checker gives an error:<br><code>尽管字符串索引用来描述字典模式（dictionary pattern）非常的有效，但也会强制要求所有的属性要匹配索引签名的返回类型。这是因为一个声明类似于 obj.property 的字符串索引，跟 obj[&quot;property&quot;]是一样的。在下面的例子中，name 的类型并不匹配字符串索引的类型，所以类型检查器会给出报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface NumberDictionary &#123;  [index: string]: number;  length: number; &#x2F;&#x2F; ok  name: string;  &#x2F;&#x2F; Property &#39;name&#39; of type &#39;string&#39; is not assignable to &#39;string&#39; index type &#39;number&#39;.&#125;</code></pre><p>However, properties of different types are acceptable if the index signature is a union of the property types:<br><code>但是，不同类型的属性是可以接受的，如果索引签名是属性类型的联合：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface NumberOrStringDictionary &#123;  [index: string]: number | string;  length: number; &#x2F;&#x2F; ok, length is a number  name: string; &#x2F;&#x2F; ok, name is a string&#125;</code></pre><p>Finally, you can make index signatures readonly in order to prevent assignment to their indices:<br><code>最后，你可以使索引签名变成只读，以防止索引赋值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ReadonlyStringArray &#123;  readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray &#x3D; getReadOnlyStringArray();myArray[2] &#x3D; &quot;Mallory&quot;;&#x2F;&#x2F; Index signature in type &#39;ReadonlyStringArray&#39; only permits reading.</code></pre><p>You can’t set myArray[2] because the index signature is readonly.<br><code>你不能设置 myArray[2]，因为索引签名是只读的。</code></p><h2 id="Extending-Types"><a href="#Extending-Types" class="headerlink" title="Extending Types"></a>Extending Types</h2><p><code>扩展类型</code><br>It’s pretty common to have types that might be more specific versions of other types. For example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S.<br><code>我们可能有一个基本的地址类型，它描述了在美国发送信件和包裹的必要字段。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface BasicAddress &#123;  name?: string;  street: string;  city: string;  country: string;  postalCode: string;&#125;</code></pre><p>In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an AddressWithUnit.<br><code>在某些情况下，这样就足够了，但是地址有时候会有单元号码，如果地址的建筑有多个单元。我们可以描述一个 AddressWithUnit。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface AddressWithUnit &#123;  name?: string;  unit: string;  street: string;  city: string;  country: string;  postalCode: string;&#125;</code></pre><p>This does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive. Instead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit.<br><code>这样做就可以了，但是有一个缺点，就是我们必须重复所有的字段来自 BasicAddress，当我们的改动只是增加性的时候。我们可以扩展原来的 BasicAddress 类型，并且只需要增加 AddressWithUnit 的唯一字段。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface BasicAddress &#123;  name?: string;  street: string;  city: string;  country: string;  postalCode: string;&#125;interface AddressWithUnit extends BasicAddress &#123;  unit: string;&#125;</code></pre><p>The extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, AddressWithUnit didn’t need to repeat the street property, and because street originates from BasicAddress, a reader will know that those two types are related in some way.<br><code>在一个接口上使用 extends 关键字，我们可以从其他命名类型复制成员，并且添加我们想要的新成员。这可以用来缩短我们写的类型声明的热身，以及为同一属性的多个声明提供相关性的信号。例如，AddressWithUnit 不需要重复 street 属性，因为 street 来自 BasicAddress，读者知道这两个类型是相关的。</code><br>interfaces can also extend from multiple types.<br><code>接口也可以扩展多个类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Colorful &#123;  color: string;&#125;interface Circle &#123;  radius: number;&#125;interface ColorfulCircle extends Colorful, Circle &#123;&#125;const cc: ColorfulCircle &#x3D; &#123;  color: &quot;red&quot;,  radius: 42,&#125;;</code></pre><h2 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h2><p><code>交叉类型</code><br>interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.<br><code>接口允许我们从其他类型扩展新类型。TypeScript 提供了一种合并现有对象类型的交叉类型。</code><br>An intersection type is defined using the &amp; operator.<br><code>交叉类型用 &amp; 运算符定义。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Colorful &#123;  color: string;&#125;interface Circle &#123;  radius: number;&#125;type ColorfulCircle &#x3D; Colorful &amp; Circle;</code></pre><p>Here, we’ve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle.<br><code>这里，我们将 Colorful 和 Circle 进行交叉，以生成一个新类型，它包含了 Colorful 和 Circle 的所有成员。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function draw(circle: Colorful &amp; Circle) &#123;  console.log(&#96;Color was $&#123;circle.color&#125;&#96;);  console.log(&#96;Radius was $&#123;circle.radius&#125;&#96;);&#125;&#x2F;&#x2F; okaydraw(&#123; color: &quot;blue&quot;, radius: 42 &#125;);&#x2F;&#x2F; oopsdraw(&#123; color: &quot;red&quot;, raidus: 42 &#125;);&#x2F;&#x2F; Argument of type &#39;&#123; color: string; raidus: number; &#125;&#39; is not assignable to parameter of type &#39;Colorful &amp; Circle&#39;.&#x2F;&#x2F; Object literal may only specify known properties, but &#39;raidus&#39; does not exist in type &#39;Colorful &amp; Circle&#39;. Did you mean to write &#39;radius&#39;?</code></pre><h2 id="Interfaces-vs-Intersections"><a href="#Interfaces-vs-Intersections" class="headerlink" title="Interfaces vs. Intersections"></a>Interfaces vs. Intersections</h2><p><code>接口与交叉类型</code><br>We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.<br><code>我们只看到了两种方式来合并类型，但是实际上是有着微妙的区别。接口使用 extends 关键字扩展其他类型，而交叉类型使用类型别名定义。接口与交叉类型之间的主要区别是如何处理冲突，这个区别通常是在选择一个接口或者类型别名的时候，接口或者类型别名是否更好。</code></p><p>这两种方式在合并类型上看起来很相似，但实际上还是有很大的不同。最原则性的不同就是在于冲突怎么处理，这也是你决定选择那种方式的主要原因。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Colorful &#123;  color: string;&#125;interface ColorfulSub extends Colorful &#123;  color: number;&#125;&#x2F;&#x2F; Interface &#39;ColorfulSub&#39; incorrectly extends interface &#39;Colorful&#39;.&#x2F;&#x2F; Types of property &#39;color&#39; are incompatible.&#x2F;&#x2F; Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><p>使用继承的方式，如果重写类型会导致编译错误，但交叉类型不会：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Colorful &#123;  color: string;&#125;type ColorfulSub &#x3D; Colorful &amp; &#123;  color: number;&#125;;</code></pre><p>虽然不会报错，那 color 属性的类型是什么呢，答案是 never，取得是 string 和 number 的交集。</p><h2 id="Generic-Object-Types"><a href="#Generic-Object-Types" class="headerlink" title="Generic Object Types"></a>Generic Object Types</h2><p><code>泛型对象类型</code><br>Let’s imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever.<br><code>想想一个可以包含任何值的盒子类型，例如字符串、数字、狮子等。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box &#123;  contents: any;&#125;</code></pre><p>Right now, the contents property is typed as any, which works, but can lead to accidents down the line.<br><code>现在，contents 属性是任意类型，这就可以工作，但是有可能会在未来出现意外。</code><br>We could instead use unknown, but that would mean that in cases where we already know the type of contents, we’d need to do precautionary checks, or use error-prone type assertions.<br><code>我们可以使用 unknown，但是这会导致在我们已经知道 contents 的类型的情况下，我们需要做一些预防性检查，或者使用错误性的类型断言。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box &#123;  contents: unknown;&#125;let x: Box &#x3D; &#123;  contents: &quot;hello world&quot;,&#125;;&#x2F;&#x2F; we could check &#39;x.contents&#39;if (typeof x.contents &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;  console.log(x.contents.toLowerCase());&#125;&#x2F;&#x2F; or we could use a type assertionconsole.log((x.contents as string).toLowerCase());</code></pre><p>One type safe approach would be to instead scaffold out different Box types for every type of contents.<br><code>一种安全的解决方案就是把不同的盒子类型用于不同的类型的内容。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface NumberBox &#123;  contents: number;&#125;interface StringBox &#123;  contents: string;&#125;interface BooleanBox &#123;  contents: boolean;&#125;</code></pre><p>But that means we’ll have to create different functions, or overloads of functions, to operate on these types.<br><code>但是，这会导致我们需要创建不同的函数，或者重载函数，来操作这些类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: &#123; contents: any &#125;, newContents: any) &#123;  box.contents &#x3D; newContents;&#125;</code></pre><p>That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.<br><code>这就是一大堆的烧饼，同时，我们可能需要在未来添加新的类型和重载。这是困难的，因为我们的盒子类型和重载都是一样的。</code><br>Instead, we can make a generic Box type which declares a type parameter.<br><code>而不是，我们可以把盒子类型变成泛型类型，它声明了一个类型参数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;  contents: Type;&#125;</code></pre><p>You might read this as “A Box of Type is something whose contents have type Type”. Later on, when we refer to Box, we have to give a type argument in place of Type.<br><code>你可以读这个为“一个类型为 Type 的盒子”。之后，当我们引用 Box 时，我们需要给它一个类型参数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let box: Box&lt;string&gt;;</code></pre><p>Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type. When TypeScript sees Box<string>, it will replace every instance of Type in Box<Type> with string, and end up working with something like { contents: string }. In other words, Box<string> and our earlier StringBox work identically.<br><code>想想 Box&lt;string&gt; 和 StringBox 类型，它们都是一样的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;contents: Type;&#125;interface StringBox &#123;contents: string;&#125;let boxA: Box&lt;string&gt; &#x3D; &#123; contents: &quot;hello&quot; &#125;;boxA.contents;(property) Box&lt;string&gt;.contents: stringlet boxB: StringBox &#x3D; &#123; contents: &quot;world&quot; &#125;;boxB.contents;(property) StringBox.contents: string</code></pre><p>Box is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new Box type at all (though we certainly could if we wanted to).<br><code>Box 可以重用，因为 Type 可以被替换成任何类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;  contents: Type;&#125;interface Apple &#123;  &#x2F;&#x2F; ....&#125;&#x2F;&#x2F; Same as &#39;&#123; contents: Apple &#125;&#39;.type AppleBox &#x3D; Box&lt;Apple&gt;;</code></pre><p>This also means that we can avoid overloads entirely by instead using generic functions.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) &#123;  box.contents &#x3D; newContents;&#125;</code></pre><p>It is worth noting that type aliases can also be generic. We could have defined our new Box<Type> interface, which was:<br><code>我们可以定义一个新的盒子类型，它是：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;  contents: Type;&#125;</code></pre><p>by using a type alias instead:<br><code>使用类型别名来代替：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Box&lt;Type&gt; &#x3D; &#123;  contents: Type;&#125;;</code></pre><p>Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.<br><code>类型别名，跟接口不同，它可以描述除了对象类型之外的其他类型，我们也可以用它来写其他类型的辅助类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type OrNull&lt;Type&gt; &#x3D; Type | null;type OneOrMany&lt;Type&gt; &#x3D; Type | Type[];&#x2F;&#x2F; 这组结果一样type OneOrManyOrNull&lt;Type&gt; &#x3D; OrNull&lt;OneOrMany&lt;Type&gt;&gt;;type OneOrManyOrNull&lt;Type&gt; &#x3D; OneOrMany&lt;Type&gt; | null;&#x2F;&#x2F; 这组结果一样type OneOrManyOrNullStrings &#x3D; OneOrManyOrNull&lt;string&gt;;type OneOrManyOrNullStrings &#x3D; OneOrMany&lt;string&gt; | null;</code></pre><p>We’ll circle back to type aliases in just a little bit.<br><code>我们会在稍后回到类型别名。</code></p><h2 id="The-Array-Type"><a href="#The-Array-Type" class="headerlink" title="The Array Type"></a>The Array Type</h2><p><code>数组类型</code><br>Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.<br><code>泛型对象类型通常是一种可以独立于其包含元素的类型的容器类型。这样，它们可以在不同的数据类型之间重用。</code><br>It turns out we’ve been working with a type just like that throughout this handbook: the Array type. Whenever we write out types like number[] or string[], that’s really just a shorthand for Array<number> and Array<string>.<br><code>我们在这本手册中已经使用过一样的类型：数组类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(value: Array&lt;string&gt;) &#123;  &#x2F;&#x2F; ...&#125;let myArray: string[] &#x3D; [&quot;hello&quot;, &quot;world&quot;];&#x2F;&#x2F; either of these work!doSomething(myArray);doSomething(new Array(&quot;hello&quot;, &quot;world&quot;));</code></pre><p>Much like the Box type above, Array itself is a generic type.<br><code>数组本身是一个泛型类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Array&lt;Type&gt; &#123;  &#x2F;**   * Gets or sets the length of the array.   *&#x2F;  length: number;  &#x2F;**   * Removes the last element from an array and returns it.   *&#x2F;  pop(): Type | undefined;  &#x2F;**   * Appends new elements to an array, and returns the new length of the array.   *&#x2F;  push(...items: Type[]): number;  &#x2F;&#x2F; ...&#125;</code></pre><p>Modern JavaScript also provides other data structures which are generic, like Map&lt;K, V&gt;, Set<T>, and Promise<T>. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types.<br><code>现代 JavaScript 也提供了其他的数据结构，比如 Map&lt;K, V&gt;, Set&lt;T&gt;, Promise&lt;T&gt;。</code></p><h2 id="The-ReadonlyArray-Type"><a href="#The-ReadonlyArray-Type" class="headerlink" title="The ReadonlyArray Type"></a>The ReadonlyArray Type</h2><p><code>只读数组类型</code></p><p>The ReadonlyArray is a special type that describes arrays that shouldn’t be changed.<br><code>只读数组是一个描述不能被修改的数组的特殊类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doStuff(values: ReadonlyArray&lt;string&gt;) &#123;  &#x2F;&#x2F; We can read from &#39;values&#39;...  const copy &#x3D; values.slice();  console.log(&#96;The first value is $&#123;values[0]&#125;&#96;);  &#x2F;&#x2F; ...but we can&#39;t mutate &#39;values&#39;.  values.push(&quot;hello!&quot;);  &#x2F;&#x2F; Property &#39;push&#39; does not exist on type &#39;readonly string[]&#39;.&#125;</code></pre><p>Much like the readonly modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents.<br><code>ReadonlyArray 主要是用来做意图声明。当我们看到一个函数返回 ReadonlyArray，就是在告诉我们不能去更改其中的内容，当我们看到一个函数支持传入 ReadonlyArray ，这是在告诉我们我们可以放心的传入数组到函数中，而不用担心会改变数组的内容。</code><br>Unlike Array, there isn’t a ReadonlyArray constructor that we can use.<br><code>不像 Array，ReadonlyArray 并不是一个我们可以用的构造器函数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">new ReadonlyArray(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);&#39;ReadonlyArray&#39; only refers to a type, but is being used as a value here.</code></pre><p>Instead, we can assign regular Arrays to ReadonlyArrays.<br><code>然而，我们可以直接把一个常规数组赋值给 ReadonlyArray。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const roArray: ReadonlyArray&lt;string&gt; &#x3D; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</code></pre><p>Just as TypeScript provides a shorthand syntax for Array<Type> with Type[], it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[].<br><code>TypeScript 也针对 ReadonlyArray&lt;Type&gt; 提供了更简短的写法 readonly Type[]。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doStuff(values: readonly string[]) &#123;  &#x2F;&#x2F; We can read from &#39;values&#39;...  const copy &#x3D; values.slice();  console.log(&#96;The first value is $&#123;values[0]&#125;&#96;);  &#x2F;&#x2F; ...but we can&#39;t mutate &#39;values&#39;.  values.push(&quot;hello!&quot;);  &#x2F;&#x2F; Property &#39;push&#39; does not exist on type &#39;readonly string[]&#39;.&#125;</code></pre><p>One last thing to note is that unlike the readonly property modifier, assignability isn’t bidirectional between regular Arrays and ReadonlyArrays.<br><code>最后有一点要注意，就是 Arrays 和 ReadonlyArray 并不能双向的赋值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x: readonly string[] &#x3D; [];let y: string[] &#x3D; [];x &#x3D; y; &#x2F;&#x2F; oky &#x3D; x;&#x2F;&#x2F; The type &#39;readonly string[]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;string[]&#39;.</code></pre><h2 id="Tuple-Types"><a href="#Tuple-Types" class="headerlink" title="Tuple Types"></a>Tuple Types</h2><p>A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.<br><code>元组类型是另外一种 Array 类型，当你明确知道数组包含多少个元素，并且每个位置元素的类型都明确知道的时候，就适合使用元组类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type StringNumberPair &#x3D; [string, number];</code></pre><p>Here, StringNumberPair is a tuple type of string and number. Like ReadonlyArray, it has no representation at runtime, but is significant to TypeScript. To the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number.<br><code>在这个例子中，StringNumberPair 就是 string 和 number 的元组类型。</code></p><p><code>跟 ReadonlyArray 一样，它并不会在运行时产生影响，但是对 TypeScript 很有意义。因为对于类型系统，StringNumberPair 描述了一个数组，索引 0 的值的类型是 string，索引 1 的值的类型是 number。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(pair: [string, number]) &#123;  const a &#x3D; pair[0];  const a: string;  const b &#x3D; pair[1];  const b: number;  &#x2F;&#x2F; ...&#125;doSomething([&quot;hello&quot;, 42]);</code></pre><p>If we try to index past the number of elements, we’ll get an error.<br><code>如果要获取元素数量之外的元素，TypeScript 会提示错误：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(pair: [string, number]) &#123;  &#x2F;&#x2F; ...  const c &#x3D; pair[2];  &#x2F;&#x2F; Tuple type &#39;[string, number]&#39; of length &#39;2&#39; has no element at index &#39;2&#39;.&#125;</code></pre><p>We can also destructure tuples using JavaScript’s array destructuring.<br><code>我们也可以使用 JavaScript 的数组解构语法解构元组：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(stringHash: [string, number]) &#123;  const [inputString, hash] &#x3D; stringHash;  console.log(inputString);  &#x2F;&#x2F; const inputString: string;  console.log(hash);  &#x2F;&#x2F; const hash: number;&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements 0 and 1 to whatever we wanted.<br><code>元组类型在重度依赖约定的 API 中很有用，因为它会让每个元素的意义都很明显。当我们解构的时候，元组给了我们命名变量的自由度。在上面的例子中，我们可以命名元素 0 和 1 为我们想要的名字。</code><br>However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.<br><code>然而，也不是每个用户都这样认为，所以有的时候，使用一个带有描述属性名字的对象也许是个更好的方式。</code><br>Other than those length checks, simple tuple types like these are equivalent to types which are versions of Arrays that declare properties for specific indexes, and that declare length with a numeric literal type.<br><code>除了长度检查，简单的元组类型跟声明了 length 属性和具体的索引属性的 Array 是一样的。</code></p></blockquote><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface StringNumberPair &#123;  &#x2F;&#x2F; specialized properties  length: 2;  0: string;  1: number;  &#x2F;&#x2F; Other &#39;Array&lt;string | number&gt;&#39; members...  slice(start?: number, end?: number): Array&lt;string | number&gt;;&#125;</code></pre><p>Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an element’s type). Optional tuple elements can only come at the end, and also affect the type of length.<br><code>在元组类型中，你也可以写一个可选属性，但可选元素必须在最后面，而且也会影响类型的 length 。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Either2dOr3d &#x3D; [number, number, number?];function setCoordinate(coord: Either2dOr3d) &#123;  const [x, y, z] &#x3D; coord;  const z: number | undefined;  console.log(&#96;Provided coordinates had $&#123;coord.length&#125; dimensions&#96;);  &#x2F;&#x2F; (property) length: 2 | 3&#125;</code></pre><p>Tuples can also have rest elements, which have to be an array&#x2F;tuple type.<br><code>Tuples 也可以使用剩余元素语法，但必须是 array/tuple 类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type StringNumberBooleans &#x3D; [string, number, ...boolean[]];type StringBooleansNumber &#x3D; [string, ...boolean[], number];type BooleansStringNumber &#x3D; [...boolean[], string, number];</code></pre><ul><li><code>StringNumberBooleans</code> describes a tuple whose first two elements are string and number respectively, but which may have any number of booleans following.<br><code>描述一个元组，前两个是字符串和数值，后面是boolean</code></li><li><code>StringBooleansNumber</code> describes a tuple whose first element is string and then any number of booleans and ending with a number.<br><code>描述一个元组，第一个是字符串，最后一个是数值，中间有任意多个boolean类型</code></li><li><code>BooleansStringNumber</code> describes a tuple whose starting elements are any number of booleans and ending with a string then a number.<br><code>描述一个元组，最后两个是string、number</code><br>A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.<br><code>有剩余元素的元组并不会设置 length，因为它只知道在不同位置上的已知元素信息：</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const a: StringNumberBooleans &#x3D; [&quot;hello&quot;, 1];const b: StringNumberBooleans &#x3D; [&quot;beautiful&quot;, 2, true];const c: StringNumberBooleans &#x3D; [&quot;world&quot;, 3, true, false, true, false, true];</code></pre><p>Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:<br><code>可选元素和剩余元素的存在，使得 TypeScript 可以在参数列表里使用元组，就像这样：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function readButtonInput(...args: [string, number, ...boolean[]]) &#123;  const [name, version, ...input] &#x3D; args;  &#x2F;&#x2F; ...&#125;</code></pre><p>is basically equivalent to:<br><code>基本等同于：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function readButtonInput(name: string, version: number, ...input: boolean[]) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.</p><h2 id="readonly-Tuple-Types"><a href="#readonly-Tuple-Types" class="headerlink" title="readonly Tuple Types"></a>readonly Tuple Types</h2><p><code>只读元组类型</code><br>One final note about tuple types - tuples types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax.<br><code>元组类型也是可以设置 readonly 的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(pair: readonly [string, number]) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>As you might expect, writing to any property of a readonly tuple isn’t allowed in TypeScript.<br><code>这样 TypeScript 就不会允许写入readonly 元组的任何属性：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(pair: readonly [string, number]) &#123;  pair[0] &#x3D; &quot;hello!&quot;;  &#x2F;&#x2F; Cannot assign to &#39;0&#39; because it is a read-only property.&#125;</code></pre><p>Tuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default. This is also important given that array literals with const assertions will be inferred with readonly tuple types.<br><code>在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯。如果我们给一个数组字面量 const 断言，也会被推断为 readonly 元组类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let point &#x3D; [3, 4] as const;function distanceFromOrigin([x, y]: [number, number]) &#123;  return Math.sqrt(x ** 2 + y ** 2);&#125;distanceFromOrigin(point);&#x2F;&#x2F; Argument of type &#39;readonly [3, 4]&#39; is not assignable to parameter of type &#39;[number, number]&#39;.&#x2F;&#x2F; The type &#39;readonly [3, 4]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;[number, number]&#39;.</code></pre><p>Here, distanceFromOrigin never modifies its elements, but expects a mutable tuple. Since point’s type was inferred as readonly [3, 4], it won’t be compatible with [number, number] since that type can’t guarantee point’s elements won’t be mutated.<br><code>尽管 distanceFromOrigin 并没有更改传入的元素，但函数希望传入一个可变元组。因为 point 的类型被推断为 readonly [3, 4]，它跟 [number number] 并不兼容，所以 TypeScript 给了一个报错。</code></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.Typescript手册 函数</title>
      <link href="//post/2022-06-08ts-more-on-functions.html"/>
      <url>//post/2022-06-08ts-more-on-functions.html</url>
      
        <content type="html"><![CDATA[<p>Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.</p><h2 id="Function-Type-Expressions"><a href="#Function-Type-Expressions" class="headerlink" title="Function Type Expressions"></a>Function Type Expressions</h2><p><code>函数类型表达式</code><br>The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:<br><code>最简单描述一个函数的方式是使用函数类型表达式（function type expression）。**它的写法有点类似于箭头函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greeter(fn: (a: string) &#x3D;&gt; void) &#123;  fn(&quot;Hello, World&quot;);&#125;function printToConsole(s: string) &#123;  console.log(s);&#125;greeter(printToConsole);</code></pre><p>The syntax (a: string) &#x3D;&gt; void means “a function with one parameter, named a, of type string, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly any.<br><code>这个函数类型表达式的语法（a: string）=&gt; void，意思是“一个参数，名为a，类型为string，没有返回值”。</code><br>Note that the parameter name is required. The function type (string) &#x3D;&gt; void means “a function with a parameter named string of type any“!<br><code>注意，参数名是必需的。函数类型（string）=&gt; void意思是“一个参数名为string，类型为any”！</code><br>Of course, we can use a type alias to name a function type:<br><code>类型别名，可以命名一个函数类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type GreetFunction &#x3D; (a: string) &#x3D;&gt; void;function greeter(fn: GreetFunction) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><h2 id="Call-Signatures"><a href="#Call-Signatures" class="headerlink" title="Call Signatures"></a>Call Signatures</h2><p><code>调用签名</code></p><p>In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type:<br><code>在JavaScript中，函数可以有属性，但是函数类型表达式语法不允许声明属性。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type DescribableFunction &#x3D; &#123;  description: string;  (someArg: number): boolean;&#125;;function doSomething(fn: DescribableFunction) &#123;  console.log(fn.description + &quot; returned &quot; + fn(6));&#125;</code></pre><p>Note that the syntax is slightly different compared to a function type expression - use : between the parameter list and the return type rather than &#x3D;&gt;.<br><code>注意，语法与函数类型表达式不同，使用:在参数列表和返回类型之间。</code></p><h2 id="Construct-Signatures"><a href="#Construct-Signatures" class="headerlink" title="Construct Signatures"></a>Construct Signatures</h2><p><code>构造签名</code><br>JavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature:<br><code>JavaScript函数也可以使用new操作符。TypeScript将它们称为构造函数，因为它们通常会创建一个新的对象。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type SomeConstructor &#x3D; &#123;  new (s: string): SomeObject;&#125;;function fn(ctor: SomeConstructor) &#123;  return new ctor(&quot;hello&quot;);&#125;</code></pre><p>Some objects, like JavaScript’s Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily:<br><code>一些对象，如JavaScript的Date对象，可以使用或不使用new。你可以在同一类型中同时使用调用和构造签名：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface CallOrConstruct &#123;  new (s: string): Date;  (n?: number): number;&#125;</code></pre><h2 id="Generic-Functions"><a href="#Generic-Functions" class="headerlink" title="Generic Functions"></a>Generic Functions</h2><p><code>泛型函数</code><br>It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:<br><code>我们经常需要写这种函数，即函数的输出类型依赖函数的输入类型，或者两个输入的类型以某种形式相互关联。让我们考虑这样一个函数，它返回数组的第一个元素：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstElement(arr: any[]) &#123;  return arr[0];&#125;</code></pre><p>This function does its job, but unfortunately has the return type any. It’d be better if the function returned the type of the array element.<br><code>注意此时函数返回值的类型是 any，如果能返回第一个元素的具体类型就更好了。</code><br>In TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature:<br><code>在TypeScript中，我们可以使用泛型来描述两个值之间的关系。我们这样做的目的是为了描述函数的输入和输出之间的关系。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined &#123;  return arr[0];&#125;</code></pre><p>By adding a type parameter Type to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:<br><code>在此函数中添加一个类型参数Type，并在两处使用它，我们创建了一个函数的输入和输出之间的关系。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; s is of type &#39;string&#39;const s &#x3D; firstElement([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);&#x2F;&#x2F; n is of type &#39;number&#39;const n &#x3D; firstElement([1, 2, 3]);&#x2F;&#x2F; u is of type undefinedconst u &#x3D; firstElement([]);</code></pre><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p><code>接口</code><br>Note that we didn’t have to specify Type in this sample. The type was inferred - chosen automatically - by TypeScript.<br><code>注意，我们在这个例子中没有指定类型。TypeScript自动推断出来了。</code><br>We can use multiple type parameters as well. For example, a standalone version of map would look like this:<br><code>我们可以使用多个类型参数。例如，一个单独版本的map函数会如下所示：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function map&lt;Input, Output&gt;(  arr: Input[],  func: (arg: Input) &#x3D;&gt; Output): Output[] &#123;  return arr.map(func);&#125;&#x2F;&#x2F; Parameter &#39;n&#39; is of type &#39;string&#39;&#x2F;&#x2F; &#39;parsed&#39; is of type &#39;number[]&#39;const parsed &#x3D; map([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], (n) &#x3D;&gt; parseInt(n));</code></pre><p>Note that in this example, TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression (number).<br><code>在这个例子中，TypeScript可以推断出Input类型参数的类型（从给定的字符串数组），以及Output类型参数的类型，基于函数表达式的返回值（number）。</code></p><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p><code>约束</code><br>We’ve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept.<br><code>我们写了一些可以操作任意类型的函数。有时候，我们可以只操作一个特定的类型集合。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型。</code><br>Let’s write a function that returns the longer of two values. To do this, we need a length property that’s a number. We constrain the type parameter to that type by writing an extends clause:<br><code>我们写一个函数，返回两个值的长度。我们需要一个length属性，它是一个数字。我们通过写一个extends子句来限制类型参数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function longest&lt;Type extends &#123; length: number &#125;&gt;(a: Type, b: Type) &#123;  if (a.length &gt;&#x3D; b.length) &#123;    return a;  &#125; else &#123;    return b;  &#125;&#125;&#x2F;&#x2F; longerArray is of type &#39;number[]&#39;const longerArray &#x3D; longest([1, 2], [1, 2, 3]);&#x2F;&#x2F; longerString is of type &#39;alice&#39; | &#39;bob&#39;const longerString &#x3D; longest(&quot;alice&quot;, &quot;bob&quot;);&#x2F;&#x2F; Error! Numbers don&#39;t have a &#39;length&#39; propertyconst notOK &#x3D; longest(10, 100);&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;&#123; length: number; &#125;&#39;.</code></pre><p>There are a few interesting things to note in this example. We allowed TypeScript to infer the return type of longest. Return type inference also works on generic functions.<br><code>在这个例子中，我们允许TypeScript推断longest的返回类型。返回类型推断也可以在泛型函数中使用。</code><br>Because we constrained Type to { length: number }, we were allowed to access the .length property of the a and b parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.<br><code>因为我们限制了类型参数为&#123; length: number &#125;，所以我们可以访问a和b参数的.length属性。没有类型约束，我们不能访问这些属性，因为值可能是其他类型而没有length属性。</code><br>The types of longerArray and longerString were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!<br><code>longerArray和longerString的类型是根据参数的类型推断出来的。记住，泛型是关于两个或多个值具有相同类型的问题！</code><br>Finally, just as we’d like, the call to longest(10, 100) is rejected because the number type doesn’t have a .length property.<br><code>最后，我们想要，调用longest(10, 100)会被拒绝，因为数字类型没有.length属性。</code></p><h2 id="Working-with-Constrained-Values"><a href="#Working-with-Constrained-Values" class="headerlink" title="Working with Constrained Values"></a>Working with Constrained Values</h2><p><code>工作中的约束值</code><br>Here’s a common error when working with generic constraints:<br><code>这里是工作中常见的错误：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function minimumLength&lt;Type extends &#123; length: number &#125;&gt;(  obj: Type,  minimum: number): Type &#123;  if (obj.length &gt;&#x3D; minimum) &#123;    return obj;  &#125; else &#123;    return &#123; length: minimum &#125;;    &#x2F;&#x2F; Type &#39;&#123; length: number; &#125;&#39; is not assignable to type &#39;Type&#39;.    &#x2F;&#x2F; &#39;&#123; length: number; &#125;&#39; is assignable to the constraint of type &#39;Type&#39;, but &#39;Type&#39; could be instantiated with a different subtype of constraint &#39;&#123; length: number; &#125;&#39;.  &#125;&#125;</code></pre><p>It might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:<br><code>这个函数看起来是可以的，因为Type是约束为&#123; length: number &#125;，函数可以返回Type或者匹配这个约束的值。问题是，函数承诺返回传入的同样类型的对象，而不是匹配约束的对象。如果这段代码是合法的，你可以写一段代码，它永远不会运行：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; &#39;arr&#39; gets value &#123; length: 6 &#125;const arr &#x3D; minimumLength([1, 2, 3], 6);&#x2F;&#x2F; and crashes here because arrays have&#x2F;&#x2F; a &#39;slice&#39; method, but not the returned object!console.log(arr.slice(0));</code></pre><h2 id="Specifying-Type-Arguments"><a href="#Specifying-Type-Arguments" class="headerlink" title="Specifying Type Arguments"></a>Specifying Type Arguments</h2><p><code>明确指定类型参数</code><br>TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:<br><code>Typescript通常可以在泛型调用中推断出意图的类型参数，但不是所有的情况。例如，如果你写了一个函数，用来合并两个数组：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function combine&lt;Type&gt;(arr1: Type[], arr2: Type[]): Type[] &#123;  return arr1.concat(arr2);&#125;</code></pre><p>Normally it would be an error to call this function with mismatched arrays:<br><code>通常情况下，如果调用这个函数传入不匹配的数组，就会报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const arr &#x3D; combine([1, 2, 3], [&quot;hello&quot;]);&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre><p>If you intended to do this, however, you could manually specify Type:<br><code>如果你想这样做，你可以手动指定Type：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const arr &#x3D; combine&lt;string | number&gt;([1, 2, 3], [&quot;hello&quot;]);</code></pre><h2 id="Guidelines-for-Writing-Good-Generic-Functions"><a href="#Guidelines-for-Writing-Good-Generic-Functions" class="headerlink" title="Guidelines for Writing Good Generic Functions"></a>Guidelines for Writing Good Generic Functions</h2><p><code>写好泛型函数的指南</code><br>Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.<br><code>写好泛型函数是很有趣的，也可以很容易地使用类型参数。有太多类型参数或者使用约束，而且这些约束不需要的话，推断就会更加不成功，使用者会困惑。</code></p><h2 id="Push-Type-Parameters-Down"><a href="#Push-Type-Parameters-Down" class="headerlink" title="Push Type Parameters Down"></a>Push Type Parameters Down</h2><p><code>推下类型参数</code><br>Here are two ways of writing a function that appear similar:<br><code>这里有两种方式写一个函数，看起来像是一样的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstElement1&lt;Type&gt;(arr: Type[]) &#123;  return arr[0];&#125;function firstElement2&lt;Type extends any[]&gt;(arr: Type) &#123;  return arr[0];&#125;&#x2F;&#x2F; a: number (good)const a &#x3D; firstElement1([1, 2, 3]);&#x2F;&#x2F; b: any (bad)const b &#x3D; firstElement2([1, 2, 3]);</code></pre><p>These might seem identical at first glance, but firstElement1 is a much better way to write this function. Its inferred return type is Type, but firstElement2’s inferred return type is any because TypeScript has to resolve the arr[0] expression using the constraint type, rather than “waiting” to resolve the element during a call.<br><code>这两个函数看起来像是一样的，但是firstElement1更好的写法。它的推断返回类型是Type，但firstElement2的推断返回类型是any，因为TypeScript要在调用时使用约束类型，而不是等待元素被解析。</code><br>Rule: When possible, use the type parameter itself rather than constraining it<br><code>当可能的话，尽量使用类型参数本身而不约束它</code><br>Use Fewer Type Parameters<br><code>使用更少的类型参数</code><br>Here’s another pair of similar functions:<br><code>这里有一对相似的函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function filter1&lt;Type&gt;(arr: Type[], func: (arg: Type) &#x3D;&gt; boolean): Type[] &#123;  return arr.filter(func);&#125;function filter2&lt;Type, Func extends (arg: Type) &#x3D;&gt; boolean&gt;(  arr: Type[],  func: Func): Type[] &#123;  return arr.filter(func);&#125;</code></pre><p>We’ve created a type parameter Func that doesn’t relate two values. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. Func doesn’t do anything but make the function harder to read and reason about!<br><code>我们创建了一个类型参数Func，它不关联两个值。这是一个红线，因为它意味着调用者希望指定类型参数时，必须手动指定一个额外的类型参数。Func不做任何事情，只是让这个函数更难读，理解。</code><br>Rule: Always use as few type parameters as possible<br><code>总是使用最少的类型参数</code></p><h2 id="Type-Parameters-Should-Appear-Twice"><a href="#Type-Parameters-Should-Appear-Twice" class="headerlink" title="Type Parameters Should Appear Twice"></a>Type Parameters Should Appear Twice</h2><p><code>类型参数应该出现两次</code><br>Sometimes we forget that a function might not need to be generic:<br><code>有时候我们忘记了一个函数可能不需要泛型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet&lt;Str extends string&gt;(s: Str) &#123;  console.log(&quot;Hello, &quot; + s);&#125;greet(&quot;world&quot;);</code></pre><p>We could just as easily have written a simpler version:<br><code>我们可以简单的写一个更简单的版本：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(s: string) &#123;  console.log(&quot;Hello, &quot; + s);&#125;</code></pre><p>Remember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it’s not relating anything.<br><code>记住，类型参数是用来关联多个值的类型的。如果一个类型参数只被一次使用在函数签名中，它不关联任何东西。</code><br>Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it<br><code>如果一个类型参数只出现在一个位置，强烈建议如果你实际上需要它的话，</code></p><h2 id="Optional-Parameters"><a href="#Optional-Parameters" class="headerlink" title="Optional Parameters"></a>Optional Parameters</h2><p><code>可选参数</code><br>Functions in JavaScript often take a variable number of arguments. For example, the toFixed method of number takes an optional digit count:<br><code>在 JavaScript 中，函数通常会接受一个可变数量的参数。例如，number 的 toFixed 方法接受一个可选的位数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f(n: number) &#123;  console.log(n.toFixed()); &#x2F;&#x2F; 0 arguments  console.log(n.toFixed(3)); &#x2F;&#x2F; 1 argument&#125;</code></pre><p>We can model this in TypeScript by marking the parameter as optional with ?:<br><code>我们可以在 TypeScript 中使用 ?: 来标记可选参数</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f(x?: number) &#123;  &#x2F;&#x2F; ...&#125;f(); &#x2F;&#x2F; OKf(10); &#x2F;&#x2F; OK</code></pre><p>Although the parameter is specified as type number, the x parameter will actually have the type number | undefined because unspecified parameters in JavaScript get the value undefined.<br><code>在 JavaScript 中，未指定参数的值会被设置为 undefined。</code><br>You can also provide a parameter default:<br><code>你也可以提供一个参数默认值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f(x &#x3D; 10) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>Now in the body of f, x will have type number because any undefined argument will be replaced with 10. Note that when a parameter is optional, callers can always pass undefined, as this simply simulates a “missing” argument:<br><code>在 f 中的 body 中，x 将有 number 类型，因为任何未定义的参数都会被替换为 10。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare function f(x?: number): void;&#x2F;&#x2F; cut&#x2F;&#x2F; All OKf();f(10);f(undefined);</code></pre><h2 id="Optional-Parameters-in-Callbacks"><a href="#Optional-Parameters-in-Callbacks" class="headerlink" title="Optional Parameters in Callbacks"></a>Optional Parameters in Callbacks</h2><p><code>回调函数中的可选参数</code><br>Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:<br><code>一旦你学会了可选参数和函数类型表达式，写函数调用回调函数时很容易出错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function myForEach(arr: any[], callback: (arg: any, index?: number) &#x3D;&gt; void) &#123;  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;    callback(arr[i], i);  &#125;&#125;</code></pre><p>What people usually intend when writing index? as an optional parameter is that they want both of these calls to be legal:<br><code>人们常常希望写 index 作为可选参数，这意味着它们都是合法的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">myForEach([1, 2, 3], (a) &#x3D;&gt; console.log(a));myForEach([1, 2, 3], (a, i) &#x3D;&gt; console.log(a, i));</code></pre><p>What this actually means is that callback might get invoked with one argument. In other words, the function definition says that the implementation might look like this:<br><code>这实际上意味着回调函数可能会被调用一个参数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function myForEach(arr: any[], callback: (arg: any, index?: number) &#x3D;&gt; void) &#123;  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;    &#x2F;&#x2F; I don&#39;t feel like providing the index today    callback(arr[i]);  &#125;&#125;</code></pre><p>In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:<br><code>在 TypeScript 中，会发出这些不可能的错误：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">myForEach([1, 2, 3], (a, i) &#x3D;&gt; &#123;  console.log(i.toFixed());  &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.&#125;);</code></pre><p>In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.<br><code>在 JavaScript 中，如果调用函数的参数多于参数，那么这些多余的参数将被忽略。TypeScript 也会像这样。函数可以接受多个参数，但是参数的类型必须是相同的。</code><br>When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument<br><code>写一个回调函数类型时，如果你不想传递这个参数，就不要写可选参数。</code></p><h2 id="Function-Overloads"><a href="#Function-Overloads" class="headerlink" title="Function Overloads"></a>Function Overloads</h2><p><code>函数重载</code><br>Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a Date that takes either a timestamp (one argument) or a month&#x2F;day&#x2F;year specification (three arguments).<br><code>在 JavaScript 中，可以调用一个函数，参数的数量和类型都不一样。例如，你可以写一个函数，用来生成一个 Date 对象，可以接受一个时间戳（一个参数）或一个月/日/年 的指定（三个参数）。</code><br>In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function:<br><code>在 TypeScript 中，我们可以写一个函数，它可以被调用不同的参数和类型，通过写出多个函数类型（通常是两个或多个），然后写出函数的 body：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date &#123;  if (d !&#x3D;&#x3D; undefined &amp;&amp; y !&#x3D;&#x3D; undefined) &#123;    return new Date(y, mOrTimestamp, d);  &#125; else &#123;    return new Date(mOrTimestamp);  &#125;&#125;const d1 &#x3D; makeDate(12345678);const d2 &#x3D; makeDate(5, 5, 5);const d3 &#x3D; makeDate(1, 3);&#x2F;&#x2F; No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</code></pre><p>In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures.<br><code>在这个例子中，我们写了两个函数类型：一个只接受一个参数，一个只接受三个参数。这两个第一个类型是函数类型。</code><br>Then, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!<br><code>然后，我们写了一个函数实现，这个函数类型不能直接调用。即使我们写了一个参数后，再写了一个可选参数，也不能调用两个参数。虽然我们写了两个参数，但是不能调用两个参数。</code></p><h2 id="Overload-Signatures-and-the-Implementation-Signature"><a href="#Overload-Signatures-and-the-Implementation-Signature" class="headerlink" title="Overload Signatures and the Implementation Signature"></a>Overload Signatures and the Implementation Signature</h2><p><code>重载签名和实现签名</code><br>This is a common source of confusion. Often people will write code like this and not understand why there is an error:<br><code>这是一个常见的混乱源。很多人写了这样的代码，但是不知道为什么会有错误。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function fn(x: string): void;function fn() &#123;  &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; Expected to be able to call with zero argumentsfn();&#x2F;&#x2F; Expected 1 arguments, but got 0.</code></pre><p>Again, the signature used to write the function body can’t be “seen” from the outside.<br><code>再次，写出函数的 body 的签名不能被外部看到。</code><br>The signature of the implementation is not visible from the outside. When writing an overloaded function, you should always have two or more signatures above the implementation of the function.<br><code>在写一个重载函数时，你应该总是写两个或多个签名，在函数的实现之上。你应该总是写两个或多个签名，在函数的实现之上。</code><br>The implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:<br><code>实现签名必须与重载签名一致。例如，这些函数有错误，因为实现签名不正确。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function fn(x: boolean): void;&#x2F;&#x2F; Argument type isn&#39;t rightfunction fn(x: string): void;&#x2F;&#x2F; This overload signature is not compatible with its implementation signature.function fn(x: boolean) &#123;&#125;function fn(x: string): string;&#x2F;&#x2F; Return type isn&#39;t rightfunction fn(x: number): boolean;&#x2F;&#x2F; This overload signature is not compatible with its implementation signature.function fn(x: string | number) &#123;  return &quot;oops&quot;;&#125;</code></pre><h2 id="Writing-Good-Overloads"><a href="#Writing-Good-Overloads" class="headerlink" title="Writing Good Overloads"></a>Writing Good Overloads</h2><p><code>写好重载</code><br>Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.<br><code>就像泛型一样，也有一些建议提供给你。遵循这些原则，可以让你的函数更方便调用、理解。</code><br>Let’s consider a function that returns the length of a string or an array:<br><code>我们来考虑一个函数，它返回一个字符串或数组的长度：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function len(s: string): number;function len(arr: any[]): number;function len(x: any) &#123;  return x.length;&#125;</code></pre><p>This function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:<br><code>这个函数代码功能实现了，也没有什么报错，但我们不能传入一个可能是字符串或者是数组的值，因为 TypeScript 只能一次用一个函数重载处理一次函数调用。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">len(&quot;&quot;); &#x2F;&#x2F; OKlen([0]); &#x2F;&#x2F; OKlen(Math.random() &gt; 0.5 ? &quot;hello&quot; : [0]);&#x2F;&#x2F; No overload matches this call.&#x2F;&#x2F; 没有匹配的重载函数。&#x2F;&#x2F; Overload 1 of 2, &#39;(s: string): number&#39;, gave the following error.&#x2F;&#x2F; 重载 1 和 2 之间的函数调用报错。&#x2F;&#x2F; Argument of type &#39;number[] | &quot;hello&quot;&#39; is not assignable to parameter of type &#39;string&#39;.&#x2F;&#x2F;  参数类型 &#39;number[] | &quot;hello&quot;&#39; 不能赋值给参数类型 &#39;string&#39;。&#x2F;&#x2F; Type &#39;number[]&#39; is not assignable to type &#39;string&#39;.&#x2F;&#x2F; 类型 &#39;number[]&#39; 不能赋值给类型 &#39;string&#39;。&#x2F;&#x2F; Overload 2 of 2, &#39;(arr: any[]): number&#39;, gave the following error.&#x2F;&#x2F; 重载 2 和 2 之间的函数调用报错。&#x2F;&#x2F; Argument of type &#39;number[] | &quot;hello&quot;&#39; is not assignable to parameter of type &#39;any[]&#39;.&#x2F;&#x2F; 参数类型 &#39;number[] | &quot;hello&quot;&#39; 不能赋值给参数类型 &#39;any[]&#39;。&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;any[]&#39;.&#x2F;&#x2F; 类型 &#39;string&#39; 不能赋值给类型 &#39;any[]&#39;。</code></pre><p>Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:<br><code>因为两个重载函数的参数数量和返回值类型都一样，我们可以写一个不重载的函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function len(x: any[] | string) &#123;  return x.length;&#125;</code></pre><p>This is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.<br><code>这更好了！调用者可以传入任意类型的值，并且我们不需要再去找一个正确的实现签名。</code><br>Always prefer parameters with union types instead of overloads when possible<br><code>如果可以的话，尽量使用联合类型而不是重载函数。</code></p><h2 id="Declaring-this-in-a-Function"><a href="#Declaring-this-in-a-Function" class="headerlink" title="Declaring this in a Function"></a>Declaring this in a Function</h2><p><code>在函数中声明 this</code><br>TypeScript will infer what the this should be in a function via code flow analysis, for example in the following:<br><code>TypeScript 会根据代码流分析来决定函数中 this 的值。例如，在下面的代码中：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const user &#x3D; &#123;  id: 123,  admin: false,  becomeAdmin: function () &#123;    this.admin &#x3D; true;  &#125;,&#125;;</code></pre><p>TypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user. this, heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object this represents. The JavaScript specification states that you cannot have a parameter called this, and so TypeScript uses that syntax space to let you declare the type for this in the function body.<br><code>TypeScript 知道函数 user.becomeAdmin 有一个对应的 this，这个 this 可以足够大部分的情况，但有很多情况需要更多的控制权。 JavaScript 规范禁止使用 this 参数，因此 TypeScript 使用这种语法空间来声明函数体中 this 的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface DB &#123;  filterUsers(filter: (this: User) &#x3D;&gt; boolean): User[];&#125;const db &#x3D; getDB();const admins &#x3D; db.filterUsers(function (this: User) &#123;  return this.admin;&#125;);</code></pre><p>This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use function and not arrow functions to get this behavior:<br><code>这种模式通常出现在回调函数风格的 API 中，其中另一个对象通常控制函数调用的时机。请注意，你需要使用 function 而不是 arrow function 来获取这种行为。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface DB &#123;  filterUsers(filter: (this: User) &#x3D;&gt; boolean): User[];&#125;const db &#x3D; getDB();const admins &#x3D; db.filterUsers(() &#x3D;&gt; this.admin);&#x2F;&#x2F; The containing arrow function captures the global value of &#39;this&#39;.&#x2F;&#x2F; 这个包含的箭头函数捕获了全局值 &#39;this&#39;。&#x2F;&#x2F; Element implicitly has an &#39;any&#39; type because type &#39;typeof globalThis&#39; has no index signature.&#x2F;&#x2F; 元素隐式有一个 &#39;any&#39; 类型，因为类型 &#39;typeof globalThis&#39; 没有索引签名。</code></pre><h2 id="Other-Types-to-Know-About"><a href="#Other-Types-to-Know-About" class="headerlink" title="Other Types to Know About"></a>Other Types to Know About</h2><p><code>其他需要知道的类型</code><br>There are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.<br><code>这里介绍一些也会经常出现的类型。像其他的类型一样，你也可以在任何地方使用它们，但它们经常与函数搭配使用。</code><br><strong>void</strong></p><p>void represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any return statements, or doesn’t return any explicit value from those return statements:<br><code>void 类型表示函数没有返回值的情况。它在函数没有返回值的情况下被推断为 any 类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; The inferred return type is voidfunction noop() &#123;  return;&#125;</code></pre><p>In JavaScript, a function that doesn’t return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. There are further details at the end of this chapter.<br><code>在 JavaScript 中，函数没有返回值的情况下，函数会自动返回 undefined。但是在 TypeScript 中，void 和 undefined 的类型不一样。有更多详情在本章末尾。</code><br>void is not the same as undefined.<br><code>void 类型不是 undefined 类型。</code></p><p><strong>object</strong></p><p>The special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. It’s very likely you will never use Object.<br><code>这个特殊的类型 object 可以表示任何不是原始类型（primitive）的值 (string、number、bigint、boolean、symbol、null、undefined)。object 不同于空对象类型 &#123; &#125;，也不同于全局类型 Object。很有可能你也用不到 Object</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>object is not Object. Always use object!<br><code>object 不同于 Object ，总是用 object!</code></p></blockquote><p>Note that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object, you can call Object.keys on them, and so on. For this reason, function types are considered to be objects in TypeScript.<br><code>注意在 JavaScript 中，函数就是对象，他们可以有属性，在他们的原型链上有 Object.prototype，并且 instanceof Object。你可以对函数使用 Object.keys 等等。由于这些原因，在 TypeScript 中，函数也被认为是 object。</code></p><p><strong>unknown</strong></p><p>The unknown type represents any value. This is similar to the any type, but is safer because it’s not legal to do anything with an unknown value:<br><code>unknown 类型可以表示任何值。有点类似于 any，但是更安全，因为对 unknown 类型的值做任何事情都是不合法的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f1(a: any) &#123;  a.b(); &#x2F;&#x2F; OK&#125;function f2(a: unknown) &#123;  a.b();  &#x2F;&#x2F; Object is of type &#39;unknown&#39;.&#125;</code></pre><p>This is useful when describing function types because you can describe functions that accept any value without having any values in your function body.<br><code>有的时候用来描述函数类型，还是蛮有用的。你可以描述一个函数可以接受传入任何值，但是在函数体内又不用到 any 类型的值。</code><br>Conversely, you can describe a function that returns a value of unknown type:<br><code>相反，你可以描述一个函数返回一个不知道什么类型的值，比如：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function safeParse(s: string): unknown &#123;  return JSON.parse(s);&#125;&#x2F;&#x2F; Need to be careful with &#39;obj&#39;!const obj &#x3D; safeParse(someRandomString);</code></pre><p><strong>never</strong></p><p>Some functions never return a value:<br><code>一些函数从来不返回值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function fail(msg: string): never &#123;  throw new Error(msg);&#125;</code></pre><p>The never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.<br><code>never 类型表示一个值不会再被观察到 (observed)。作为一个返回类型时，它表示这个函数会丢一个异常，或者会结束程序的执行。</code><br>never also appears when TypeScript determines there’s nothing left in a union.<br><code>当 TypeScript 确定在联合类型中已经没有可能是其中的类型的时候，never 类型也会出现：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function fn(x: string | number) &#123;  if (typeof x &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    &#x2F;&#x2F; do something  &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    &#x2F;&#x2F; do something else  &#125; else &#123;    x; &#x2F;&#x2F; has type &#39;never&#39;!  &#125;&#125;</code></pre><p><strong>Function</strong></p><p>The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any:<br><code>Function 类型描述了所有函数值的属性，比如 bind、call、apply 等等。这个类型也有一个特殊的属性，可以被调用，这些调用会返回任何类型的值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(f: Function) &#123;  return f(1, 2, 3);&#125;</code></pre><p>This is an untyped function call and is generally best avoided because of the unsafe any return type.<br><code>这是一个无类型函数调用 (untyped function call)，这种调用最好被避免，因为它返回的是一个不安全的 any类型。</code><br>If you need to accept an arbitrary function but don’t intend to call it, the type () &#x3D;&gt; void is generally safer.<br><code>如果你准备接受一个黑盒的函数，但是又不打算调用它，() =&gt; void 会更安全一些。</code></p><h2 id="Rest-Parameters-and-Arguments"><a href="#Rest-Parameters-and-Arguments" class="headerlink" title="Rest Parameters and Arguments"></a>Rest Parameters and Arguments</h2><p><code>剩余参数</code><br><strong>Background Reading:</strong></p><ul><li>Rest Parameters</li><li>Spread Syntax</li></ul><h2 id="Rest-Parameters"><a href="#Rest-Parameters" class="headerlink" title="Rest Parameters"></a>Rest Parameters</h2><p><code>剩余参数</code><br>In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.<br><code>除了用可选参数、重载能让函数接收不同数量的函数参数，我们也可以通过使用剩余参数语法（rest parameters），定义一个可以传入数量不受限制的函数参数的函数：</code><br>A rest parameter appears after all other parameters, and uses the … syntax:<br><code>剩余参数必须放在所有参数的最后面，并使用 ... 语法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function multiply(n: number, ...m: number[]) &#123;  return m.map((x) &#x3D;&gt; n \* x);&#125;&#x2F;&#x2F; &#39;a&#39; gets value [10, 20, 30, 40]const a &#x3D; multiply(10, 1, 2, 3, 4);</code></pre><p>In TypeScript, the type annotation on these parameters is implicitly any[] instead of any, and any type annotation given must be of the form Array<T>or T[], or a tuple type (which we’ll learn about later).<br><code>在 TypeScript 中，剩余参数的类型会被隐式设置为 any[] 而不是 any，如果你要设置具体的类型，必须是 Array&lt;T&gt; 或者 T[]的形式，再或者就是元组类型（tuple type）。</code></p><h2 id="Rest-Arguments"><a href="#Rest-Arguments" class="headerlink" title="Rest Arguments"></a>Rest Arguments</h2><p><code>剩余参数</code><br>Conversely, we can provide a variable number of arguments from an array using the spread syntax. For example, the push method of arrays takes any number of arguments:<br><code>我们可以借助一个使用 ... 语法的数组，为函数提供不定数量的实参。举个例子，数组的 push 方法就可以接受任何数量的实参：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const arr1 &#x3D; [1, 2, 3];const arr2 &#x3D; [4, 5, 6];arr1.push(...arr2);</code></pre><p>Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:<br><code>注意一般情况下，TypeScript 并不会假定数组是不变的(immutable)，这会导致一些意外的行为：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Inferred type is number[] -- &quot;an array with zero or more numbers&quot;,&#x2F;&#x2F; not specifically two numbersconst args &#x3D; [8, 5];const angle &#x3D; Math.atan2(...args);&#x2F;&#x2F; A spread argument must either have a tuple type or be passed to a rest parameter.</code></pre><p>The best fix for this situation depends a bit on your code, but in general a const context is the most straightforward solution:<br><code>这种情况的最佳解决方案可能是一个更简单的方案：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Inferred as 2-length tupleconst args &#x3D; [8, 5] as const;&#x2F;&#x2F; OKconst angle &#x3D; Math.atan2(...args);</code></pre><p>Using rest arguments may require turning on downlevelIteration when targeting older runtimes.<br><code>使用剩余参数可能需要在更旧的运行时配合 downlevelIteration 参数。</code></p><h2 id="Parameter-Destructuring"><a href="#Parameter-Destructuring" class="headerlink" title="Parameter Destructuring"></a>Parameter Destructuring</h2><p><code>你可以使用参数解构方便的将作为参数提供的对象解构为函数体内一个或者多个局部变量，在 JavaScript 中，是这样的：</code></p><p><strong>Background Reading:</strong></p><ul><li>Destructuring Assignment</li></ul><p>You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:<br><code>你可以使用参数解构来轻松地将一个作为参数提供的对象解构为函数体内一个或者多个局部变量。在 JavaScript 中，它的样子是这样的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function sum(&#123; a, b, c &#125;) &#123;  console.log(a + b + c);&#125;sum(&#123; a: 10, b: 3, c: 9 &#125;);&#x2F;&#x2F; The type annotation for the object goes after the destructuring syntax:function sum(&#123; a, b, c &#125;: &#123; a: number; b: number; c: number &#125;) &#123;  console.log(a + b + c);&#125;</code></pre><p>This can look a bit verbose, but you can use a named type here as well:<br><code>这可能会太长，但你可以使用一个命名类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Same as prior exampletype ABC &#x3D; &#123; a: number; b: number; c: number &#125;;function sum(&#123; a, b, c &#125;: ABC) &#123;  console.log(a + b + c);&#125;</code></pre><h2 id="Assignability-of-Functions"><a href="#Assignability-of-Functions" class="headerlink" title="Assignability of Functions"></a>Assignability of Functions</h2><p><code>函数的可赋值性</code><br>Return type void<br><code>返回void</code><br>The void return type for functions can produce some unusual, but expected behavior.<br><code>函数的返回类型为void时，可能会产生一些有意想不到的行为。</code><br>Contextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type vf &#x3D; () &#x3D;&gt; void), when implemented, can return any other value, but it will be ignored.<br><code>在一个返回类型为void的函数中，不会强制函数不返回什么东西。另一种说法是一个上下文函数类型，它的返回类型为void，当实现的时候，可以返回任何值，但是它将被忽略。</code><br>Thus, the following implementations of the type () &#x3D;&gt; void are valid:<br><code>因此，下面的实现是有效的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type voidFunc &#x3D; () &#x3D;&gt; void;const f1: voidFunc &#x3D; () &#x3D;&gt; &#123;  return true;&#125;;const f2: voidFunc &#x3D; () &#x3D;&gt; true;const f3: voidFunc &#x3D; function () &#123;  return true;&#125;;</code></pre><p>And when the return value of one of these functions is assigned to another variable, it will retain the type of void:<br><code>当一个函数的返回值被赋值给另一个变量时，它将保持返回类型为void的类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const v1 &#x3D; f1();const v2 &#x3D; f2();const v3 &#x3D; f3();</code></pre><p>This behavior exists so that the following code is valid even though Array.prototype.push returns a number and the Array.prototype.forEach method expects a function with a return type of void.<br><code>这种行为存在，这样就可以保证下面的代码是有效的，即使 Array.prototype.push 返回一个数字，Array.prototype.forEach 方法也期望一个返回类型为void的函数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const src &#x3D; [1, 2, 3];const dst &#x3D; [0];src.forEach((el) &#x3D;&gt; dst.push(el));</code></pre><p>There is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything.<br><code>当一个字面量函数定义有一个返回类型为void的函数，那么函数必须不返回任何东西。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f2(): void &#123;  &#x2F;&#x2F; @ts-expect-error  return true;&#125;const f3 &#x3D; function (): void &#123;  &#x2F;&#x2F; @ts-expect-error , Type &#39;boolean&#39; is not assignable to type &#39;void&#39;.  return true;&#125;;</code></pre><p>For more on void please refer to these other documentation entries:<br><code>更多关于void的文档请参见这些其他文档条目：</code><br><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#void">v1 handbook</a><br><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#void">v2 handbook</a><br>FAQ - “Why are functions returning non-void assignable to function returning void?”<br><code>为什么函数返回非void类型可以赋值给函数返回void类型？</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html">TypeScript 手册 functions</a><br><a href="https://ts.yayujs.com/handbook/MoreOnFunctions.html#%E5%87%BD%E6%95%B0-more-on-functions">函数（More On Functions）</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.Typescript手册 收缩类型</title>
      <link href="//post/2022-06-08ts-norrowing.html"/>
      <url>//post/2022-06-08ts-norrowing.html</url>
      
        <content type="html"><![CDATA[<h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><p><code>缩小范围</code></p><p>Imagine we have a function called padLeft.<br><code>试想我们有这样一个函数，函数名为 padLeft：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function padLeft(padding: number | string, input: string): string &#123;  throw new Error(&quot;Not implemented yet!&quot;);&#125;</code></pre><p>If padding is a number, it will treat that as the number of spaces we want to prepend to input. If padding is a string, it should just prepend padding to input. Let’s try to implement the logic for when padLeft is passed a number for padding.</p><p><code>如果 padding 是数字，它将会将 padding 视为我们要添加的空格数量，如果 padding 是字符串，它将会添加 padding 到 input 的前面。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function padLeft(padding: number | string, input: string) &#123;  return &quot; &quot;.repeat(padding) + input;  &#x2F;&#x2F; Argument of type &#39;string | number&#39; is not assignable to parameter of type &#39;number&#39;.  &#x2F;&#x2F; 参数类型 &#39;string | number&#39; 不能赋值给参数类型 &#39;number&#39;。  &#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.  &#x2F;&#x2F; 类型 &#39;string&#39; 不能赋值给类型 &#39;number&#39;。&#125;</code></pre><p>Uh-oh, we’re getting an error on padding.<br><code>哇，我们得到一个错误，padding。</code><br>TypeScript is warning us that adding a number | string to a number might not give us what we want, and it’s right. In other words, we haven’t explicitly checked if padding is a number first, nor are we handling the case where it’s a string, so let’s do exactly that.<br><code>这是 TypeScript 在警告我们，如果把一个 number 类型 (即例子里的数字 1 )和一个 number | string 类型相加，也许并不会达到我们想要的结果。换句话说，我们应该先检查下 padding 是否是一个 number，或者处理下当 padding 是 string 的情况，那我们可以这样做：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;  &#125;  return padding + input;&#125;</code></pre><p>If this mostly looks like uninteresting JavaScript code, that’s sort of the point. Apart from the annotations we put in place, this TypeScript code looks like JavaScript. The idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.<br><code>如果这个代码看起来没有什么意思，那就是 TypeScript 的类型系统希望我们能写出一些比较普通的 JavaScript 代码，而不是折腾至最后才知道类型安全。</code><br>While it might not look like much, there’s actually a lot going under the covers here. Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like if&#x2F;else, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.<br><code>这里的实现比较简单，但是它真的是一个类型检查器，它会在 JavaScript 中的 if/else、条件表达式、循环、真假值检查等控制流中进行类型检查。</code><br>Within our if check, TypeScript sees typeof padding &#x3D;&#x3D;&#x3D; “number” and understands that as a special form of code called a type guard. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing. In many editors we can observe these types as they change, and we’ll even do so in our examples.<br><code>在我们的 if 检查中，TypeScript 会看到 typeof padding === &quot;number&quot;，并且会解释这个表达式为一个特殊的代码，这个代码被称为类型检查。TypeScript 会根据我们的程序的执行流，来检查一个值的最具体的类型。这些特殊的检查（称为类型检查）和赋值，会影响到类型的精确性。在编辑器中，我们可以看到这些类型的变化，我们也会在我们的例子中看到。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;    &#x2F;&#x2F; (parameter) padding: number  &#125;  return padding + input;  &#x2F;&#x2F; (parameter) padding: string&#125;</code></pre><p>There are a couple of different constructs TypeScript understands for narrowing.<br><code>TypeScript 会理解一些更加精确的构造。</code></p><h2 id="typeof-type-guards"><a href="#typeof-type-guards" class="headerlink" title="typeof type guards"></a>typeof type guards</h2><p><code>类型保护</code></p><p>As we’ve seen, JavaScript supports a typeof operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:<br><code>JavaScript 支持一个 typeof 操作符，它可以给我们的值返回一些基本的信息。TypeScript 期望这些信息是一个特定的集合：</code></p><p>“string”<br>“number”<br>“bigint”<br>“boolean”<br>“symbol”<br>“undefined”<br>“object”<br>“function”</p><p>Like we saw with padLeft, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.<br><code>和 padLeft 一样，这个操作符在 JavaScript 库中很常见，TypeScript 可以理解它来缩小不同的分支的类型。</code><br>In TypeScript, checking against the value returned by typeof is a type guard. Because TypeScript encodes how typeof operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, typeof doesn’t return the string null. Check out the following example:<br><code>在 TypeScript 中，检查 typeof 返回的值就是一种类型保护。TypeScript 知道 typeof 不同值的结果，它也能识别 JavaScript 中一些怪异的地方，就比如在上面的列表中，typeof 并没有返回字符串 null，看下面这个例子：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printAll(strs: string | string[] | null) &#123;  if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;    for (const s of strs) &#123;      &#x2F;&#x2F; Object is possibly &#39;null&#39;.      console.log(s);    &#125;  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    console.log(strs);  &#125; else &#123;    &#x2F;&#x2F; do nothing  &#125;&#125;</code></pre><p>In the printAll function, we try to check if strs is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, typeof null is actually “object”! This is one of those unfortunate accidents of history.<br><code>在这个 printAll 函数中，我们尝试判断 strs 是否是一个对象，原本的目的是判断它是否是一个数组类型，但是在 JavaScript 中，typeof null 也会返回 object。而这是 JavaScript 一个不幸的历史事故。</code><br>Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that strs was only narrowed down to string[] | null instead of just string[].<br><code>熟练的用户自然不会感到惊讶，但也并不是所有人都如此熟练。不过幸运的是，TypeScript 会让我们知道 strs 被收窄为 strings[] | null ，而不仅仅是 string[]。</code><br>This might be a good segue into what we’ll call “truthiness” checking.<br><code>这可能是一个好的转折点。</code></p><h2 id="Truthiness-narrowing"><a href="#Truthiness-narrowing" class="headerlink" title="Truthiness narrowing"></a>Truthiness narrowing</h2><p><code>真实性缩减</code></p><p>Truthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.<br><code>真实性可能不是在字典里面找到的，但是你会听到 JavaScript 中的真实性。</code><br>In JavaScript, we can use any expression in conditionals, &amp;&amp;s, ||s, if statements, Boolean negations (!), and more. As an example, if statements don’t expect their condition to always have the type boolean.<br><code>这是因为 JavaScript 会做隐式类型转换，像 0 、NaN、&quot;&quot;、0n、null undefined 这些值都会被转为 false，其他的值则会被转为 true。当然你也可以使用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getUsersOnlineMessage(numUsersOnline: number) &#123;  if (numUsersOnline) &#123;    return &#96;There are $&#123;numUsersOnline&#125; online now!&#96;;  &#125;  return &quot;Nobody&#39;s here. :(&quot;;&#125;</code></pre><p>In JavaScript, constructs like if first “coerce” their conditions to booleans to make sense of them, and then choose their branches depending on whether the result is true or false. Values like<br><code>0、NaN、&quot;&quot;、0n、null undefined 这些值都会被转为 false，其他的值则会被转为 true。当然你也可以使用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!：</code></p><ul><li>0</li><li>NaN</li><li>“” (the empty string)</li><li>0n (the bigint version of zero)</li><li>null</li><li>undefined</li></ul><p>all coerce to false, and other values get coerced true. You can always coerce values to booleans by running them through the Boolean function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type true, while inferring the first as type boolean.)<br>所有 这些值都会被转为 false，其他的值则会被转为 true。你可以通过调用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!。(这种情况下，TypeScript 会推断一个简单的布尔值类型 true，而不是类型 boolean。)</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; both of these result in &#39;true&#39;Boolean(&quot;hello&quot;); &#x2F;&#x2F; type: boolean, value: true!!&quot;world&quot;; &#x2F;&#x2F; type: true,    value: true</code></pre><p>It’s fairly popular to leverage this behavior, especially for guarding against values like null or undefined. As an example, let’s &#96;&#96;&#96;using it for our printAll function.<code>这种使用方式非常流行，尤其适用于防范 null 和 undefiend 这种值的时候。举个例子，我们可以在 printAll 函数中这样使用：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printAll(strs: string | string[] | null) &#123;  if (strs &amp;&amp; typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;    for (const s of strs) &#123;      console.log(s);    &#125;  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    console.log(strs);  &#125;&#125;</code></pre><p>You’ll notice that we’ve gotten rid of the error above by checking if strs is truthy. This at least prevents us from dreaded errors when we run our code like:<br><code>这里我们获得了一个错误，因为我们检查了 strs 是否为真。这至少防止了我们在运行代码时出现的错误。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; TypeError: null is not iterable</code></pre><p>Keep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing printAll<br><code>但还是要注意，在基本类型上的真值检查很容易导致错误，比如，如果我们这样写 printAll 函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printAll(strs: string | string[] | null) &#123;  &#x2F;&#x2F; !!!!!!!!!!!!!!!!  &#x2F;&#x2F; DON&#39;T DO THIS!  &#x2F;&#x2F; KEEP READING  &#x2F;&#x2F; !!!!!!!!!!!!!!!!  if (strs) &#123;    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;      for (const s of strs) &#123;        console.log(s);      &#125;    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;      console.log(strs);    &#125;  &#125;&#125;</code></pre><p>We wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.<br><code>我们将整个函数包裹在真值检查中，但这有一个潜在的问题：我们可能不再正确处理空字符串的情况。</code><br>TypeScript doesn’t hurt us here at all, but this is behavior worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do nothing with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.<br><code>TypeScript 不会给我们任何麻烦，但如果你不了解 JavaScript，这可能是一个很有用的技巧。TypeScript 可以帮助你提前发现错误，但如果你选择不做任何事情，那么只能是有限的。如果你想，你可以使用一个 linter 来确保你在这种情况下正确处理。</code><br>One last word on narrowing by truthiness is that Boolean negations with ! filter out from negated branches.<br><code>另外一个通过真值检查收窄类型的方式是通过!操作符。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function multiplyAll(values: number[] | undefined, factor: number): number[] | undefined &#123;  if (!values) &#123;    return values;  &#125; else &#123;    return values.map((x) &#x3D;&gt; x \* factor);  &#125;&#125;</code></pre><h2 id="Equality-narrowing"><a href="#Equality-narrowing" class="headerlink" title="Equality narrowing"></a>Equality narrowing</h2><p><code>等值缩减</code></p><p>TypeScript also uses switch statements and equality checks like &#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;, and !&#x3D; to narrow types. For example:<br><code>TypeScript 也使用了 switch 语句和等值检查，比如 ===、!==、==、!=。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function example(x: string | number, y: string | boolean) &#123;  if (x &#x3D;&#x3D;&#x3D; y) &#123;    &#x2F;&#x2F; We can now call any &#39;string&#39; method on &#39;x&#39; or &#39;y&#39;.    x.toUpperCase();    &#x2F;&#x2F; (method) String.toUpperCase(): string    y.toLowerCase();    &#x2F;&#x2F; (method) String.toLowerCase(): string  &#125; else &#123;    console.log(x);    &#x2F;&#x2F; (parameter) x: string | number    console.log(y);    &#x2F;&#x2F; (parameter) y: string | boolean  &#125;&#125;</code></pre><p>When we checked that x and y are both equal in the above example, TypeScript knew their types also had to be equal. Since string is the only common type that both x and y could take on, TypeScript knows that x and y must be a string in the first branch.<br><code>在上面的例子中，我们检查了 x 和 y 是否相等。TypeScript 知道 x 和 y 的类型也必须相等。因为 string 是所有 x 和 y 可能取得的类型的共同类型，所以 TypeScript 知道 x 和 y 必须是 string 的第一个分支。</code><br>Checking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a printAll function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out nulls, and TypeScript still correctly removes null from the type of strs.<br><code>检查特定的字面值（而不是变量）也可以工作。在我们提到的真值收窄中，我们写了一个 printAll 函数，它错误地处理了空字符串，而不是通过检查 null 来做。可以通过检查 null 来阻止 null，TypeScript 仍然能正确地从 strs 的类型中去除 null。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printAll(strs: string | string[] | null) &#123;  if (strs !&#x3D;&#x3D; null) &#123;    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;      for (const s of strs) &#123;        &#x2F;&#x2F; (parameter) strs: string[]        console.log(s);      &#125;    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;      console.log(strs);      &#x2F;&#x2F; (parameter) strs: string    &#125;  &#125;&#125;</code></pre><p>JavaScript’s looser equality checks with &#x3D;&#x3D; and !&#x3D; also get narrowed correctly. If you’re unfamiliar, checking whether something &#x3D;&#x3D; null actually not only checks whether it is specifically the value null - it also checks whether it’s potentially undefined. The same applies to &#x3D;&#x3D; undefined: it checks whether a value is either null or undefined.<br><code>JavaScript 的更粗糙的等值检查，比如 == 和 !=，也能正确收窄类型。如果你不了解，检查 something == null 是否不仅检查了 something 是否是特定的值 null，还检查了它是否可能是未定义的。同样的道理，检查 something == undefined 是否不仅检查了 something 是否是特定的值 undefined，还检查了它是否可能是未定义的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Container &#123;  value: number | null | undefined;&#125;function multiplyValue(container: Container, factor: number) &#123;  &#x2F;&#x2F; Remove both &#39;null&#39; and &#39;undefined&#39; from the type.  if (container.value !&#x3D; null) &#123;    console.log(container.value);    &#x2F;&#x2F; (property) Container.value: number    &#x2F;&#x2F; Now we can safely multiply &#39;container.value&#39;.    container.value *&#x3D; factor;  &#125;&#125;</code></pre><h2 id="The-in-operator-narrowing"><a href="#The-in-operator-narrowing" class="headerlink" title="The in operator narrowing"></a>The in operator narrowing</h2><p><code>in操作符缩减</code></p><p>JavaScript has an operator for determining if an object has a property with a name: the in operator. TypeScript takes this into account as a way to narrow down potential types.<br><code>JavaScript 有一个操作符用来确定对象是否有一个属性名：in 操作符。TypeScript 使用这种方式来收窄可能的类型。</code><br>For example, with the code: “value” in x. where “value” is a string literal and x is a union type. The “true” branch narrows x’s types which have either an optional or required property value, and the “false” branch narrows to types which have an optional or missing property value.<br><code>例如，在 x 中，“value” 是一个字面量字符串，x 是一个联合类型。“true” 分支收窄 x 的类型，其中有一个可选或必须的属性值，而“false” 分支收窄到有一个可选或缺少的属性值。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;type Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;function move(animal: Fish | Bird) &#123;  if (&quot;swim&quot; in animal) &#123;    return animal.swim();  &#125;  return animal.fly();&#125;</code></pre><p>To reiterate optional properties will exist in both sides for narrowing, for example a human could both swim and fly (with the right equipment) and thus should show up in both sides of the in check:<br><code>为了收窄可选属性，人类可以同时飞行和游泳（有正确的装备），因此应该在 in 检查的两侧显示。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;type Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;type Human &#x3D; &#123; swim?: () &#x3D;&gt; void; fly?: () &#x3D;&gt; void &#125;;function move(animal: Fish | Bird | Human) &#123;  if (&quot;swim&quot; in animal) &#123;    animal;    &#x2F;&#x2F; (parameter) animal: Fish | Human  &#125; else &#123;    animal;    &#x2F;&#x2F; (parameter) animal: Bird | Human  &#125;&#125;</code></pre><h2 id="instanceof-narrowing"><a href="#instanceof-narrowing" class="headerlink" title="instanceof narrowing"></a>instanceof narrowing</h2><p><code>instanceof缩减</code></p><p>JavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript x instanceof Foo checks whether the prototype chain of x contains Foo.prototype. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with new. As you might have guessed, instanceof is also a type guard, and TypeScript narrows in branches guarded by instanceofs.<br><code>JavaScript 有一个操作符用来检查一个值是否是另一个值的实例：in 操作符。更详细的说，在 JavaScript x instanceof Foo 检查 x 的原型链是否包含 Foo.prototype。但我们这里不会深入，当我们接触到类时，它们仍然可以用于构造函数。你可能会猜到，instanceof 是一个类型检查，而 TypeScript 收窄在 instanceof 检查的分支。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function logValue(x: Date | string) &#123;  if (x instanceof Date) &#123;    console.log(x.toUTCString());    &#x2F;&#x2F; (parameter) x: Date  &#125; else &#123;    console.log(x.toUpperCase());    &#x2F;&#x2F; (parameter) x: string  &#125;&#125;</code></pre><h2 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a>Assignments</h2><p><code>赋值</code></p><p>As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.<br><code>我们前面提到过，当我们给任何变量赋值时，TypeScript 会检查赋值右侧并收窄左侧适当的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;let x: string | number;x &#x3D; 1;console.log(x);let x: number;x &#x3D; &quot;goodbye!&quot;;console.log(x);let x: string;</code></pre><p>Notice that each of these assignments is valid. Even though the observed type of x changed to number after our first assignment, we were still able to assign a string to x. This is because the declared type of x - the type that x started with - is string | number, and assignability is always checked against the declared type.<br><code>注意，每一个赋值都是有效的。即使 x 的发现类型改变为 number 之后，我们仍然能够给 x 赋值一个字符串。这是因为 x 的声明类型是 string | number，而赋值时是检查赋值类型是否可以赋值给它。</code><br>If we’d assigned a boolean to x, we’d have seen an error since that wasn’t part of the declared type.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;let x: string | number;x &#x3D; 1;console.log(x);let x: number;x &#x3D; true;&#x2F;&#x2F; Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.console.log(x);let x: string | number;</code></pre><h2 id="Control-flow-analysis"><a href="#Control-flow-analysis" class="headerlink" title="Control flow analysis"></a>Control flow analysis</h2><p><code>控制流分析</code></p><p>Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in ifs, whiles, conditionals, etc. For example<br><code>在这个点之前，我们已经探索了一些基本的例子，如何收窄在特定分支中。但这里有一些比较复杂的事情，比如从每个变量上来看，如果有一个 if 语句，while 语句，条件表达式等，都可以看到收窄。例如</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;  &#125;  return padding + input;&#125;</code></pre><p>padLeft returns from within its first if block. TypeScript was able to analyze this code and see that the rest of the body (return padding + input;) is unreachable in the case where padding is a number. As a result, it was able to remove number from the type of padding (narrowing from string | number to string) for the rest of the function.<br><code>padLeft 返回在它的第一个 if 块中。TypeScript 可以分析这段代码，并且发现 rest of the body (return padding + input;) 是不可达的，在 padding 是一个 number 的情况下。因此，它可以移除 padding 的声明类型（收窄从 string | number 到 string），从而移除了 padding 的类型。</code><br>This analysis of code based on reachability is called control flow analysis, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.<br><code>这段代码基于可达性的分析是控制流分析，TypeScript 使用这个分析来收窄类型，当遇到类型检查和赋值时。当一个变量被分析时，控制流可以分裂和重新合并，并且这个变量在每个点都会有不同的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function example() &#123;  let x: string | number | boolean;  x &#x3D; Math.random() &lt; 0.5;  console.log(x);  let x: boolean;  if (Math.random() &lt; 0.5) &#123;    x &#x3D; &quot;hello&quot;;    console.log(x);    let x: string;  &#125; else &#123;    x &#x3D; 100;    console.log(x);    let x: number;  &#125;  return x;  let x: string | number;&#125;</code></pre><h2 id="Using-type-predicates"><a href="#Using-type-predicates" class="headerlink" title="Using type predicates"></a>Using type predicates</h2><p><code>使用类型断言</code></p><p>We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.<br><code>我们已经使用了现有的 JavaScript 工具来处理收窄，但有时候你想更加直接控制类型在你的代码中的变化。</code><br>To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:<br><code>定义一个用户定义的类型断言，我们只需要定义一个返回类型为类型断言的函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function isFish(pet: Fish | Bird): pet is Fish &#123;  return (pet as Fish).swim !&#x3D;&#x3D; undefined;&#125;</code></pre><p>pet is Fish is our type predicate in this example. A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.<br><code>pet is Fish 是我们的类型断言。一个断言的格式是 parameterName is Type，其中 parameterName 必须是当前函数签名中的一个参数名。</code><br>Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.<br><code>任何时候，isFish 被调用，TypeScript 将会收窄这个变量的类型，如果原始类型是兼容的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Both calls to &#39;swim&#39; and &#39;fly&#39; are now okay.let pet &#x3D; getSmallPet();if (isFish(pet)) &#123;  pet.swim();&#125; else &#123;  pet.fly();&#125;</code></pre><p>Notice that TypeScript not only knows that pet is a Fish in the if branch; it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.<br><code>TypeScript 知道 pet 是一个 Fish 在 if 分支；它也知道在 else 分支，你没有一个 Fish，所以你必须有一个 Bird。</code><br>You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:<br><code>你可以使用 isFish 来过滤 Fish | Bird 数组，并获得一个 Fish 数组。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];const underWater1: Fish[] &#x3D; zoo.filter(isFish);&#x2F;&#x2F; or, equivalentlyconst underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];&#x2F;&#x2F; The predicate may need repeating for more complex examplesconst underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;  return isFish(pet);&#125;);</code></pre><p>In addition, classes can use this is Type to narrow their type.We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.<br><code>类可以使用 is Type 来收窄类型。我们已经使用了现有的 JavaScript 工具来处理收窄，但有时候你想更加直接控制类型在你的代码中的变化。</code><br>To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:<br><code>定义一个用户定义的类型断言，我们只需要定义一个返回类型为类型断言的函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function isFish(pet: Fish | Bird): pet is Fish &#123;  return (pet as Fish).swim !&#x3D;&#x3D; undefined;&#125;</code></pre><p>pet is Fish is our type predicate in this example. A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.<br><code>pet is Fish 是我们的类型断言。一个断言的格式是 parameterName is Type，其中 parameterName 必须是当前函数签名中的一个参数名。</code><br>Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.<br><code>任何时候，isFish 被调用，TypeScript 将会收窄这个变量的类型，如果原始类型是兼容的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Both calls to &#39;swim&#39; and &#39;fly&#39; are now okay.let pet &#x3D; getSmallPet();if (isFish(pet)) &#123;  pet.swim();&#125; else &#123;  pet.fly();&#125;</code></pre><p>Notice that TypeScript not only knows that pet is a Fish in the if branch; it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.<br><code>TypeScript 知道 pet 是一个 Fish 在 if 分支；它也知道在 else 分支，你没有一个 Fish，所以你必须有一个 Bird。</code><br>You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:<br><code>你可以使用 isFish 来过滤 Fish | Bird 数组，并获得一个 Fish 数组。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];const underWater1: Fish[] &#x3D; zoo.filter(isFish);&#x2F;&#x2F; or, equivalentlyconst underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];&#x2F;&#x2F; The predicate may need repeating for more complex examplesconst underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;  return isFish(pet);&#125;);</code></pre><p>In addition, classes can use this is Type to narrow their type.<br><code>除此之外，类中可以使用this is Type来缩减类型。</code></p><h2 id="Discriminated-unions"><a href="#Discriminated-unions" class="headerlink" title="Discriminated unions"></a>Discriminated unions</h2><p><code>分区联合</code></p><p>Most of the examples we’ve looked at so far have focused around narrowing single variables with simple types like string, boolean, and number. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.<br>For some motivation, let’s imagine we’re trying to encode shapes like circles and squares.<br>Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called kind to tell which shape we’re dealing with. Here’s a first attempt at defining Shape.<br><code>让我们试想有这样一个处理 Shape （比如 Circles、Squares ）的函数，Circles 会记录它的半径属性，Squares 会记录它的边长属性，我们使用一个 kind 字段来区分判断处理的是 Circles 还是 Squares，这是初始的 Shape 定义：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Shape &#123;  kind: &quot;circle&quot; | &quot;square&quot;;  radius?: number;  sideLength?: number;&#125;</code></pre><p>Notice we’re using a union of string literal types: “circle” and “square” to tell us whether we should treat the shape as a circle or square respectively. By using “circle” | “square” instead of string, we can avoid misspelling issues.<br><code>我们使用一个字符串字面量类型的联合：&quot;circle&quot; 和 &quot;square&quot;，来告诉我们是处理一个圆形还是一个正方形。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function handleShape(shape: Shape) &#123;  &#x2F;&#x2F; oops!  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;rect&quot;) &#123;    &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;circle&quot; | &quot;square&quot;&#39; and &#39;&quot;rect&quot;&#39; have no overlap.    &#x2F;&#x2F; 此条件将总是返回 &#39;false&#39;，因为类型 &#39;&quot;circle&quot; | &quot;square&quot;&#39; 和 &#39;&quot;rect&quot;&#39; 没有重叠。    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>We can write a getArea function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.<br><code>我们可以写一个 getArea 函数，用来处理圆形。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getArea(shape: Shape) &#123;  return Math.PI * shape.radius ** 2;  &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.&#125;</code></pre><p>Under strictNullChecks that gives us an error - which is appropriate since radius might not be defined. But what if we perform the appropriate checks on the kind property?<br><code>在严格的 null 检查下，我们会得到一个错误 - 因为 radius 可能不存在。但是如果我们对 kind 属性进行正确的检查，就不会出现错误。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getArea(shape: Shape) &#123;  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI * shape.radius ** 2;    &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.  &#125;&#125;</code></pre><p>Hmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a ! after shape.radius) to say that radius is definitely present.<br><code>哇，TypeScript 还不知道怎么办。我们已经碰到了一个点，我们知道更多的信息了，比类型检查器更多。我们可以尝试使用一个非空断言（shape.radius 后面加一个 !）来告诉 TypeScript radius 是一定存在的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getArea(shape: Shape) &#123;  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI * shape.radius! ** 2;  &#125;&#125;</code></pre><p>But this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (!) to convince it that shape.radius was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of strictNullChecks we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.<br><code>但这不太好。我们必须向类型检查器发出一些非空断言（!）来告诉它 shape.radius 存在，但这些断言是错误的，如果我们开始移动代码。同时，在非严格的 null 检查下，我们还是可以随意访问这些字段（因为可选属性是被假定为总是存在的，当读取它们时）。我们可以很好地做。</code><br>The problem with this encoding of Shape is that the type-checker doesn’t have any way to know whether or not radius or sideLength are present based on the kind property. We need to communicate what we know to the type checker. With that in mind, let’s take another swing at defining Shape.<br><code>这个 Shape 的编码有点问题，因为类型检查器没有任何方式可以告诉我们 radius 或 sideLength 存在。我们需要向类型检查器通报我们知道的信息。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Circle &#123;  kind: &quot;circle&quot;;  radius: number;&#125;interface Square &#123;  kind: &quot;square&quot;;  sideLength: number;&#125;type Shape &#x3D; Circle | Square;</code></pre><p>Here, we’ve properly separated Shape out into two types with different values for the kind property, but radius and sideLength are declared as required properties in their respective types.<br><code>这里，我们已经将 Shape 分成了两种类型，其中 kind 属性的值不同，radius 和 sideLength 在它们的类型中声明为必须的属性。</code><br>Let’s see what happens here when we try to access the radius of a Shape.<br><code>我们看看这里如何访问 Shape 的 radius。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getArea(shape: Shape) &#123;  return Math.PI * shape.radius ** 2;  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Shape&#39;.  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Square&#39;.&#125;</code></pre><p>Like with our first definition of Shape, this is still an error. When radius was optional, we got an error (with strictNullChecks enabled) because TypeScript couldn’t tell whether the property was present. Now that Shape is a union, TypeScript is telling us that shape might be a Square, and Squares don’t have radius defined on them! Both interpretations are correct, but only the union encoding of Shape will cause an error regardless of how strictNullChecks is configured.<br><code>与我们第一次定义 Shape 的例子相同，这还是一个错误。当 radius 是可选的时，我们得到一个错误（与 strictNullChecks 启用时），因为 TypeScript 不能告诉我们这个属性是否存在。</code><br>But what if we tried checking the kind property again?<br><code>如果我们再次检查 kind 属性？</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getArea(shape: Shape) &#123;  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI * shape.radius ** 2;    &#x2F;&#x2F; (parameter) shape: Circle  &#125;&#125;</code></pre><p>That got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a discriminated union, and can narrow out the members of the union.<br><code>这消除了错误！当一个联合里的每个类型都包含常量类型的共同属性，TypeScript 认为这是一个分区联合，可以缩小联合的成员。</code><br>In this case, kind was that common property (which is what’s considered a discriminant property of Shape). Checking whether the kind property was “circle” got rid of every type in Shape that didn’t have a kind property with the type “circle”. That narrowed shape down to the type Circle.<br><code>在这种情况下，kind 属性是那个被认为是 Shape 的分区属性（这是被认为是 Shape 的分区属性）。检查 kind 属性是否是 &quot;circle&quot; 可以消除掉没有 kind 属性的类型。这缩小了 shape 到 Circle 类型。</code><br>The same checking works with switch statements as well. Now we can try to write our complete getArea without any pesky ! non-null assertions.<br><code>在这里，我们可以尝试写我们的完整 getArea 没有任何非空断言！</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    &#x2F;&#x2F; (parameter) shape: Circle    case &quot;square&quot;:      return shape.sideLength ** 2;    &#x2F;&#x2F; (parameter) shape: Square  &#125;&#125;</code></pre><p>The important thing here was the encoding of Shape. Communicating the right information to TypeScript - that Circle and Square were really two separate types with specific kind fields - was crucial. Doing that let us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our switch statement.<br><code>这里有重要的事情，需要通过编码 Shape 来告诉 TypeScript，Circle 和 Square 是真正的两个类型，具有特定的 kind 属性。这样就可以写出类型安全的 TypeScript 代码，看起来和 JavaScript 一样。</code><br>As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a switch statement.<br><code>作为一个例子，试着玩一下上面的例子，并删除一些 return 关键字。你会发现，类型检查可以帮助避免在意外的情况下跳过不同的分支。</code><br>Discriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client&#x2F;server communication), or encoding mutations in a state management framework.<br><code>分区联合是用来表示任何类型的消息协议，比如在网络上发送消息（客户端/服务器通信），或者编码状态管理框架的变化。</code></p><h2 id="The-never-type"><a href="#The-never-type" class="headerlink" title="The never type"></a>The never type</h2><p><code>never类型</code></p><p>When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist.<br><code>在缩小联合的时候，你可以将联合的可能性降低到没有任何可能性的状态。在这种情况下，TypeScript 会使用 never 类型来表示不应该存在的状态。</code></p><h2 id="Exhaustiveness-checking"><a href="#Exhaustiveness-checking" class="headerlink" title="Exhaustiveness checking"></a>Exhaustiveness checking</h2><p><code>推断性检查</code></p><p>The never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement.<br><code>never类型可以赋值给所有类型，但是不可以赋值给 never（除了 never 本身）。这意味着你可以使用缩小，并且可以在 switch 语句中使用推断性检查。</code><br>For example, adding a default to our getArea function which tries to assign the shape to never will raise when every possible case has not been handled.<br><code>添加一个默认到 getArea 函数中，这样就会抛出异常，因为没有处理所有可能性。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Shape &#x3D; Circle | Square;function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    case &quot;square&quot;:      return shape.sideLength ** 2;    default:      const _exhaustiveCheck: never &#x3D; shape;      return _exhaustiveCheck;  &#125;&#125;</code></pre><p>Adding a new member to the Shape union, will cause a TypeScript error:<br><code>添加一个新的成员到 Shape 联合，会导致一个 TypeScript 错误：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Triangle &#123;  kind: &quot;triangle&quot;;  sideLength: number;&#125;type Shape &#x3D; Circle | Square | Triangle;function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    case &quot;square&quot;:      return shape.sideLength ** 2;    default:      const _exhaustiveCheck: never &#x3D; shape;      &#x2F;&#x2F; Type &#39;Triangle&#39; is not assignable to type &#39;never&#39;.      &#x2F;&#x2F; 类型 &#39;Triangle&#39; 不能赋值给类型 &#39;never&#39;。      return _exhaustiveCheck;  &#125;&#125;</code></pre><p>因为 TypeScript 的收窄特性，执行到 default 的时候，类型被收窄为 Triangle，但因为任何类型都不能赋值给 never 类型，这就会产生一个编译错误。通过这种方式，你就可以确保 getArea 函数总是穷尽了所有 shape 的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Typescript 常见类型</title>
      <link href="//post/2022-06-08ts-Everyday%20Types.html"/>
      <url>//post/2022-06-08ts-Everyday%20Types.html</url>
      
        <content type="html"><![CDATA[<h2 id="Everyday-Types"><a href="#Everyday-Types" class="headerlink" title="Everyday Types"></a>Everyday Types</h2><p><code>常见类型</code><br>In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.<br><code>在这一章中，我们将探讨一些 JavaScript 代码中的常见类型，并在 TypeScript 中说明这些类型的相应方式。这并不是一个完整的列表，而且未来的章节将说明更多的方法来命名和使用其他类型。</code><br>Types can also appear in many more places than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.<br><code>类型也可以出现在类型注释之外。我们学习类型本身时，我们也会学习到哪些地方可以引用这些类型来形成新的构造。</code><br>We’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.<br><code>我们将开始介绍最基本的 JavaScript 或 TypeScript 代码中可能遇到的常见类型。这些类型将作为更复杂的类型的基础建筑块。</code></p><h2 id="The-primitives-string-number-and-boolean"><a href="#The-primitives-string-number-and-boolean" class="headerlink" title="The primitives: string,number, and boolean"></a>The primitives: string,number, and boolean</h2><p>JavaScript has three very commonly used primitives: string, number, and boolean. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript typeof operator on a value of those types:<br><code>JavaScript 有三个非常常见的原始类型：字符串，数字和布尔值。这三个类型在 TypeScript 中对应。如果你可以接受，这三个类型的名字都是相同的：</code></p><ul><li>string represents string values like “Hello, world”<br><code>string 表示字符串，比如 &quot;Hello, world&quot;</code></li><li>number is for numbers like 42. JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply number<br><code>number 是数字，比如 42。JavaScript 不支持整数，所以没有相应的 int 或 float - 所有都是 number</code></li><li>boolean is for the two values true and false<br><code>boolean 是布尔值，比如 true 和 false</code></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>The type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.<br><code>类型名 String ，Number 和 Boolean （首字母大写）也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用 string ，number 或者 boolean 。</code></p></div><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><code>数组</code><br>To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g. string[] is an array of strings, and so on). You may also see this written as Array<number>, which means the same thing. We’ll learn more about the syntax T<U> when we cover generics.<br><code>指定数组的类型，可以使用 number[] 的语法，这种语法可以用于任何类型（比如 string[] 是一个字符串数组，而 so on）。你也可以看到这种写法 Array&lt;number&gt;，它表示相同的意思。我们将在接下来的章节中学习更多关于语法 T&lt;U&gt; 的详细信息。</code><br>:::warning<br>Note that [number] is a different thing; refer to the section on Tuples.<br><code>[number] 不是同一个东西，请参见关于元组的章节。</code><br>:::</p><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.<br><code>TypeScript 也有一个特殊的类型 any，可以用于指定你不想要某个值导致类型检查错误的情况。</code><br>When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:<br><code>当值是 any 类型时，你可以访问它的任何属性（这将导致它的类型为 any ），调用它，将它赋值给（或从）任何类型的值，或者其他任何合法的语法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let obj: any &#x3D; &#123; x: 0 &#125;;&#x2F;&#x2F; None of the following lines of code will throw compiler errors.&#x2F;&#x2F; 以下代码行都不会引发编译器错误。&#x2F;&#x2F; Using &#96;any&#96; disables all further type checking, and it is assumed&#x2F;&#x2F; 使用“any”将禁用所有进一步的类型检查，并且假定&#x2F;&#x2F; you know the environment better than TypeScript.&#x2F;&#x2F; 你知道环境优于TypeScript。obj.foo();obj();obj.bar &#x3D; 100;obj &#x3D; &quot;hello&quot;;const n: number &#x3D; obj;</code></pre><p>The any type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.<br><code>any 类型是用于指定你不想要写出一个长的类型来说明 TypeScript 对某一行代码是合法的。</code></p><h2 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h2><p>When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any.<br><code>当你不指定类型，并且 TypeScript 不能从上下文中推断出来时，编译器默认使用 any。</code><br>You usually want to avoid this, though, because any isn’t type-checked. Use the compiler flag noImplicitAny to flag any implicit any as an error.<br><code>你通常想避免这种情况，但是 any 不会被类型检查。使用编译器标记 noImplicitAny 来标记 any 为错误。</code></p><h2 id="Type-Annotations-on-Variables"><a href="#Type-Annotations-on-Variables" class="headerlink" title="Type Annotations on Variables"></a>Type Annotations on Variables</h2><p><code>变量上的类型注解</code></p><p>When you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:<br><code>使用 const ，var 或 let 声明变量时，可以添加一个类型注解来显式指定变量的类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let myName: string &#x3D; &quot;Alice&quot;;</code></pre><p>TypeScript doesn’t use “types on the left”-style declarations like int x &#x3D; 0; Type annotations will always go after the thing being typed.<br><code>TypeScript 不使用“左边的类型”的声明方式，如 int x = 0; 类型注解将总是在被类型的东西后面。</code><br>In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code. For example, the type of a variable is inferred based on the type of its initializer:<br><code>在大多数情况下，不需要这样做。在每个变量的初始值的类型可以被自动推断出来。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; No type annotation needed -- &#39;myName&#39; inferred as type &#39;string&#39;&#x2F;&#x2F; 没有类型注解需要 -- &#39;myName&#39; 类型被推断为 &#39;string&#39;let myName &#x3D; &quot;Alice&quot;;</code></pre><p>For the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.<br><code>大多数情况下，你不需要显式地指定类型注解。如果你是新手，尝试使用比你认为更少的类型注解，你可能会意外地发现 TypeScript 可以完全理解你的代码。</code></p><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><code>函数</code></p><p>Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.<br><code>函数是 JavaScript 中传递数据的主要方式。TypeScript 允许你指定函数的输入和输出值的类型。</code></p><h2 id="Parameter-Type-Annotations"><a href="#Parameter-Type-Annotations" class="headerlink" title="Parameter Type Annotations"></a>Parameter Type Annotations</h2><p><code>参数上的类型注解</code></p><p>When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:<br><code>声明函数时，可以在每个参数后面添加类型注解来声明函数接受哪些类型的参数。参数类型注解在参数名后面：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Parameter type annotationfunction greet(name: string) &#123;  console.log(&quot;Hello, &quot; + name.toUpperCase() + &quot;!!&quot;);&#125;</code></pre><p>When a parameter has a type annotation, arguments to that function will be checked:<br><code>当参数有类型注解时，函数的参数会被检查：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Would be a runtime error if executed!&#x2F;&#x2F; 如果执行，就会产生一个运行时错误！greet(42);&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.&#x2F;&#x2F; 参数类型 &#39;number&#39; 不能赋值给参数类型 &#39;string&#39;。</code></pre><p>Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.<br><code>即使你没有类型注解，TypeScript 也会检查你传入的参数是否正确。</code></p><h2 id="Return-Type-Annotations"><a href="#Return-Type-Annotations" class="headerlink" title="Return Type Annotations"></a>Return Type Annotations</h2><p><code>返回值上的类型注解</code></p><p>You can also add return type annotations. Return type annotations appear after the parameter list:<br><code>你也可以添加返回值类型注解。返回值类型注解出现在参数列表后面：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getFavoriteNumber(): number &#123;  return 26;&#125;</code></pre><p>Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.<br><code>和变量类型注解一样，你通常不需要返回值类型注解，因为 TypeScript 将基于返回语句的类型推断出来。上面的示例示例不会改变任何东西。一些代码库将显式指定一个返回值类型，以防止意外的改变，或者只是为了个人偏好。</code></p><h2 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h2><p><code>匿名函数</code></p><p>Anonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.<br><code>匿名函数和函数声明一样。当函数出现在 TypeScript 可以确定它会如何被调用时，函数的参数会被自动指定类型。</code><br>Here’s an example:<br><code>这里有一个示例：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; No type annotations here, but TypeScript can spot the bug&#x2F;&#x2F; 没有类型注解，但 TypeScript 可以检测到错误const names &#x3D; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;];&#x2F;&#x2F; Contextual typing for function&#x2F;&#x2F; 函数上下文类型names.forEach(function (s) &#123;  console.log(s.toUppercase());  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?  &#x2F;&#x2F; 属性 &#39;toUppercase&#39; 不存在于类型 &#39;string&#39; 中。你可能想用 &#39;toUpperCase&#39; 吗？&#125;);&#x2F;&#x2F; Contextual typing also applies to arrow functions&#x2F;&#x2F; 箭头函数上下文类型names.forEach((s) &#x3D;&gt; &#123;  console.log(s.toUppercase());  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?  &#x2F;&#x2F; 属性 &#39;toUppercase&#39; 不存在于类型 &#39;string&#39; 中。你可能想用 &#39;toUpperCase&#39; 吗？&#125;);</code></pre><p>Even though the parameter s didn’t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have.<br><code>即使参数 s 没有类型注解，TypeScript 会使用 forEach 函数的类型，以及推断的数组类型，来确定 s 的类型。</code><br>This process is called contextual typing because the context that the function occurred within informs what type it should have.<br><code>这个过程是上下文类型的，因为函数发生在哪里的上下文，就会确定它应该有哪种类型。</code><br>Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.<br><code>与推断规则相似，你不需要显式学习这种过程，但是了解这种过程可以帮助你发现，当值不需要类型注解时，它会发生什么。之后，我们会看到更多的例子，如何值的上下文可以影响它的类型。</code></p><h2 id="Object-Types"><a href="#Object-Types" class="headerlink" title="Object Types"></a>Object Types</h2><p><code>对象类型</code></p><p>Apart from primitives, the most common sort of type you’ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.<br><code>除了原始类型，最常见的类型是对象类型。这指的是任何 JavaScript 值，它的属性都是很多的！为了定义对象类型，我们只需要列出它的属性和它们的类型。</code><br>For example, here’s a function that takes a point-like object:<br><code>这里有一个接受点类型对象的函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; The parameter&#39;s type annotation is an object typefunction printCoord(pt: &#123; x: number; y: number &#125;) &#123;  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);&#125;printCoord(&#123; x: 3, y: 7 &#125;);</code></pre><p>Here, we annotated the parameter with a type with two properties - x and y - which are both of type number. You can use , or ; to separate the properties, and the last separator is optional either way.<br><code>这里，我们使用了一个有两个属性的类型，x 和 y，它们都是 number 类型。你可以使用 , 或 ; 分隔属性，最后的分隔符可以是任意的。</code><br>The type part of each property is also optional. If you don’t specify a type, it will be assumed to be any.<br><code>每个属性的类型部分都是可选的。如果你没有指定类型，它会被认为是 any 类型。</code></p><h2 id="Optional-Properties"><a href="#Optional-Properties" class="headerlink" title="Optional Properties"></a>Optional Properties</h2><p><code>可选属性</code></p><p>Object types can also specify that some or all of their properties are optional. To do this, add a ? after the property name:<br><code>对象类型可以指定一些或全部的属性是可选的。要做到这一点，只需要在属性名后面加上 ? 就可以了。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printName(obj: &#123; first: string; last?: string &#125;) &#123;  &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; Both OKprintName(&#123; first: &quot;Bob&quot; &#125;);printName(&#123; first: &quot;Alice&quot;, last: &quot;Alisson&quot; &#125;);</code></pre><p>In JavaScript, if you access a property that doesn’t exist, you’ll get the value undefined rather than a runtime error. Because of this, when you read from an optional property, you’ll have to check for undefined before using it.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printName(obj: &#123; first: string; last?: string &#125;) &#123;  &#x2F;&#x2F; Error - might crash if &#39;obj.last&#39; wasn&#39;t provided!  console.log(obj.last.toUpperCase());Object is possibly &#39;undefined&#39;.  if (obj.last !&#x3D;&#x3D; undefined) &#123;    &#x2F;&#x2F; OK    console.log(obj.last.toUpperCase());  &#125;  &#x2F;&#x2F; A safe alternative using modern JavaScript syntax:  console.log(obj.last?.toUpperCase());&#125;</code></pre><h2 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h2><p><code>联合类型</code></p><p>TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start combining them in interesting ways.</p><h2 id="Defining-a-Union-Type"><a href="#Defining-a-Union-Type" class="headerlink" title="Defining a Union Type"></a>Defining a Union Type</h2><p><code>定义一个联合类型</code></p><p>The first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union’s members.</p><p>Let’s write a function that can operate on strings or numbers:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printId(id: number | string) &#123;  console.log(&quot;Your ID is: &quot; + id);&#125;&#x2F;&#x2F; OKprintId(101);&#x2F;&#x2F; OKprintId(&quot;202&quot;);&#x2F;&#x2F; ErrorprintId(&#123; myID: 22342 &#125;);&#x2F;&#x2F; Argument of type &#39;&#123; myID: number; &#125;&#39; is not assignable to parameter of type &#39;string | number&#39;.</code></pre><h2 id="Working-with-Union-Types"><a href="#Working-with-Union-Types" class="headerlink" title="Working with Union Types"></a>Working with Union Types</h2><p><code>使用联合类型</code></p><p>It’s easy to provide a value matching a union type - simply provide a type matching any of the union’s members. If you have a value of a union type, how do you work with it?</p><p>TypeScript will only allow an operation if it is valid for every member of the union. For example, if you have the union string | number, you can’t use methods that are only available on string:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printId(id: number | string) &#123;  console.log(id.toUpperCase());Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.  Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.&#125;</code></pre><p>The solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.</p><p>For example, TypeScript knows that only a string value will have a typeof value “string”:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printId(id: number | string) &#123;  if (typeof id &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    &#x2F;&#x2F; In this branch, id is of type &#39;string&#39;    console.log(id.toUpperCase());  &#125; else &#123;    &#x2F;&#x2F; Here, id is of type &#39;number&#39;    console.log(id);  &#125;&#125;</code></pre><p>Another example is to use a function like Array.isArray:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function welcomePeople(x: string[] | string) &#123;  if (Array.isArray(x)) &#123;    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string[]&#39;    console.log(&quot;Hello, &quot; + x.join(&quot; and &quot;));  &#125; else &#123;    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string&#39;    console.log(&quot;Welcome lone traveler &quot; + x);  &#125;&#125;</code></pre><p>Notice that in the else branch, we don’t need to do anything special - if x wasn’t a string[], then it must have been a string.</p><p>Sometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a slice method. If every member in a union has a property in common, you can use that property without narrowing:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Return type is inferred as number[] | stringfunction getFirstThree(x: number[] | string) &#123;  return x.slice(0, 3);&#125;</code></pre><p>It might be confusing that a union of types appears to have the intersection of those types’ properties. This is not an accident - the name union comes from type theory. The union number | string is composed by taking the union of the values from each type. Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat.</p><h2 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h2><p><code>类型别名</code></p><p>We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.</p><p>A type alias is exactly that - a name for any type. The syntax for a type alias is:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Point &#x3D; &#123;  x: number;  y: number;&#125;;&#x2F;&#x2F; Exactly the same as the earlier examplefunction printCoord(pt: Point) &#123;  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);&#125;printCoord(&#123; x: 100, y: 100 &#125;);</code></pre><p>You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type ID &#x3D; number | string;</code></pre><p>Note that aliases are only aliases - you cannot use type aliases to create different&#x2F;distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type UserInputSanitizedString &#x3D; string;function sanitizeInput(str: string): UserInputSanitizedString &#123;  return sanitize(str);&#125;&#x2F;&#x2F; Create a sanitized inputlet userInput &#x3D; sanitizeInput(getInput());&#x2F;&#x2F; Can still be re-assigned with a string thoughuserInput &#x3D; &quot;new input&quot;;</code></pre><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p><code>接口</code></p><p>An interface declaration is another way to name an object type:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Point &#123;  x: number;  y: number;&#125;function printCoord(pt: Point) &#123;  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);&#125;printCoord(&#123; x: 100, y: 100 &#125;);</code></pre><p>Just like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the structure of the value we passed to printCoord - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a structurally typed type system.</p><h2 id="Differences-Between-Type-Aliases-and-Interfaces"><a href="#Differences-Between-Type-Aliases-and-Interfaces" class="headerlink" title="Differences Between Type Aliases and Interfaces"></a>Differences Between Type Aliases and Interfaces</h2><p><code>类型别名和接口的区别</code></p><p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p><p><strong>Interface</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Extending an interfaceinterface Animal &#123;  name: string;&#125;interface Bear extends Animal &#123;  honey: boolean;&#125;const bear &#x3D; getBear();bear.name;bear.honey;</code></pre><p><strong>Type</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Extending a type via intersectionstype Animal &#x3D; &#123;  name: string;&#125;;type Bear &#x3D; Animal &amp; &#123;  honey: boolean;&#125;;const bear &#x3D; getBear();bear.name;bear.honey;</code></pre><p>Adding new fields to an existing interface</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Window &#123;  title: string;&#125;interface Window &#123;  ts: TypeScriptAPI;&#125;const src &#x3D; &#39;const a &#x3D; &quot;Hello World&quot;&#39;;window.ts.transpileModule(src, &#123;&#125;);</code></pre><p>A type cannot be changed after being created</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Window &#x3D; &#123;  title: string;&#125;;type Window &#x3D; &#123;  ts: TypeScriptAPI;&#125;;&#x2F;&#x2F; Error: Duplicate identifier &#39;Window&#39;.</code></pre><p>You’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.</p><ul><li>Prior to TypeScript version 4.2, type alias names may appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.</li><li>Type aliases may not participate in declaration merging, but interfaces can.</li><li>Interfaces may only be used to declare the shapes of objects, not rename primitives.</li><li>Interface names will always appear in their original form in error messages, but only when they are used by name.</li></ul><p>For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type.</p><h2 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h2><p><code>类型断言</code></p><p>Sometimes you will have information about the type of a value that TypeScript can’t know about.</p><p>For example, if you’re using document.getElementById, TypeScript only knows that this will return some kind of HTMLElement, but you might know that your page will always have an HTMLCanvasElement with a given ID.</p><p>In this situation, you can use a type assertion to specify a more specific type:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const myCanvas &#x3D; document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;</code></pre><p>Like a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.</p><p>You can also use the angle-bracket syntax (except if the code is in a .tsx file), which is equivalent:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const myCanvas &#x3D; &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);</code></pre><p>Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or null generated if the type assertion is wrong.</p><p>TypeScript only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents “impossible” coercions like:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const x &#x3D; &quot;hello&quot; as number;&#x2F;&#x2F; Conversion of type &#39;string&#39; to type &#39;number&#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#39;unknown&#39; first.</code></pre><p>Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown, which we’ll introduce later), then to the desired type:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const a &#x3D; expr as any as T;</code></pre><h2 id="Literal-Types"><a href="#Literal-Types" class="headerlink" title="Literal Types"></a>Literal Types</h2><p><code>字面量类型</code></p><p>In addition to the general types string and number, we can refer to specific strings and numbers in type positions.</p><p>One way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both var and let allow for changing what is held inside the variable, and const does not. This is reflected in how TypeScript creates types for literals.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let changingString &#x3D; &quot;Hello World&quot;;changingString &#x3D; &quot;Olá Mundo&quot;;&#x2F;&#x2F; Because &#96;changingString&#96; can represent any possible string, that&#x2F;&#x2F; is how TypeScript describes it in the type systemchangingString;let changingString: string;const constantString &#x3D; &quot;Hello World&quot;;&#x2F;&#x2F; Because &#96;constantString&#96; can only represent 1 possible string, it&#x2F;&#x2F; has a literal type representationconstantString;const constantString: &quot;Hello World&quot;;</code></pre><p>By themselves, literal types aren’t very valuable:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x: &quot;hello&quot; &#x3D; &quot;hello&quot;;&#x2F;&#x2F; OKx &#x3D; &quot;hello&quot;;&#x2F;&#x2F; ...x &#x3D; &quot;howdy&quot;;&#x2F;&#x2F; Type &#39;&quot;howdy&quot;&#39; is not assignable to type &#39;&quot;hello&quot;&#39;.</code></pre><p>It’s not much use to have a variable that can only have one value!</p><p>But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;  &#x2F;&#x2F; ...&#125;printText(&quot;Hello, world&quot;, &quot;left&quot;);printText(&quot;G&#39;day, mate&quot;, &quot;centre&quot;);Argument of type &#39;&quot;centre&quot;&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot;&#39;.</code></pre><p>Numeric literal types work the same way:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function compare(a: string, b: string): -1 | 0 | 1 &#123;  return a &#x3D;&#x3D;&#x3D; b ? 0 : a &gt; b ? 1 : -1;&#125;</code></pre><p>Of course, you can combine these with non-literal types:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Options &#123;  width: number;&#125;function configure(x: Options | &quot;auto&quot;) &#123;  &#x2F;&#x2F; ...&#125;configure(&#123; width: 100 &#125;);configure(&quot;auto&quot;);configure(&quot;automatic&quot;);Argument of type &#39;&quot;automatic&quot;&#39; is not assignable to parameter of type &#39;Options | &quot;auto&quot;&#39;.</code></pre><p>There’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types true and false. The type boolean itself is actually just an alias for the union true | false.</p><h2 id="Literal-Inference"><a href="#Literal-Inference" class="headerlink" title="Literal Inference"></a>Literal Inference</h2><p><code>字面量推断</code><br>When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const obj &#x3D; &#123; counter: 0 &#125;;if (someCondition) &#123;  obj.counter &#x3D; 1;&#125;</code></pre><p>TypeScript doesn’t assume the assignment of 1 to a field which previously had 0 is an error. Another way of saying this is that obj.counter must have the type number, not 0, because types are used to determine both reading and writing behavior.</p><p>The same applies to strings:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125;;handleRequest(req.url, req.method);Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;GET&quot; | &quot;POST&quot;&#39;.</code></pre><p>In the above example req.method is inferred to be string, not “GET”. Because code can be evaluated between the creation of req and the call of handleRequest which could assign a new string like “GUESS” to req.method, TypeScript considers this code to have an error.</p><p>There are two ways to work around this.</p><p>You can change the inference by adding a type assertion in either location:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Change 1:const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; &#125;;&#x2F;&#x2F; Change 2handleRequest(req.url, req.method as &quot;GET&quot;);</code></pre><p>Change 1 means “I intend for req.method to always have the literal type “GET””, preventing the possible assignment of “GUESS” to that field after. Change 2 means “I know for other reasons that req.method has the value “GET”“.</p><p>You can use as const to convert the entire object to be type literals:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125; as const;handleRequest(req.url, req.method);</code></pre><p>The as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number.</p><h2 id="null-and-undefined"><a href="#null-and-undefined" class="headerlink" title="null and undefined"></a>null and undefined</h2><p><code>null和undefined</code></p><p>JavaScript has two primitive values used to signal absent or uninitialized value: null and undefined.</p><p>TypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on.</p><h2 id="strictNullChecks-off"><a href="#strictNullChecks-off" class="headerlink" title="strictNullChecks off"></a>strictNullChecks off</h2><p><code>strictNullChecks关闭</code></p><p>With strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn strictNullChecks on if it’s practical to do so in their codebase.</p><h2 id="strictNullChecks-on"><a href="#strictNullChecks-on" class="headerlink" title="strictNullChecks on"></a>strictNullChecks on</h2><p><code>strictNullChecks开启</code></p><p>With strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(x: string | null) &#123;  if (x &#x3D;&#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; do nothing  &#125; else &#123;    console.log(&quot;Hello, &quot; + x.toUpperCase());  &#125;&#125;</code></pre><h2 id="Non-null-Assertion-Operator-Postfix"><a href="#Non-null-Assertion-Operator-Postfix" class="headerlink" title="Non-null Assertion Operator (Postfix !)"></a>Non-null Assertion Operator (Postfix !)</h2><p><code>非空断言运算符</code></p><p>TypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking. Writing ! after any expression is effectively a type assertion that the value isn’t null or undefined:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function liveDangerously(x?: number | null) &#123;  &#x2F;&#x2F; No error  console.log(x!.toFixed());&#125;</code></pre><p>Just like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use ! when you know that the value can’t be null or undefined.</p><h2 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h2><p><code>枚举</code></p><p>Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the Enum reference page.</p><h2 id="Less-Common-Primitives"><a href="#Less-Common-Primitives" class="headerlink" title="Less Common Primitives"></a>Less Common Primitives</h2><p><code>更少常见的原始类型</code><br>It’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.</p><p>bigint<br>From ES2020 onwards, there is a primitive in JavaScript used for very large integers, BigInt:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Creating a bigint via the BigInt functionconst oneHundred: bigint &#x3D; BigInt(100);&#x2F;&#x2F; Creating a BigInt via the literal syntaxconst anotherHundred: bigint &#x3D; 100n;</code></pre><p>You can learn more about BigInt in the TypeScript 3.2 release notes.</p><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>There is a primitive in JavaScript used to create a globally unique reference via the function Symbol():</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const firstName &#x3D; Symbol(&quot;name&quot;);const secondName &#x3D; Symbol(&quot;name&quot;);if (firstName &#x3D;&#x3D;&#x3D; secondName) &#123;This condition will always return &#39;false&#39; since the types &#39;typeof firstName&#39; and &#39;typeof secondName&#39; have no overlap.  &#x2F;&#x2F; Can&#39;t ever happen&#125;</code></pre><p>You can learn more about them in Symbols reference page.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean">Typescript 常见类型</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Typescript 基础</title>
      <link href="//post/2022-06-07ts-basics.html"/>
      <url>//post/2022-06-07ts-basics.html</url>
      
        <content type="html"><![CDATA[<h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><p>Welcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the ‘Getting Started’ guides<br><code>欢迎来到 TypeScript 手册的第一页。如果您是第一次使用 TypeScript - 您可能想要开始一个&#39;Getting Started&#39;指南</code></p><p>Each and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named message.<br><code>每个和所有的值在 JavaScript 中都有一组行为可以观察从运行不同的操作。这会感觉很抽象，但是作为一个快速的例子，考虑一些我们可能运行的操作的变量名称 message。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Accessing the property &#39;toLowerCase&#39;&#x2F;&#x2F; on &#39;message&#39; and then calling itmessage.toLowerCase();&#x2F;&#x2F; Calling &#39;message&#39;message();</code></pre><p>If we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it. The second one tries to call message directly.<br><code>如果 我们将这个分解，第一个可运行的行代码访问一个属性叫做 toLowerCase 并且调用它。第二个尝试直接调用 message。</code><br>But assuming we don’t know the value of message - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.<br><code>但是假设我们不知道 message 的值 - 并且这是很常见的 - 我们不可以可靠地说什么结果我们会得到运行这些代码。每个操作的行为取决于我们本身的值。</code></p><ul><li>Is message callable? <code>message 是可调用的吗？</code></li><li>Does it have a property called toLowerCase on it? <code>message 有一个属性叫做 toLowerCase 吗？</code></li><li>If it does, is toLowerCase even callable? <code>如果是，是否 toLowerCase 可调用？</code></li><li>If both of these values are callable, what do they return? <code>如果这两个值都是可调用的，它们会返回什么？</code></li></ul><p>The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.<br><code>这些问题的答案通常是我们在写 JavaScript 时保留在我们的脑中，并且我们必须希望我们拿到所有的细节正确。</code><br>Let’s say message was defined in the following way.<br><code>让我们假设 message 被定义为以下的方式。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const message &#x3D; &quot;Hello World!&quot;;</code></pre><p>As you can probably guess, if we try to run message.toLowerCase(), we’ll get the same string only in lower-case.<br><code>如果我们试着运行 message.toLowerCase()，我们会得到一个只有小写字母的字符串。</code><br>What about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:<br><code>如果您熟悉 JavaScript，您会知道这个失败了一个异常：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; TypeError: message is not a function</code></pre><p>It’d be great if we could avoid mistakes like this.<br><code>我们应该能避免这样的错误。</code><br>When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has. That’s part of what that TypeError is alluding to - it’s saying that the string “Hello World!” cannot be called as a function.<br><code>当我们运行我们的代码，我们的 JavaScript 运行时通过分析值的类型来决定如何做。这是它引用的 TypeError 的一部分 - 它说明 &quot;Hello World!&quot; 不能被调用作为函数。</code><br>For some values, such as the primitives string and number, we can identify their type at runtime using the typeof operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, consider this function:<br><code>对于某些值，如字符串和数字，我们可以在运行时通过 typeof 操作符来识别它的类型。但是对于其他的东西，没有相应的运行时机制来识别它们的类型。例如，让我们来看这个函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function fn(x) &#123;  return x.flip();&#125;</code></pre><p>We can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesn’t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.<br><code>我们可以通过阅读代码, 看到这个函数只有在给定一个可调用 flip 属性的对象时才能工作，但 JavaScript 没有一种方式可以在运行代码时来识别 fn 的行为。只有在调用它时才能知道 fn 的行为，这种行为难以预测，这意味着在写代码时难以知道你的代码会做什么。</code><br>Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash. JavaScript only truly provides dynamic typing - running the code to see what happens.<br><code>在这种方式中，一个类型是描述哪些值可以传给 fn，哪些会崩溃的概念。JavaScript 只是提供了动态类型定义 - 运行代码来看看会发生什么。</code><br>The alternative is to use a static type system to make predictions about what code is expected before it runs.<br><code>另一种方式是使用静态类型系统来预测在运行代码之前会发生什么。</code></p><h2 id="Static-type-checking"><a href="#Static-type-checking" class="headerlink" title="Static type-checking"></a>Static type-checking</h2><p><code>静态类型检查</code><br>Think back to that TypeError we got earlier from trying to call a string as a function. Most people don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.<br><code>想起那个 TypeError 我们以前从尝试调用一个字符串作为函数时得到的。大多数人不喜欢在运行他们的代码时得到任何类型的错误，这些错误被称为 bug！而当我们写新代码时，我们尽可能地避免引入新的 bug。</code><br>If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.<br><code>如果我们添加些点代码，保存我们的文件，重新运行代码，并立即看到错误，我们可能会快速地发现问题；但这并不总是如此。我们可能没有测试特性的充分程度，所以我们可能没有真正发生可能会抛出的错误！或者如果我们能够看到错误，我们可能已经做了大量的重构和添加了很多不同的代码，我们被迫要探索它们。</code><br>Ideally, we could have a tool that helps us find these bugs before our code runs. That’s what a static type-checker like TypeScript does. Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.<br><code>最好的方式是我们可以在我们的代码运行之前，有一个工具帮我们找到这些 bug。这是 TypeScript 的静态类型检查器做的。静态类型系统描述了我们的值在运行我们的程序时的形状和行为。一个类型检查器像 TypeScript 使用这些信息，告诉我们当可能会出现问题时。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const message &#x3D; &quot;hello!&quot;;message();&#x2F;&#x2F; This expression is not callable.&#x2F;&#x2F;   Type &#39;String&#39; has no call signatures.</code></pre><p>Running that last sample with TypeScript will give us an error message before we run the code in the first place.<br><code>运行这个最后一个示例，TypeScript 将在第一个代码之前报错。</code></p><h2 id="Non-exception-Failures"><a href="#Non-exception-Failures" class="headerlink" title="Non-exception Failures"></a>Non-exception Failures</h2><p><code>非异常失败</code><br>So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected.<br><code>直到现在，我们都讨论了一些关于运行时错误的事情，比如说，当 JavaScript 运行时认为某些东西是无效的。这些情况出现的原因是 ECMAScript 规范明确指出了在运行时如何应该行为。</code><br>For example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined:<br><code>比如说，规范指出了尝试调用不可调用的东西应该抛出一个错误。可能会认为这是“明显的行为”，但你可以想象一下，访问一个对象上不存在的属性应该抛出一个错误。而 JavaScript 给我们不同的行为，返回值 undefined：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const user &#x3D; &#123;  name: &quot;Daniel&quot;,  age: 26,&#125;;user.location; &#x2F;&#x2F; returns undefined</code></pre><p>Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about location not being defined:<br><code>最终，一个静态类型系统必须要在它的系统中，告诉我们应该把哪些代码标记为错误的代码，即使它是“有效的 JavaScript”，也不会立即抛出错误。在 TypeScript 中，下面的代码会报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const user &#x3D; &#123;  name: &quot;Daniel&quot;,  age: 26,&#125;;user.location;&#x2F;&#x2F; Property &#39;location&#39; does not exist on type &#39;&#123; name: string; age: number; &#125;&#39;.</code></pre><p>While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs.<br><code>在某些情况下，这意味着一个交换，在你能表达的范围内，在你的程序中，你可以把一些有效的 JavaScript 抛出错误。而 TypeScript 捕获很多有效的错误。</code><br>For example: typos,<br><code>比如说，拼写错误，</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const announcement &#x3D; &quot;Hello World!&quot;;&#x2F;&#x2F; How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase();&#x2F;&#x2F; We probably meant to write this...announcement.toLocaleLowerCase();</code></pre><p>uncalled functions,<br><code>未调用的函数，</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function flipCoin() &#123;  &#x2F;&#x2F; Meant to be Math.random()  return Math.random &lt; 0.5;  &#x2F;&#x2F; Operator &#39;&lt;&#39; cannot be applied to types &#39;() &#x3D;&gt; number&#39; and &#39;number&#39;.&#125;</code></pre><p>or basic logic errors.<br><code>或基本的逻辑错误。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const value &#x3D; Math.random() &lt; 0.5 ? &quot;a&quot; : &quot;b&quot;;if (value !&#x3D;&#x3D; &quot;a&quot;) &#123;  &#x2F;&#x2F; ...&#125; else if (value &#x3D;&#x3D;&#x3D; &quot;b&quot;) &#123;  &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;a&quot;&#39; and &#39;&quot;b&quot;&#39; have no overlap.  &#x2F;&#x2F; Oops, unreachable&#125;</code></pre><h2 id="Types-for-Tooling"><a href="#Types-for-Tooling" class="headerlink" title="Types for Tooling"></a>Types for Tooling</h2><p><code>类型为工具</code><br>TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can also prevent us from making those mistakes in the first place.<br><code>TypeScript 可以捕获我们在我们的代码中做错误的错误。这很好，但 TypeScript 可以防止我们做错误。</code><br>The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use.<br><code>类型检查器有信息来检查变量和其他属性是否正确。一旦有这些信息，它也可以开始提建议你应该使用哪些属性。</code><br>That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.<br><code>这意味着 TypeScript 可以用于编辑代码，并且核心类型检查器可以提供错误消息和代码补全。这是人们通常在说讨论工具时所提到的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import express from &quot;express&quot;;const app &#x3D; express();app.get(&quot;&#x2F;&quot;, function (req, res) &#123;  res.sen    &#x2F;&#x2F; send    &#x2F;&#x2F; sendDate    &#x2F;&#x2F; sendfile    &#x2F;&#x2F; sendFile    &#x2F;&#x2F; sendStatus&#125;);app.</code></pre><p>TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that your favorite editor has TypeScript support available.<br><code>TypeScript 也深深地认识到工具，并且这也包括了完成和错误的补全，你在输入时可以自动修复错误，重新组织代码，以及寻找变量的定义，或寻找所有引用的变量。这全部是基于类型检查器的，并且是完全的跨平台，所以你可能喜欢的编辑器有 TypeScript 的支持。</code></p><h2 id="tsc-the-TypeScript-compiler"><a href="#tsc-the-TypeScript-compiler" class="headerlink" title="tsc, the TypeScript compiler"></a>tsc, the TypeScript compiler</h2><p><code>tsc</code>，TypeScript 编译器<br>We’ve been talking about type-checking, but we haven’t yet used our type-checker. Let’s get acquainted with our new friend tsc, the TypeScript compiler. First we’ll need to grab it via npm.<br><code>我们已经讲述了类型检查，但我们还没有使用我们的类型检查器。我们需要通过 npm 来获取 tsc，TypeScript 编译器。</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g typescript</code></pre><p>This installs the TypeScript Compiler tsc globally. You can use npx or similar tools if you’d prefer to run tsc from a local node_modules package instead.<br><code>这将安装 TypeScript 编译器 tsc 在全局。如果你想从本地的 node_modules 包里运行 tsc，可以使用 npx 或类似的工具。</code><br>Now let’s move to an empty folder and try writing our first TypeScript program: hello.ts:<br><code>现在我们移动到一个空文件夹，并尝试写我们的第一个 TypeScript 程序：hello.ts：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Greets the world.console.log(&quot;Hello world!&quot;);</code></pre><p>Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command tsc which was installed for us by the typescript package.<br><code>通过运行 tsc 命令，我们可以检查我们的程序。</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tsc hello.ts</code></pre><p>Tada!<br><code>拍拍拍！</code><br>Wait, “tada” what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.<br><code>等等，“拍拍拍”，什么意思？我们运行 tsc，没有任何事情发生！</code><br>But check again - we got some file output instead. If we look in our current directory, we’ll see a hello.js file next to hello.ts. That’s the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a .ts file:<br><code>但再检查一次，我们会看到一个 hello.js 文件，它在 hello.ts 后面。这是 tsc 编译或转换成一个纯 JavaScript 文件的 hello.ts 的输出。如果我们检查内容，我们会看到 TypeScript 在处理 .ts 文件后打印出来的内容：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Greets the world.console.log(&quot;Hello world!&quot;);</code></pre><p>In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.<br><code>在这种情况下，TypeScript 尝试输出一个清洁的可读代码，看起来像一个人写的代码。这并不总是如此简单，TypeScript 缩进一致，注意代码的不同行，并尝试保持注释在同一行。</code><br>What about if we did introduce a type-checking error? Let’s rewrite hello.ts:<br><code>如果我们把 hello.ts 中的 console.log 改成 console.logs，我们会发现什么？我们再次重写 hello.ts：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; This is an industrial-grade general-purpose greeter function:function greet(person, date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date&#125;!&#96;);&#125;greet(&quot;Brendan&quot;);</code></pre><p>If we run tsc hello.ts again, notice that we get an error on the command line!<br><code>如果我们运行 tsc hello.ts 再次，我们会发现在命令行上出现一个错误！</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">Expected 2 arguments, but got 1.</code></pre><p>TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!<br><code>TypeScript 提醒我们没有传递参数给 greet 函数，并且正确地。直到现在，我们只写了标准 JavaScript，然而类型检查仍然可以找到我们的代码的问题。感谢 TypeScript！</code></p><h2 id="Emitting-with-Errors"><a href="#Emitting-with-Errors" class="headerlink" title="Emitting with Errors"></a>Emitting with Errors</h2><p><code>发射错误</code><br>One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, you will know better than TypeScript.<br><code>一个你可能没有注意到的事情是，我们的 hello.js 文件变了一次。如果我们打开这个文件，我们会看到它的内容仍然基本和我们的输入文件一样。这可能是一个很糟的情况，因为 tsc 报告了我们的代码的错误，但这是基于 TypeScript 的核心值：很多时候，你会更了解更多的事情。</code><br>To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?<br><code>重复上一段内容，类型检查代码限制了你可以运行的程序，因此有一个交换，如果你的类型检查器找到了可接受的东西，那么你可以运行它。但是，有时候，这些检查会拖慢你的程序。例如，假设你是一个 JavaScript 的移植者，并且你把类型检查错误插入到你的代码中。最终，你会把它们清理掉，但是原来的 JavaScript 代码已经已经正常运行了！为什么你会把它移植到 TypeScript 中，然后停止运行它？</code><br>So TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag:<br><code>因此，TypeScript 不会拖慢你。但是，随着时间的推移，你可能会想要更加安全，并且使 TypeScript 变得更严格。在这种情况下，你可以使用 noEmitOnError 编译器选项。试着把 hello.ts 文件中的代码改一下，然后运行 tsc 并且使用这个选项：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">tsc --noEmitOnError hello.ts</code></pre><p>You’ll notice that hello.js never gets updated.<br><code>hello.js 不会被更新。</code></p><h2 id="Explicit-Types"><a href="#Explicit-Types" class="headerlink" title="Explicit Types"></a>Explicit Types</h2><p><code>显式类型</code><br>Up until now, we haven’t told TypeScript what person or date are. Let’s edit the code to tell TypeScript that person is a string, and that date should be a Date object. We’ll also use the toDateString() method on date.<br><code>直到现在，我们都没有告诉 TypeScript 什么是人或日期。我们现在编辑代码，让 TypeScript 知道 person 是一个字符串，而 date 应该是一个 Date 对象。我们也使用 date 的 toDateString() 方法。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(person: string, date: Date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;</code></pre><p>What we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as ”greet takes a person of type string, and a date of type Date“.<br><code>我们做了一个类型标注，让 TypeScript 知道 greet 可以被调用的时候，person 的类型是 string，而 date 的类型是 Date。</code><br>With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For example…<br><code>这样，TypeScript 可以告诉我们其他情况下 greet 可能会被调用错误。例如…</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(person: string, date: Date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;greet(&quot;Maddison&quot;, Date());&#x2F;&#x2F; Argument of type &#39;string&#39; is not assignable to parameter of type &#39;Date&#39;.</code></pre><p>Huh? TypeScript reported an error on our second argument, but why?<br><code>哎？TypeScript 在第二个参数上报错了，但是为什么？</code><br>Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting.<br><code>可能就是因为 JavaScript 中的 Date() 返回一个字符串，而 new Date() 则会返回我们期望的结果。</code><br>Anyway, we can quickly fix up the error:<br><code>然后，我们可以快速修复错误：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(person: string, date: Date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;greet(&quot;Maddison&quot;, new Date());</code></pre><p>Keep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just infer (or “figure out”) the types for us even if we omit them.<br><code>记住，我们不是总是要写明类型标注。在大多数情况下，TypeScript 也可以自动推断（或者说认为）类型，即使我们没有写明类型标注。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let msg &#x3D; &quot;hello there!&quot;;let msg: string;</code></pre><p>Even though we didn’t tell TypeScript that msg had the type string it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.<br><code>即使我们没有告诉 TypeScript msg 的类型是 string，它也能够自动推断出来。这是一个特性，并且当类型系统自动推断出相同类型的时候，不要写明类型标注。</code><br>:::tip</p><p>the message bubble inside the code sample above. That is what your editor would show if you had hovered over the word.<br><code>在上面的代码段中，你的编辑器会显示一个消息泡。如果你鼠标悬停在这个单词上，那么你的编辑器会显示这个消息泡。</code><br>:::</p><h2 id="Erased-Types"><a href="#Erased-Types" class="headerlink" title="Erased Types"></a>Erased Types</h2><p><code>擦除类型</code><br>Let’s take a look at what happens when we compile the above function greet with tsc to output JavaScript:<br><code>我们看看如果我们用 tsc 编译上面的函数 greet，它会输出 JavaScript 代码：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&quot;use strict&quot;;function greet(person, date) &#123;  console.log(    &quot;Hello &quot;.concat(person, &quot;, today is &quot;).concat(date.toDateString(), &quot;!&quot;)  );&#125;greet(&quot;Maddison&quot;, new Date());</code></pre><p>Notice two things here:<br><code>注意这里有两件事情：</code><br>Our person and date parameters no longer have type annotations.<br><code>我们的 person 和 date 参数没有类型标注。</code><br>Our “template string” - that string that used backticks (the <code>character) - was converted to plain strings with concatenations (+).</code>我们的模板字符串（使用 字符）已经被转换成了纯字符串，并且使用了 + 字符串连接。<code>More on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.</code>TypeScript 不是 JavaScript（或者说 ECMAScript）的一部分，所以不会有浏览器或其他运行时可以直接运行 TypeScript 的情况。因此 TypeScript 需要一个编译器，以便我们可以去掉或转换 TypeScript 的任何特定代码，以便我们可以运行它。大多数 TypeScript 特定代码都会被去掉，反之，这里的类型标注也会被去掉。&#96;</p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>Remember: Type annotations never change the runtime behavior of your program.<br><code>记住：类型标注不会改变你的程序的运行时行为。</code></div><h2 id="Downleveling"><a href="#Downleveling" class="headerlink" title="Downleveling"></a>Downleveling</h2><p><code>降级</code><br>One other difference from the above was that our template string was rewritten from<br><code>我们的模板字符串是从</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;;</code></pre><p>to</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&quot;Hello &quot; + person + &quot;, today is &quot; + date.toDateString() + &quot;!&quot;;</code></pre><p>Why did this happen?<br><code>为什么这样发生了？</code><br>Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - don’t ask). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called downleveling.<br><code>模板字符串是 ECMAScript 2015 的一个特性（或者说 ECMAScript 6，ES2015，ES6 等）。TypeScript 有能力将从更新的 ECMAScript 移到更旧的 ECMAScript，比如 ECMAScript 3 或 ECMAScript 5（或者说 ES3 和 ES5）。这种移动的过程称为降级。</code><br>By default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with –target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running tsc –target es2015 hello.ts gives us the following output:<br><code>默认情况下，TypeScript 目标 ES3，一个非常老的 ECMAScript 版本。我们可以选择一个更新的版本，使用 target 选项。运行 tsc --target es2015 hello.ts 就会得到以下的输出：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(person, date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;greet(&quot;Maddison&quot;, new Date());</code></pre><p>While the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.<br><code>默认目标是 ES3，大多数当前浏览器都支持 ES2015。大多数开发人员可以安全地指定 ES2015 或以上作为目标，除非需要与某些古老的浏览器兼容。</code></p><h2 id="Strictness"><a href="#Strictness" class="headerlink" title="Strictness"></a>Strictness</h2><p><code>严格</code><br>Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially null&#x2F;undefined values. Much like how tsc emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.<br><code>不同的用户到 TypeScript 上来看，有不同的意图。有人想要一个更宽松的选择，这可以帮助验证某些部分的程序，并且仍然有很好的工具。这是 TypeScript 默认的行为，其中类型是可选的，推断会接受更宽松的类型，并且没有检查可能 null/undefined 的值。和 tsc 在出现错误的时候一样，这些默认值被放在了你的脚跟上（兜底：这些默认选项并不会阻碍你的开发）。如果你正在迁移已有的 JavaScript，那么这可能是一个最佳的第一步。</code><br>In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.<br><code>不同的用户喜欢立刻验证程序，而不是等到最后。这是 TypeScript 的语言提供了严格性设置，这些设置可以改变静态类型检查的行为。这些设置可以改变静态类型检查的行为，而不是一个开关。这些设置越高，TypeScript 越会检查更多的信息。这可能需要一点额外的工作，但一般来说，这能提供更好的工具，并且能更好地支持你的代码。当可能的时候，一个新的代码应该总是开启这些严格性检查。</code><br>TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The strict flag in the CLI, or “strict”: true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks.<br><code>TypeScript 有多个严格性标志，可以开启或关闭，所有的示例都将使用所有的标志，除非特别说明。CLI 中的 strict 开关，或 tsconfig.json 中的 strict: true 开启了所有的标志，但是我们可以单独关闭它们。两个最大的，你应该知道的是 noImplicitAny 和 strictNullChecks。</code></p><h2 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h2><p><code>无隐式any</code><br>Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: any. This isn’t the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway.<br><code>在某些地方，TypeScript 不会为我们自动推断类型，而是使用最宽松的类型：any。这并不是最差的情况，因为仍然是 JavaScript 的经验。</code><br>However, using any often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any.<br><code>使用 any 很容易让你的程序变得更加不可靠。因为更加类型化的程序，你会发现更多的错误，并且更加容易地调试。开启 noImplicitAny 标志会在任何自动推断类型为 any 的变量上发出错误。</code></p><h2 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h2><p><code>严格null</code><br>By default, values like null and undefined are assignable to any other type. This can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it<code> a billion dollar mistake!</code> The <code>strictNullChecks</code> flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined.<br><code>默认情况下，null 和 undefined 可以赋值给任何类型。这可以让写一些代码更容易，但是忘记处理 null 和 undefined 就会导致世界上的很多错误，有人认为这是一百亿美元错误！ strictNullChecks 可以让处理 null 和 undefined 更加明确，并且让我们不用担心是否忘记处理 null 和 undefined。</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html#static-type-checking">Typescript The Basics</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Typescript起步</title>
      <link href="//post/2022-06-08ts-start.html"/>
      <url>//post/2022-06-08ts-start.html</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此文及后续的几篇是对<a href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html">Typescript官方原文</a>的翻译，方便阅读</p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>typescript 起步，分别针对 4 类不同的程序开发者进行引导， <strong>对号入座</strong></p><ul><li>新手程序猿，没有接触过任何开发语言</li><li>JS 开发者</li><li>Java&#x2F;C#开发 [跳过]</li><li>函数式编程人员</li><li>5 分钟内了解 Typescript</li></ul><h2 id="新手程序猿"><a href="#新手程序猿" class="headerlink" title="新手程序猿"></a>新手程序猿</h2><p>Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!<br><code>祝贺您选择了 TypeScript 作为您的第一种语言，您已经做出了优秀的决策！</code><br>You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.<br><code>你大概已经听说过，TypeScript 是 JavaScript 的一个变体。TypeScript 和 JavaScript 的关系是在现代编程语言中非常独特的，所以学习更多关于这个关系的知识将帮助你了解 TypeScript 和 JavaScript 的区别。</code></p><h3 id="What-is-JavaScript-A-Brief-History"><a href="#What-is-JavaScript-A-Brief-History" class="headerlink" title="What is JavaScript? A Brief History"></a>What is JavaScript? A Brief History</h3><p><code>什么是 JavaScript？简单的历史</code></p><p>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.<br><code>JavaScript 是一种简单的脚本语言，用于浏览器。在创建时，它预期会被用于嵌入在网页中的短片代码 — 写入超过十几行代码会有点不便。</code><br>Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich applications of all kinds.<br><code>Web 浏览器开发者对这个增加了 JS 使用的响应，优化了他们的执行引擎（动态编译）和扩展了他们可以做的事情（添加 APIs），这使得 Web 开发者使用它来做更多的事情。在现代网站上，您的浏览器通常运行着一些应用程序，其中包括千万行代码的应用程序。这是一个非常长的“网”的发展，从一个简单的静态页面开始，并进入一个丰富的应用程序的平台。</code><br>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use only JavaScript to program their entire stack!<br><code>不仅如此，JS 变得越来越受欢迎，并且可以在浏览器之外使用，比如使用 node.js 来实现 JS 服务器。JS 的“运行在任何地方”性质使得它一个极受欢迎的选择。有许多开发者今天只使用 JavaScript 来编程他们的整个堆栈！</code><br>To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own quirks — oddities and surprises, and JavaScript’s humble beginning makes it have many of these. Some examples:<br><code>概括，我们有一种语言，被设计为快速使用，然后扩展到一个具有千万行代码的应用程序的工具。每种语言都有自己的特性，有的有点不同，有的有点惊人，而 JavaScript 的轻重感使得它有许多这些。有些例子：</code></p><p>JavaScript’s equality operator (&#x3D;&#x3D;) coerces its arguments, leading to unexpected behavior:<br><code>JavaScript 的相等操作符（==）会强制转换它的参数，导致意外的行为：</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (&quot;&quot; &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; It is! But why??&#125;if (1 &lt; x &lt; 3) &#123;  &#x2F;&#x2F; True for *any* value of x!&#125;</code></pre><p>JavaScript also allows accessing properties which aren’t present:<br><code>JavaScript 也允许访问不存在的属性：</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123; width: 10, height: 15 &#125;;&#x2F;&#x2F; Why is this NaN? Spelling is hard!const area &#x3D; obj.width * obj.heigth;</code></pre><p>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.<br><code>大多数编程语言会抛出错误，当这些错误发生时，它们会抛出错误，而不是在编译时。当写小型程序时，这些惊人的惊喜是可接受的；当写大型应用程序时，这些惊喜是一个严重的问题。</code></p><ul><li>TypeScript: A Static Type Checker</li></ul><p>We said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as static checking. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static type checking.<br><code>我们说过，某些语言不允许运行那些错误的程序。检测代码中的错误，而不运行它, 是静态检查。确定哪些是错误的，哪些是正确的，是基于值的类型的静态检查。</code><br>TypeScript checks a program for errors before execution, and does so based on the kinds of values, it’s a static type checker. For example, the last example above has an error because of the type of obj. Here’s the error TypeScript found:<br><code>TypeScript 检测程序前，并且基于值的类型，它是一个静态类型检查器。例如，上面的最后一个例子有一个错误，因为 obj 的类型是 NaN。这里 TypeScript 发现了错误：</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123; width: 10, height: 15 &#125;;const area &#x3D; obj.width * obj.heigth;&#x2F;&#x2F; Property &#39;heigth&#39; does not exist on type &#39;&#123; width: number; height: number; &#125;&#39;. Did you mean &#39;height&#39;?</code></pre><h3 id="A-Typed-Superset-of-JavaScript"><a href="#A-Typed-Superset-of-JavaScript" class="headerlink" title="A Typed Superset of JavaScript"></a>A Typed Superset of JavaScript</h3><p><code>一个类型定义的超集 JavaScript</code></p><p>How does TypeScript relate to JavaScript, though?<br><code>TypeScript 的类型定义是什么，和 JavaScript 的类型定义有什么关系？</code></p><h3 id="Syntax-语法"><a href="#Syntax-语法" class="headerlink" title="Syntax 语法"></a>Syntax 语法</h3><p>TypeScript is a language that is a superset of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a syntax error because it’s missing a ):<br><code>Typescript 是 JavaScript 的一个子集：JS 语言的语法是合法的 TS。语法是指我们写程序的方式。例如，这段代码有一个语法错误，因为没有一个）。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let a &#x3D; (4&#39;)&#39; expected.</code></pre><p>TypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.<br><code>TypeScript 不会认为任何 JavaScript 代码是错误的，因为它的语法。这意味着你可以把任何工作的 JavaScript 代码放在 TypeScript 文件中，而不用担心它的语法。</code></p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>类型</p><p>However, TypeScript is a typed superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about obj.heigth was not a syntax error: it is an error of using some kind of value (a type) in an incorrect way.</p><p><code>然而，TypeScript 是一个类型的超集，意味着它添加了一些规则，如何使用不同类型的值。前面的错误，obj.heigth 是不是一个语法错误？它是一个错误的使用某种类型的值（一个类型）的方式。</code></p><p>As another example, this is JavaScript code that you can run in your browser, and it will log a value:</p><p><code>另一个例子，这是你可以在浏览器中运行的 JavaScript 代码，它会记录一个值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">console.log(4 &#x2F; []);&#x2F;&#x2F; The right-hand side of an arithmetic operation must be of type &#39;any&#39;, &#39;number&#39;, &#39;bigint&#39; or an enum type.</code></pre><p>It’s possible you really did intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)</p><p><code>之前一个数除以一个数组，可能仅仅是想看下会出现什么，尽管他是一个错误程序。Typescript 的类型检查器是设计的，让正确的程序通过，并且尽可能少的错误。(后面，我们会学习如何配置 TypeScript 检查你的代码。)</code></p><p>If you move some code from a JavaScript file to a TypeScript file, you might see type errors depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.</p><p><code>如果你从一个 JavaScript 文件移动到一个 TypeScript 文件，你可能会看到一些类型错误，取决于你的代码如何写。这些可能是代码的正确性，或者 TypeScript 过于保守。本指南中，我们会演示如何添加各种 TypeScript 语法，以便消除这些错误。</code></p><h3 id="Runtime-Behavior"><a href="#Runtime-Behavior" class="headerlink" title="Runtime Behavior"></a>Runtime Behavior</h3><p><code>运行时行为</code><br>TypeScript is also a programming language that preserves the runtime behavior of JavaScript. For example, dividing by zero in JavaScript produces Infinity instead of throwing a runtime exception. As a principle, TypeScript never changes the runtime behavior of JavaScript code.<br>TypeScript 也是一个编程语言，它保留 JavaScript 的运行时行为。例如，在 JavaScript 中除以零会产生无穷，而不是抛出一个运行时异常。作为一个原则，TypeScript 不会改变 JavaScript 代码的运行时行为。<br>This means that if you move code from JavaScript to TypeScript, it is guaranteed to run the same way, even if TypeScript thinks that the code has type errors.<br><code>这意味着如果你从 JavaScript 移动到 TypeScript，它就保证会运行一样的，即使 TypeScript 认为代码有类型错误。</code><br>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.<br><code>保持和 JavaScript 的运行时一致的行为是 TypeScript 的基础承诺，因为它意味着你可以很容易地从 JavaScript 到 TypeScript 过渡，而不用担心潜在的差异，可能会影响你的程序的正常运行。</code></p><h3 id="Erased-Types"><a href="#Erased-Types" class="headerlink" title="Erased Types"></a>Erased Types</h3><p><code>擦除类型</code><br>Roughly speaking, once TypeScript’s compiler is done with checking your code, it erases the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.<br><code>换句话说，一旦 TypeScript 编译器完成了检查你的代码，它会擦除类型，生成结果的“编译”代码。这意味着，一旦你的代码编译完成，结果的普通 JS 代码将没有类型信息。</code><br>This also means that TypeScript never changes the behavior of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.<br><code>这意味着，在编译时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。底线是，在运行时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。</code><br>Finally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.<br><code>最后，TypeScript 不提供任何额外的运行时库。你的程序将使用和 JavaScript 程序一样的标准库（或外部库），所以没有额外的 TypeScript-特定的框架来学习。</code></p><h3 id="Learning-JavaScript-and-TypeScript"><a href="#Learning-JavaScript-and-TypeScript" class="headerlink" title="Learning JavaScript and TypeScript"></a>Learning JavaScript and TypeScript</h3><p><code>学习 JavaScript 和 TypeScript</code><br>We frequently see the question “Should I learn JavaScript or TypeScript?“.<br><code>我们经常会看到这个问题：“我应该学习 JavaScript 还是 TypeScript？”</code><br>The answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.<br><code>答案是，你不能学习 TypeScript，除非你学习 JavaScript！TypeScript 和 JavaScript 共享语法和运行时行为，所以你学习 JavaScript 的任何内容都是帮助你学习 TypeScript 的同时。</code><br>There are many, many resources available for programmers to learn JavaScript; you should not ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged javascript than typescript, but all of the javascript questions also apply to TypeScript.<br><code>有很多，很多资源可供程序员学习 JavaScript；如果你写 TypeScript，你不应该忽略这些资源。例如，有 20 倍的 StackOverflow 问题标记了 javascript，而 typescript 问题也适用于 javascript。</code><br>If you find yourself searching for something like “how to sort a list in TypeScript”, remember: TypeScript is JavaScript’s runtime with a compile-time type checker. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.<br><code>如果你发现自己在搜索“如何排序一个列表”，记住：TypeScript 是 JavaScript 的运行时，同时还有一个编译时类型检查器。你在 TypeScript 中排序一个列表的方式和在 JavaScript 中一样。如果你找到一个使用 TypeScript 的资源，那也是很好的，但不要限制自己在每天的问题中想要使用 TypeScript-特定的答案来实现运行时任务。</code></p><h3 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h3><p><code>下一步</code><br>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:<br><code>这是一个简单的概述，从这里你可以：</code><br>Learn some of the JavaScript fundamentals, we recommend either:<br><code>学习 JavaScript 基本原理，我们建议：</code><br>Microsoft’s JavaScript Resources or<br>JavaScript guide at the Mozilla Web Docs<br>Continue to TypeScript for JavaScript Programmers<br><code>继续学习 TypeScript 为 JavaScript 程序员</code><br>Read the full Handbook from start to finish (30m)<br><code>阅读全部手册从头到尾（30 分钟）</code>大佬就是大佬 30 分钟能搞定，我估计要搞 3 天，手册这地方内容还是很多的<br>Explore the Playground examples<br><code>探索 Playground 示例</code></p><h2 id="JS-开发者"><a href="#JS-开发者" class="headerlink" title="JS 开发者"></a>JS 开发者</h2><p>TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.<br><code>TypeScript 与 JavaScript 的关系是不正常的。TypeScript 提供了 JavaScript 的所有功能，并且在这些功能的基础上添加了一层：TypeScript 的类型系统。</code><br>For example, JavaScript provides language primitives like string and number, but it doesn’t check that you’ve consistently assigned these. TypeScript does.<br><code>例如，JavaScript 提供了字符串和数字，但它不检查你是否按照一致的方式分配这些。TypeScript 也提供了。</code><br>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.<br><code>这意味着你的已有的工作中的 JavaScript 代码也是 TypeScript 代码。TypeScript 的主要好处是它可以高亮你的代码中的意外行为，降低 bug 的可能性。</code><br>This tutorial provides a brief overview of TypeScript, focusing on its type system.<br><code>这个教程主要介绍 TypeScript 的类型系统。</code></p><h3 id="Types-by-Inference"><a href="#Types-by-Inference" class="headerlink" title="Types by Inference"></a>Types by Inference</h3><p><code>类型推论</code></p><p>TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.<br><code>TypeScript 知道 JavaScript 语言，并且会为你生成类型。例如，创建一个变量并为它赋值，TypeScript 就会使用值作为它的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let helloWorld &#x3D; &quot;Hello World&quot;;&#x2F;&#x2F; let helloWorld: string</code></pre><p>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that helloWorld is a string in the above example.<br><code>通过了解 JavaScript 工作方式，TypeScript 可以建立一个接受 JavaScript 代码，但有类型的类型系统。这个类型系统没有需要在你的代码中添加额外的字符来明确类型。这就是 TypeScript 知道 helloWorld 是一个字符串的原因。</code></p><p>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.<br><code>你可能在 Visual Studio Code 中写了 JavaScript，并且有自动补全。Visual Studio Code 使用 TypeScript 作为后台来更加方便地工作。（原来如此）</code></p><h3 id="Defining-Types"><a href="#Defining-Types" class="headerlink" title="Defining Types"></a>Defining Types</h3><p><code>定义类型</code><br>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.<br><code>你可以使用 JavaScript 的许多设计模式。_然而，有些设计模式使得类型无法被自动推断（例如，使用动态规划的模式_。为了解决这些情况，TypeScript 支持一个 JavaScript 的扩展，它提供了给你告诉 TypeScript 的类型应该是什么的地方。</code><br>For example, to create an object with an inferred type which includes name: string and id: number, you can write:<br><code>例如，创建一个具有推断类型的对象，它包含 name: string 和 id: number，你可以这样写：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const user &#x3D; &#123;  name: &quot;Hayes&quot;,  id: 0,&#125;;</code></pre><p>You can explicitly describe this object’s shape using an interface declaration:<br><code>你可以使用接口声明来明确地描述这个对象的形状：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface User &#123;  name: string;  id: number;&#125;</code></pre><p>You can then declare that a JavaScript object conforms to the shape of your new interface by using syntax like : TypeName after a variable declaration:<br><code>你可以使用类型名称来告诉 JavaScript 你的变量是属于哪个类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const user: User &#x3D; &#123;  name: &quot;Hayes&quot;,  id: 0,&#125;;</code></pre><p>If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:<br><code>如果你提供的对象不符合你提供的接口，TypeScript 就会警告你：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface User &#123;  name: string;  id: number;&#125;const user: User &#x3D; &#123;  username: &quot;Hayes&quot;,  &#x2F;&#x2F; Type &#39;&#123; username: string; id: number; &#125;&#39; is not assignable to type &#39;User&#39;.  &#x2F;&#x2F; Object literal may only specify known properties, and &#39;username&#39; does not exist in type &#39;User&#39;.  id: 0,&#125;;</code></pre><p>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:<br><code>因为 JavaScript 支持类和对象-面向对象编程，所以 TypeScript 也支持。你可以使用接口声明类：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface User &#123;  name: string;  id: number;&#125;class UserAccount &#123;  name: string;  id: number;  constructor(name: string, id: number) &#123;    this.name &#x3D; name;    this.id &#x3D; id;  &#125;&#125;const user: User &#x3D; new UserAccount(&quot;Murphy&quot;, 1);</code></pre><p>You can use interfaces to annotate parameters and return values to functions:<br><code>你可以使用接口来标注函数的参数和返回值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getAdminUser(): User &#123;  &#x2F;&#x2F;...&#125;function deleteUser(user: User) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>There is already a small set of primitive types available in JavaScript: boolean, bigint, null, number, string, symbol, and undefined, which you can use in an interface. TypeScript extends this list with a few more, such as any (allow anything), unknown (ensure someone using this type declares what the type is), never (it’s not possible that this type could happen), and void (a function which returns undefined or has no return value).<br><code>已经有一些简单的原始类型可用于 JavaScript：boolean, bigint, null, number, string, symbol, 和 undefined，你可以在接口中使用它们。TypeScript 将这些类型扩展了一些，如 any（允许任何东西），unknown（确保使用者使用这个类型时声明了它的类型），never（不可能发生的类型），和 void（函数返回 undefined 或没有返回值）。</code></p><p>You’ll see that there are two syntaxes for building types: Interfaces and Types. You should prefer interface. Use type when you need specific features.<br><code>你会看到有两种编写类型的语法：接口和类型。当你需要特定的功能时，你应该使用接口。使用类型时，你需要特定的功能。</code></p><h3 id="Composing-Types"><a href="#Composing-Types" class="headerlink" title="Composing Types"></a>Composing Types</h3><p><code>组合类型</code><br>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.<br><code>通过使用联合类型，或者通过使用泛型来组合复杂的类型。</code></p><h3 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h3><p><code>联合类型</code><br>With a union, you can declare that a type could be one of many types. For example, you can describe a boolean type as being either true or false:<br><code>通过使用联合类型，你可以声明一个类型是可能是 true 或 false 的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type MyBool &#x3D; true | false;</code></pre><p>Note: If you hover over MyBool above, you’ll see that it is classed as boolean. That’s a property of the Structural Type System. More on this below.<br><code>请注意，如果你将鼠标移到 MyBool 上，你会看到它是一个 boolean 类型。这是结构类型系统的一个属性。更多内容在下面。</code><br>A popular use-case for union types is to describe the set of string or number literals that a value is allowed to be:<br><code>联合类型的一个常见用例是描述一个值可以是一个字符串或数字的集合：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type WindowStates &#x3D; &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;type LockStates &#x3D; &quot;locked&quot; | &quot;unlocked&quot;;type PositiveOddNumbersUnderTen &#x3D; 1 | 3 | 5 | 7 | 9;</code></pre><p>Unions provide a way to handle different types too. For example, you may have a function that takes an array or a string:<br><code>联合类型可以用来处理不同类型的参数。例如，你可以有一个函数可以接受一个数组或字符串类型的参数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getLength(obj: string | string[]) &#123;  return obj.length;&#125;</code></pre><p>To learn the type of a variable, use typeof:<br><code>使用 typeof 来查看一个变量的类型：</code></p><h3 id="Type-Predicate"><a href="#Type-Predicate" class="headerlink" title="Type Predicate"></a>Type Predicate</h3><p><code>类型断言</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">string typeof s &#x3D;&#x3D;&#x3D; &quot;string&quot;number typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;boolean typeof b &#x3D;&#x3D;&#x3D; &quot;boolean&quot;undefined typeof undefined &#x3D;&#x3D;&#x3D; &quot;undefined&quot;function typeof f &#x3D;&#x3D;&#x3D; &quot;function&quot;array Array.isArray(a)</code></pre><p>For example, you can make a function return different values depending on whether it is passed a string or an array:<br><code>例如，你可以用来返回不同的值，根据传入的参数是字符串还是数组：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function wrapInArray(obj: string | string[]) &#123;  if (typeof obj &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    return [obj];    (parameter) obj: string  &#125;  return obj;&#125;</code></pre><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p><code>泛型</code></p><p>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.<br><code>泛型可以提供类型变量。例如，数组。数组没有泛型可以包含任何东西。数组有泛型可以描述数组中包含的值。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type StringArray &#x3D; Array&lt;string&gt;;type NumberArray &#x3D; Array&lt;number&gt;;type ObjectWithNameArray &#x3D; Array&lt;&#123; name: string &#125;&gt;;You can declare your own types that use generics:</code></pre><p><code>你可以声明自己的类型，使用泛型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Backpack&lt;Type&gt; &#123;  add: (obj: Type) &#x3D;&gt; void;  get: () &#x3D;&gt; Type;&#125;&#x2F;&#x2F; This line is a shortcut to tell TypeScript there is a&#x2F;&#x2F; constant called &#96;backpack&#96;, and to not worry about where it came from.declare const backpack: Backpack&lt;string&gt;;&#x2F;&#x2F; object is a string, because we declared it above as the variable part of Backpack.const object &#x3D; backpack.get();&#x2F;&#x2F; Since the backpack variable is a string, you can&#39;t pass a number to the add function.backpack.add(23);Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.</code></pre><h3 id="Structural-Type-System"><a href="#Structural-Type-System" class="headerlink" title="Structural Type System"></a>Structural Type System</h3><p><code>结构类型系统</code></p><p>One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.<br><code>结构类型系统的一个核心原则是，类型检查只关注值的形状。这称为“鸭子类型”或“结构类型”。</code><br>In a structural type system, if two objects have the same shape, they are considered to be of the same type.<br><code>在结构类型系统中，如果两个对象具有相同的形状，则被视为相同的类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Point &#123;  x: number;  y: number;&#125;function logPoint(p: Point) &#123;  console.log(&#96;$&#123;p.x&#125;, $&#123;p.y&#125;&#96;);&#125;&#x2F;&#x2F; logs &quot;12, 26&quot;const point &#x3D; &#123; x: 12, y: 26 &#125;;logPoint(point);</code></pre><p>The point variable is never declared to be a Point type. However, TypeScript compares the shape of point to the shape of Point in the type-check. They have the same shape, so the code passes.<br><code>point 变量没有被声明为 Point 类型。但是，TypeScript 对比 point 和 Point 的形状，它们具有相同的形状，所以代码通过。</code><br>The shape-matching only requires a subset of the object’s fields to match.<br><code>结构类型系统只需要对象的一部分字段匹配。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const point3 &#x3D; &#123; x: 12, y: 26, z: 89 &#125;;logPoint(point3); &#x2F;&#x2F; logs &quot;12, 26&quot;const rect &#x3D; &#123; x: 33, y: 3, width: 30, height: 80 &#125;;logPoint(rect); &#x2F;&#x2F; logs &quot;33, 3&quot;const color &#x3D; &#123; hex: &quot;#187ABF&quot; &#125;;logPoint(color);&#x2F;&#x2F; Argument of type &#39;&#123; hex: string; &#125;&#39; is not assignable to parameter of type &#39;Point&#39;.&#x2F;&#x2F; Type &#39;&#123; hex: string; &#125;&#39; is missing the following properties from type &#39;Point&#39;: x, y</code></pre><p>There is no difference between how classes and objects conform to shapes:<br><code>类和对象都遵循结构类型系统。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class VirtualPoint &#123;  x: number;  y: number;  constructor(x: number, y: number) &#123;    this.x &#x3D; x;    this.y &#x3D; y;  &#125;&#125;const newVPoint &#x3D; new VirtualPoint(13, 56);logPoint(newVPoint); &#x2F;&#x2F; logs &quot;13, 56&quot;</code></pre><p>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.<br><code>如果对象或类有所有必要的属性，TypeScript将认为它们匹配，无论实现细节。</code></p><h3 id="Next-Steps-1"><a href="#Next-Steps-1" class="headerlink" title="Next Steps"></a>Next Steps</h3><p><code>下一步</code><br>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:<br><code>从这里开始，你可以：</code><br>Read the full Handbook from start to finish (30m)<br><code>阅读完整手册（30分钟）</code><br>Explore the Playground examples<br><code>探索 Playground 示例</code></p><h2 id="Java-x2F-C-开发"><a href="#Java-x2F-C-开发" class="headerlink" title="Java&#x2F;C#开发"></a>Java&#x2F;C#开发</h2><p>虽然 Java&#x2F;C#也接触过，但这不是我本次的重点，之后会补上</p><h2 id="函数式编程人员"><a href="#函数式编程人员" class="headerlink" title="函数式编程人员"></a>函数式编程人员</h2><p>TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.<br><code>TypeScript 开始于一个尝试，将传统对象-对象类型的编程语言转换为 JavaScript，这样的编程人员可以将传统的对象-对象编程程序转换为 Web 端的程序。</code><br>This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.<br><code>这个介绍是为了工作 Haskell 或 ML 程序员而设计的，它描述了 TypeScript 的类型系统与 Haskell 的类型系统之间的不同。</code><br>This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.<br><code>这个介绍不会讲到对象-对象编程。实际上，在 TypeScript 中的对象-对象编程程序与其他流行语言的对象-对象编程程序相似。</code></p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p><code>先决条件</code><br>In this introduction, I assume you know the following:<br><code>在这个介绍中，我假设你知道了以下内容：</code><br>How to program in JavaScript, the good parts.<br><code>如何编写 JavaScript 程序，好的部分。</code><br>Type syntax of a C-descended language.<br><code>C-descended 语言的类型语法。</code><br>If you need to learn the good parts of JavaScript, read JavaScript: The Good Parts. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. R4RS Scheme is a good example.<br><code>如果你需要学习 JavaScript，请阅读 JavaScript：The Good Parts。如果你知道如何编写基于值词法的词法作用域语言，并且拥有大量可变性和不多的其他特性，你可以跳过这本书。R4RS Scheme 是一个好例子。</code><br>The C++ Programming Language is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: x: string instead of string x.<br><code>C++ 编程语言是一个好的地方学习 C-style 类型语法。</code></p><h3 id="Concepts-not-in-Haskell"><a href="#Concepts-not-in-Haskell" class="headerlink" title="Concepts not in Haskell"></a>Concepts not in Haskell</h3><p><code>在 Haskell 中不存在的概念</code></p><h3 id="Built-in-types"><a href="#Built-in-types" class="headerlink" title="Built-in types"></a>Built-in types</h3><p><code>内置类型</code><br>JavaScript defines 8 built-in types:<br><code>JavaScript 定义了 8 个内置类型：</code> <strong>这里是包装类型</strong><br>Type Explanation<br><code>类型说明</code><br>Number a double-precision IEEE 754 floating point.<br><code>数字，双精度 IEEE 754 浮点数。</code><br>String an immutable UTF-16 string.<br><code>字符串，不可变的 UTF-16 字符串。</code><br>BigInt integers in the arbitrary precision format.<br><code>大整数，任意精度格式。</code><br>Boolean true and false.<br><code>布尔值，true 和 false。</code><br>Symbol a unique value usually used as a key.<br><code>符号，通常用作键。</code><br>Null equivalent to the unit type.<br><code>空，等同于单元类型。</code><br>Undefined also equivalent to the unit type.<br><code>未定义，也等同于单元类型。</code><br>Object similar to records.<br><code>对象，类似于记录。</code><br>See the MDN page for more detail.<br><code>参见 MDN 页面。</code></p><p>TypeScript has corresponding primitive types for the built-in types:<br><code>TypeScript 有对应的内置类型的原始类型：</code><br>number<br>string<br>bigint<br>boolean<br>symbol<br>null<br>undefined<br>object</p><h3 id="Other-important-TypeScript-types"><a href="#Other-important-TypeScript-types" class="headerlink" title="Other important TypeScript types"></a>Other important TypeScript types</h3><p><code>其他重要的 TypeScript 类型</code><br>Type Explanation<br><code>类型说明</code><br>unknown the top type.<br><code>未知类型，顶级类型。</code><br>never the bottom type.<br><code>永远不会是类型，底级类型。</code><br>object literal eg { property: Type }<br><code>对象字面量，例如 &#123; property: 类型 &#125;。</code><br>void a subtype of undefined intended for use as a return type.<br><code>void 类型，作为返回类型。</code><br>T[] mutable arrays, also written Array<T><br><code>T[] 可变数组，也称为 Array&lt;T&gt;。</code><br>[T, T] tuples, which are fixed-length but mutable<br><code>[T, T] 元组，固定长度但可变。</code><br>(t: T) &#x3D;&gt; U functions<br><code>(t: T) =&gt; U 函数。</code><br>Notes:<br><code>注意：</code><br>Function syntax includes parameter names. This is pretty hard to get used to!<br><code>函数语法包括参数名。这很难使用！</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let fst: (a: any, b: any) &#x3D;&gt; any &#x3D; (a, b) &#x3D;&gt; a;&#x2F;&#x2F; or more precisely: 或者更准确地：let fst: &lt;T, U&gt;(a: T, b: U) &#x3D;&gt; T &#x3D; (a, b) &#x3D;&gt; a;&#x2F;&#x2F; Object literal type syntax closely mirrors object literal value syntax:&#x2F;&#x2F; 模式匹配字面量类型语法与对象字面量值语法类似。let o: &#123; n: number; xs: object[] &#125; &#x3D; &#123; n: 1, xs: [] &#125;;[T, T] is a subtype of T[].&#x2F;&#x2F; This is different than Haskell, where tuples are not related to lists.&#x2F;&#x2F; 此外，这是不同于 Haskell 的，元组不和列表相关。</code></pre><h3 id="Boxed-types"><a href="#Boxed-types" class="headerlink" title="Boxed types"></a>Boxed types</h3><p><code>包装类型</code><br>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type number and the boxed type Number. The boxed types are rarely needed, since their methods return primitives.<br><code>JavaScript 有对应的包装类型，包含与这些类型相关的方法。</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">(1).toExponential();&#x2F;&#x2F; equivalent toNumber.prototype.toExponential.call(1);</code></pre><p>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.<br><code>调用方法在数字字面量上需要在括号中，以帮助解析器。</code></p><h3 id="Gradual-typing"><a href="#Gradual-typing" class="headerlink" title="Gradual typing"></a>Gradual typing</h3><p><code>渐进类型</code><br>TypeScript uses the type any whenever it can’t tell what the type of an expression should be. Compared to Dynamic, calling any a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an any[] without marking the value in any way:<br><code>TypeScript 使用 any 时，当它不能确定表达式的类型时。</code><br>&#x2F;&#x2F; with “noImplicitAny”: false in tsconfig.json, anys: any[]<br><code>在 tsconfig.json 中，加入 &quot;noImplicitAny&quot;: false 可以禁用 anys: any[]。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const anys &#x3D; [];anys.push(1);anys.push(&quot;oh no&quot;);anys.push(&#123; anything: &quot;goes&quot; &#125;);</code></pre><p>And you can use an expression of type any anywhere:<br><code>你可以在任何地方使用 any 类型表达式。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">anys.map(anys[1]); &#x2F;&#x2F; oh no, &quot;oh no&quot; is not a function</code></pre><p>any is contagious, too — if you initialize a variable with an expression of type any, the variable has type any too.<br><code>any 类型是传播的，</code> 如果初始化一个变量为 any 类型，变量的类型也是 any。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let sepsis &#x3D; anys[0] + anys[1]; &#x2F;&#x2F; this could mean anything</code></pre><p>To get an error when TypeScript produces an any, use “noImplicitAny”: true, or “strict”: true in tsconfig.json.<br><code>为了在 TypeScript 生成 any 时得到错误提示，使用 &quot;noImplicitAny&quot;: true 或 &quot;strict&quot;: true 在 tsconfig.json 中。</code></p><h3 id="Structural-typing"><a href="#Structural-typing" class="headerlink" title="Structural typing"></a>Structural typing</h3><p><code>结构类型</code><br>Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:<br><code>结构性类型是大多数函数编程程序员熟悉的概念，尽管 Haskell 和大多数 ML 不是结构性类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; @strict: falselet o &#x3D; &#123; x: &quot;hi&quot;, extra: 1 &#125;; &#x2F;&#x2F; oklet o2: &#123; x: string &#125; &#x3D; o; &#x2F;&#x2F; ok</code></pre><p>Here, the object literal { x: “hi”, extra: 1 } has a matching literal type { x: string, extra: number }. That type is assignable to { x: string } since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of { x: string }.<br><code>这里，对象字面量 &#123; x: &quot;hi&quot;, extra: 1 &#125; 有一个匹配的字面量类型 &#123; x: string, extra: number &#125;。</code><br>Named types just give a name to a type; for assignability purposes there’s no difference between the type alias One and the interface type Two below. They both have a property p: string. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)<br><code>命名类型只是给一个类型命名；用于类型赋值的目的不同于接口下面的类型别名和类型参数，但是它们都有属性 p: string。 (类型别名和接口的递归定义和类型参数有所不同。)</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type One &#x3D; &#123; p: string &#125;;interface Two &#123;  p: string;&#125;class Three &#123;  p &#x3D; &quot;Hello&quot;;&#125;let x: One &#x3D; &#123; p: &quot;hi&quot; &#125;;let two: Two &#x3D; x;two &#x3D; new Three();</code></pre><h3 id="Unions-1"><a href="#Unions-1" class="headerlink" title="Unions"></a>Unions</h3><p><code>联合类型</code></p><p>In TypeScript, union types are untagged. In other words, they are not discriminated unions like data in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.<br>在 TypeScript 中，联合类型是无标签的。<code> 在其他语言中，联合类型是标签化的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function start(  arg: string | string[] | (() &#x3D;&gt; string) | &#123; s: string &#125;): string &#123;  &#x2F;&#x2F; this is super common in JavaScript  if (typeof arg &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    return commonCase(arg);  &#125; else if (Array.isArray(arg)) &#123;    return arg.map(commonCase).join(&quot;,&quot;);  &#125; else if (typeof arg &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;    return commonCase(arg());  &#125; else &#123;    return commonCase(arg.s);  &#125;  function commonCase(s: string): string &#123;    &#x2F;&#x2F; finally, just convert a string to another string    return s;  &#125;&#125;</code></pre><p>string, Array and Function have built-in type predicates, conveniently leaving the object type for the else branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.<br><code>字符串、数组和函数有内置类型推断，</code> 可以在 else 分支中推断出对象类型。<code>The following types have built-in predicates:</code>下面的类型有内置推断：<code>Type Predicate</code>类型推断&#96;</p><p>string typeof s &#x3D;&#x3D;&#x3D; “string”<br>number typeof n &#x3D;&#x3D;&#x3D; “number”<br>bigint typeof m &#x3D;&#x3D;&#x3D; “bigint”<br>boolean typeof b &#x3D;&#x3D;&#x3D; “boolean”<br>symbol typeof g &#x3D;&#x3D;&#x3D; “symbol”<br>undefined typeof undefined &#x3D;&#x3D;&#x3D; “undefined”<br>function typeof f &#x3D;&#x3D;&#x3D; “function”<br>array Array.isArray(a)<br>object typeof o &#x3D;&#x3D;&#x3D; “object”</p><p>Note that functions and arrays are objects at runtime, but have their own predicates.<br><code>函数和数组在运行时是对象，</code> 但是有自己的推断。&#96;</p><h3 id="Intersections"><a href="#Intersections" class="headerlink" title="Intersections"></a>Intersections</h3><p><code>交叉类型</code></p><p>In addition to unions, TypeScript also has intersections:<br><code>在 TypeScript 中，还有交叉类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Combined &#x3D; &#123; a: number &#125; &amp; &#123; b: string &#125;;type Conflicting &#x3D; &#123; a: number &#125; &amp; &#123; a: string &#125;;</code></pre><p>Combined has two properties, a and b, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so Conflicting.a: number &amp; string.<br><code>Combined 有两个属性，a 和 b， 如果写成一个对象字面量类型， 则 a 和 b 都是 number 和 string 类型。</code></p><h3 id="Unit-types"><a href="#Unit-types" class="headerlink" title="Unit types"></a>Unit types</h3><p><code>单元类型</code><br>Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string “foo” has the type “foo”. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:<br><code>单元类型是原始类型的子类型， 它们包含一个原始值。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;pad(&quot;hi&quot;, 10, &quot;left&quot;);</code></pre><p>When needed, the compiler widens — converts to a supertype — the unit type to the primitive type, such as “foo” to string. This happens when using mutability, which can hamper some uses of mutable variables:<br><code>当需要时，编译器会扩展， 将单元类型转换为原始类型， 例如 &quot;foo&quot; 转换为 string。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let s &#x3D; &quot;right&quot;;pad(&quot;hi&quot;, 10, s); &#x2F;&#x2F; error: &#39;string&#39; is not assignable to &#39;&quot;left&quot; | &quot;right&quot;&#39;Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot;&#39;.</code></pre><p>Here’s how the error happens:<br><code>这里有一个错误：</code><br>“right”: “right”</p><p>s: string because “right” widens to string on assignment to a mutable variable.<br>string is not assignable to “left” | “right”</p><p>You can work around this with a type annotation for s, but that in turn prevents assignments to s of variables that are not of type “left” | “right”.<br><code>你可以使用类型注解来解决这个问题， 但是这会导致 s 的赋值， 只能赋值给 &quot;left&quot; | &quot;right&quot; 类型的变量。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let s: &quot;left&quot; | &quot;right&quot; &#x3D; &quot;right&quot;;pad(&quot;hi&quot;, 10, s);</code></pre><h3 id="Concepts-similar-to-Haskell"><a href="#Concepts-similar-to-Haskell" class="headerlink" title="Concepts similar to Haskell"></a>Concepts similar to Haskell</h3><p><code>与 Haskell 类似的概念</code></p><h3 id="Contextual-typing"><a href="#Contextual-typing" class="headerlink" title="Contextual typing"></a>Contextual typing</h3><p><code>上下文类型</code></p><p>TypeScript has some obvious places where it can infer types, like variable declarations:<br><code>TypeScript 有一些明显的地方， 可以推断类型， 如变量声明。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let s &#x3D; &quot;I&#39;m a string!&quot;;</code></pre><p>But it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:<br><code>TypeScript 也可以推断在某些地方没有声明类型的情况下， 如果你已经使用其他 C-语言语法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare function map&lt;T, U&gt;(f: (t: T) &#x3D;&gt; U, ts: T[]): U[];let sns &#x3D; map((n) &#x3D;&gt; n.toString(), [1, 2, 3]);</code></pre><p>Here, n: number in this example also, despite the fact that T and U have not been inferred before the call. In fact, after [1,2,3] has been used to infer T&#x3D;number, the return type of n &#x3D;&gt; n.toString() is used to infer U&#x3D;string, causing sns to have the type string[].<br><code>这里， n: number 在这个例子中也， 即使在调用之前没有推断 T 和 U 的类型。 在实际上， 在 [1,2,3] 被用来推断 T=number 的时候， n =&gt; n.toString() 的返回类型会被用来推断 U=string， 导致 sns 的类型为 string[]。</code><br>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare map with the array first:<br><code>注意， 推断会工作在任何顺序， 但是 intellisense 只会从左到右， 因此 TypeScript 只会优先声明 map 函数， 先声明数组。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare function map&lt;T, U&gt;(ts: T[], f: (t: T) &#x3D;&gt; U): U[];</code></pre><p>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as string or number. And it can infer return types from context:<br><code>上下文类型也可以递归地通过对象字面量， 和单元类型， 如果没有声明类型， 则会被推断为 string 或 number。 并且可以从上下文中推断函数的返回类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare function run&lt;T&gt;(thunk: (t: T) &#x3D;&gt; void): T;let i: &#123; inference: string &#125; &#x3D; run((o) &#x3D;&gt; &#123;  o.inference &#x3D; &quot;INSERT STATE HERE&quot;;&#125;);</code></pre><p>The type of o is determined to be { inference: string } because<br><code>这个 o 的类型是由 run 函数的参数类型决定的， 因为</code><br>Declaration initializers are contextually typed by the declaration’s type: { inference: string }.<br><code>声明初始值是由声明的类型决定的</code><br>The return type of a call uses the contextual type for inferences, so the compiler infers that T&#x3D;{ inference: string }.<br><code>调用的返回类型是由上下文类型决定的， 因此编译器会推断 T=&#123; inference: string &#125;。</code><br>Arrow functions use the contextual type to type their parameters, so the compiler gives o: { inference: string }.<br><code>箭头函数使用上下文类型来类型参数， 因此编译器会给 o: &#123; inference: string &#125;。</code><br>And it does so while you are typing, so that after typing o., you get completions for the property inference, along with any other properties you’d have in a real program.<br><code>而且这样， 在你输入 o. 的时候， 你会得到 inference 的属性的完整补全， 同时也会有其他实际程序中的属性。</code><br>Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.<br><code>这个功能可以让 TypeScript 的推断看起来像一个统一类型推断引擎， 但是它不是。</code></p><h3 id="Type-aliases"><a href="#Type-aliases" class="headerlink" title="Type aliases"></a>Type aliases</h3><p><code>类型别名</code></p><p>Type aliases are mere aliases, just like type in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.<br><code>类型别名是类型别名， 像 Haskell 中的类型。 编译器会尝试使用别名名称在源代码中使用， 但不一定成功。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Size &#x3D; [number, number];let x: Size &#x3D; [101.1, 999.9];</code></pre><p>The closest equivalent to newtype is a tagged intersection:<br><code>最接近的等价是标记交集：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type FString &#x3D; string &amp; &#123; **compileTimeOnly: any &#125;;</code></pre><p>An FString is just like a normal string, except that the compiler thinks it has a property named **compileTimeOnly that doesn’t actually exist. This means that FString can still be assigned to string, but not the other way round.<br><code>FString 是一个普通字符串， 但是编译器认为它有一个名为 **compileTimeOnly 的属性， 这个属性并不存在。 这意味着 FString 仍然可以被赋值给 string， 但是不能被赋值给其他类型。</code></p><h3 id="Discriminated-Unions"><a href="#Discriminated-Unions" class="headerlink" title="Discriminated Unions"></a>Discriminated Unions</h3><p><code>可识别联合</code></p><p>The closest equivalent to data is a union of types with discriminant properties, normally called discriminated unions in TypeScript:<br><code>最接近的等价是数据的一个联合类型， 常见的是 TypeScript 中的分层联合：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Shape &#x3D;  | &#123; kind: &quot;circle&quot;; radius: number &#125;  | &#123; kind: &quot;square&quot;; x: number &#125;  | &#123; kind: &quot;triangle&quot;; x: number; y: number &#125;;</code></pre><p>Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading | is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:<br><code>与 Haskell 不同， 标记， 或者说分层联合的标记， 在每个对象类型中都是一个属性。 每个变体都有一个相同的属性， 并且它的单元类型不同。 这仍然是一个联合类型； 前面的 | 是联合类型的可选部分。 你可以使用普通的 JavaScript 代码来区分联合成员：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Shape &#x3D;| &#123; kind: &quot;circle&quot;; radius: number &#125;| &#123; kind: &quot;square&quot;; x: number &#125;| &#123; kind: &quot;triangle&quot;; x: number; y: number &#125;;function area(s: Shape) &#123;  if (s.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI _ s.radius _ s.radius;  &#125; else if (s.kind &#x3D;&#x3D;&#x3D; &quot;square&quot;) &#123;    return s.x _ s.x;  &#125; else &#123;  r eturn (s.x _ s.y) &#x2F; 2;  &#125;&#125;</code></pre><p>Note that the return type of area is inferred to be number because TypeScript knows the function is total. If some variant is not covered, the return type of area will be number | undefined instead.<br><code>注意， area 的返回类型被推断为 number， 因为 TypeScript 知道函数是完全的。 如果某个变体没有被覆盖， area 的返回类型将会是 number | undefined。</code><br>Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:<br><code>与 Haskell 不同， 共有属性在联合中显示， 你可以使用有效的方式来区分联合成员：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function height(s: Shape) &#123;  if (s.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return 2 \* s.radius;  &#125; else &#123;  &#x2F;&#x2F; s.kind: &quot;square&quot; | &quot;triangle&quot;    return s.x;  &#125;&#125;</code></pre><h3 id="Type-Parameters"><a href="#Type-Parameters" class="headerlink" title="Type Parameters"></a>Type Parameters</h3><p><code>参数类型</code><br>Like most C-descended languages, TypeScript requires declaration of type parameters:<br><code>类似于大多数 C-descended 语言， TypeScript 需要声明类型参数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function liftArray&lt;T&gt;(t: T): Array&lt;T&gt; &#123;  return [t];&#125;</code></pre><p>There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:<br><code>没有要求， 但是类型参数是一个惯例， 单大写字母。 类型参数可以被限制为一个类型， 这个类型行为类似于类型约束：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstish&lt;T extends &#123; length: number &#125;&gt;(t1: T, t2: T): T &#123;  return t1.length &gt; t2.length ? t1 : t2;&#125;</code></pre><p>TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.<br><code>TypeScript 可以通过调用参数的类型推断出类型参数， 因此通常不需要指定类型参数。</code><br>Because TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to propagate type information, such as constraining parameters to be the same type:<br><code>TypeScript 是结构性的， 不需要类型参数， 因为它们不需要使一个函数多态。 类型参数只是用来传递类型信息， 如限制参数为相同类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function length&lt;T extends ArrayLike&lt;unknown&gt;&gt;(t: T): number &#123;&#125;function length(t: ArrayLike&lt;unknown&gt;): number &#123;&#125;</code></pre><p>In the first length, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.<br><code>在第一个 length， T 没有必要； 可以注意， 它只被引用一次， 因此它不会被用来限制返回值或其他参数的类型。</code></p><h3 id="Higher-kinded-types"><a href="#Higher-kinded-types" class="headerlink" title="Higher-kinded types"></a>Higher-kinded types</h3><p><code>高阶类型</code></p><p>TypeScript does not have higher kinded types, so the following is not legal:<br><code>TypeScript 不支持高阶类型， 因此下面的不合法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function length&lt;T extends ArrayLike&lt;unknown&gt;, U&gt;(m: T&lt;U&gt;) &#123;&#125;</code></pre><h3 id="Point-free-programming"><a href="#Point-free-programming" class="headerlink" title="Point-free programming"></a>Point-free programming</h3><p>Point-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.<br><code>点-free 编程 — 重量级的使用 curry 和函数组合 — 在 JavaScript 中可以， 但是可能会很多。 在 TypeScript 中， 类型推断对点-free 编程失败， 因此你会指定类型参数而不是值参数。 结果是这样的多， 因此比较适合避免点-free 编程。</code></p><h3 id="Module-system"><a href="#Module-system" class="headerlink" title="Module system"></a>Module system</h3><p><code>模块系统</code></p><p>JavaScript’s modern module syntax is a bit like Haskell’s, except that any file with import or export is implicitly a module:<br><code>JavaScript 的现代模块语法和 Haskell 类似， 只是任何带有 import 或 export 的文件都是隐式的模块：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; value, Type &#125; from &quot;npm-package&quot;;import &#123; other, Types &#125; from &quot;.&#x2F;local-package&quot;;import \* as prefix from &quot;..&#x2F;lib&#x2F;third-package&quot;;</code></pre><p>You can also import commonjs modules — modules written using node.js’ module system:<br><code>你也可以导入 commonjs 模块 — 使用 node.js 的模块系统写的模块：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import f &#x3D; require(&quot;single-function-package&quot;);</code></pre><p>You can export with an export list:<br><code>你可以使用 export 列表导出：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export &#123; f &#125;;function f() &#123;  return g();&#125;function g() &#123;&#125; &#x2F;&#x2F; g is not exported</code></pre><p>Or by marking each export individually:<br><code>或者通过单独标记每个导出：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function f &#123; return g() &#125;function g() &#123; &#125;</code></pre><p>The latter style is more common but both are allowed, even in the same file.<br><code>后者更常见， 但是都可以， 即使在同一个文件中。</code></p><h3 id="readonly-and-const"><a href="#readonly-and-const" class="headerlink" title="readonly and const"></a>readonly and const</h3><p>In JavaScript, mutability is the default, although it allows variable declarations with const to declare that the reference is immutable. The referent is still mutable:<br><code>在 JavaScript 中， 可变性是默认的， 即使它允许使用 const 声明的变量声明引用是不可变的。 引用仍然可变：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const a &#x3D; [1, 2, 3];a.push(102); &#x2F;&#x2F; ):a[0] &#x3D; 101; &#x2F;&#x2F; D:</code></pre><p>TypeScript additionally has a readonly modifier for properties.<br><code>TypeScript 还有一个 readonly 属性修饰符。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Rx &#123;  readonly x: number;&#125;let rx: Rx &#x3D; &#123; x: 1 &#125;;rx.x &#x3D; 12; &#x2F;&#x2F; error</code></pre><p>It also ships with a mapped type Readonly<T> that makes all properties readonly:<br><code>它还有一个映射类型 Readonly&lt;T&gt;， 让所有属性都变成只读的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface X &#123;  x: number;&#125;let rx: Readonly&lt;X&gt; &#x3D; &#123; x: 1 &#125;;rx.x &#x3D; 12; &#x2F;&#x2F; error</code></pre><p>And it has a specific ReadonlyArray<T> type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:<br><code>它还有一个特殊的 ReadonlyArray&lt;T&gt; 类型， 去除了侧影响的方法和防止写入数组索引， 同时还有这种类型的特殊语法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let a: ReadonlyArray&lt;number&gt; &#x3D; [1, 2, 3];let b: readonly number[] &#x3D; [1, 2, 3];a.push(102); &#x2F;&#x2F; errorb[0] &#x3D; 101; &#x2F;&#x2F; error</code></pre><p>You can also use a const-assertion, which operates on arrays and object literals:<br><code>你也可以使用 const 断言， 它操作了数组和对象字面量：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let a &#x3D; [1, 2, 3] as const;a.push(102); &#x2F;&#x2F; errora[0] &#x3D; 101; &#x2F;&#x2F; error</code></pre><p>However, none of these options are the default, so they are not consistently used in TypeScript code.<br><code>但是， 没有这些选项是默认的， 因此它们不是一致地使用在 TypeScript 代码中。</code></p><h3 id="Next-Steps-2"><a href="#Next-Steps-2" class="headerlink" title="Next Steps"></a>Next Steps</h3><p><code>下一步</code></p><p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:<br><code>此文档是日常代码中的语法和类型一个高级的概览， 从这里你应该：</code><br>Read the full Handbook from start to finish (30m)<br><code>阅读完整的手册（30分钟）</code><br>Explore the Playground examples<br><code>探索 Playground 示例</code></p><h2 id="5-分钟内了解-Typescript"><a href="#5-分钟内了解-Typescript" class="headerlink" title="5 分钟内了解 Typescript"></a>5 分钟内了解 Typescript</h2><p>跳过，这部分比较简单，看原文吧，之后重点放到手册里。</p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-HTTPS</title>
      <link href="//post/2022-06-05https.html"/>
      <url>//post/2022-06-05https.html</url>
      
        <content type="html"><![CDATA[<h2 id="吐槽掘金"><a href="#吐槽掘金" class="headerlink" title="吐槽掘金"></a>吐槽掘金</h2><ul><li>后台有定时器在运行，一直发送请求，打开多个 web 标签页面，cpu 直接飙升到 100% +，鉴于掘金太卡，所以转载</li></ul><h2 id="为什么要有-HTTPS"><a href="#为什么要有-HTTPS" class="headerlink" title="为什么要有 HTTPS"></a>为什么要有 HTTPS</h2><p>在 HTTPS 出现之前，所有请求都是以明文方式送出的，那么如果有人在传输途中偷听或者抓包的话，你的所有通信内容都会泄漏。<br>比较安全的方法是将通信内容加密在发送给对方。加密方法有两种，对称加密和非对称加密。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul><li>对称加密指的是加密和解密用同一个密钥。</li><li>但是在通信之前，客户端和服务端是不会有这样同一把密钥的。需要其中一方将密钥发送给对方。</li><li>在整个传输过程没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。<br>所以纯对称加密是不安全的。</li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密指的是加密和解密用不同的密钥。可以是用私钥加密，公钥解密，也可以是用公钥加密，私钥解密。<br>但是会有这种情况。</p><ul><li>服务端拥有私钥和公钥，将公钥发给客户端。<br>既然客户端可以获得公钥，黑客也可以获得公钥。那么服务端发送给客户端的所有内容黑客也是可以解读的。</li><li>客户端用公钥加密发送给服务端不受影响，因为黑客手上没有服务器的私钥。<br>所以纯非对称加密也是不安全的。</li></ul><h2 id="传输密钥的过程"><a href="#传输密钥的过程" class="headerlink" title="传输密钥的过程"></a>传输密钥的过程</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/17217c84d03a66a9~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="图解传输密钥的过程"><a href="#图解传输密钥的过程" class="headerlink" title="图解传输密钥的过程"></a>图解传输密钥的过程</h2><p>HTTPS 采用对称加密来加密通信内容，所用的密钥称为 A。用非对称加密来加密密钥 A 再发送给对方（有点绕）。只要密钥 A 不落入他人手中，那传输的数据就不会被别人破译。</p><p>那么问题来了，要如何安全的将这把密钥送到对方手上呢？</p><p>我们来看密钥的传输过程<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/17218630ec9be8b3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="为什么-HTTPS-是可靠的？"><a href="#为什么-HTTPS-是可靠的？" class="headerlink" title="为什么 HTTPS 是可靠的？"></a>为什么 HTTPS 是可靠的？</h2><p>HTTPS 是可靠的，因为它解决了三个问题。</p><ol><li>加密通信，即使别人获取到了信息也没法复原成原来的信息。</li><li>防止中间人攻击。黑客没法冒充服务端。因为在第 2 步，服务端给了客户端一个 CA 证书。</li></ol><ul><li>如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠。</li><li>如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。</li></ul><ol start="3"><li>CA 证书的公信力<br>CA 证书需要由公司或者个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。<br>在技术层面上，CA 机构的公钥是写在操作系统或者浏览器里的。只有用 CA 机构的私钥加密的内容才能完成解密。确保了证书的确是 CA 机构发行的。</li></ol><h2 id="密钥的作用"><a href="#密钥的作用" class="headerlink" title="密钥的作用"></a>密钥的作用</h2><p>最后让我们再来回顾一下每一把密钥的作用<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/17217e2ee1709bcd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="HTTPS-一定安全吗"><a href="#HTTPS-一定安全吗" class="headerlink" title="HTTPS 一定安全吗"></a>HTTPS 一定安全吗</h2><p>非全站 HTTPS 并不安全</p><p>登录页面支持 HTTPS 不就行了，首页又没有涉及账户信息<br>其实这是非常不安全的行为，黑客会利用这一点进行攻击，一般是以下流程：</p><p>1.用户在首页点击「登录」，页面跳转到有 htps 的网银页面，但此时由于首页是 htp 请求，所以是明文的，这就会被黑客劫持 2.黑客劫持用户的跳转请求，将 https 网银页面地址转换为 http 的地址再发送给银行</p><p>用户&lt;&#x3D;&#x3D;HTTP&#x3D;&#x3D;&gt;黑客&lt;&#x3D;&#x3D;HTTPS&#x3D;&#x3D;&gt;银行</p><p>1.此时如果用户输入账户信息，那么会被中间的黑客获取，此时的账号密码就被泄露了</p><p>好在是银行的网银页面,只支持 htps,因此上述攻击暂时是无效的</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1w4411m7GL">【web 安全 3】【硬核】HTTPS 原理全解析</a></p><p>作者：站在书脊之上<br>链接：<a href="https://juejin.cn/post/6844904160089882631">https://juejin.cn/post/6844904160089882631</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-7 最佳实践</title>
      <link href="//post/2022-06-02vue-7.html"/>
      <url>//post/2022-06-02vue-7.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602200611.webp"></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="http://t-blog-images.aijs.top/img/20220602200621.webp"></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><img src="http://t-blog-images.aijs.top/img/20220602200638.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-8 typescript</title>
      <link href="//post/2022-06-02vue-8.html"/>
      <url>//post/2022-06-02vue-8.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602201222.webp"></p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h3><p><img src="http://t-blog-images.aijs.top/img/20220602201022.webp"></p><h3 id="选项式"><a href="#选项式" class="headerlink" title="选项式"></a>选项式</h3><p><img src="http://t-blog-images.aijs.top/img/20220602201032.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-6 升级规模</title>
      <link href="//post/2022-06-02vue-6.html"/>
      <url>//post/2022-06-02vue-6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602200123.webp"></p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p><img src="http://t-blog-images.aijs.top/img/20220602200102.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-5 内置组件</title>
      <link href="//post/2022-06-02vue-5.html"/>
      <url>//post/2022-06-02vue-5.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602195846.webp"></p><h2 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h2><p><img src="http://t-blog-images.aijs.top/img/20220602195059.webp"></p><h3 id="teleport·传送门"><a href="#teleport·传送门" class="headerlink" title="teleport·传送门"></a>teleport·传送门</h3><p><img src="http://t-blog-images.aijs.top/img/20220602195124.webp"></p><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p><img src="http://t-blog-images.aijs.top/img/20220602195153.webp"></p><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><p> <img src="http://t-blog-images.aijs.top/img/20220602195252.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-4 可重用性</title>
      <link href="//post/2022-06-02vue-4.html"/>
      <url>//post/2022-06-02vue-4.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602185624.webp"></p><h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p><img src="http://t-blog-images.aijs.top/img/20220602193659.webp"></p><h3 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193738.webp"></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193751.webp"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-3 深入组件</title>
      <link href="//post/2022-06-02vue-3.html"/>
      <url>//post/2022-06-02vue-3.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602185624.webp"></p><h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><p><img src="http://t-blog-images.aijs.top/img/20220602193405.webp"></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193158.webp"></p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193205.webp"></p><h3 id="透传-Attribute"><a href="#透传-Attribute" class="headerlink" title="透传 Attribute"></a>透传 Attribute</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193213.webp"></p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193228.webp"></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193235.webp"></p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193244.webp"></p><h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p><img src="http://t-blog-images.aijs.top/img/20220602193659.webp"></p><h3 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193738.webp"></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193751.webp"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-2 v3</title>
      <link href="//post/2022-06-02vue-2.html"/>
      <url>//post/2022-06-02vue-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602191916.webp"></p><h3 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192006.webp"></p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192306.webp"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192315.webp"></p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192323.webp"></p><h3 id="模版-ref"><a href="#模版-ref" class="headerlink" title="模版 ref"></a>模版 ref</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192333.webp"></p><h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192342.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-1 基础</title>
      <link href="//post/2022-06-02vue-1.html"/>
      <url>//post/2022-06-02vue-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><h2 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h2><p><img src="http://t-blog-images.aijs.top/img/20220602190150.webp"></p><h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><!-- ![](http://t-blog-images.aijs.top/img/20220602190219.webp) --><p><img src="http://t-blog-images.aijs.top/img/20220602191619.webp"></p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><!-- ![](http://t-blog-images.aijs.top/img/20220602190321.webp) --><p><img src="http://t-blog-images.aijs.top/img/20220602191251.webp"></p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p><img src="http://t-blog-images.aijs.top/img/20220602190525.webp"></p><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p><img src="http://t-blog-images.aijs.top/img/20220602190828.webp"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><img src="http://t-blog-images.aijs.top/img/20220602191049.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-0 概览</title>
      <link href="//post/2022-06-02vue-0.html"/>
      <url>//post/2022-06-02vue-0.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><ul><li>使用 proxy 重写了 vue2，并增加了组合式 api</li><li>以下思维导图以<a href="https://staging-cn.vuejs.org/">vue3 文档</a>内容为依据，在学习过程中绘制</li><li>学习过程中对比了 vue3 和 react</li><li>很长一段时间没看vue了，vue3一直没接触，媳妇不学。万一哪天媳妇需要用vue3了，没人带岂不是要失业，赶紧学起来～</li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><!-- ![](http://t-blog-images.aijs.top/img/20220602185624.webp) --><!-- ![](http://t-blog-images.aijs.top/img/20220602201338.webp) --><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>念叨着 <code>渐进式</code> <code>依赖收集</code> 去学习<a href="https://staging-cn.vuejs.org/guide/introduction.html">vue指南</a></li></ul><p><img src="http://t-blog-images.aijs.top/img/20220602201731.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react useState 错误使用</title>
      <link href="//post/2022-05-31bug.html"/>
      <url>//post/2022-05-31bug.html</url>
      
        <content type="html"><![CDATA[<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const Share: FC&lt;ShareProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const &#123; entityType, entityCode &#125; &#x3D; props  const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;    value: props.value,    title: props.title,    shareId: props.shareId,    mappingPassword: props.mappingPassword,    passwordEnable: props.passwordEnable,    mappingState: props.mappingState,    expireTime: props.expireTime,    shortCode: props.shortCode,  &#125;)  const &#123; value &#125; &#x3D; state  ...  return (    &lt;div&gt;      &#123;renderBtn&#125;      &lt;ShareModal        entityType&#x3D;&#123;entityType&#125;        entityCode&#x3D;&#123;entityCode&#125;        &#123;...modalProps&#125;        state&#x3D;&#123;state&#125;        setState&#x3D;&#123;setState&#125;      &#x2F;&gt;    &lt;&#x2F;div&gt;  )&#125;export default Share</code></pre><h2 id="ShareModal"><a href="#ShareModal" class="headerlink" title="ShareModal"></a>ShareModal</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface ShareModalProps extends ModalFuncProps &#123;  entityType: EntityType  entityCode: string  className?: string  state: StateProps  setState: (state: StateProps) &#x3D;&gt; void&#125;const Copy &#x3D; (&#123; text, children &#125;: &#123; text: string; children: string &#125;) &#x3D;&gt; &#123;  return (    &lt;CopyToClipboard      text&#x3D;&#123;text&#125;      onCopy&#x3D;&#123;() &#x3D;&gt; &#123;        message.success(&#39;链接已复制&#39;)      &#125;&#125;    &gt;      &lt;span&gt;&#123;children&#125;&lt;&#x2F;span&gt;    &lt;&#x2F;CopyToClipboard&gt;  )&#125;const ShareModal: FC&lt;ShareModalProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const [form] &#x3D; HookForm.useForm()  const &#123; state, setState, entityType, entityCode, ...restProps &#125; &#x3D; props  const &#123; value, title, mappingPassword, shortCode, expireTime &#125; &#x3D; state  const &#123;    onChange: toggle,    resetPassword: reset,    update,  &#125; &#x3D; useShare(&#123;    entityCode,    entityType,    state,    setState,  &#125;)  ....  return (    &lt;Modal      &#123;...restProps&#125;      className&#x3D;&#123;styles[&#39;share-modal-wrap&#39;]&#125;      title&#x3D;&quot;链接分享&quot;      destroyOnClose      width&#x3D;&#123;420&#125;      footer&#x3D;&#123;null&#125;    &gt;      &lt;ConditionComponent isShow&#x3D;&#123;value&#125;&gt;        ....        &lt;HookForm form&#x3D;&#123;form&#125; style&#x3D;&#123;&#123; marginBottom: 10, width: &#39;100%&#39; &#125;&#125; layout&#x3D;&quot;vertical&quot;&gt;          &lt;HookForm.Item noStyle shouldUpdate&gt;            &#123;() &#x3D;&gt; &#123;              const &#123; url, mappingPassword, expireTime &#125; &#x3D; form.getFieldsValue()              const text &#x3D; &#96;$&#123;url&#125;（密码：$&#123;mappingPassword&#125;）《$&#123;title&#125;》$&#123;moment(                expireTime,              ).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)&#125;过期&#96;              return (                &lt;HookForm.Item name&#x3D;&quot;url&quot; label&#x3D;&quot;&quot;&gt;                  &lt;Input                    className&#x3D;&#123;styles[&#39;share-copy&#39;]&#125;                    addonAfter&#x3D;&#123;&lt;Copy text&#x3D;&#123;text&#125;&gt;复制链接和密码&lt;&#x2F;Copy&gt;&#125;                    disabled                  &#x2F;&gt;                &lt;&#x2F;HookForm.Item&gt;              )            &#125;&#125;          &lt;&#x2F;HookForm.Item&gt;        &lt;&#x2F;HookForm&gt;      &lt;&#x2F;ConditionComponent&gt;    &lt;&#x2F;Modal&gt;  )&#125;export default ShareModal</code></pre><h2 id="用户反馈"><a href="#用户反馈" class="headerlink" title="用户反馈"></a>用户反馈</h2><p>为什么分享的链接与要分享的链接对不上？</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useCallback 受依赖项的影响，不更新，之前改过同事的代码，这次扫了一样，没有 callback，就这问题修改几个了</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><ul><li><p>找了下数据<code>ShareModal</code>组件,看到两个入参<code>state, setState</code> ，我艹</p></li><li><p>继续往上层找</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&lt;ShareModal  entityType&#x3D;&#123;entityType&#125;  entityCode&#x3D;&#123;entityCode&#125;  &#123;...modalProps&#125;  state&#x3D;&#123;state&#125; &#x2F;&#x2F; 😓  setState&#x3D;&#123;setState&#125; &#x2F;&#x2F;😓&#x2F;&gt;</code></pre></li><li><p>再往上找，useState 内部只执行一次，数据初始化完成不再改变</p></li></ul><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;  value: props.value,  title: props.title,  shareId: props.shareId,  mappingPassword: props.mappingPassword,  passwordEnable: props.passwordEnable,  mappingState: props.mappingState,  expireTime: props.expireTime,  shortCode: props.shortCode,&#125;);const &#123; value &#125; &#x3D; state;</code></pre><ul><li>这里代码这么写，其他地方肯定也有这样的写法，😓</li></ul><h2 id="改一下"><a href="#改一下" class="headerlink" title="改一下"></a>改一下</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;&#125;);useEffect(() &#x3D;&gt; &#123;  setState(&#123; ...props &#125;);&#125;, [props.shareId]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-编程范式-函数式编程简单了解</title>
      <link href="//post/2022-05-28func.html"/>
      <url>//post/2022-05-28func.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>js 为了实现面向对象的思想，做了很多事情，导致大家在学习 js 的时候，会遇到复杂的原型、原型链、继承，还有对人不友好的 this ；而当我们用这些东西组合起来模拟面向对象的特性的时候，就更加痛苦了。但我们可以使用一种更友好的方式，函数式编程。<br><strong>简单来说就是：面向对象的思想在 js 中不是很好用</strong></p><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>函数式编程（functional programing）是编程范式之一。我们常见的范式还有面向过程、面向行为、面向对象等。</p><p>范式：我们可以认为它是一种<code>思维模式</code>加上它的实现方法，<code>简单说就是编程的方法论</code>。</p><ul><li><p><strong>面向过程编程</strong>：简单解释就是按照步骤来实现。</p></li><li><p><strong>面向行为编程</strong>：它是函数式编程的衍生范型，将电脑运算平展为一系列的变化，并且避免使用程序指令以及堆叠的对象。</p></li><li><p><strong>面向对象编程</strong>：它的思维方式是把现实世界中的事物抽象成程序世界中的类和对象，然后通过封装，继承和多态来演示事物之间的联系。</p></li><li><p><strong>面向函数式编程</strong>：它的思维方式是把现实世界中的事物和事物之间的联系，抽象到程序世界中。</p></li></ul><h2 id="函数式编程特点："><a href="#函数式编程特点：" class="headerlink" title="函数式编程特点："></a>函数式编程特点：</h2><ul><li><p>程序的本质：就是利用计算机的计算能力将输入转化成对应的输出。</p></li><li><p>函数式编程中的函数指的不是编程语言里的函数，而是数学意义上的映射关系。比如 y&#x3D;sin(x) 中 x 和 y 值的映射关系。</p></li><li><p>纯函数：相同的输入获得相同的输出（无副作用）。</p></li><li><p>函数式编程就是对数据(函数)映射关系的抽象。</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>高阶函数</li><li>闭包</li><li>纯函数</li><li>柯里化</li><li>组合函数</li></ul><h2 id="三大编程范式"><a href="#三大编程范式" class="headerlink" title="三大编程范式"></a>三大编程范式</h2><h3 id="编程范式有以下三种："><a href="#编程范式有以下三种：" class="headerlink" title="编程范式有以下三种："></a>编程范式有以下三种：</h3><p>1、面向对象编程<br>2、面向过程编程<br>3、面向函数编程</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><span style="color: red">面向对象编程最大的特点是：以类、对象作为组织代码的单元以及它的四大特性。<p>面向过程编程最大的特点是：以函数作为组织代码的单元，数据与方法相分离。</p><p>函数式编程跟面向过程编程一样，也是以函数作为组织代码的单元。</p><p>不过，它跟面向过程编程的区别在于，它的函数是无状态的。<br></span></p><h3 id="何为无状态？"><a href="#何为无状态？" class="headerlink" title="何为无状态？"></a>何为无状态？</h3><p>简单点讲就是，函数内部涉及的变量都是局部变量，<br>不会像面向对象编程那样，共享类成员变量，<br>也不会像面向过程编程那样，共享全局变量。<br>函数的执行结果只与入参有关，跟其他任何外部变量无关。<br>同样的入参，不管怎么执行，得到的结果都是一样的。<br>这实际上就是数学函数或数学表达式的基本要求。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>不同的编程范式之间并不是截然不同的，总是有一些相同的编程规则。<br>比如，不管是面向过程、面向对象还是函数式编程，它们都有变量、函数的概念，<br>最顶层都要有 main 函数执行入口，来组装编程单元（类、函数等）。<br>只不过，面向对象的编程单元是类或对象，面向过程的编程单元是函数，函数式编程的编程单元是无状态函数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zoo.team/article/function-production"></a><br><a href="https://blog.csdn.net/weixin_43871678/article/details/124617216" target="_blank" >三大编程范式</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wiki Laser Pen</title>
      <link href="//post/2022-05-27wiki-laserPen.html"/>
      <url>//post/2022-05-27wiki-laserPen.html</url>
      
        <content type="html"><![CDATA[<h2 id="Laser-Pen"><a href="#Laser-Pen" class="headerlink" title="Laser Pen"></a>Laser Pen</h2><p><code>Laser Pen </code>是一套用来在 web canvas 上绘制鼠标轨迹的工具集。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>wiki</code>全屏演示时候，为了便于听众跟随演讲者进度，给鼠标轨迹加上标记。</p><p><img src="http://t-blog-images.aijs.top/img/demo.gif"></p><p>注：公司项目由于版权问题，不便演示</p><h2 id="初步上手"><a href="#初步上手" class="headerlink" title="初步上手"></a>初步上手</h2><p>首先在你的项目中添加对 Laser Pen 的依赖：</p><pre class="line-numbers language-none"><code class="language-none">yarn add laser-pen</code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">npm i laser-pen</code></pre><p>然后监听鼠标的 move 事件，获取鼠标移动轨迹的坐标，并同时记录 move 事件触发时的时间戳。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 获取 canvas 元素的坐标const canvasDom &#x3D; document.querySelector(&#39;canvas&#39;)const canvasPos &#x3D; canvasDom.getBoundingClientRect()const ctx &#x3D; canvas.getContext(&#39;2d&#39;)&#x2F;&#x2F; 用来存储所有鼠标轨迹数据let mouseTrack &#x3D; []&#x2F;&#x2F; 监听鼠标事件document.addEventListener(&#39;mousemove&#39;, (event) &#x3D;&gt; &#123;  mouseTrack.push(&#123;    x: event.clientX - canvasPos.x,    y: event.clientY - canvasPos.y,    time: Date.now(),  &#125;)&#125;)</code></pre><p>最后在调用 drawLaserPen 方法绘制鼠标轨迹</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123; drainPoints, drawLaserPen &#125; from &#39;laser-pen&#39;function draw() &#123;  &#x2F;&#x2F; 过滤掉一些失效的轨迹坐标  mouseTrack &#x3D; drainPoints(mouseTrack)  if (mouseTrack.length &gt;&#x3D; 3) &#123;    &#x2F;&#x2F; 绘制鼠标轨迹    drawLaserPen(ctx, mouseTrack)  &#125;  requestAnimation(draw)&#125;</code></pre><p>到这里，你应该已经可以在 canvas 上实现鼠标轨迹的绘制了。</p><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>如果默认的轨迹效果不能满足你的要求，Laser Pen 还提供了一些接口让你可以方便的修改鼠标轨迹的样式。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 设置延迟时间，mousemove 事件产生的坐标点在超过延迟时间后就不会被绘制，会直接影响轨迹的长度setDelay: (millisecond: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的最大宽度，轨迹是一条由粗变细的曲线，maxWidth 表示粗的那一头的线宽setMaxWidth: (width: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的最小宽度，轨迹是一条由粗变细的曲线，minWidth 表示细的那一头的线宽setMinWidth: (width: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置曲线张力大小，张力越大拐点处越平滑，反之越尖锐setTension: (t: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的最小透明度，轨迹是一条由不透明变透明的曲线，opacity 表示轨迹末尾的不透明度setOpacity: (o: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的颜色setColor: (r: number, g: number, b: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹头部是否是圆形setRoundCap: (b: boolean) &#x3D;&gt; void;</code></pre><p>在任何时候调用上述接口修改鼠标轨迹的样式，都会在紧接着的下一次绘制中生效。所以如果你想实现一个类似 RGB 跑马灯的鼠标轨迹也是可以的。</p><h2 id="定制化开发"><a href="#定制化开发" class="headerlink" title="定制化开发"></a>定制化开发</h2><p>如果上面的接口都不能满足你的要求，那么你就需要做一些定制化的开发了。</p><p>绘制鼠标轨迹的过程大概分为 5 个步骤：</p><p>清洗轨迹坐标数据<br>根据轨迹坐标计算每个坐标的控制点<br>通过坐标点和控制点数据生成 Bezier 曲线<br>将上一步生成的曲线分割为更短的 Bezier 曲线，并计算每条曲线的绘制样式<br>依次绘制每条 Bezier 曲线<br>这 5 个步骤对应下面的第 1 到第 5 个接口，最后的 drawLaserPen 接口是对前面 5 个接口的组合。 如果直接调用 drawLaserPen 不能满足你的要求，你可以在前 5 个接口的基础上自行组合，实现你想要的效果。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 去掉原始鼠标坐标数据中不合理的数据，包括超过延迟时间的坐标，和一些排列不合法的坐标drainPoints: (originalPoints: IOriginalPointData[]) &#x3D;&gt; IOriginalPointData[];&#x2F;&#x2F; 根据鼠标坐标数据计算每个坐标点的前后控制点calControlPoints: (points: IPoint[]) &#x3D;&gt; IControlPoint[];&#x2F;&#x2F; 将鼠标坐标数据和控制点数据组合为贝塞尔曲线transformPointToBezier: (  points: IPoint[],  controlPoints: IControlPoint[]) &#x3D;&gt; Bezier[];&#x2F;&#x2F; 根据原始的贝塞尔曲线数据，计算出用于绘制的数据结构calDrawingData: (  bzArray: Bezier[],  totalLength: number) &#x3D;&gt; IDrawingBezierData[];&#x2F;&#x2F; 根据计算出的绘制数据，将曲线绘制到画布上drawDrawingBezierData: (  ctx: CanvasRenderingContext2D,  data: IDrawingBezierData[]) &#x3D;&gt; void;&#x2F;&#x2F; 一个方便简单使用的入口方法，直接通过处理好的鼠标坐标数据，绘制鼠标轨迹drawLaserPen: (ctx: CanvasRenderingContext2D, points: IPoint[]) &#x3D;&gt; void;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/SilentTiger/laser-pen">laser-pen</a></li><li>突然有个想法：王者荣耀的拖尾效果实现原理，是不是和这个类似？</li></ul>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-logger源码</title>
      <link href="//post/2022-05-27redux-logger.html"/>
      <url>//post/2022-05-27redux-logger.html</url>
      
        <content type="html"><![CDATA[<h2 id="redux-日志中间件"><a href="#redux-日志中间件" class="headerlink" title="redux 日志中间件"></a>redux 日志中间件</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">.├── core.js├── defaults.js├── diff.js├── helpers.js &#x2F;&#x2F; 一些帮助函数└── index.js0 directories, 5 files</code></pre><h2 id="defaultLogger"><a href="#defaultLogger" class="headerlink" title="defaultLogger"></a>defaultLogger</h2><p><strong>v3 版本，破坏性变更</strong></p><p>之前</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import createLogger from &quot;redux-logger&quot;;</code></pre><p>之后</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; createLogger &#125; from &quot;redux-logger&quot;;</code></pre><p><strong>源码</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; src&#x2F;index.jsconst defaultLogger &#x3D; (&#123; dispatch, getState &#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  if (typeof dispatch &#x3D;&#x3D;&#x3D; &quot;function&quot; || typeof getState &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;    &#x2F;&#x2F; createLogger，柯里化 工厂模式    return createLogger()(&#123; dispatch, getState &#125;);  &#125;  &#x2F;&#x2F; 如果没有传递dispatch和getState，打印错误信息  &#x2F;&#x2F; v3版本，破坏性变更, 根据《语义化版本》不看内容也知道有破坏性变更  &#x2F;&#x2F; Since 3.0.0 redux-logger exports by default logger with default settings  &#x2F;&#x2F; import createLogger from &#39;redux-logger&#39; &#x3D;&gt; import &#123; createLogger &#125; from &#39;redux-logger&#39;  console.error(&#96;[redux-logger v3] BREAKING CHANGE[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.[redux-logger v3] Change[redux-logger v3] import createLogger from &#39;redux-logger&#39;[redux-logger v3] to[redux-logger v3] import &#123; createLogger &#125; from &#39;redux-logger&#39;&#96;);&#125;;export &#123; defaults, createLogger, defaultLogger as logger &#125;;export default defaultLogger;</code></pre><h2 id="createLogger"><a href="#createLogger" class="headerlink" title="createLogger"></a>createLogger</h2><ul><li>使用传入的 options， 创建日志记录器</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * Creates logger with following options * 创建日志记录器，配置如下： * @namespace * @param &#123;object&#125; options - options for logger * @param &#123;string | function | object&#125; options.level - console[level] 日志级别 * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间 * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳 * @param &#123;object&#125; options.colors - custom colors 定制颜色 * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现 * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出 * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组 * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为 * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换 * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换 * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换 * * @returns &#123;function&#125; logger middleware 返回中间件 *&#x2F;function createLogger(options &#x3D; &#123;&#125;) &#123;  const loggerOptions &#x3D; Object.assign(&#123;&#125;, defaults, options);  const &#123;    logger,    stateTransformer,    errorTransformer,    predicate,    logErrors,    diffPredicate,  &#125; &#x3D; loggerOptions;  &#x2F;&#x2F; Return if &#39;console&#39; object is not defined  &#x2F;&#x2F; 如果&#39;console&#39;对象未定义，返回  if (typeof logger &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);  &#125;  &#x2F;&#x2F; Detect if &#39;createLogger&#39; was passed directly to &#39;applyMiddleware&#39;.  &#x2F;&#x2F; 判断是否传递给applyMiddleware  if (options.getState &amp;&amp; options.dispatch) &#123;    &#x2F;&#x2F; eslint-disable-next-line no-console    console.error(&#96;[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:&#x2F;&#x2F; Logger with default optionsimport &#123; logger &#125; from &#39;redux-logger&#39;const store &#x3D; createStore(  reducer,  applyMiddleware(logger))&#x2F;&#x2F; Or you can create your own logger with custom options http:&#x2F;&#x2F;bit.ly&#x2F;redux-logger-optionsimport &#123; createLogger &#125; from &#39;redux-logger&#39;const logger &#x3D; createLogger(&#123;  &#x2F;&#x2F; ...options&#125;);const store &#x3D; createStore(  reducer,  applyMiddleware(logger))&#96;);    &#x2F;&#x2F; 中间件书写套路    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);  &#125;  const logBuffer &#x3D; [];  return (&#123; getState &#125;) &#x3D;&gt;    (next) &#x3D;&gt;    (action) &#x3D;&gt; &#123;      &#x2F;&#x2F; Exit early if predicate function returns &#39;false&#39; 如果predicate函数返回false，退出      if (typeof predicate &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; !predicate(getState, action)) &#123;        return next(action);      &#125;      const logEntry &#x3D; &#123;&#125;;      logBuffer.push(logEntry);      logEntry.started &#x3D; timer.now();      logEntry.startedTime &#x3D; new Date();      logEntry.prevState &#x3D; stateTransformer(getState());      logEntry.action &#x3D; action;      let returnedValue;      if (logErrors) &#123;        try &#123;          returnedValue &#x3D; next(action);        &#125; catch (e) &#123;          logEntry.error &#x3D; errorTransformer(e);        &#125;      &#125; else &#123;        returnedValue &#x3D; next(action);      &#125;      logEntry.took &#x3D; timer.now() - logEntry.started;      logEntry.nextState &#x3D; stateTransformer(getState());      const diff &#x3D;        loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;          ? diffPredicate(getState, action)          : loggerOptions.diff;      printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;));      logBuffer.length &#x3D; 0;      if (logEntry.error) throw logEntry.error;      return returnedValue;    &#125;;&#125;</code></pre><p><strong>defaults 默认配置</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; src&#x2F;default.jsexport default &#123;  level: &quot;log&quot;,  logger: console,  logErrors: true,  collapsed: undefined,  predicate: undefined,  duration: false,  timestamp: true,  stateTransformer: (state) &#x3D;&gt; state,  actionTransformer: (action) &#x3D;&gt; action,  errorTransformer: (error) &#x3D;&gt; error,  colors: &#123;    title: () &#x3D;&gt; &quot;inherit&quot;,    prevState: () &#x3D;&gt; &quot;#9E9E9E&quot;,    action: () &#x3D;&gt; &quot;#03A9F4&quot;,    nextState: () &#x3D;&gt; &quot;#4CAF50&quot;,    error: () &#x3D;&gt; &quot;#F20404&quot;,  &#125;,  diff: false,  diffPredicate: undefined,  &#x2F;&#x2F; Deprecated options 已废弃配置  transformer: undefined,&#125;;&#x2F;&#x2F; 字段释义&#x2F;** * Creates logger with following options * 创建日志记录器，配置如下： * @namespace * @param &#123;object&#125; options - options for logger * @param &#123;string | function | object&#125; options.level - console[level] 日志级别 * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间 * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳 * @param &#123;object&#125; options.colors - custom colors 定制颜色 * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现 * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出 * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组 * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为 * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换 * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换 * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换 * * @returns &#123;function&#125; logger middleware 返回中间件 *&#x2F;</code></pre><p><strong>奇怪</strong></p><ul><li>这两个配置在测试文件中，没找到相关测试代码</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> &#x2F;&#x2F; 配置 diff: false, &#x2F;&#x2F; diffPredicate: undefined, &#x2F;&#x2F; ... const diff &#x3D;       loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;         ? diffPredicate(getState, action)         : loggerOptions.diff; &#x2F;&#x2F; 打印日志中 printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;)); &#x2F;&#x2F; src&#x2F;core.js printBuffer的定义function printBuffer(buffer, options) &#123;   const &#123;     &#x2F;&#x2F; ...       diff,   &#125; &#x3D; options;   &#x2F;&#x2F; 如果开启   if (diff) &#123;     &#x2F;&#x2F; 执行了 diffLogger     diffLogger(prevState, nextState, logger, isCollapsed);   &#125;&#125;&#x2F;&#x2F; src&#x2F;diff.jsexport default function diffLogger(prevState, newState, logger, isCollapsed) &#123;  &#x2F;&#x2F; import differ from &#39;deep-diff&#39;;计算对象差异化的包  const diff &#x3D; differ(prevState, newState);  try &#123;    if (isCollapsed) &#123;      logger.groupCollapsed(&#39;diff&#39;);    &#125; else &#123;      logger.group(&#39;diff&#39;);    &#125;  &#125; catch (e) &#123;    logger.log(&#39;diff&#39;);  &#125;  &#x2F;&#x2F; 有差异执行输出，这个差异包含类型kind E:编辑 N:新增 D:删除 A:数组  &#x2F;&#x2F; dictionary为对象，对kind值进行枚举  &#x2F;&#x2F; 遍历输出  if (diff) &#123;    diff.forEach((elem) &#x3D;&gt; &#123;      const &#123; kind &#125; &#x3D; elem;      const output &#x3D; render(elem);      logger.log(&#96;%c $&#123;dictionary[kind].text&#125;&#96;, style(kind), ...output);    &#125;);  &#125; else &#123;    logger.log(&#39;—— no diff ——&#39;);  &#125;  try &#123;    logger.groupEnd();  &#125; catch (e) &#123;    logger.log(&#39;—— diff end —— &#39;);  &#125;&#125;</code></pre><h2 id="helpers"><a href="#helpers" class="headerlink" title="helpers"></a>helpers</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; repeat + pad &#x3D; padLeft 左侧补零， es多少有个apiexport const repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);export const pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;&#x2F;&#x2F; 时间格式化export const formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;&#x2F;&#x2F; Use performance API if it&#39;s available in order to get better precisionexport const timer &#x3D;(typeof performance !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; performance !&#x3D;&#x3D; null) &amp;&amp; typeof performance.now &#x3D;&#x3D;&#x3D; &#39;function&#39; ?  performance :  Date;</code></pre><p><strong>运行测试下</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);const pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;const formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;console.log(formatTime(new Date()))&#x2F;&#x2F; 输出18:58:15.667</code></pre><h2 id="源码图"><a href="#源码图" class="headerlink" title="源码图"></a>源码图</h2><p><img src="http://t-blog-images.aijs.top/img/20220527190102.webp"></p><h2 id="deep-diff"><a href="#deep-diff" class="headerlink" title="deep-diff"></a>deep-diff</h2><ul><li>看下两个对象比较的事例</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var lhs &#x3D; &#123;name: &#39;my object&#39;,description: &#39;it\&#39;s an object!&#39;,details: &#123;it: &#39;has&#39;,an: &#39;array&#39;,with: [&#39;a&#39;, &#39;few&#39;, &#39;elements&#39;]&#125;&#125;;var rhs &#x3D; &#123;name: &#39;updated object&#39;,description: &#39;it\&#39;s an object!&#39;,details: &#123;it: &#39;has&#39;,an: &#39;array&#39;,with: [&#39;a&#39;, &#39;few&#39;, &#39;more&#39;, &#39;elements&#39;, &#123; than: &#39;before&#39; &#125;]&#125;&#125;;var differences &#x3D; deep.diff(lhs, rhs);&#x2F;&#x2F; 输出27 May 17:27:12 - [  DiffEdit &#123;    kind: &#39;E&#39;,    path: [ &#39;name&#39; ],    lhs: &#39;my object&#39;,    rhs: &#39;updated object&#39;  &#125;,  DiffArray &#123;    kind: &#39;A&#39;,    path: [ &#39;details&#39;, &#39;with&#39; ],    index: 4,    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#123; than: &#39;before&#39; &#125; &#125;  &#125;,  DiffArray &#123;    kind: &#39;A&#39;,    path: [ &#39;details&#39;, &#39;with&#39; ],    index: 3,    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#39;elements&#39; &#125;  &#125;,  DiffEdit &#123;    kind: &#39;E&#39;,    path: [ &#39;details&#39;, &#39;with&#39;, 2 ],    lhs: &#39;elements&#39;,    rhs: &#39;more&#39;  &#125;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode i18n-ally</title>
      <link href="//post/2022-05-27i18n.html"/>
      <url>//post/2022-05-27i18n.html</url>
      
        <content type="html"><![CDATA[<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><ul><li>大型公司的国际化需求很高，需要支持多语言，比如中文、英文、日文等等。</li><li>i18n-ally是一个基于vscode的国际化工具，可以帮助你快速的实现国际化。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>如果经常做国际化的研发，应该很清楚，代码中写多语言，然而，多语言在项目中维护是非常困难的。</li><li>当遇到大型项目，业务要做拆分成为<code>微前端架构</code>，多语言要在多个项目中维护，浪费时间不说，还可能造成不一致问题</li><li>处理方式：<ol><li>将对应的多语言开发为npm包，在项目中引入</li><li>拆多语言为一个应用平台，实现多项目共享，实现可视化交互（我们目前使用，自研localize平台，实现多语言管理）</li></ol></li></ul><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><strong>应用平台</strong></p><ul><li>动态生效： 修改多语言不需要重启、发布服务</li><li>翻译管理：多人协同在线翻译</li><li>版本管理： 记录翻译变更记录以及对应的操作人，方便定位与排错</li><li>自动多区同步：只需在中国区修改，系统会自动同步到国外5区</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>提示优雅，未处理的多语言会有提示</li><li>编辑方便</li></ul><p align="center"><img src="https://github.com/lokalise/i18n-ally/blob/main/screenshots/full-logo-new.png?raw=true" alt="logo" width="450"/></p><p align='center'>English | <a href="https://github.com/lokalise/i18n-ally/blob/main/README.zh-CN.md">简体中文</a></p><p align="center" style="display: flex; flex-wrap: wrap"><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://img.shields.io/visual-studio-marketplace/v/lokalise.i18n-ally.svg?color=blue&amp;label=VS%20Code%20Marketplace&logo=visual-studio-code" alt="Visual Studio Marketplace Version" /></a><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://img.shields.io/visual-studio-marketplace/d/lokalise.i18n-ally.svg?color=4bdbe3" alt="Visual Studio Marketplace Downloads" /></a><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://img.shields.io/visual-studio-marketplace/i/lokalise.i18n-ally.svg?color=63ba83" alt="Visual Studio Marketplace Installs" /></a><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://vsmarketplacebadge.apphb.com/trending-monthly/lokalise.i18n-ally.svg?color=a1b858" alt="Marketplace Trending Monthly" /></a><br/><a href="https://github.com/lokalise/i18n-ally/wiki" target="__blank"><img alt="Wiki" src="https://img.shields.io/static/v1?label=docs&message=wiki&color=e3897b"></a><a href="https://github.com/lokalise/i18n-ally" target="__blank"><img src="https://img.shields.io/github/last-commit/lokalise/i18n-ally.svg?color=c977be" alt="GitHub last commit" /></a><a href="https://github.com/lokalise/i18n-ally/issues" target="__blank"><img src="https://img.shields.io/github/issues/lokalise/i18n-ally.svg?color=a38eed" alt="GitHub issues" /></a><a href="https://github.com/lokalise/i18n-ally" target="__blank"><img alt="GitHub stars" src="https://img.shields.io/github/stars/lokalise/i18n-ally?style=social"></a></p><p align='center'><b>v2.0</b> is released with new <a href='https://github.com/lokalise/i18n-ally/wiki/Editor-UI'>Editor UI</a> and <a href='https://github.com/lokalise/i18n-ally/wiki/Review-&-Collaboration-System'>Review System</a> 🎉</p><p align='center'><i><a href="https://github.com/lokalise/i18n-ally/wiki/Migration-v1.x">Migrate from v1.x</a></i></p><br><p align="center"><a href='https://github.com/lokalise/i18n-ally/wiki/Supported-Frameworks' target="__blank"><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/supported-frameworks.png?raw=true" alt="Supported Frameworks" width="550"/></a></p><h3 align="center">Maintained by</h3><p align="center"><a title="Lokalise: accelerate localization from code to delivery" href="https://lokalise.com/?utm_source=vscmarket&amp;utm_campaign=i18nally&amp;utm_medium=banner"><img src="https://github.com/lokalise/i18n-ally/raw/screenshots/lokalise-logo.png?raw=true" alt="Lokalise logo" width="275px"></a><br><sup>Lokalise is the fastest growing language cloud technology made by developers, for developers.<br>As a collaborative productivity platform, it helps structure and automate the translation and localization process for any company in the world.<br>Lokalise是开发人员为开发人员开发的增长最快的语言云技术<br>作为一个协作生产力平台，它可以帮助世界上任何公司构建和自动化翻译和本地化过程。<a title="Lokalise: accelerate localization from code to delivery" href="https://lokalise.com/?utm_source=vscmarket&amp;utm_campaign=i18nally&amp;utm_medium=banner">Learn more</a></sup></p><br><br><h4 align="center"><a href="https://github.com/lokalise/i18n-ally/wiki">📖 Docs 文档</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/FAQ">💭 FAQ 问答</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/Configurations">⚙️ Configs 配置</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/Locale-Formats#supported-locale-formats">📜 Supported Formats 支持格式</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/Contribute">🧱 Contribute 贡献</a></h4><br><br><h3 align='center'>Inline Annotations 行内提示</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/annotation-animated.gif?raw=true"></p><h3 align='center'>Hover and Direct Actions 悬停和直接操作</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/hover.png?raw=true"></p><h3 align='center'>Manage All Translations in One Place 在一个位置管理所有翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/review-sidebar.png?raw=true"></p><h3 align='center'><a href='https://github.com/lokalise/i18n-ally/wiki/Editor-UI'>Editor UI编辑界面</a> & <a href='https://github.com/lokalise/i18n-ally/wiki/Review-&-Collaboration-System'>Review System 预览系统</a></h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/review-editor.png?raw=true"></p><h3 align='center'>Extract Translations from Code 从代码中提取翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/extract.png?raw=true"></p><h3 align='center'>Report Missing Translations 报告缺失的翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/problems.png?raw=true"></p><h3 align='center'>Machine Translation 机器翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/quick-actions.png?raw=true"></p><h3 align='center'>Annotations for JSON and YAML 来源于JSON 和 YAML的提示</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/annotation-locale.png?raw=true"></p><h3 align="center">General Features</h3><ul><li>Supports multi-root workspaces  支持多个工作空间</li><li>Supports remote development 支持远程开发</li><li>Supports numerous popular frameworks 支持多种流行框架</li><li>Supports <a href="https://kazupon.github.io/vue-i18n/guide/messages.html#linked-locale-messages">linked locale messages 链接的区域设置消息</a></li><li>Uses i18n for the extension itself, of course. 当然，将i18n用于扩展本身。 <a href="https://github.com/lokalise/i18n-ally#-multilingual-support">Translation List 翻译列表</a></li></ul><h2 id="🌍-Multilingual-Support-多语言支持"><a href="#🌍-Multilingual-Support-多语言支持" class="headerlink" title="🌍 Multilingual Support 多语言支持"></a>🌍 Multilingual Support 多语言支持</h2><p>This extension itself supports i18n as well. It will be auto-matched to the display language you use in your VS Code editor. We currently support the following languages.<br>这个扩展支持多语言。它将自动匹配到你在VS Code编辑器中使用的语言。我们目前支持的语言有：</p><table><thead><tr><th>Language</th><th>Maintainer</th><th>Contributors</th></tr></thead><tbody><tr><td>English   英语</td><td><a href="https://github.com/antfu">@antfu</a></td><td><a href="https://github.com/rubjo">@rubjo</a>, <a href="https://github.com/EdRands">@EdRands</a></td></tr><tr><td>Simplified Chinese (简体中文)</td><td><a href="https://github.com/antfu">@antfu</a></td><td></td></tr><tr><td>Traditional Chinese (繁體中文)</td><td><a href="https://github.com/antfu">@antfu</a></td><td></td></tr><tr><td>Norwegian (Norsk) 挪威语</td><td></td><td><a href="https://github.com/rubjo">@rubjo</a></td></tr><tr><td>Spanish (Español) 西班牙的</td><td></td><td><a href="https://github.com/Baltimer">@Baltimer</a></td></tr><tr><td>Japanese (日本語) 日语</td><td></td><td><a href="https://github.com/isdh">@isdh</a></td></tr><tr><td>Dutch (Nederlands) 荷兰语</td><td></td><td><a href="https://github.com/Niekvdm">@Niekvdm</a>, <a href="https://github.com/Excalibaard">@Excalibaard</a></td></tr><tr><td>Portuguese (Brazilian) 葡萄牙语</td><td></td><td><a href="https://github.com/Ibcs16">@Ibcs16</a></td></tr><tr><td>French (Français) 法语</td><td></td><td><a href="https://github.com/Nicoxx45">@Nicoxx45</a>, <a href="https://github.com/eri">@eri</a></td></tr><tr><td>Swedish (Svenska)瑞典语</td><td><a href="https://github.com/vladdeSV">@vladdeSV</a></td><td></td></tr><tr><td>Ukrainian (Українська) 乌克兰语</td><td></td><td><a href="https://github.com/uhodav">@uhodav</a></td></tr><tr><td>Russian (Русский) 俄语</td><td></td><td><a href="https://github.com/uhodav">@uhodav</a></td></tr><tr><td>German (Deutsch) 德语</td><td><a href="https://github.com/alexanderniebuhr">@alexanderniebuhr</a></td><td></td></tr><tr><td>Turkish (Türkçe) 土耳其语</td><td></td><td><a href="https://github.com/eri">@eri</a></td></tr></tbody></table><p><a href="https://github.com/lokalise/i18n-ally/wiki/Contribute#working-on-translations"><strong>帮忙翻译</strong></a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>👨‍💻 如果您想帮助一种语言的翻译更新，请在<strong>维护者</strong>字段中输入您的姓名。我会在需要的时候提到你。非常感谢。</p></blockquote><h2 id="❤️-感谢"><a href="#❤️-感谢" class="headerlink" title="❤️ 感谢"></a>❤️ 感谢</h2><p>此插件的灵感来源于<a href="https://github.com/think2011/vscode-vue-i18n">think2011&#x2F;vscode-vue-i18n</a>. 如果没有<a href="https://github.com/think2011">@think2011</a>,i18n-ally不会存在</p><p>对Vue单文件组件（SFC）的支持由[kazupon&#x2F;Vue-i18n-locale-message]提供支持(<a href="https://github.com/kazupon/vue-i18n-locale-message)%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%B1vue-i18n%E7%9A%84%E4%BD%9C%E8%80%85%E5%88%9B%E5%BB%BA%E7%9A%84%E3%80%82%E8%B0%A2%E8%B0%A2%E4%BD%A0%E5%81%9A%E8%BF%99%E4%B8%AA%EF%BC%81">https://github.com/kazupon/vue-i18n-locale-message)，它是由vue-i18n的作者创建的。谢谢你做这个！</a></p><h3 id="代码共享者"><a href="#代码共享者" class="headerlink" title="代码共享者"></a>代码共享者</h3><p>非常感谢所有杰出的贡献者：<br><a href="https://github.com/lokalise/i18n-ally/graphs/contributors"><img src="https://opencollective.com/i18n-ally/contributors.svg?width=890"/></a></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><a href="https://github.com/lokalise/i18n-ally/blob/master/LICENSE">MIT License</a> © 2019-PRESENT <a href="https://github.com/antfu">Anthony Fu</a></p><p>MIT License © 2018-2019 <a href="https://github.com/think2011">think2011</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally">Visual Studio Code&gt;Other&gt;i18n Ally</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/lokalise/i18n-ally">github 官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-thunk源码</title>
      <link href="//post/2022-05-27redux-thunk.html"/>
      <url>//post/2022-05-27redux-thunk.html</url>
      
        <content type="html"><![CDATA[<h2 id="源码版本"><a href="#源码版本" class="headerlink" title="源码版本"></a>源码版本</h2><p><a href="https://github.com/reduxjs/redux-thunk/releases/tag/v2.4.1">v2.4.1</a></p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>通过redux源码applyMiddleware了解到，是对store.dispatch进行增强</li><li>可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。</li><li>可以在这个函数中执行一些异步的操作</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function addCount() &#123;  return &#123;type: ADD_COUNT&#125;&#125; export function addCountAsync() &#123;  return dispatch &#x3D;&gt; &#123; &#x2F;&#x2F; dispatch对应源码的 ： action(dispatch, getState, extraArgument);的第一个参数    setTimeout( () &#x3D;&gt; &#123;      dispatch(addCount())    &#125;,2000)  &#125;&#125;</code></pre><ul><li>addCountAsync函数就返回了一个函数，将dispatch作为函数的第一个参数传递进去，在函数内进行异步操作就可以了。</li></ul><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><ul><li>这个文件结构与redux、react-redux相比，没有什么特别之处，这里及以后如无必要不在进行阅读</li><li>简单扫一眼就好</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** A function that accepts a potential &quot;extra argument&quot; value to be injected later, * and returns an instance of the thunk middleware that uses that value *&#x2F;&#x2F;** 一个函数接收一个可能的&quot;extra argument&quot;值，并返回一个thunk中间件，它使用这个值 *&#x2F;function createThunkMiddleware&lt;  State &#x3D; any,  BasicAction extends Action &#x3D; AnyAction,  ExtraThunkArg &#x3D; undefined&gt;(extraArgument?: ExtraThunkArg) &#123;  &#x2F;&#x2F; Standard Redux middleware definition pattern:  &#x2F;&#x2F; 标准Redux中间件定义模式:  &#x2F;&#x2F; See: https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#writing-custom-middleware  const middleware: ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt; &#x3D;    (&#123; dispatch, getState &#125;) &#x3D;&gt; (next) &#x3D;&gt;  (action) &#x3D;&gt; &#123;      &#x2F;&#x2F; The thunk middleware looks for any functions that were passed to &#96;store.dispatch&#96;.      &#x2F;&#x2F; If this &quot;action&quot; is really a function, call it and return the result.      &#x2F;&#x2F; 这个thunk中间件会查找store.dispatch传入的任何函数。如果这个&quot;action&quot;是一个函数，调用它并返回结果。      if (typeof action &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;        &#x2F;&#x2F; Inject the store&#39;s &#96;dispatch&#96; and &#96;getState&#96; methods, as well as any &quot;extra arg&quot;        &#x2F;&#x2F; 注入store的dispatch和getState方法，以及任意的&quot;extra arg&quot;        return action(dispatch, getState, extraArgument);      &#125;      &#x2F;&#x2F; 否则，像往常一样将操作传递给中间件链      &#x2F;&#x2F; Otherwise, pass the action down the middleware chain as usual      return next(action);    &#125;;  return middleware;&#125;</code></pre><p><strong>中间件模式</strong></p><p>柯里化：将一个函数的参数分解成多个参数，并且返回一个新的函数，这个新的函数可以被调用，并且返回原函数的结果。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const anotherExampleMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;  &#x2F;&#x2F; Do something in here, when each action is dispatched  return next(action)&#125;</code></pre><p><strong>storeAPI</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; storeAPIconst store &#x3D; &#123;  dispatch: dispatch as Dispatch&lt;A&gt;,  subscribe,  getState,  replaceReducer,  [$$observable]: observable&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext</code></pre><p><em>工厂模式</em></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const thunk &#x3D; createThunkMiddleware() as ThunkMiddleware &amp; &#123;  withExtraArgument&lt;    ExtraThunkArg,    State &#x3D; any,    BasicAction extends Action &#x3D; AnyAction  &gt;(    extraArgument: ExtraThunkArg  ): ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt;&#125;&#x2F;&#x2F; Attach the factory function so users can create a customized version&#x2F;&#x2F; with whatever &quot;extra arg&quot; they want to inject into their thunks&#x2F;&#x2F; 尝试将工厂函数附加到用户可以创建任何额外的&quot;extra arg&quot;的thunk中间件thunk.withExtraArgument &#x3D; createThunkMiddlewareexport default thunk</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/reduxjs/redux-thunk/blob/master/src/index.ts">redux-thunk源码</a><br><a href="https://blog.csdn.net/hsany330/article/details/105951197">Redux中间件之redux-thunk使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
            <tag> redux-thunk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 代码注释</title>
      <link href="//post/2022-05-26code.html"/>
      <url>//post/2022-05-26code.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p><code>//</code>这种js注释代码在vscode其他地方引用时候，没有提示， 如果需要有提示，需要写成<code>/** 提示 **/</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">写法1export enum ELeaveType &#123;  MATERNITY_ &#x3D; 17, &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),&#125;写法2export enum ELeaveType &#123;  &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),  MATERNITY_ &#x3D; 17, &#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220526153244.webp"></p><h2 id="有提示注释写法"><a href="#有提示注释写法" class="headerlink" title="有提示注释写法"></a>有提示注释写法</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export enum ELeaveType &#123;...  &#x2F;**&quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),**&#x2F;  MATERNITY_ &#x3D; 17, ...&#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220526153709.webp"></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux 源码 2</title>
      <link href="//post/2022-05-25.redux2.html"/>
      <url>//post/2022-05-25.redux2.html</url>
      
        <content type="html"><![CDATA[<h2 id="redux-简介"><a href="#redux-简介" class="headerlink" title="redux 简介"></a>redux 简介</h2><p>Predictable state container for JavaScript apps</p><p>字面意思</p><p>js应用可预测状态容器</p><p><img src="http://t-blog-images.aijs.top/img/20220527091836.webp"></p><h2 id="怎么用，为什么用"><a href="#怎么用，为什么用" class="headerlink" title="怎么用，为什么用"></a>怎么用，为什么用</h2><p><a href="https://redux.js.org/">看官网。。。</a></p><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><p><strong>代码注释如下</strong></p><ul><li>redux store持有state树，唯一可以改变store中数据的方式是dispatch</li><li>在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer</li><li>一个根据当前state和行为返回新state的函数</li><li>初始state，</li><li>store中间件。可以使用第三方中间件增强store</li><li>redux store 可以读取state，dispatch行为，订阅改变</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call &#96;dispatch()&#96; on it. *  * redux store持有state树，唯一可以改变store中数据的方式是dispatch *  * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using &#96;combineReducers&#96;. * * 在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer *  * @param reducer A function that returns the next state tree, given * the current state tree and the action to handle. *  * 一个根据当前state和行为返回新state的函数 * * @param preloadedState The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use &#96;combineReducers&#96; to produce the root reducer function, this must be * an object with the same shape as &#96;combineReducers&#96; keys. * * 初始state， *  * @param enhancer The store enhancer. You may optionally specify it * to enhance the store with third-party capabilities such as middleware, * time travel, persistence, etc. The only store enhancer that ships with Redux * is &#96;applyMiddleware()&#96;. * * store中间件。可以使用第三方中间件增强store *  * @returns A Redux store that lets you read the state, dispatch actions * and subscribe to changes. *  * redux store 可以读取state，dispatch行为，订阅改变 *&#x2F;</code></pre><p><strong>函数声明</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function createStore&lt;  S,  A extends Action,  Ext &#x3D; &#123;&#125;,  StateExt &#x3D; never&gt;(  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Extexport default function createStore&lt;  S,  A extends Action,  Ext &#x3D; &#123;&#125;,  StateExt &#x3D; never&gt;(  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer  preloadedState?: PreloadedState&lt;S&gt;, &#x2F;&#x2F; &#x2F;&#x2F;初始状态  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Extexport default function createStore&lt;  S,  A extends Action,  Ext &#x3D; &#123;&#125;,  StateExt &#x3D; never&gt;(  reducer: Reducer&lt;S, A&gt;,&#x2F;&#x2F; reducer  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;, &#x2F;&#x2F;初始状态  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件  &#x2F;&#x2F; 这里可以看到 preloadedState的参数| StoreEnhancer&lt;Ext, StateExt&gt; 与 enhancer类型一致， 这里处理第二参数可能是 enhancer  &#x2F;&#x2F; 代码主体分有做判断：  &#x2F;&#x2F; if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;  &#x2F;&#x2F;   enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;  &#x2F;&#x2F;   preloadedState &#x3D; undefined  &#x2F;&#x2F; &#125; ): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;&#125;</code></pre><p><strong>createStore 主体代码</strong></p><ul><li>一些入参校验</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">if (  (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||  (typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof arguments[3] &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;  throw new Error(    &#39;It looks like you are passing several store enhancers to &#39; +      &#39;createStore(). This is not supported. Instead, compose them &#39; +      &#39;together to a single function. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#creating-a-store-with-enhancers for an example.&#39;  )&#125;if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;  enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;  preloadedState &#x3D; undefined&#125;if (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;  if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) &#123;    throw new Error(      &#96;Expected the enhancer to be a function. Instead, received: &#39;$&#123;kindOf(        enhancer      )&#125;&#39;&#96;    )  &#125;  return enhancer(createStore)(    reducer,    preloadedState as PreloadedState&lt;S&gt;  ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext&#125;if (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;  throw new Error(    &#96;Expected the root reducer to be a function. Instead, received: &#39;$&#123;kindOf(      reducer    )&#125;&#39;&#96;  )&#125;&#x2F;&#x2F; 当前reducerlet currentReducer &#x3D; reducer&#x2F;&#x2F; 当前状态let currentState &#x3D; preloadedState as S&#x2F;&#x2F; 当前订阅let currentListeners: (() &#x3D;&gt; void)[] | null &#x3D; []&#x2F;&#x2F; 新的订阅let nextListeners &#x3D; currentListenerslet isDispatching &#x3D; false&#x2F;** * This makes a shallow copy of currentListeners so we can use * nextListeners as a temporary list while dispatching. * * This prevents any bugs around consumers calling * subscribe&#x2F;unsubscribe in the middle of a dispatch. *&#x2F;&#x2F;&#x2F; 浅拷贝当前currentListeners得到 nextListeners 用于 dispatching   &#x2F;&#x2F; 确定新的可变监听function ensureCanMutateNextListeners() &#123;  。。。&#125;&#x2F;&#x2F; 获取store的状态function getState(): S &#123;  。。。&#125;&#x2F;&#x2F; 传入监听，返回监听移除的函数function subscribe(listener: () &#x3D;&gt; void) &#123;  。。。  return function unsubscribe() &#123;    。。。。  &#125;&#125;function dispatch(action: A) &#123;  。。。&#125;&#x2F;&#x2F; 用于同构更新reducerfunction replaceReducer&lt;NewState, NewActions extends A&gt;(  nextReducer: Reducer&lt;NewState, NewActions&gt;): Store&lt;ExtendState&lt;NewState, StateExt&gt;, NewActions, StateExt, Ext&gt; &amp; Ext &#123;  。。。&#125;&#x2F;** * Interoperability point for observable&#x2F;reactive libraries. * @returns A minimal observable of state changes. * For more information, see the observable proposal: * https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-observable *&#x2F;&#x2F;&#x2F; 实现小型观察状态变更function observable() &#123;  。。。&#125;&#x2F;&#x2F; 当store被创建，初始化操作会被dispatch，，每个reducer会返回最初的state. 有效地填充初始状态树。dispatch(&#123; type: ActionTypes.INIT &#125; as A)const store &#x3D; &#123;  dispatch: dispatch as Dispatch&lt;A&gt;,  subscribe,  getState,  replaceReducer,  [$$observable]: observable&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Extreturn store &#x2F;&#x2F; store上的api我们又熟悉了</code></pre><p><strong>ensureCanMutateNextListeners</strong></p><ul><li>浅拷贝当前currentListeners得到 nextListeners 用于 dispatching</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function ensureCanMutateNextListeners() &#123;  if (nextListeners &#x3D;&#x3D;&#x3D; currentListeners) &#123;    nextListeners &#x3D; currentListeners.slice()  &#125;&#125;</code></pre><p><strong>getState</strong></p><ul><li>获取store的状态</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getState(): S &#123;  if (isDispatching) &#123;    throw new Error(      &#39;You may not call store.getState() while the reducer is executing. &#39; +        &#39;The reducer has already received the state as an argument. &#39; +        &#39;Pass it down from the top reducer instead of reading it from the store.&#39;    )  &#125;  return currentState as S&#125;</code></pre><p><strong>subscribe</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;**   * Adds a change listener. It will be called any time an action is dispatched,   * and some part of the state tree may potentially have changed. You may then   * call &#96;getState()&#96; to read the current state tree inside the callback.   *   * You may call &#96;dispatch()&#96; from a change listener, with the following   * caveats:   *   * 1. The subscriptions are snapshotted just before every &#96;dispatch()&#96; call.   * If you subscribe or unsubscribe while the listeners are being invoked, this   * will not have any effect on the &#96;dispatch()&#96; that is currently in progress.   * However, the next &#96;dispatch()&#96; call, whether nested or not, will use a more   * recent snapshot of the subscription list.   *   * 2. The listener should not expect to see all state changes, as the state   * might have been updated multiple times during a nested &#96;dispatch()&#96; before   * the listener is called. It is, however, guaranteed that all subscribers   * registered before the &#96;dispatch()&#96; started will be called with the latest   * state by the time it exits.   *   * @param listener A callback to be invoked on every dispatch.   * @returns A function to remove this change listener.   *&#x2F;  &#x2F;&#x2F; 上述注释  &#x2F;** 添加一个监听，在action被触发时候会调用，state会进行更新，在回调中可以用getState方法获取当前状态树   * 两个注意：订阅的是在每个dispatch之前的快照，   * 1.   * 订阅是在每次&#39;dispatch（）&#39;调用之前进行快照的。   * 如果在调用侦听器时订阅或取消订阅，这将不会对当前正在进行的“dispatch（）”产生任何影响。   * 但是，下一个&#39;dispatch（）&#39;调用（无论是否嵌套）将使用订阅列表的最新快照。   * 2。   * 监听器不应该期望看到所有的状态更改，因为在调用监听器之前，状态可能在嵌套的&#39;dispatch（）&#39;期间被多次更新。   * 但是，可以保证在“dispatch（）”启动之前注册的所有订阅者在退出时都将以最新状态调用。   * *&#x2F;  function subscribe(listener: () &#x3D;&gt; void) &#123;    if (typeof listener !&#x3D;&#x3D; &#39;function&#39;) &#123;      throw new Error(        &#96;Expected the listener to be a function. Instead, received: &#39;$&#123;kindOf(          listener        )&#125;&#39;&#96;      )    &#125;    if (isDispatching) &#123;      throw new Error(        &#39;You may not call store.subscribe() while the reducer is executing. &#39; +          &#39;If you would like to be notified after the store has been updated, subscribe from a &#39; +          &#39;component and invoke store.getState() in the callback to access the latest state. &#39; +          &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;      )    &#125;    let isSubscribed &#x3D; true    ensureCanMutateNextListeners()    nextListeners.push(listener) &#x2F;&#x2F; 增加    return function unsubscribe() &#123;      if (!isSubscribed) &#123;        return      &#125;      if (isDispatching) &#123;        throw new Error(          &#39;You may not unsubscribe from a store listener while the reducer is executing. &#39; +            &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;        )      &#125;      isSubscribed &#x3D; false      ensureCanMutateNextListeners()      const index &#x3D; nextListeners.indexOf(listener)      nextListeners.splice(index, 1) &#x2F;&#x2F; 移除      currentListeners &#x3D; null    &#125;  &#125;</code></pre><p><strong>dispatch</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** * Dispatches an action. It is the only way to trigger a state change. * * The &#96;reducer&#96; function, used to create the store, will be called with the * current state tree and the given &#96;action&#96;. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the &#96;redux-thunk&#96; package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling &#96;redux-devtools&#96;. An action must have * a &#96;type&#96; property which may not be &#96;undefined&#96;. It is a good idea to use * string constants for action types. * * @returns For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap &#96;dispatch()&#96; to * return something else (for example, a Promise you can await). *&#x2F;function dispatch(action: A) &#123;  if (!isPlainObject(action)) &#123; &#x2F;&#x2F; 只能是简单的对象    throw new Error(      &#96;Actions must be plain objects. Instead, the actual type was: &#39;$&#123;kindOf(        action      )&#125;&#39;. You may need to add middleware to your store setup to handle dispatching other values, such as &#39;redux-thunk&#39; to handle dispatching functions. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#middleware and https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-6-async-logic#using-the-redux-thunk-middleware for examples.&#96;    )  &#125;  if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;    throw new Error(      &#39;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#39;    )  &#125;  if (isDispatching) &#123;    throw new Error(&#39;Reducers may not dispatch actions.&#39;)  &#125;  try &#123;    isDispatching &#x3D; true    currentState &#x3D; currentReducer(currentState, action) &#x2F;&#x2F; 传入当前状态和操作，返回新的状态  &#125; finally &#123;    isDispatching &#x3D; false  &#125;  const listeners &#x3D; (currentListeners &#x3D; nextListeners) &#x2F;&#x2F; 触发更新  for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;    const listener &#x3D; listeners[i]    listener()  &#125;  return action&#125;</code></pre><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><ul><li>使用时候以键值对形式存在<br><strong>使用</strong></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import useInfoReducer from &#39;.&#x2F;userInfo&#39;import recordReducer from &#39;.&#x2F;record&#39;const rootReducer &#x3D; combineReducers(&#123;  useInfoReducer,  recordReducer&#125;)const store &#x3D; createStore(rootReducer)</code></pre><p><strong>源码</strong></p><ul><li>返回不期望的state型警告信息</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function getUnexpectedStateShapeWarningMessage(  inputState: object,  reducers: ReducersMapObject,  action: Action,  unexpectedKeyCache: &#123; [key: string]: true &#125;) &#123;  const reducerKeys &#x3D; Object.keys(reducers)  const argumentName &#x3D;    action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.INIT      ? &#39;preloadedState argument passed to createStore&#39;      : &#39;previous state received by the reducer&#39;  if (reducerKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;    return (      &#39;Store does not have a valid reducer. Make sure the argument passed &#39; +      &#39;to combineReducers is an object whose values are reducers.&#39;    )  &#125;  if (!isPlainObject(inputState)) &#123;    return (      &#96;The $&#123;argumentName&#125; has unexpected type of &quot;$&#123;kindOf(        inputState      )&#125;&quot;. Expected argument to be an object with the following &#96; +      &#96;keys: &quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;&#96;    )  &#125;  const unexpectedKeys &#x3D; Object.keys(inputState).filter(    key &#x3D;&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]  )  unexpectedKeys.forEach(key &#x3D;&gt; &#123;    unexpectedKeyCache[key] &#x3D; true  &#125;)  if (action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.REPLACE) return  if (unexpectedKeys.length &gt; 0) &#123;    return (      &#96;Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &#39;keys&#39; : &#39;key&#39;&#125; &#96; +      &#96;&quot;$&#123;unexpectedKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot; found in $&#123;argumentName&#125;. &#96; +      &#96;Expected to find one of the known reducer keys instead: &#96; +      &#96;&quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;. Unexpected keys will be ignored.&#96;    )  &#125;&#125; &#x2F;&#x2F; 对 reducer型进行断言function assertReducerShape(reducers: ReducersMapObject) &#123;  Object.keys(reducers).forEach(key &#x3D;&gt; &#123;    const reducer &#x3D; reducers[key]    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;)    if (typeof initialState &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;      throw new Error(         &#x2F;&#x2F; 初始化initialState时候可以用null,但是不可以用undefined        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined during initialization. &#96; +          &#96;If the state passed to the reducer is undefined, you must &#96; +          &#96;explicitly return the initial state. The initial state may &#96; +          &#96;not be undefined. If you don&#39;t want to set a value for this reducer, &#96; +          &#96;you can use null instead of undefined.&#96;      )    &#125;    if (      typeof reducer(undefined, &#123;        type: ActionTypes.PROBE_UNKNOWN_ACTION()      &#125;) &#x3D;&#x3D;&#x3D; &#39;undefined&#39;    ) &#123;      throw new Error(         &#x2F;&#x2F; 1.随机类型&#x2F; redux&#x2F;*类型 的操作类型为redux私有，不允许使用         &#x2F;&#x2F; 2.初始化状态不可以是undefined,         &#x2F;&#x2F; 3.新状态如果是undefined的，必须返回初始状态        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. &#96; +          &#96;Don&#39;t try to handle &#39;$&#123;ActionTypes.INIT&#125;&#39; or other actions in &quot;redux&#x2F;*&quot; &#96; +          &#96;namespace. They are considered private. Instead, you must return the &#96; +          &#96;current state for any unknown actions, unless it is undefined, &#96; +          &#96;in which case you must return the initial state, regardless of the &#96; +          &#96;action type. The initial state may not be undefined, but can be null.&#96;      )    &#125;  &#125;)&#125;&#x2F;&#x2F; combineReducers的实现，其实就是将多个值，合并在一个对象中export default function combineReducers(reducers: ReducersMapObject) &#123;  const reducerKeys &#x3D; Object.keys(reducers)  const finalReducers: ReducersMapObject &#x3D; &#123;&#125;  for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;    const key &#x3D; reducerKeys[i]    if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;      finalReducers[key] &#x3D; reducers[key]    &#125;  &#125;  const finalReducerKeys &#x3D; Object.keys(finalReducers)  &#x2F;&#x2F; This is used to make sure we don&#39;t warn about the same  &#x2F;&#x2F; keys multiple times.  &#x2F;&#x2F;这用于确保我们不会多次警告相同的key。  let unexpectedKeyCache: &#123; [key: string]: true &#125;  return function combination(    state: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;,    action: AnyAction  ) &#123;    &#x2F;&#x2F;校验信息...    let hasChanged &#x3D; false    const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;      const key &#x3D; finalReducerKeys[i]      &#x2F;&#x2F; reducer      const reducer &#x3D; finalReducers[key]      &#x2F;&#x2F; 之前状态      const previousStateForKey &#x3D; state[key]      &#x2F;&#x2F; 新状态      const nextStateForKey &#x3D; reducer(previousStateForKey, action)      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;        const actionType &#x3D; action &amp;&amp; action.type        throw new Error(          &#96;When called with an action of type $&#123;            actionType ? &#96;&quot;$&#123;String(actionType)&#125;&quot;&#96; : &#39;(unknown type)&#39;          &#125;, the slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined. &#96; +            &#96;To ignore an action, you must explicitly return the previous state. &#96; +            &#96;If you want this reducer to hold no value, you can return null instead of undefined.&#96;        )      &#125;      nextState[key] &#x3D; nextStateForKey      &#x2F;&#x2F; 判断是否发生更新      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey    &#125;    hasChanged &#x3D;      hasChanged || finalReducerKeys.length !&#x3D;&#x3D; Object.keys(state).length      &#x2F;&#x2F; 更新返回新的状态，否则返回之前状态    return hasChanged ? nextState : state  &#125;&#125;</code></pre><h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><ul><li>给action包裹层dispatch</li><li>action有两种类型： 函数、键值对</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function bindActionCreators(  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,  dispatch: Dispatch) &#123;  &#x2F;&#x2F; 函数类型直接bindActionCreator返回  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;    return bindActionCreator(actionCreators, dispatch)  &#125;  if (typeof actionCreators !&#x3D;&#x3D; &#39;object&#39; || actionCreators &#x3D;&#x3D;&#x3D; null) &#123;    throw new Error(      &#96;bindActionCreators expected an object or a function, but instead received: &#39;$&#123;kindOf(        actionCreators      )&#125;&#39;. &#96; +        &#96;Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&#96;    )  &#125;  const boundActionCreators: ActionCreatorsMapObject &#x3D; &#123;&#125;  &#x2F;&#x2F; 对象遍历调用bindActionCreator  for (const key in actionCreators) &#123;    const actionCreator &#x3D; actionCreators[key]    if (typeof actionCreator &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;      boundActionCreators[key] &#x3D; bindActionCreator(actionCreator, dispatch)    &#125;  &#125;  return boundActionCreators&#125;</code></pre><p><strong>使用及测试代码见</strong></p><p><code>redux/test/typescript/actionCreators.ts</code></p><p><strong>bindActionCreator</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 作用是每个actionCreator增加一个dispatch包裹function bindActionCreator&lt;A extends AnyAction &#x3D; AnyAction&gt;(  actionCreator: ActionCreator&lt;A&gt;,  dispatch: Dispatch) &#123;  return function (this: any, ...args: any[]) &#123;    return dispatch(actionCreator.apply(this, args)) &#x2F;&#x2F; 主要代码  &#125;&#125;</code></pre><h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><ul><li>中间件</li><li>对store能力进行增强</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function applyMiddleware(  ...middlewares: Middleware[]): StoreEnhancer&lt;any&gt; &#123;  return (createStore: StoreEnhancerStoreCreator) &#x3D;&gt;    &lt;S, A extends AnyAction&gt;(      reducer: Reducer&lt;S, A&gt;,      preloadedState?: PreloadedState&lt;S&gt;    ) &#x3D;&gt; &#123;      const store &#x3D; createStore(reducer, preloadedState)      &#x2F;&#x2F; 声明      let dispatch: Dispatch &#x3D; () &#x3D;&gt; &#123;        throw new Error(          &#39;Dispatching while constructing your middleware is not allowed. &#39; +            &#39;Other middleware would not be applied to this dispatch.&#39;        )      &#125;      const middlewareAPI: MiddlewareAPI &#x3D; &#123;        getState: store.getState,                                      &#x2F;&#x2F;使用上述函数进行        dispatch: (action, ...args) &#x3D;&gt; dispatch(action, ...args)      &#125;      &#x2F;&#x2F; 中间件数组      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))      &#x2F;&#x2F; 增强的是dispatch      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)      return &#123;        ...store,        dispatch      &#125;    &#125;&#125;&#96;&#96;&#96;ts      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))            dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)      return &#123;        ...store,        dispatch      &#125;    &#125;&#125;</code></pre><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><ul><li>洋葱模型<br><strong>使用</strong></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">compose(f, g, h)(...args) &#x3D;&gt; f(g(h(...args)))</code></pre><p><strong>源码</strong></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function compose(...funcs: Function[]) &#123;  &#x2F;&#x2F; 参数长度判断  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line    return &lt;T&gt;(arg: T) &#x3D;&gt; arg  &#125;  &#x2F;&#x2F; 长度为1  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;    return funcs[0]  &#125;  &#x2F;&#x2F; 主要代码一行  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt;  a(b(...args)))&#125;</code></pre><p><strong>讲compose的文章</strong></p><p><a href="http://givencui.com/index.php/archives/28/" target="_blank" >这里有一篇非常好</a></p><h2 id="DO-NOT-USE-ActionTypes"><a href="#DO-NOT-USE-ActionTypes" class="headerlink" title="__DO_NOT_USE__ActionTypes"></a>__DO_NOT_USE__ActionTypes</h2><ul><li>一些私有的action被redux保留，对于不明确的action，必须返回当前state.</li><li>如果当前状态是undefined,必须返回初始状态</li><li>不要在代码中直接涉及这些action</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const ActionTypes &#x3D; &#123;  INIT: &#96;@@redux&#x2F;INIT$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,  REPLACE: &#96;@@redux&#x2F;REPLACE$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,  PROBE_UNKNOWN_ACTION: () &#x3D;&gt; &#96;@@redux&#x2F;PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;&#96;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="http://t-blog-images.aijs.top/img/redux源码内容.png"/><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="http://t-blog-images.aijs.top/img/20220527091836.webp"></p><h2 id="巩固"><a href="#巩固" class="headerlink" title="巩固"></a>巩固</h2><p><img src="http://t-blog-images.aijs.top/img/20220527095407.webp"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/u_15283585/2958523">最精简的Redux源码解析，看完从此再也不怕面试官</a><br><a href="https://www.jianshu.com/p/490fc0d89029">Redux 源码解析</a><br><a href="https://github.com/841660202/redux">github 源码</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux 源码 1</title>
      <link href="//post/2022-05-25.redux.html"/>
      <url>//post/2022-05-25.redux.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>A Predictable State Container for JS Apps</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;redux&quot;,  &quot;version&quot;: &quot;5.0.0-alpha.0&quot;,  &quot;description&quot;: &quot;Predictable state container for JavaScript apps&quot;,  &quot;keywords&quot;: [    &quot;redux&quot;,    &quot;reducer&quot;,  &#x2F;&#x2F; reducer, redux构成组成之一    &quot;state&quot;,    &#x2F;&#x2F; 状态管理    &quot;predictable&quot;,   &#x2F;&#x2F; 可预测的    &quot;functional&quot;,    &#x2F;&#x2F; 纯函数的    &quot;immutable&quot;,     &#x2F;&#x2F; 不可变的    &quot;hot&quot;,    &quot;live&quot;,    &quot;replay&quot;,        &#x2F;&#x2F; 回放    &quot;flux&quot;,          &#x2F;&#x2F; redux对flux的改进    &quot;elm&quot;            &#x2F;&#x2F; Elm 是一门专注于Web前端的纯函数式语言, reducer受elm启发  ],  &#x2F;&#x2F; 入口  &quot;main&quot;: &quot;lib&#x2F;redux.js&quot;,  &#x2F;&#x2F; unpkg 是一个内容源自 npm 的全球快速 CDN, 它能以快速而简单的方式提供任意包、任意文件，通过类似这样的 URL ：unpkg.com&#x2F;:package@:version&#x2F;:file  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.3&#x2F;dist&#x2F;redux.min.js 是对应redux@4.0.3版本的压缩后的js文件  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux ——根据package.json配置的unpkg, 重定向为--—&gt; https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.4&#x2F;dist&#x2F;redux.js , 做了两次重定向  &#x2F;&#x2F; 如何你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux&#x2F; (注意redux后有&#x2F;), 是一个页面  &quot;unpkg&quot;: &quot;dist&#x2F;redux.js&quot;, &#x2F;&#x2F; 用unpkg的裸url访问时, 指定到该文件  &#x2F;**    module      点击 Setting up multi-platform npm packages 查看相关介绍。      就像 main 字段一样，定义一个针对 es6 模块及语法的入口文件。      构建工具在构建项目的时候，如果发现了这个字段，会首先使用这个字段指向的文件，如果未定义，则回退到 main 字段指向的文件。      支持的工具：      rollup      webpack  **&#x2F;  &quot;module&quot;: &quot;es&#x2F;redux.js&quot;,&#x2F;&#x2F; TypeScript是javascript 的超集, typings&#x2F;types字段, 定义了TypeScript的入口文件  &quot;types&quot;: &quot;types&#x2F;index.d.ts&quot;,  &#x2F;&#x2F; 发布上传内容  &#x2F;&#x2F; 是一个可选字段, 用来描述作将软件包作为依赖项安装时要包含的条目, 相当于白名单, 类似.gitignore类似的语法, files字段中包含的文件不能通过.npmignore或.gitignore排除  &quot;files&quot;: [    &quot;dist&quot;,    &quot;lib&quot;,    &quot;es&quot;,    &quot;src&quot;,    &quot;types&quot;  ],  &quot;scripts&quot;: &#123;    ...  &#125;,  &#x2F;&#x2F; 表示在生产环境下使用该依赖, 对应 npm install xx -S 或 npm install xx --save  &quot;dependencies&quot;: &#123;    &quot;@babel&#x2F;runtime&quot;: &quot;^7.16.7&quot;  &#125;,  &#x2F;&#x2F; 表示仅在开发环境下使用, 不会在生产环境中使用的依赖, 对应 npm install xx -D 或 npm install xx --save-dev  &quot;devDependencies&quot;: &#123;   ...  &#125;,  &quot;npmName&quot;: &quot;redux&quot;,  &#x2F;&#x2F; npm文件映射。把需要同步到 cdnjs 的文件配置在这里。  &quot;npmFileMap&quot;: [    &#123;      &quot;basePath&quot;: &quot;&#x2F;dist&#x2F;&quot;,      &quot;files&quot;: [        &quot;*.js&quot;      ]    &#125;  ],  &#x2F;&#x2F; webpack相关字段, 声明该模块是否包含 sideEffects（副作用），从而可以为 tree-shaking 提供更大的优化空间。  &quot;sideEffects&quot;: false&#125;</code></pre><h2 id="version字段"><a href="#version字段" class="headerlink" title="version字段"></a>version字段</h2><p>包的版本, 必须有, 要符合<a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning guidelines</a>, 参考 <a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a>, 建议仔细通读<br><img src="http://t-blog-images.aijs.top/img/20220525140247.webp" width=600 style="object-fit: content"/></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://givencui.com/index.php/archives/29/">配合redux项目深度了解package.json</a><br><a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning guidelines</a><br><a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a></p><h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── applyMiddleware.ts├── bindActionCreators.ts├── combineReducers.ts├── compose.ts├── createStore.ts├── index.ts├── types│   ├── actions.ts│   ├── middleware.ts│   ├── reducers.ts│   └── store.ts└── utils    ├── actionTypes.ts    ├── formatProdErrorMessage.ts    ├── isPlainObject.ts    ├── kindOf.ts    ├── symbol-observable.ts    └── warning.ts2 directories, 16 files</code></pre><h2 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export &#123;  createStore,  combineReducers,  bindActionCreators,  applyMiddleware,  compose,  __DO_NOT_USE__ActionTypes&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux  源码2</title>
      <link href="//post/2022-05-24react-redux2.html"/>
      <url>//post/2022-05-24react-redux2.html</url>
      
        <content type="html"><![CDATA[<p>源码版本<code>&quot;version&quot;: &quot;8.0.2&quot;,</code></p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><ul><li>主要作用通过subscription调用redux中store的subscription产生订阅，订阅内容是onStateChange的回调</li><li>通过react的Provider功能，提供传递给根的store和根的subscription给后续使用了connect的组件</li></ul><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;* provider 组件代码 *&#x2F;function Provider(&#123; store, context, children &#125;) &#123;   &#x2F;* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  *&#x2F;   const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;      &#x2F;* 创建了一个根 Subscription 订阅器 *&#x2F;    const subscription &#x3D; new Subscription(store)    &#x2F;* subscription 的 notifyNestedSubs 方法 ，赋值给  onStateChange方法 *&#x2F;    &#x2F;&#x2F;onStateChange就是之后触发的listenr    subscription.onStateChange &#x3D; subscription.notifyNestedSubs      return &#123;      store,      subscription    &#125; &#x2F;*  store 改变创建新的contextValue *&#x2F;  &#125;, [store])  &#x2F;*  获取更新之前的state值 ，函数组件里面的上下文要优先于组件更新渲染  *&#x2F;  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])  useEffect(() &#x3D;&gt; &#123;    const &#123; subscription &#125; &#x3D; contextValue    &#x2F;* 触发trySubscribe方法执行，创建listens *&#x2F;    subscription.trySubscribe() &#x2F;&#x2F; 发起订阅    if (previousState !&#x3D;&#x3D; store.getState()) &#123;        &#x2F;* 组件更新渲染之后，如果此时state发生改变，那么立即触发 subscription.notifyNestedSubs 方法  *&#x2F;        &#x2F;&#x2F;触发所有的listener      subscription.notifyNestedSubs()     &#125;    &#x2F;*   *&#x2F;    return () &#x3D;&gt; &#123;      subscription.tryUnsubscribe()  &#x2F;&#x2F; 卸载订阅      subscription.onStateChange &#x3D; null    &#125;    &#x2F;*  contextValue state 改变出发新的 effect *&#x2F;  &#125;, [contextValue, previousState])  &#x2F;&#x2F;若Provider没有显示传入context，则为使用React.createContext创建的上下文  const Context &#x3D; context || ReactReduxContext  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt;&#125;</code></pre><h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><ul><li>订阅消息、发起更新</li><li>在根的Provider的作用是调用redux中store的订阅方法，将根的onStateChange进行订阅</li><li>在子代中是收集所有被 connect 包裹的组件中的Subscription的更新函数 onstatechange，然后形成一个 callback 链表，再由父级 Subscription 统一派发执行更新，只会往上传递一层，不会一直传递使得每一个上级都有自身的更新函数</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;* 发布订阅者模式 *&#x2F;export default class Subscription &#123;  constructor(store, parentSub) &#123;    this.store &#x3D; store    this.parentSub &#x3D; parentSub    this.unsubscribe &#x3D; null    this.listeners &#x3D; nullListeners    this.handleChangeWrapper &#x3D; this.handleChangeWrapper.bind(this)  &#125;  &#x2F;* 负责检测是否该组件订阅，然后添加订阅者也就是listener *&#x2F;    &#x2F;&#x2F;当父代调用过trySubscribe后，子代再调用，因为this.unsubscribe有值，所以并不会实际执行父代的trySubscribe，而只是将listener放进父代中管理  addNestedSub(listener) &#123;    this.trySubscribe()    return this.listeners.subscribe(listener)  &#125;  &#x2F;* 向listeners发布通知 *&#x2F;  notifyNestedSubs() &#123;    this.listeners.notify()  &#125;  &#x2F;* 对于 Provide onStateChange 就是 notifyNestedSubs 方法，  对于 connect 包裹接受更新的组件 ，onStateChange 就是 负责更新组件的函数 。   *&#x2F;  handleChangeWrapper() &#123;    if (this.onStateChange) &#123;      this.onStateChange()    &#125;  &#125;   &#x2F;* 判断有没有开启订阅 *&#x2F;  isSubscribed() &#123;    return Boolean(this.unsubscribe)  &#125;  &#x2F;* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 *&#x2F;  trySubscribe() &#123;    &#x2F;*    parentSub即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription    *&#x2F;    &#x2F;&#x2F;当Subscription执行过一次改方法后，再调用因为this.unsubscribe有值    &#x2F;&#x2F;所以该方法调用一次后就不会再被调用了    &#x2F;&#x2F;意味着addNestedSub中只会添加listener，而不会再调用trySubscribe，使得listener不会往上传递    if (!this.unsubscribe) &#123;      this.unsubscribe &#x3D; this.parentSub        ? this.parentSub.addNestedSub(this.handleChangeWrapper)        &#x2F;* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   *&#x2F;        : this.store.subscribe(this.handleChangeWrapper)      this.listeners &#x3D; createListenerCollection()    &#125;  &#125;  &#x2F;* 取消订阅 *&#x2F;  tryUnsubscribe() &#123;    if (this.unsubscribe) &#123;      this.unsubscribe()      this.unsubscribe &#x3D; null      this.listeners.clear()      this.listeners &#x3D; nullListeners    &#125;  &#125;&#125;</code></pre><ul><li>首先Provider创建 Subscription 时候没有第二个参数，就说明provider 中的Subscription 不存在 parentSub 。</li><li>那么再调用Provider组件中useEffect钩子中trySubscribe的时候,会触发this.store.subscribe , subscribe 就是 redux 的 subscribe ,此时真正发起了订阅</li><li>订阅的内容是notifyNestedSubs，即通知根管理的listeners触发<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">subscription.onStateChange &#x3D; subscription.notifyNestedSubs &#x2F;* 向listeners发布通知 *&#x2F;notifyNestedSubs() &#123;  this.listeners.notify()&#125;</code></pre></li></ul><h2 id="createListenerCollection"><a href="#createListenerCollection" class="headerlink" title="createListenerCollection"></a>createListenerCollection</h2><p>通过双向链表的结构管理每一个listener<br>以链表的形式收集对应的 listeners (每一个Subscription) 的handleChangeWrapper函数即onStateChange。<br>通过 batch 方法( react-dom 中的 unstable_batchedUpdates ) 来进行批量更新，许将一次事件循环中的所有 React 更新都一起批量处理到一个渲染过程中。</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; unstable_batchedUpdates as batch &#125; from &#39;.&#x2F;utils&#x2F;reactBatchedUpdates&#39;setBatch(batch)function createListenerCollection() &#123;   &#x2F;* batch 由getBatch得到的 unstable_batchedUpdates 方法 *&#x2F;  const batch &#x3D; getBatch()  let first &#x3D; null  let last &#x3D; null  return &#123;    &#x2F;* 清除当前listeners的所有listener *&#x2F;    clear() &#123;      first &#x3D; null      last &#x3D; null    &#125;,    &#x2F;* 派发更新 *&#x2F;    notify() &#123;      batch(() &#x3D;&gt; &#123;        let listener &#x3D; first        while (listener) &#123;          listener.callback()          listener &#x3D; listener.next        &#125;      &#125;)    &#125;,    &#x2F;* 获取listeners的所有listener *&#x2F;    get() &#123;      let listeners &#x3D; []      let listener &#x3D; first      while (listener) &#123;        listeners.push(listener)        listener &#x3D; listener.next      &#125;      return listeners    &#125;,     &#x2F;* 接收订阅，将当前的callback（handleChangeWrapper）存到当前的链表中  *&#x2F;    subscribe(callback) &#123;      let isSubscribed &#x3D; true      let listener &#x3D; (last &#x3D; &#123;        callback,        next: null,        prev: last &#x2F;&#x2F;首次last为空      &#125;)         if (listener.prev) &#123;        listener.prev.next &#x3D; listener      &#125; else &#123;        first &#x3D; listener      &#125;      &#x2F;* 取消当前 handleChangeWrapper 的订阅*&#x2F;      return function unsubscribe() &#123;        if (!isSubscribed || first &#x3D;&#x3D;&#x3D; null) return        isSubscribed &#x3D; false&#x2F;&#x2F;双向链表删除节点的操作        if (listener.next) &#123;          listener.next.prev &#x3D; listener.prev        &#125; else &#123;          last &#x3D; listener.prev        &#125;        if (listener.prev) &#123;          listener.prev.next &#x3D; listener.next        &#125; else &#123;          first &#x3D; listener.next        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>基本使用</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)const mapStateToProps &#x3D; state &#x3D;&gt; (&#123; todos: state.todos &#125;)const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;  return &#123;    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)  &#125;&#125;&#x2F;** stateProps , state 映射到 props 中的内容* dispatchProps， dispatch 映射到 props 中的内容。* ownProps 组件本身的 props当未传递时，默认的合并规则为&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;*&#x2F;mergeProps&#x3D;(stateProps, dispatchProps, ownProps) &#x3D;&gt; Objectoptions&#x3D;&#123;  context?: Object,   &#x2F;&#x2F; 自定义上下文  pure?: boolean, &#x2F;&#x2F; 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。  areStatesEqual?: Function, &#x2F;&#x2F; 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean  areOwnPropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean  areStatePropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) &#x3D;&gt; boolean  areMergedPropsEqual?: Function, &#x2F;&#x2F; 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) &#x3D;&gt; boolean  forwardRef?: boolean, &#x2F;&#x2F;当为true 时候,可以通过ref 获取被connect包裹的组件实例。&#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220525105732.webp"></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Connects a React component to a Redux store. * * - Without arguments, just wraps the component, without changing the behavior &#x2F; props * * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior * is to override ownProps (as stated in the docs), so what remains is everything that&#39;s * not a state or dispatch prop * * - When 3rd param is passed, we don&#39;t know if ownProps propagate and whether they * should be valid component props, because it depends on mergeProps implementation. * As such, it is the user&#39;s responsibility to extend ownProps interface from state or * dispatch props or both when applicable * * @param mapStateToProps A function that extracts values from state * @param mapDispatchToProps Setup for dispatching actions * @param mergeProps Optional callback to merge state and dispatch props together * @param options Options for configuring the connection * *&#x2F;function connect&lt;  TStateProps &#x3D; &#123;&#125;,  TDispatchProps &#x3D; &#123;&#125;,  TOwnProps &#x3D; &#123;&#125;,  TMergedProps &#x3D; &#123;&#125;,  State &#x3D; unknown&gt;(  mapStateToProps?: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;,  mapDispatchToProps?: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;,  mergeProps?: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;,  &#123;    &#x2F;&#x2F; The &#96;pure&#96; option has been removed, so TS doesn&#39;t like us destructuring this to check its existence.    &#x2F;&#x2F; @ts-ignore    pure,    areStatesEqual &#x3D; strictEqual,    areOwnPropsEqual &#x3D; shallowEqual,    areStatePropsEqual &#x3D; shallowEqual,    areMergedPropsEqual &#x3D; shallowEqual,    &#x2F;&#x2F; use React&#39;s forwardRef to expose a ref of the wrapped component    forwardRef &#x3D; false,    &#x2F;&#x2F; the context consumer to use    context &#x3D; ReactReduxContext,  &#125;: ConnectOptions&lt;unknown, unknown, unknown, unknown&gt; &#x3D; &#123;&#125;): unknown &#123;    const Context &#x3D; context  &#x2F;*  * stateProps , state 映射到 props 中的内容  * dispatchProps， dispatch 映射到 props 中的内容。  * ownProps 组件本身的 props  当未传递时，默认的合并规则为  &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;  *&#x2F; &#x2F;* 经过代理包装后的 mapStateToProps,完成传入store等操作*&#x2F;  const initMapStateToProps &#x3D; mapStateToPropsFactory(mapStateToProps)  &#x2F;* 经过代理包装后的 mapDispatchToProps，完成传入store.dispatch等操作*&#x2F;  const initMapDispatchToProps &#x3D; mapDispatchToPropsFactory(mapDispatchToProps)  &#x2F;* 经过代理包装后的 mergeProps，用于形成真正的 mergeProps函数，合并业务组件的 props , state 映射的 props , dispatch 映射的 props *&#x2F;  const initMergeProps &#x3D; mergePropsFactory(mergeProps)  const shouldHandleStateChanges &#x3D; Boolean(mapStateToProps)  &#x2F;&#x2F;默认的高阶组件connectAdvanced，实际渲染的组件是其中返回的一个ConnectFunction&#x2F;&#x2F;selectorFactory为整合connect更新过程中的形成新props的主要函数&#x2F;&#x2F;selectorFactory为后面的finalPropsSelectorFactory  const wrapWithConnect: AdvancedComponentDecorator&lt;    TOwnProps,    WrappedComponentProps  &gt; &#x3D; (WrappedComponent) &#x3D;&gt; &#123;    ...  &#125;&#125;</code></pre><ul><li>当我们不向connect传递第三个参数mergeProps 的时候，默认的defaultMergeProps如下，作为新的 props 传递给了业务组件</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function defaultMergeProps(stateProps, dispatchProps, ownProps) &#123;  return &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;&#125;</code></pre><h2 id="selectorFactory"><a href="#selectorFactory" class="headerlink" title="selectorFactory"></a>selectorFactory</h2><p><img src="http://t-blog-images.aijs.top/img/20220525101153.webp"></p><ul><li>首先得到真正connect 经过一层代理函数 mapStateToProps ,mapDispatchToProps ,mergeProps</li><li>然后调用selectorFactory (在pure模式下，selectorFactory 就是 pureFinalPropsSelectorFactory )<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function finalPropsSelectorFactory(  dispatch,  &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;) &#123;  &#x2F;&#x2F; mapStateToProps mapDispatchToProps mergeProps 为真正connect 经过一层代理的 proxy 函数  const mapStateToProps &#x3D; initMapStateToProps(dispatch, options)  const mapDispatchToProps &#x3D; initMapDispatchToProps(dispatch, options)  const mergeProps &#x3D; initMergeProps(dispatch, options)  &#x2F;&#x2F;默认pure为true，selectorFactory默认为pureFinalPropsSelectorFactory  const selectorFactory &#x3D; options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory   &#x2F;&#x2F; 返回一个 函数用于生成新的 props   return selectorFactory(    mapStateToProps,    mapDispatchToProps,    mergeProps,    dispatch,    options  )&#125;</code></pre></li></ul><h2 id="pureFinalPropsSelectorFactory"><a href="#pureFinalPropsSelectorFactory" class="headerlink" title="pureFinalPropsSelectorFactory"></a>pureFinalPropsSelectorFactory</h2><p><img src="http://t-blog-images.aijs.top/img/20220525100640.webp"></p><ul><li>如果是第一次，那么直接调用mergeProps合并ownProps,stateProps,dispatchProps 形成最终的props。</li><li>如果不是第一次，那么判断到底是props还是 store.state 发生改变，然后针对那里变化，重新生成对应的props，最终合并到真正的props</li><li>整个 selectorFactory 逻辑就是形成新的props传递给我们的业务组件。</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;** pure组件处理 ， 对比 props 是否发生变化 然后 合并props *&#x2F;export function pureFinalPropsSelectorFactory(  mapStateToProps,  mapDispatchToProps,  mergeProps,  dispatch,  &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125; &#x2F;&#x2F;判断 state prop 是否相等) &#123;  let hasRunAtLeastOnce &#x3D; false  let state  let ownProps  let stateProps  let dispatchProps  let mergedProps   &#x2F;* 第一次 直接形成 ownProps  stateProps  dispatchProps 合并  形成新的 props *&#x2F;  function handleFirstCall(firstState, firstOwnProps) &#123;    state &#x3D; firstState    ownProps &#x3D; firstOwnProps    &#x2F;&#x2F;获取业务组件中mapStateToProps函数的返回值    stateProps &#x3D; mapStateToProps(state, ownProps)    &#x2F;&#x2F;获取业务组件中mapDispatchToProps函数的返回值    dispatchProps &#x3D; mapDispatchToProps(dispatch, ownProps)    &#x2F;&#x2F;合并state、dispatch、组件自身的props，形成最终传递给组件的props    mergedProps &#x3D; mergeProps(stateProps, dispatchProps, ownProps)    hasRunAtLeastOnce &#x3D; true    return mergedProps  &#125;    function handleNewPropsAndNewState() &#123;    &#x2F;&#x2F;  props 和 state 都改变  mergeProps   &#125;  function handleNewProps() &#123;    &#x2F;&#x2F; props 改变  mergeProps  &#125;  function handleNewState() &#123;     &#x2F;&#x2F; state 改变 mergeProps  &#125;  &#x2F;*  不是第一次的情况 props 或者 store.state 发生改变的情况。 *&#x2F;  function handleSubsequentCalls(nextState, nextOwnProps) &#123;      &#x2F;* 判断两次 props 是否相等 *&#x2F;    const propsChanged &#x3D; !areOwnPropsEqual(nextOwnProps, ownProps)       &#x2F;* 判断两次 store.state 是否相等 *&#x2F;    const stateChanged &#x3D; !areStatesEqual(nextState, state)    state &#x3D; nextState    ownProps &#x3D; nextOwnProps        &#x2F;&#x2F;根据改变的类型不同，返回对应合并策略下的props    if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState()    if (propsChanged) return handleNewProps()    if (stateChanged) return handleNewState()    return mergedProps  &#125;    &#x2F;&#x2F;根据是否第一次形成props，执行对应方法  return function pureFinalPropsSelector(nextState, nextOwnProps) &#123;    return hasRunAtLeastOnce      ? handleSubsequentCalls(nextState, nextOwnProps)      : handleFirstCall(nextState, nextOwnProps)  &#125;&#125;</code></pre><h2 id="connectHOC"><a href="#connectHOC" class="headerlink" title="connectHOC"></a>connectHOC</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const mapStateToProp &#x3D; (store) &#x3D;&gt; (&#123; userInfo: store.root.userInfo &#125;)function Index()&#123;    &#x2F;* ..... *&#x2F;    return &lt;div&gt; &#123; &#x2F;* .... *&#x2F; &#125; &lt;&#x2F;div&gt;&#125;export default connect(mapStateToProp)(Index)</code></pre><ul><li>connect(mapStateToProp)&#x3D;&#x3D;&#x3D;connectAdvanced()</li></ul><details class="custom-details"><summary>点击查看更多</summary><p><ul><li>这部分代码，在8.x.x版本在conncet中直接处理，并没有拆分为单独函数</li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function connectAdvanced(  selectorFactory, &#x2F;&#x2F; 每次 props,state改变执行 ，用于生成新的 props。  &#123;    getDisplayName &#x3D; name &#x3D;&gt; &#96;ConnectAdvanced($&#123;name&#125;)&#96;,    &#x2F;&#x2F;可能被包装函数（如connect（））重写    methodName &#x3D; &#39;connectAdvanced&#39;,    &#x2F;&#x2F;如果定义了，则传递给包装元素的属性的名称，指示要呈现的调用。用于监视react devtools中不必要的重新渲染。    renderCountProp &#x3D; undefined,    shouldHandleStateChanges &#x3D; true,  &#x2F;&#x2F;确定此HOC是否订阅存储更改    storeKey &#x3D; &#39;store&#39;,    withRef &#x3D; false,    forwardRef &#x3D; false, &#x2F;&#x2F; 是否 用 forwarRef 模式    context &#x3D; ReactReduxContext,&#x2F;&#x2F; Provider 保存的上下文    ...connectOptions  &#125; &#x3D; &#123;&#125;) &#123;  &#x2F;* ReactReduxContext 就是store存在的context *&#x2F;  const Context &#x3D; context   &#x2F;* WrappedComponent 为connect 包裹的组件本身  *&#x2F;     return  function wrapWithConnect(WrappedComponent)&#123;      &#x2F;&#x2F; WrappedComponent 被 connect 的业务组件本身  &#125;&#125;</code></pre><ul><li>拿到Provider提供的context上下文</li></ul></p></details><h2 id="wrapWithConnect"><a href="#wrapWithConnect" class="headerlink" title="wrapWithConnect"></a>wrapWithConnect</h2><p>wrapWithConnect作为高阶组件，会返回一个组件，这个组件会对原有的业务组件，进行一系列增强等工作<br>判断是否是 pure 纯组件模式，如果是用react.memo包裹,这样做的好处是，会向 pureComponent 一样对 props 进行浅比较<br>如果 connect 有forwardRef配置项，用React.forwardRef处理</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function wrapWithConnect(WrappedComponent) &#123;&#x2F;&#x2F;WrappedComponent为实际传递的业务组件    const wrappedComponentName &#x3D;      WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;      const displayName &#x3D; getDisplayName(wrappedComponentName)        &#x2F;&#x2F;要合并都内容，connectOptions为上一步闭包拿到的内容    const selectorFactoryOptions &#x3D; &#123;      ...connectOptions,      getDisplayName,      methodName,      renderCountProp,      shouldHandleStateChanges,      storeKey,      displayName,      wrappedComponentName,      WrappedComponent    &#125;    const &#123; pure &#125; &#x3D; connectOptions        &#x2F;&#x2F;selectorFactory为finalPropsSelectorFactory    function createChildSelector(store) &#123;      &#x2F;&#x2F; 合并函数 mergeprops 得到最新的props      &#x2F;&#x2F; 及默认返回pureFinalPropsSelectorFactory，会根据是否第一次合并、修改类型等进行不同策略等合并以及返回最终都props      return selectorFactory(store.dispatch, selectorFactoryOptions)    &#125;    &#x2F;&#x2F;判断是否是pure纯组件模式 如果是将用 useMemo 缓存组件提升性能    const usePureOnlyMemo &#x3D; pure ? useMemo : callback &#x3D;&gt; callback()    &#x2F;&#x2F; 负责更新的容器子组件，可以看作是实际渲染的类组件    function ConnectFunction (props)&#123;        &#x2F;&#x2F; props 为 业务组件 真正的 props     &#125;    &#x2F;&#x2F;如果    const Connect &#x3D; pure ? React.memo(ConnectFunction) : ConnectFunction      Connect.WrappedComponent &#x3D; WrappedComponent    Connect.displayName &#x3D; displayName    &#x2F;* forwardRef *&#x2F;    if (forwardRef) &#123;      const forwarded &#x3D; React.forwardRef(function forwardConnectRef(        props,        ref      ) &#123;      &#x2F;&#x2F;connect中是否传递了forwardRef选项        return &lt;Connect &#123;...props&#125; reactReduxForwardedRef&#x3D;&#123;ref&#125; &#x2F;&gt;      &#125;)        forwarded.displayName &#x3D; displayName      forwarded.WrappedComponent &#x3D; WrappedComponent      &#x2F;&#x2F;hoistStatics为一个第三方库，负责把一个类中的静态属性拷贝到另一个类中      return hoistStatics(forwarded, WrappedComponent)    &#125;      return hoistStatics(Connect, WrappedComponent)  &#125;&#125;</code></pre><h2 id="为何要传递forwardRef？"><a href="#为何要传递forwardRef？" class="headerlink" title="为何要传递forwardRef？"></a>为何要传递forwardRef？</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">connect(mapStateToProp,mapDispatchToProps,mergeProps,&#123; forwardRef:true  &#125;)(Child)</code></pre><p>如果不传递，而是在其他组件中直接放ref到使用了connect的组件，则ref实际应用到的是ConncectFunction组件，而非真正的WrappedComponent组件<br>所以react-redux提供forwardRef选项，使用React.forwardRef，将ref实际放到真正的WrappedComponent上</p><h2 id="ConnectFunction"><a href="#ConnectFunction" class="headerlink" title="ConnectFunction"></a>ConnectFunction</h2><ul><li><p>实际渲染的组件</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function ConnectFunction(props) &#123;    &#x2F;* TODO:  第一步 把 context ForwardedRef props 取出来 *&#x2F;    &#x2F;&#x2F;取出forwardRef和传递给ConnectFunction的所有除forwardRef的props    &#x2F;&#x2F;除了forwardRef以外的props也就是实际业务代码中传递给conncec包裹组件都props    const [      reactReduxForwardedRef,      wrapperProps &#x2F;&#x2F; props 传递的props    ] &#x3D; useMemo(() &#x3D;&gt; &#123;      const &#123; reactReduxForwardedRef, ...wrapperProps &#125; &#x3D; props      return [reactReduxForwardedRef, wrapperProps]    &#125;, [props])   &#x2F;&#x2F; 获取上层Provider提供的context，多个Provider只会取最近的Provider    &#x2F;&#x2F; 获取 context内容 里面含有  redux 中store 和 subscription    const contextValue &#x3D; useContext(Context)    &#x2F;&#x2F;TODO: 判断 store 是否来自props  didStoreComeFromProps ,正常情况下 ，prop 中是不存在 store 所以  didStoreComeFromProps &#x3D; false    const didStoreComeFromProps &#x3D;      Boolean(props.store) &amp;&amp;      Boolean(props.store.getState) &amp;&amp;      Boolean(props.store.dispatch)    &#x2F;&#x2F;store是否来自Provider提供的上下文    const didStoreComeFromContext &#x3D;      Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)    &#x2F;&#x2F;根据两种情况获取store    const store &#x3D; didStoreComeFromProps ? props.store : contextValue.store          &#x2F;&#x2F;返回merge函数 用于生成真正传给子组件 props    const childPropsSelector &#x3D; useMemo(() &#x3D;&gt; &#123;    &#x2F;&#x2F;默认情况下pure为true，返回的是pureFinalPropsSelectorFactory      return createChildSelector(store)    &#125;, [store])    &#x2F;&#x2F; TODO:  第二步  创建connect组件自身的subscription 监听者实例      const [subscription, notifyNestedSubs] &#x3D; useMemo(() &#x3D;&gt; &#123;        &#x2F;&#x2F; 如果没有订阅更新，那么直接返回，默认情况下开启了订阅      if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY&#x2F;&#x2F;为每一个conncet的组件创建订阅器，获取上层Provider提供的contextValue.subscription&#x2F;&#x2F;connct的组件获取的是上层的Provder提供的subscription，有多个Provider，只会取层级最近的一个&#x2F;&#x2F;所以connect中的connect组件，获取到的是离它最近的Provider中的订阅器，通过它来管理自身的listener更新函数      const subscription &#x3D; new Subscription(        store,        didStoreComeFromProps ? null : contextValue.subscription &#x2F;&#x2F; 和 上级 &#96;subscription&#96; 建立起关系。 this.parentSub &#x3D; contextValue.subscription      )      &#x2F;&#x2F; notifyNestedSubs 触发 noticy 所有子代 listener 监听者 -&gt; 触发batch方法,触发 batchupdate方法 ,批量更新      &#x2F;&#x2F;并更新一下this指向      const notifyNestedSubs &#x3D; subscription.notifyNestedSubs.bind(        subscription      )      return [subscription, notifyNestedSubs]    &#125;, [store, didStoreComeFromProps, contextValue])    &#x2F;*  创建出一个新的contextValue ,把父级的 subscription 换成自己的 subscription   *&#x2F;    const overriddenContextValue &#x3D; useMemo(() &#x3D;&gt; &#123;         if (didStoreComeFromProps) &#123;         return contextValue      &#125;      &#x2F;&#x2F;默认情况下，返回自身的订阅器以及redux中的store给自身的子代connect中获取      return &#123;        ...contextValue,        subscription      &#125;    &#125;, [didStoreComeFromProps, contextValue, subscription])        &#x2F;&#x2F;定义了一个useReducer，当actualChildProps变化时，调用dispatch方法forceComponentUpdateDispatch进行组件更新    const [      [previousStateUpdateResult], &#x2F;&#x2F;调用dispatch更新后的内容      forceComponentUpdateDispatch  &#x2F;*  *&#x2F;    ] &#x3D; useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)    &#x2F;&#x2F; TODO: 第三步缓存组件本次的props等内容，在下一次组件更新时做比较    const lastChildProps &#x3D; useRef() &#x2F;&#x2F;保存上一次 合并过的 props信息（经过 ownprops ,stateProps , dispatchProps 合并过的 ）    const lastWrapperProps &#x3D; useRef(wrapperProps) &#x2F;&#x2F;保存本次业务组件的 props     const childPropsFromStoreUpdate &#x3D; useRef() &#x2F;&#x2F;用来保存更新后的最新的props    const renderIsScheduled &#x3D; useRef(false) &#x2F;&#x2F; 当前组件是否处于渲染阶段        &#x2F;&#x2F; actualChildProps 为当前真正处理过后，经过合并的 props    const actualChildProps &#x3D; usePureOnlyMemo(() &#x3D;&gt; &#123;        &#x2F;&#x2F; 调用 mergeProps 进行合并，返回合并后的最新 porps        &#x2F;&#x2F;及调用pureFinalPropsSelectorFactory后的合并结果      return childPropsSelector(store.getState(), wrapperProps)         &#x2F;&#x2F;会在store、调用了checkForUpdates、传递给组建的props发生变化后，重新计算获取合并后的props     &#125;, [store, previousStateUpdateResult, wrapperProps])   &#x2F;* 负责更新缓存变量，方便下一次更新的时候比较 *&#x2F;    useEffect(()&#x3D;&gt;&#123;      captureWrapperProps(...[          lastWrapperProps,          lastChildProps,          renderIsScheduled,          wrapperProps,          actualChildProps,          childPropsFromStoreUpdate,          notifyNestedSubs       ])    &#125;)        &#x2F;&#x2F;实际订阅更新组件的地方    useEffect(()&#x3D;&gt;&#123;        subscribeUpdates(...[        shouldHandleStateChanges,        store,        subscription,        childPropsSelector,        lastWrapperProps,        lastChildProps,        renderIsScheduled,        childPropsFromStoreUpdate,        notifyNestedSubs,        forceComponentUpdateDispatch       ])    &#125;,[store, subscription, childPropsSelector])    &#x2F;&#x2F; TODO: 第四步：渲染实际挂载的组件，通过useMemo进行组件的缓存    const renderedWrappedComponent &#x3D; useMemo(      () &#x3D;&gt; (        &lt;WrappedComponent          &#123;...actualChildProps&#125;          ref&#x3D;&#123;reactReduxForwardedRef&#125;        &#x2F;&gt;      ),      &#x2F;&#x2F;当actualChildProps发生变化的时候重新渲染组件      &#x2F;&#x2F;这里就是组件重新渲染的原因：主要通过监听actualChildProps的变化      [reactReduxForwardedRef, WrappedComponent, actualChildProps]    )    &#x2F;&#x2F; 将上一步的renderedWrappedComponent包裹一层Provider    &#x2F;&#x2F; 提供该connect组件自身的订阅器、store给子代中的connect组件获取    const renderedChild &#x3D; useMemo(() &#x3D;&gt; &#123;      &#x2F;&#x2F;shouldHandleStateChanges 来源 connect是否有第一个参数      if (shouldHandleStateChanges) &#123;        return (          &#x2F;&#x2F; ContextToUse 传递 context           &lt;ContextToUse.Provider value&#x3D;&#123;overriddenContextValue&#125;&gt;            &#123;renderedWrappedComponent&#125;          &lt;&#x2F;ContextToUse.Provider&gt;        )      &#125;      return renderedWrappedComponent    &#125;, [ContextToUse, renderedWrappedComponent, overriddenContextValue])    return renderedChild  &#125;</code></pre></li><li><p>创建该connect组件自身的subscription, 并使用Provider包裹，层层传递新的context(很重要)</p></li><li><p>所以connect组件的子代connect组件，获取到的都是其上层最近的connect提供的Provider中的订阅器，然后将更新函数checkForUpdates放进其中管理</p></li><li><p>然后通过 useMemo 创建出一个新的 contextValue ,把父级的 subscription 换成自己的 subscription。用于通过 Provider 传递新的 context</p></li><li><p>接下来通过useReducer制造出真正触发更新的forceComponentUpdateDispatch 这个dispatch函数。也就是整个 state 或者是 props改变，触发组件更新的函数，这个函数放进checkForUpdates中执行</p></li></ul><h2 id="captureWrapperProps"><a href="#captureWrapperProps" class="headerlink" title="captureWrapperProps"></a>captureWrapperProps</h2><ul><li>进行内容缓存，为了下次组件更新进行比较<pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F;获取包装的props function captureWrapperProps(  lastWrapperProps,  lastChildProps,  renderIsScheduled,  wrapperProps,  actualChildProps,  childPropsFromStoreUpdate,  notifyNestedSubs) &#123;  lastWrapperProps.current &#x3D; wrapperProps  &#x2F;&#x2F;子props   lastChildProps.current &#x3D; actualChildProps &#x2F;&#x2F;经过 megeprops 之后形成的新prop  renderIsScheduled.current &#x3D; false  &#x2F;&#x2F; 当前组件渲染完成&#125;</code></pre></li></ul><h2 id="subscribeUpdates"><a href="#subscribeUpdates" class="headerlink" title="subscribeUpdates"></a>subscribeUpdates</h2><ul><li><p>实际添加更新回调的地方</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function subscribeUpdates(  shouldHandleStateChanges,  store,  subscription,  childPropsSelector,  lastWrapperProps,  &#x2F;&#x2F;子props   lastChildProps, &#x2F;&#x2F;经过 megeprops 之后形成的 prop  renderIsScheduled,  childPropsFromStoreUpdate,  notifyNestedSubs,  forceComponentUpdateDispatch) &#123;  if (!shouldHandleStateChanges) return   &#x2F;&#x2F; 捕获值以检查此组件是否卸载以及何时卸载  let didUnsubscribe &#x3D; false  let lastThrownError &#x3D; null   &#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调  const checkForUpdates &#x3D; ()&#x3D;&gt;&#123;      &#x2F;&#x2F;....  &#125;  &#x2F;&#x2F;将checkForUpdates作为listener  subscription.onStateChange &#x3D; checkForUpdates  &#x2F;&#x2F;开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中。  subscription.trySubscribe()  &#x2F;&#x2F;在第一次呈现之后从存储中提取数据，以防存储从我们开始就改变了。  &#x2F;&#x2F;确保获取到的最新的store.getState,然后判断是否更新组件  checkForUpdates()  &#x2F;* 卸载订阅起 *&#x2F;  const unsubscribeWrapper &#x3D; () &#x3D;&gt; &#123;    didUnsubscribe &#x3D; true    subscription.tryUnsubscribe()    subscription.onStateChange &#x3D; null  &#125;  return unsubscribeWrapper&#125;</code></pre></li><li><p>首先声明 store 更新订阅传播到此组件时的回调函数checkForUpdates把它赋值给onStateChange,如果store中的state发生改变，那么在组件订阅了state内容之后，相关联的state改变就会触发当前组件的onStateChange,来合并得到新的props</p></li><li><p>subscription.trySubscribe()把订阅函数onStateChange绑定给父级subscription,进行了层层订阅</p></li><li><p>为了确保拿到的store内容是最新的，所以首先执行了一次checkForUpdates<br><img src="https://img-blog.csdnimg.cn/d03af8b00dcd4deaad5bcb09c5cc2903.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5aWH5aSn5Y-U,size_20,color_FFFFFF,t_70,g_se,x_16"></p></li></ul><h2 id="checkForUpdates"><a href="#checkForUpdates" class="headerlink" title="checkForUpdates"></a>checkForUpdates</h2><ul><li><p>判断是否需要更新的函数</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调const checkForUpdates &#x3D; () &#x3D;&gt; &#123;  if (didUnsubscribe) &#123;    &#x2F;&#x2F;如果取消订阅了    return  &#125;   &#x2F;&#x2F; 获取 store 里state  const latestStoreState &#x3D; store.getState()q  let newChildProps, error  try &#123;    &#x2F;* 得到最新的 props *&#x2F;    newChildProps &#x3D; childPropsSelector(      latestStoreState,      lastWrapperProps.current    )  &#125;   &#x2F;&#x2F;如果新的合并的 props没有更改，则此处不做任何操作-层叠订阅更新  if (newChildProps &#x3D;&#x3D;&#x3D; lastChildProps.current) &#123;     if (!renderIsScheduled.current) &#123;        notifyNestedSubs() &#x2F;* 通知子代 subscription 触发 checkForUpdates 来检查是否需要更新。 *&#x2F;    &#125;  &#125; else &#123;    lastChildProps.current &#x3D; newChildProps    childPropsFromStoreUpdate.current &#x3D; newChildProps    renderIsScheduled.current &#x3D; true    &#x2F;&#x2F; 触发useReducer的dispatch来进行更新，该dispatch会改变useReducer返回的previousStateUpdateResult    &#x2F;&#x2F; 而previousStateUpdateResult是作为actualChildProps的依赖项引发actualChildProps的改变    &#x2F;&#x2F; actualChildProps又是实际渲染组件的依赖性，从而引发组件的重新渲染更新    forceComponentUpdateDispatch(&#123;      type: &#39;STORE_UPDATED&#39;,      payload: &#123;        error      &#125;    &#125;)  &#125;&#125;</code></pre></li><li><p>checkForUpdates 通过调用 childPropsSelector来形成新的props,然后判断之前的 prop 和当前新的 prop 是否相等。如果相等，证明没有发生变化,无须更新当前组件，那么通过调用notifyNestedSubs来通知子代容器组件，检查是否需要更新。如果不相等证明订阅的store.state发生变化，那么立即执行forceComponentUpdateDispatch来触发组件的更新</p></li></ul><h2 id="整个订阅流程"><a href="#整个订阅流程" class="headerlink" title="整个订阅流程"></a>整个订阅流程</h2><p>整个订阅的流程是，如果被connect包裹，并且具有第一个参数。首先通过context获取最近的 subscription，然后创建一个新的subscription,并且和父级的subscription建立起关联。当第一次hoc容器组件挂在完成后，在useEffect里，进行订阅，将自己的订阅函数checkForUpdates,作为回调函数，通过trySubscribe 和this.parentSub.addNestedSub ,加入到父级subscription的listeners中。由此完成整个订阅流程</p><h2 id="整个发布流程"><a href="#整个发布流程" class="headerlink" title="整个发布流程"></a>整个发布流程</h2><p>整个更新流程是，当组件中调用dispatch触发了redux的state改变和redux的订阅器，从而触发根订阅器的触发listeners.notify ,也就是checkForUpdates函数，然后checkForUpdates函数首先根据mapStoretoprops，mergeprops等操作，验证该组件是否发起订阅，props 是否改变，并更新，如果发生改变，那么触发useReducer的forceComponentUpdateDispatch函数，来更新业务组件，如果没有发生更新，那么通过调用notifyNestedSubs,来通知当前subscription的listeners检查是否更新，然后尽心层层checkForUpdates,逐级向下，借此完成整个更新流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>connect使用柯里化</li><li>useMemo缓存渲染组件的操作</li><li>发布订阅模式以及通过双向链表来管理</li><li>如何通过Provider进行层层订阅</li><li>react-redux触发更新的依据是actualChildProps是否改变</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_43294560/article/details/123284317">react-redux源码解析</a><br><a href="https://github.com/841660202/react-redux">github 源码</a><br><a href="https://blog.csdn.net/qq_33715850/article/details/122535984">React-redux源码解析–准备知识</a><br><a href="https://blog.csdn.net/qq_33715850/article/details/122590433">React-redux源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-redux </tag>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux 源码1</title>
      <link href="//post/2022-05-24react-redux.html"/>
      <url>//post/2022-05-24react-redux.html</url>
      
        <content type="html"><![CDATA[<h2 id="react-redux官方介绍"><a href="#react-redux官方介绍" class="headerlink" title="react-redux官方介绍"></a>react-redux官方介绍</h2><ul><li>官方UI绑定层。 React Redux is the <code>official React UI bindings layer</code> for Redux. </li><li>从redux的store读数据。 It lets your React components <code>read data from a Redux store</code>,</li><li>触发行为给store来更新状态。and <code>dispatch actions to the store to update state</code>.</li></ul><h2 id="react-redux-源码"><a href="#react-redux-源码" class="headerlink" title="react-redux 源码"></a>react-redux 源码</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── alternate-renderers.ts├── components│   ├── Context.ts│   ├── Provider.tsx│   └── connect.tsx # 大部分代码都在这里├── connect # 给 connect.tsx使用│   ├── invalidArgFactory.ts│   ├── mapDispatchToProps.ts│   ├── mapStateToProps.ts│   ├── mergeProps.ts│   ├── selectorFactory.ts│   ├── verifySubselectors.ts│   └── wrapMapToProps.ts├── exports.ts├── hooks│   ├── useDispatch.ts│   ├── useReduxContext.ts│   ├── useSelector.ts│   └── useStore.ts├── index.ts├── next.ts├── types.ts└── utils    ├── Subscription.ts    ├── batch.ts    ├── bindActionCreators.ts    ├── isPlainObject.ts    ├── reactBatchedUpdates.native.ts    ├── reactBatchedUpdates.ts    ├── shallowEqual.ts    ├── useIsomorphicLayoutEffect.native.ts    ├── useIsomorphicLayoutEffect.ts    ├── useSyncExternalStore.ts    ├── verifyPlainObject.ts    └── warning.ts</code></pre><h2 id="packge-json"><a href="#packge-json" class="headerlink" title="packge.json"></a>packge.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; packge.json&#123;  &quot;name&quot;: &quot;react-redux&quot;,  &quot;version&quot;: &quot;8.0.2&quot;,  &quot;description&quot;: &quot;Official React bindings for Redux&quot;,  &quot;keywords&quot;: [    &quot;react&quot;,    &quot;reactjs&quot;,    &quot;redux&quot;  ],  &quot;license&quot;: &quot;MIT&quot;,  &quot;author&quot;: &quot;Dan Abramov &lt;dan.abramov@me.com&gt; (https:&#x2F;&#x2F;github.com&#x2F;gaearon)&quot;,  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&quot;,  &quot;repository&quot;: &quot;github:reduxjs&#x2F;react-redux&quot;,  &quot;bugs&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&#x2F;issues&quot;,  &#x2F;&#x2F; 找找入口，入口有3种：  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;, &#x2F;&#x2F; 常规操作入口  &quot;types&quot;: &quot;.&#x2F;es&#x2F;index.d.ts&quot;, &#x2F;&#x2F; 类型入口  &quot;unpkg&quot;: &quot;dist&#x2F;react-redux.js&quot;, &#x2F;&#x2F; cdn入口  &quot;module&quot;: &quot;es&#x2F;index.js&quot;,&#x2F;&#x2F;esm入口  &#x2F;&#x2F; npm发布上传的文件  &quot;files&quot;: [    &quot;dist&quot;,    &quot;lib&quot;,    &quot;src&quot;, &#x2F;&#x2F; 一般用于开发阶段代码调试,soucemap    &quot;es&quot;  ],  &quot;scripts&quot;: &#123;    &#x2F;&#x2F; 脚本不看了...  &#125;,  &#x2F;&#x2F; 配置了依赖项，这些依赖项不需要在本包安装，在项目中安装即可  &quot;peerDependencies&quot;: &#123;    &quot;@types&#x2F;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;@types&#x2F;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;react-native&quot;: &quot;&gt;&#x3D;0.59&quot;,    &quot;redux&quot;: &quot;^4&quot;  &#125;,  &quot;peerDependenciesMeta&quot;: &#123;    &quot;@types&#x2F;react&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;@types&#x2F;react-dom&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;react-dom&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;react-native&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;redux&quot;: &#123;      &quot;optional&quot;: true    &#125;  &#125;,  &#x2F;&#x2F; 发布后，业务开发者使用，需要安装，&#x2F;&#x2F;自动安装  &quot;dependencies&quot;: &#123;    &quot;@babel&#x2F;runtime&quot;: &quot;^7.12.1&quot;,    &quot;@types&#x2F;hoist-non-react-statics&quot;: &quot;^3.3.1&quot;,    &quot;@types&#x2F;use-sync-external-store&quot;: &quot;^0.0.3&quot;,    &quot;hoist-non-react-statics&quot;: &quot;^3.3.2&quot;,    &quot;react-is&quot;: &quot;^18.0.0&quot;,    &quot;use-sync-external-store&quot;: &quot;^1.0.0&quot;  &#125;,  &#x2F;&#x2F; 开发阶段需要用到的，一般是examples中demo使用  &quot;devDependencies&quot;: &#123;    &#x2F;&#x2F;...  &#125;&#125;</code></pre><h2 id="exports-ts"><a href="#exports-ts" class="headerlink" title="exports.ts"></a>exports.ts</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export &#123;  Provider, &#x2F;&#x2F; import Provider from &#39;.&#x2F;components&#x2F;Provider&#39;  ReactReduxContext, &#x2F;&#x2F; import &#123; ReactReduxContext &#125; from &#39;.&#x2F;components&#x2F;Context&#39;  connect, &#x2F;&#x2F; import connect from &#39;.&#x2F;components&#x2F;connect&#39;  useDispatch, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;  createDispatchHook, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;  useSelector, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;  createSelectorHook, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;  useStore, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;  createStoreHook, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;  shallowEqual, &#x2F;&#x2F; import shallowEqual from &#39;.&#x2F;utils&#x2F;shallowEqual&#39;&#125;</code></pre><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>先看下 ，最熟悉的api</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; components&#x2F;Provider.tsx&#x2F;&#x2F; 这个组件做的事情&#x2F;&#x2F; 1. 合并浏览器和服务器的状态&#x2F;&#x2F; 2. 对于同构的应用，处理subscription订阅function Provider&lt;A extends Action &#x3D; AnyAction&gt;(&#123;  store,  context,  children,  serverState,&#125;: ProviderProps&lt;A&gt;) &#123;  &#x2F;&#x2F; 1.useMemo，对入参进行格式化「处理了store和 服务端的 serverState」  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;    const subscription &#x3D; createSubscription(store)    return &#123;      store,      subscription,      getServerState: serverState ? () &#x3D;&gt; serverState : undefined,    &#125;  &#125;, [store, serverState])  &#x2F;&#x2F; 2.之前的state状态从store中直接获取  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])  &#x2F;&#x2F; 3.同构相关，跳过  useIsomorphicLayoutEffect(() &#x3D;&gt; &#123;    const &#123; subscription &#125; &#x3D; contextValue    subscription.onStateChange &#x3D; subscription.notifyNestedSubs    subscription.trySubscribe()    if (previousState !&#x3D;&#x3D; store.getState()) &#123;      subscription.notifyNestedSubs()    &#125;    return () &#x3D;&gt; &#123;      subscription.tryUnsubscribe()      subscription.onStateChange &#x3D; undefined    &#125;  &#125;, [contextValue, previousState])  &#x2F;&#x2F; 4.react-redux上下文  const Context &#x3D; context || ReactReduxContext  &#x2F;&#x2F; @ts-ignore &#39;AnyAction&#39; is assignable to the constraint of type &#39;A&#39;, but &#39;A&#39; could be instantiated with a different subtype  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt; &#x2F;&#x2F; 这行代码是不是非常熟悉了&#125;export default Provider</code></pre><h2 id="ReactReduxContext"><a href="#ReactReduxContext" class="headerlink" title="ReactReduxContext"></a>ReactReduxContext</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; .&#x2F;components&#x2F;Context.tsx&#x2F;&#x2F; 这个组件做的事情&#x2F;&#x2F; 1.创建个createContext&#x2F;&#x2F; 2.给个名字displayName&#x2F;&#x2F; ...类型代码不关注export const ReactReduxContext &#x3D;&#x2F;*#__PURE__*&#x2F; React.createContext&lt;ReactReduxContextValue&gt;(null as any)&#x2F;&#x2F; ...类型代码不关注if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;  ReactReduxContext.displayName &#x3D; &#39;ReactRedux&#39;&#125;export default ReactReduxContext</code></pre><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; .&#x2F;components&#x2F;connect.tsx&#x2F;&#x2F; 这个文件比较长，先不看&#x2F;&#x2F; hoist-non-react-statics这个依赖可以帮助我们自动拷贝非React的静态方法</code></pre><h2 id="useDispatch、createDispatchHook"><a href="#useDispatch、createDispatchHook" class="headerlink" title="useDispatch、createDispatchHook"></a>useDispatch、createDispatchHook</h2><p>把ts类型删删，看上去更简单了</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; .&#x2F;hooks&#x2F;useDispatch&#x2F;&#x2F; 用createDispatchHook钩子工厂创建了个钩子useDispatchexport function createDispatchHook(context) &#123;  &#x2F;&#x2F; TODO: createStoreHook下面再看，先跳过  const useStore &#x3D; context &#x3D;&#x3D;&#x3D; ReactReduxContext ? useDefaultStore : createStoreHook(context)  return function useDispatch() &#123;    const store &#x3D; useStore()    &#x2F;&#x2F; @ts-ignore    return store.dispatch  &#125;&#125;&#x2F;** * A hook to access the redux &#96;dispatch&#96; function. * * @returns &#123;any|function&#125; redux store&#39;s &#96;dispatch&#96; function * * @example * * import React, &#123; useCallback &#125; from &#39;react&#39; * import &#123; useDispatch &#125; from &#39;react-redux&#39; * * export const CounterComponent &#x3D; (&#123; value &#125;) &#x3D;&gt; &#123; *   const dispatch &#x3D; useDispatch() *   const increaseCounter &#x3D; useCallback(() &#x3D;&gt; dispatch(&#123; type: &#39;increase-counter&#39; &#125;), []) *   return ( *     &lt;div&gt; *       &lt;span&gt;&#123;value&#125;&lt;&#x2F;span&gt; *       &lt;button onClick&#x3D;&#123;increaseCounter&#125;&gt;Increase counter&lt;&#x2F;button&gt; *     &lt;&#x2F;div&gt; *   ) * &#125; *&#x2F;export const useDispatch &#x3D; &#x2F;*#__PURE__*&#x2F; createDispatchHook()</code></pre><h2 id="useSelector、createSelectorHook"><a href="#useSelector、createSelectorHook" class="headerlink" title="useSelector、createSelectorHook"></a>useSelector、createSelectorHook</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; .&#x2F;hooks&#x2F;useSelector&#x2F;&#x2F; 用 createSelectorHook 钩子工厂创建了个钩子 useSelectorlet useSyncExternalStoreWithSelector &#x3D; notInitialized as uSESWSexport const initializeUseSelector &#x3D; (fn: uSESWS) &#x3D;&gt; &#123;  useSyncExternalStoreWithSelector &#x3D; fn&#125;const refEquality: EqualityFn&lt;any&gt; &#x3D; (a, b) &#x3D;&gt; a &#x3D;&#x3D;&#x3D; b&#x2F;&#x2F; 下面的代码保留范型，Selectedexport function createSelectorHook(  context &#x3D; ReactReduxContext): &lt;TState &#x3D; unknown, Selected &#x3D; unknown&gt;(  selector: (state: TState) &#x3D;&gt; Selected,  equalityFn?: EqualityFn&lt;Selected&gt;) &#x3D;&gt; Selected &#123;  const useReduxContext &#x3D;    context &#x3D;&#x3D;&#x3D; ReactReduxContext      ? useDefaultReduxContext      : () &#x3D;&gt; useContext(context)  return function useSelector(    selector,    equalityFn &#x3D; refEquality  ) &#123;    const &#123; store, subscription, getServerState &#125; &#x3D; useReduxContext()!    const selectedState &#x3D; useSyncExternalStoreWithSelector(      subscription.addNestedSub,      store.getState,      getServerState || store.getState,      selector,      equalityFn    )    useDebugValue(selectedState) &#x2F;&#x2F; 标记    return selectedState  &#125;&#125;&#x2F;** * A hook to access the redux store&#39;s state. This hook takes a selector function * as an argument. The selector is called with the store state. * * This hook takes an optional equality comparison function as the second parameter * that allows you to customize the way the selected state is compared to determine * whether the component needs to be re-rendered. * * @param &#123;Function&#125; selector the selector function * @param &#123;Function&#x3D;&#125; equalityFn the function that will be used to determine equality * * @returns &#123;any&#125; the selected state * * @example * * import React from &#39;react&#39; * import &#123; useSelector &#125; from &#39;react-redux&#39; * * export const CounterComponent &#x3D; () &#x3D;&gt; &#123; *   const counter &#x3D; useSelector(state &#x3D;&gt; state.counter) *   return &lt;div&gt;&#123;counter&#125;&lt;&#x2F;div&gt; * &#125; *&#x2F;export const useSelector &#x3D; &#x2F;*#__PURE__*&#x2F; createSelectorHook()</code></pre><h2 id="useStore、createStoreHook"><a href="#useStore、createStoreHook" class="headerlink" title="useStore、createStoreHook"></a>useStore、createStoreHook</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 1.用钩子工厂创建了个钩子&#x2F;&#x2F; 2.从   const &#123; store &#125; &#x3D; useReduxContext()! 获取store&#x2F;** * Hook factory, which creates a &#96;useStore&#96; hook bound to a given context. * * @param &#123;React.Context&#125; [context&#x3D;ReactReduxContext] Context passed to your &#96;&lt;Provider&gt;&#96;. * @returns &#123;Function&#125; A &#96;useStore&#96; hook bound to the specified context. *&#x2F;export function createStoreHook&lt;  S &#x3D; unknown,  A extends BasicAction &#x3D; AnyAction  &#x2F;&#x2F; @ts-ignore&gt;(context?: Context&lt;ReactReduxContextValue&lt;S, A&gt;&gt; &#x3D; ReactReduxContext) &#123;  const useReduxContext &#x3D;    &#x2F;&#x2F; @ts-ignore    context &#x3D;&#x3D;&#x3D; ReactReduxContext      ? useDefaultReduxContext      : () &#x3D;&gt; useContext(context)  return function useStore&lt;    State &#x3D; S,    Action extends BasicAction &#x3D; A    &#x2F;&#x2F; @ts-ignore  &gt;() &#123;    const &#123; store &#125; &#x3D; useReduxContext()!    &#x2F;&#x2F; @ts-ignore    return store as Store&lt;State, Action&gt;  &#125;&#125;&#x2F;** * A hook to access the redux store. * * @returns &#123;any&#125; the redux store * * @example * * import React from &#39;react&#39; * import &#123; useStore &#125; from &#39;react-redux&#39; * * export const ExampleComponent &#x3D; () &#x3D;&gt; &#123; *   const store &#x3D; useStore() *   return &lt;div&gt;&#123;store.getState()&#125;&lt;&#x2F;div&gt; * &#125; *&#x2F;export const useStore &#x3D; &#x2F;*#__PURE__*&#x2F; createStoreHook()</code></pre><h2 id="connect-1"><a href="#connect-1" class="headerlink" title="connect"></a>connect</h2><p> 见：react-redux 源码2</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-redux </tag>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex width:0</title>
      <link href="//post/2022-05-23width0.html"/>
      <url>//post/2022-05-23width0.html</url>
      
        <content type="html"><![CDATA[<h2 id="flex嵌套"><a href="#flex嵌套" class="headerlink" title="flex嵌套"></a>flex嵌套</h2><p>内部元素宽度默认100%，撑开父元素，父元素的根元素限制最大宽度，子元素并不受flex控制</p><p>遇到多次了，这次是维护其他同事的代码，又撞见了，说明这个问题很常见，一个不留神，就踩到了</p><pre class="line-numbers language-none"><code class="language-none">根元素  ……  - 父元素flex  …… flex   - 子元素flex(默认宽度100%)</code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">.doc-tree-base-title-node .doc-tree-base-title-text &gt; a &#123;    display: flex;    align-items: center;    color: #777;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;    flex: 1;&#125;</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="http://t-blog-images.aijs.top/img/20220523171556.webp"></p><p> 观察下发现，flex是嵌套的，最外层的还是flex，一层一层，最外层的宽度，却是由最内层的宽度决定（这个调试可以看到）</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>图1</li></ul><p> <img src="http://t-blog-images.aijs.top/img/20220523171802.webp"></p><ul><li>图2</li></ul><p> <img src="http://t-blog-images.aijs.top/img/20220523171918.webp"></p><ul><li>图3</li></ul><p> <img src="http://t-blog-images.aijs.top/img/20220523172024.webp"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p> 图1 元素没有宽度，宽度默认是<code>100%</code></p><p> 图1到图3是由a标签子元素撑开的，宽度是<code>100%</code>,加上操作按钮，元素宽度超100%</p><p> 而在侧边树结构的最外层设置了<code>max-width: 500px</code>,而内部子元素尺寸却是<code>599.48 x 36</code></p><p> 显然是不合理的</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2> <pre class="line-numbers language-none"><code class="language-none">根元素  ……  - 父元素flex  …… flex   - 子元素flex(默认宽度设置宽度0 或者其他小点的宽度，越小越好)</code></pre><p> <img src="http://t-blog-images.aijs.top/img/20220523173256.webp"></p><h2 id="什么原因导致的"><a href="#什么原因导致的" class="headerlink" title="什么原因导致的"></a>什么原因导致的</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">MDN flex</a></p><p>语法</p><pre class="line-numbers language-CSS" data-language="CSS"><code class="language-CSS">&#x2F;* 关键字值 *&#x2F;flex: auto;flex: initial;flex: none;&#x2F;* 一个值, 无单位数字: flex-grow *&#x2F;flex: 2;&#x2F;* 一个值, width&#x2F;height: flex-basis *&#x2F;flex: 10em;flex: 30px;flex: min-content;&#x2F;* 两个值: flex-grow | flex-basis *&#x2F;flex: 1 30px;&#x2F;* 两个值: flex-grow | flex-shrink *&#x2F;flex: 2 2;&#x2F;* 三个值: flex-grow | flex-shrink | flex-basis *&#x2F;flex: 2 2 10%;&#x2F;*全局属性值 *&#x2F;flex: inherit;flex: initial;flex: unset;</code></pre><p>可以使用一个，两个或三个值来指定 flex属性。</p><p>1.<strong>单值语法</strong>: 值必须为以下其中之一:</p><ul><li>一个无单位数(<code>&lt;number&gt;</code>): 它会被当作flex:<code>&lt;number&gt;</code> 1 0; 解释：<code>&lt;flex-shrink&gt;</code>的值被假定为1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为0。</li><li>一个有效的宽度(width)值: 它会被当作 <code>&lt;flex-basis&gt;</code>的值。</li><li>关键字none，auto或initial.<br>2.<strong>双值语法</strong>: 第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。第二个值必须为以下之一：</li><li>一个无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li><li>一个有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。<br>3.<strong>三值语法</strong>:</li><li>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作  <code>&lt;flex-shrink&gt;</code> 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li></ul><p> 可以看到单值，作为双值处理</p> <pre class="line-numbers language-css" data-language="css"><code class="language-css">flex-shrink:1;flex-basis: 0;</code></pre><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p> 自来看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis">flex-base</a></p><p> 查看文档后发现，文档上没说关于<code>flex-basic: 0 </code>的事情,给了个演示，也看不出来想表达什么</p><p><a href="https://blog.csdn.net/u010951953/article/details/124145786">flex-basis 属性的含义</a><br><a href="https://www.w3.org/TR/2018/CR-css-flexbox-1-20181119/#flex-basis-property">w3c flex-basis-property</a><br>flex布局一般由flex容器（display 属性值为 flex 或 inline-flex）和其子元素（后文亦称flex子项或flex item）构成。flex-basis 属性一般作用在flex子项上，它定义了：在flex容器分配剩余空间前flex子项在主轴方向上的初始尺寸。flex子项在主轴方向上的实际尺寸是根据元素自身尺寸、flex-basis、flex-grow、flex-shrink 等属性共同决定的。如何计算实际尺寸不是本文重点，不继续展开。</p><h2 id="flex-basis-0px与0"><a href="#flex-basis-0px与0" class="headerlink" title="flex-basis:0px与0%"></a>flex-basis:0px与0%</h2><ul><li>如果 flex-basis 的值为百分数，且它flex容器的尺寸没有被显式设置，此时 flex-basis 的值会被解析为 content</li></ul><h2 id="其他，值得一看"><a href="#其他，值得一看" class="headerlink" title="其他，值得一看"></a>其他，值得一看</h2><h2 id="flex-1"><a href="#flex-1" class="headerlink" title="flex: 1"></a>flex: 1</h2><p>在浏览器中，flex: 1 的 flex-basis 值为什么不是W3C文档中提到的 0 ？</p><p>当使用 flex 属性但又省略不写它其中的 flex-basis 值时，会将 flex-basis 设置为 0.</p><p>这里的 0 单位是 px 还是 % 我们在Chrome浏览器里就能验证：</p><img src="http://t-blog-images.aijs.top/img/20220523181618.webp" width=400  style="object-fit: content"/><p>答案是 px.</p><p>这段是2015年修正日志里的，意思是将之前 flex 简写语法里的 flex-basis 的解析值从 0% 恢复为原来的 0.</p><p>注意： 这个值的解析规则经历了 0px -&gt; 0% -&gt; 0px 的变化，这是W3C flex 标准文档的视角。</p><p>简而言之就是有兼容性问题。现在已有很多网页都利用了 flex 属性的这个特性来开发。如果简写语法里 flex-basis 的解析从 0% 变为 0px 会导致部分情况下flex容器塌陷，致使很多网页异常</p><p><a href="https://blog.csdn.net/u010951953/article/details/124145786">建议看原文</a></p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-CSS如何工作</title>
      <link href="//post/2022-05-23css.html"/>
      <url>//post/2022-05-23css.html</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当浏览器展示一个文件的时候，它必须兼顾文件的内容和文件的样式信息</p></blockquote><h2 id="如何加载CSS和HTML"><a href="#如何加载CSS和HTML" class="headerlink" title="如何加载CSS和HTML"></a>如何加载CSS和HTML</h2><p>下面的步骤是浏览加载网页的简化版本:</p><ol><li>浏览器载入HTML文件（比如从网络上获取）。</li><li>将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li><li>接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li><li>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li><li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li><li>网页展示在屏幕上（这一步被称为着色）。</li></ol><p><strong>运行图</strong></p><img src="http://t-blog-images.aijs.top/img/rendering.svg" width=400 style="object-fit:content; background: #fff"/><hr/><h2 id="无法解析的CSS会发生什么"><a href="#无法解析的CSS会发生什么" class="headerlink" title="无法解析的CSS会发生什么"></a>无法解析的CSS会发生什么</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>答案就是浏览器什么也不会做，继续解析下一个CSS样式！</p></blockquote><p>以下是废话：</p><ul><li><p>浏览器并不会同时实现所有的新CSS，此外很多人也不会使用最新版本的浏览器。鉴于CSS一直不断的开发，因此领先于浏览器可以识别的范围，那么你也许会好奇当浏览器遇到无法解析的CSS选择器或声明的时候会发生什么呢？</p></li><li><p>CSS规则： 如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的CSS声明。在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候上述的情况同样会发生（直接忽略）。</p></li><li><p>选择器： 相似的，当浏览器遇到无法解析的选择器的时候，他会<code>直接忽略整个选择器规则</code>，然后解析下一个CSS选择器。</p></li></ul><hr/><h2 id="关于DOM"><a href="#关于DOM" class="headerlink" title="关于DOM"></a>关于DOM</h2><p>一个DOM有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node&#x2F;DOM或DOM node）。节点由节点本身和其他DOM节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。</p><p>对于DOM的理解会很大程度上帮助你设计、调试和维护你的CSS，因为DOM是你的CSS样式和文件内容的结合。当你使用浏览器F12调试的时候你需要操作DOM以查看使用了哪些规则。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;p&gt;  Let&#39;s use:  &lt;span&gt;Cascading&lt;&#x2F;span&gt;  &lt;span&gt;Style&lt;&#x2F;span&gt;  &lt;span&gt;Sheets&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">P├─ &quot;Let&#39;s use:&quot;├─ SPAN|  └─ &quot;Cascading&quot;├─ SPAN|  └─ &quot;Style&quot;└─ SPAN   └─ &quot;Sheets&quot;</code></pre><hr/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works">MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 浏览器原理 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>monorepo</title>
      <link href="//post/2022-05-23monorepo.html"/>
      <url>//post/2022-05-23monorepo.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>调试源码时候，总会遇到多包的仓库，遇到了不晓得如何调试</li><li>开发个库或者是插件之类的开发的比较混乱</li><li>经历多个项目的毒打，终于有时间学下<code>monorepo</code></li></ul><h2 id="lerna、yarn-workspace"><a href="#lerna、yarn-workspace" class="headerlink" title="lerna、yarn workspace"></a>lerna、yarn workspace</h2><ul><li>和java微服务架构代码很像</li><li>很多项目是 lerna+yarn workspace，如果不懂，或者了解了一点<code>lerna</code>。上去一顿操作，各种报错，在所难免（亲身经历）</li></ul><h2 id="monorepo管理"><a href="#monorepo管理" class="headerlink" title="monorepo管理"></a>monorepo管理</h2><p>对于维护过多个package(功能相近)的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块&#x2F;包 (package)，不同于常见的每个模块建一个 repo。</p><p>目前有不少大型开源项目采用了这种方式，如 Babel，React, Meteor, Ember, Angular,Jest, Umijs, Vue, 还有 create-react-app, react-router 等。几乎我们熟知的仓库，都无一例外的采用了monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages目录中、分多个 package 进行管理。</p><p>目录结构如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">├── packages|   ├── pkg1|   |   ├── package.json|   ├── pkg2|   |   ├── package.json├── package.json</code></pre><p>monorepo 最主要的好处是统一的工作流和Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。</p><p>一图胜千言:<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOThmNTYwZDgxZDg"></p><p>前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p><p>虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。</p><p>结合shop-service门户的实际场景和业务需要，天然的 MonoRepo ! 一个理想的开发环境可以抽象成这样：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”</p></blockquote><p>在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。</p><p>上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。</p><h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p><p>2.1 安装<br>推荐全局安装，因为会经常用到 lerna 命令</p><pre class="line-numbers language-none"><code class="language-none">npm i -g lerna</code></pre><p>2.2 初始化项目</p><pre class="line-numbers language-none"><code class="language-none">lerna init</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWE5MDhiMTkyOWQ"></p><p>其中 package.json &amp; lerna.json 如下:</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; package.json&#123;  &quot;name&quot;: &quot;root&quot;,  &quot;private&quot;: true, &#x2F;&#x2F; 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦  &quot;devDependencies&quot;: &#123;    &quot;lerna&quot;: &quot;^3.15.0&quot;  &#125;&#125; &#x2F;&#x2F; lerna.json&#123;  &quot;packages&quot;: [    &quot;packages&#x2F;*&quot;  ],  &quot;version&quot;: &quot;0.0.0&quot;&#125;</code></pre><p>2.3 创建npm包<br>增加两个 packages</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWIyOTgzNjExZDE"></p><p>2.4 增加模块依赖<br>分别给相应的 package 增加依赖模块</p><pre class="line-numbers language-none"><code class="language-none">lerna add chalk &#x2F;&#x2F; 为所有 package 增加 chalk 模块 lerna add semver --scope @mo-demo&#x2F;cli-shared-utils &#x2F;&#x2F; 为 @mo-demo&#x2F;cli-shared-utils 增加 semver 模块 lerna add @mo-demo&#x2F;cli-shared-utils --scope @mo-demo&#x2F;cli &#x2F;&#x2F; 增加内部模块之间的依赖</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWI2NTNmMGQ5NjQ"></p><p>2.5 发布</p><pre class="line-numbers language-none"><code class="language-none">lerna publish</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWJiMWY4MjhjZjk"></p><p>2.6 依赖包管理<br>上述1-5步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。</p><p>我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本。</p><pre class="line-numbers language-none"><code class="language-none">lerna bootstrap --hoist</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWJmNjUxZDkxMWY"></p><p>为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;packages&quot;: [    &quot;packages&#x2F;*&quot;  ],  &quot;command&quot;: &#123;    &quot;bootstrap&quot;: &#123;      &quot;hoist&quot;: true    &#125;  &#125;,  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;&#125;</code></pre><p>配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：</p><pre class="line-numbers language-none"><code class="language-none">lerna clean</code></pre><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWM2OTdjODVjMWM" width=350 style="object-fit:contain"/>然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 `node_modules` 中了。<h2 id="Lerna-Monorepo-最佳实践"><a href="#Lerna-Monorepo-最佳实践" class="headerlink" title="Lerna + Monorepo 最佳实践"></a>Lerna + Monorepo 最佳实践</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>lerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p></blockquote><p>目前最常见的 monorepo 解决方案是 Lerna 和 yarn 的 workspaces 特性，基于lerna和yarn workspace的monorepo工作流。由于yarn和lerna在功能上有较多的重叠,我们采用yarn官方推荐的做法,用yarn来处理依赖问题，用lerna来处理发布问题。能用yarn做的就用yarn做吧</p><h2 id="yarn-workspace"><a href="#yarn-workspace" class="headerlink" title="yarn workspace"></a>yarn workspace</h2><p>3.1.1 搭建环境<br>普通项目：clone下来后通过yarn install,即可搭建完项目，有时需要配合postinstall hooks,来进行自动编译，或者其他设置。</p><p>monorepo: 各个库之间存在依赖，如A依赖于B，因此我们通常需要将B link到A的node_module里，一旦仓库很多的话，手动的管理这些link操作负担很大，因此需要自动化的link操作，按照拓扑排序将各个依赖进行link</p><p>解决方式：通过使用workspace，yarn install会自动的帮忙解决安装和link问题</p><pre class="line-numbers language-none"><code class="language-none">yarn install # 等价于 lerna bootstrap --npm-client yarn --use-workspaces</code></pre><p>3.1.2 清理环境<br>在依赖乱掉或者工程混乱的情况下，清理依赖</p><p>普通项目： 直接删除node_modules以及编译后的产物。</p><p>monorepo： 不仅需要删除root的node_modules的编译产物还需要删除各个package里的node_modules以及编译产物</p><p>解决方式：使用lerna clean来删除所有的node_modules，使用yarn workspaces run clean来执行所有package的清理工作</p><pre class="line-numbers language-none"><code class="language-none">lerna clean # 清理所有的node_modulesyarn workspaces run clean # 执行所有package的clean操作</code></pre><p>3.1.3 安装|删除依赖<br>普通项目： 通过yarn add和yarn remove即可简单姐解决依赖库的安装和删除问题</p><p>monorepo: 一般分为三种场景</p><p>给某个package安装依赖：yarn workspace packageB add packageA 将packageA作为packageB的依赖进行安装</p><p>给所有的package安装依赖: 使用yarn workspaces add lodash 给所有的package安装依赖</p><p>给root 安装依赖：一般的公用的开发工具都是安装在root里，如typescript,我们使用yarn add -W -D typescript来给root安装依赖</p><p>对应的三种场景删除依赖如下</p><pre class="line-numbers language-none"><code class="language-none">yarn workspace packageB remove packageAyarn workspaces remove lodashyarn remove -W -D typescript</code></pre><p>3.1.4 项目构建<br>普通项目：建立一个build的npm script，使用yarn build即可完成项目构建</p><p>monorepo:区别于普通项目之处在于各个package之间存在相互依赖，如packageB只有在packageA构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。</p><p>我们可以自己构建拓扑排序规则，很不幸的是yarn的workspace暂时并未支持按照拓扑排序规则执行命令,虽然该 rfc已经被accepted，但是尚未实现, 幸运的是lerna支持按照拓扑排序规则执行命令, –sort参数可以控制以拓扑排序规则执行命令</p><pre class="line-numbers language-none"><code class="language-none">lerna run --stream --sort build</code></pre><p>3.1.5 版本升级及发包<br>项目测试完成后，就涉及到版本发布，版本发布一般涉及到如下一些步骤</p><p>条件验证: 如验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作</p><p>version_bump:发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循 semVer语义，</p><p>生成changelog: 为了方便查看每个package每个版本解决了哪些功能，我们需要给每个package都生成一份changelog方便用户查看各个版本的功能变化。</p><p>生成git tag：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个git tag</p><p>git 发布版本：每次发版我们都需要单独生成一个commit记录来标记milestone</p><p>发布npm包：发布完git后我们还需要将更新的版本发布到npm上，以便外部用户使用</p><p>我们发现手动的执行这些操作是很麻烦的且及其容易出错，幸运的是lerna可以帮助我们解决这些问题</p><p>yarn官方并不打算支持发布流程，只是想做好包管理工具，因此这部分还是需要通过lerna支持</p><p>lerna提供了publish和version来支持版本的升级和发布, publish的功能可以即包含version的工作，也可以单纯的只做发布操作。</p><p>3.2 优雅的提交<br>3.2.1 <code>commitizen</code> &amp;&amp; <code>cz-lerna-changelog</code><br>commitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。</p><p>cz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTNmZGEyMTA3MGI"></p><p>我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。</p><p>因为这是整个工程的开发依赖，所以在根目录安装：</p><pre class="line-numbers language-none"><code class="language-none">yarn add  -D commitizenyarn add  -D cz-lerna-changelog</code></pre><p>安装完成后，在 <code>package.json</code> 中增加 <code>config</code> 字段，把 <code>cz-lerna-changelog</code> 配置给 <code>commitizen</code>。同时因为<code>commitizen</code>不是全局安全的，所以需要添加 <code>scripts</code> 脚本来执行 <code>git-cz</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;root&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;git-cz&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;    &#125;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;commitizen&quot;: &quot;^3.1.1&quot;,    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,    &quot;lerna&quot;: &quot;^3.15.0&quot;  &#125;&#125;</code></pre><p>之后在常规的开发中就可以使用 yarn run commit 来根据提示一步一步输入，来完成代码的提交。</p><p>3.2.2 commitlint &amp;&amp; husky<br>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用<code>yarn run commit</code> 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p><p>安装 commitlint 以及要遵守的规范</p><pre class="line-numbers language-none"><code class="language-none">yarn add -D @commitlint&#x2F;cli @commitlint&#x2F;config-conventional</code></pre><p>在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范</p><pre class="line-numbers language-none"><code class="language-none">module.exports &#x3D; &#123; extends: [&#39;@commitlint&#x2F;config-conventional&#39;] &#125;</code></pre><p>安装 husky</p><pre class="line-numbers language-none"><code class="language-none">yarn add -D husky</code></pre><p>在 package.json 中增加如下配置</p><pre class="line-numbers language-none"><code class="language-none">&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123;    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;     &#125;&#125;</code></pre><p>“commit-msg”是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 yarn run commit 来提交。</p><p>3.2.3 eslint &amp;&amp; lint-staged<br>除了规范提交信息，代码本身肯定也少了靠规范来统一风格。</p><p>安装</p><pre class="line-numbers language-none"><code class="language-none">yarn add  -D standard lint-staged</code></pre><p>eslint就是完整的一套 JavaScript（typescript） 代码规范，自带 linter &amp; 代码自动修正。自动格式化代码并修正，提前发现风格以及程序问题, 同时也支持typescript的代码规范校验，<code>eslintrc.json</code>配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;extends&quot;: [        &quot;yayajing&quot;,        &quot;plugin:@typescript-eslint&#x2F;recommended&quot;    ],    &quot;parser&quot;: &quot;typescript-eslint-parser&quot;,    &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],    &quot;rules&quot;: &#123;        &quot;eqeqeq&quot;:&quot;off&quot;,        &quot;@typescript-eslint&#x2F;explicit-function-return-type&quot;: &quot;off&quot;,        &quot;no-template-curly-in-string&quot;: &quot;off&quot;    &#125;  &#125;</code></pre><p><code>lint-staged staged</code> 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。<br>package.json配置</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; package.json&#123;  &quot;name&quot;: &quot;root&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;c&quot;: &quot;git-cz&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;    &#125;  &#125;,  &quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;pre-commit&quot;: &quot;lint-staged&quot;,      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;    &#125;  &#125;,  &quot;lint-staged&quot;: &#123;    &quot;*.ts&quot;: [      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@commitlint&#x2F;cli&quot;: &quot;^8.1.0&quot;,    &quot;@commitlint&#x2F;config-conventional&quot;: &quot;^8.1.0&quot;,    &quot;commitizen&quot;: &quot;^3.1.1&quot;,    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,    &quot;husky&quot;: &quot;^3.0.0&quot;,    &quot;lerna&quot;: &quot;^3.15.0&quot;,    &quot;lint-staged&quot;: &quot;^9.2.0&quot;  &#125;&#125;</code></pre><p>安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 eslint –fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加pre-commit的钩子用来执行 lint-staged 的校验操作。</p><p>此时提交 ts 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。</p><p>3.3 发布自动生成日志<br>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：</p><p>3.3.1 lerna version 更新版本</p><ul><li><p>找出从上一个版本发布以来有过变更的 package</p></li><li><p>提示开发者确定要发布的版本号</p></li><li><p>将所有更新过的的 package 中的package.json的version字段更新</p></li><li><p>将依赖更新过的 package 的 包中的依赖版本号更新</p></li><li><p>更新 lerna.json 中的 version 字段</p></li><li><p>提交上述修改，并打一个 tag</p></li><li><p>推送到 git 仓库<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTMzNTMzMzhkYTA"></p></li></ul><p>3.3.2 使用 npm publish 将新版本推送到 npm<br><code>CHANGELOG</code> 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 <code>--conventional-commits</code>。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 <code>lerna.json</code>中，如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;packages&quot;: [    &quot;packages&#x2F;*&quot;  ],  &quot;command&quot;: &#123;    &quot;bootstrap&quot;: &#123;      &quot;hoist&quot;: true    &#125;,    &quot;version&quot;: &#123;      &quot;conventionalCommits&quot;: true    &#125;  &#125;,  &quot;ignoreChanges&quot;: [    &quot;**&#x2F;*.md&quot;  ],  &quot;version&quot;: &quot;0.0.1-alpha.1&quot;&#125;</code></pre><p><code>lerna version</code> 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 <code>ignoreChanges</code> 配置排除。如上。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTM3NTQwN2Y0MzY"></p><p>实际 <code>lerna version</code>很少直接使用，因为它包含在 <code>lerna publish</code> 中了，直接使用 <code>lerna publish</code>就好了。</p><p>3.4 完善的测试用例<br>monorepo项目：测试有两种方式</p><ul><li><p>使用统一的jest测试配置这样方便全局的跑jest即可，好处是可以方便统计所有代码的测试覆盖率，坏处是如果package比较异构（如小程序，前端，node 服务端等），统一的测试配置不太好编写</p></li><li><p>每个package单独支持test命令，使用yarn workspace run test，坏处是不好统一收集所有代码的测试覆盖率</p></li></ul><p>如果采用jest编写测试用例，支持typescript的话，需要初始化配置jest.config.js：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">module.exports &#x3D; &#123;  preset: &#39;ts-jest&#39;,  moduleFileExtensions: [&#39;ts&#39;],  testEnvironment: &#39;node&#39;&#125;</code></pre><p>4 实践总结<br>到这里，基本上已经构建了基于lerna和yarn workspace的monorepo项目的最佳实践了，该有的功能都有：</p><ul><li><p>完善的工作流</p></li><li><p>typescript支持</p></li><li><p>风格统一的编码</p></li><li><p>完整的单元测试</p></li><li><p>一键式的发布机制</p></li><li><p>完美的更新日志</p></li></ul><p>……</p><p>当然，构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/i10630226/article/details/99702447">lerna+yarn workspace+monorepo项目的最佳实践</a><br><a href="https://www.jianshu.com/p/c10d0b8c5581">5分钟搞懂Monorepo</a><br><a href="https://www.easemob.com/news/5948">2021年管理Monorepo代码库的11种出色工具</a></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> npm </tag>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信标（Beacon ）</title>
      <link href="//post/2022-05-23beacon.html"/>
      <url>//post/2022-05-23beacon.html</url>
      
        <content type="html"><![CDATA[<h2 id="Beacon-特点"><a href="#Beacon-特点" class="headerlink" title="Beacon  特点"></a>Beacon  特点</h2><ul><li>接口用于将<em>异步</em>和<em>非阻塞</em>请求发送到服务器。</li><li>请求使用HTTP协议中的POST方法，请求通常<em>不需要响应</em>。</li><li>这个请求被保证在，页面的unload状态从发起到完成之前，被发送。而并不需要一个阻塞请求，例如 XMLHttpRequest 。</li></ul><h2 id="Beacon-场景"><a href="#Beacon-场景" class="headerlink" title="Beacon  场景"></a>Beacon  场景</h2><p>发送异步非阻塞数据到服务端</p><h2 id="为什么是信标？"><a href="#为什么是信标？" class="headerlink" title="为什么是信标？"></a>为什么是信标？</h2><p>Beacon 接口满足了<em>分析</em>和<em>诊断代码</em>的需要，这些代码通常会尝试在<em>卸载文档之前将数据发送到 web服务器</em>。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。</p><p>用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload (en-US) 事件或 beforeunload (en-US) 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。</p><h2 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h2><p>其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。</p><p>但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。</p><h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><p>Beacon API 的 Navigator.sendBeacon() 方法用于在全局浏览上下文中向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。</p><h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>Beacon API的 WorkerNavigator.sendBeacon() 方法用于从 worker global scope 向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或 FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>API 提供了解决这些问题的标准方法</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>浏览器兼容性<br>Navigator.sendBeacon().Browser_compatibility表说明了该方法具有相对广泛地实现。但是，WorkerNavigator.sendBeacon().Browser_compatibility数据显示该方法没有被实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter Bruno</title>
      <link href="//post/2022-05-20fluter-bruno.html"/>
      <url>//post/2022-05-20fluter-bruno.html</url>
      
        <content type="html"><![CDATA[<h1 id="Bruno"><a href="#Bruno" class="headerlink" title="Bruno"></a>Bruno</h1><p><img src="http://t-blog-images.aijs.top/img/20220520105610.webp"><br>Bruno 是由贝壳「用户体验中心 &amp; 移动端作业组」联合打造的一套企业级移动端 Flutter 组件库，于 12 月 10 日正式开源:</p><p><a href="https://bruno.ke.com/">官网</a></p><p><a href="https://pub.flutter-io.cn/packages/bruno">Pub 地址</a></p><p><a href="https://github.com/LianjiaTech/bruno">GitHub 仓库</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>贝壳自 2018 年底开始对 Flutter 的探索和实践，Flutter 落地业务有效地提升了产研效率。但跨业务线协同效率较低，重复劳动力大，代码维护成本高等问题依旧凸显。Bruno 是贝壳针对上述问题在公司内发起的提效专项，致力于打造贝壳标准 Flutter 生态。经过两年的打磨和沉淀，Bruno 现已服务贝壳 B 端全线业务，涵盖 30 多种类型 100+  组件，为近 18 个 App 服务，新增页面组件覆盖率平均达到 80% 以上。</p><p>相信贝壳遇到的问题也是大型团队或者个人开发者不可避免的问题，目前针对该类问题的中后台解决方案层出不穷，但在 Flutter 生态中类似成熟解决方案匮乏。我们希望将贝壳在 Flutter 领域的实践经验回馈给社区，更加完善 Flutter 生态，因此 Bruno 正式开源。</p><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>Bruno 基于生长、包容、联接的设计理念，赋予组件轻巧灵活、拥抱变化、包容万物的品质。</p><h1 id="Bruno-的优势"><a href="#Bruno-的优势" class="headerlink" title="Bruno 的优势"></a>Bruno 的优势</h1><ol><li>适度灵活、充分可扩展</li></ol><p>Bruno 倡导标准化下的自由、简单、灵活，基于 Flutter 基础组件的封装，使其具备适度灵活，使用组件提效尤为重要。同时组件支持充分可扩展，既可满足多产品的快速接入又能包容特殊场景。</p><p>经过两年的业务实践，我们最终产出了 102 个组件，覆盖类型有 图表、导航、数据录入、操作反馈、内容展示 等。</p><p><img src="http://t-blog-images.aijs.top/img/54b2f46cdc6ee8467b67d92d9c0d2d98.gif"><br>2. 连接设计&lt;–&gt;开发</p><p>Bruno 基于 Sketch MeaXure 二次开发，实现组件自动识别和标注。开发者可以从设计侧产出的标注稿中清晰的看到页面涵盖的组件，信息无缝传达，高效连接设计与开发。</p><p><img src="http://t-blog-images.aijs.top/img/a72e4aee43eb8e32589bef23dd95c75d.gif"><br>3. 主题定制、品牌风格自定义</p><p>Bruno 不仅支持全局色号的替换，还支持组件圆角、字体大小、内部间距等属性的定制。在定制全局样式打造自有品牌风格的同时，支持单个组件自定义满足特异化场景需求。</p><ul><li>默认基础规范</li></ul><img src="http://t-blog-images.aijs.top/img/20220520105949.webp" style="width:400px;object-fit:contain" /><img src="http://t-blog-images.aijs.top/img/20220520110003.webp" style="width:400px;object-fit:contain" /><ul><li>全局样式定制</li></ul><p><img src="http://t-blog-images.aijs.top/img/61dc33d90cd80e88c4a52cccdc713c48.gif"></p><ul><li>单组件样式定制</li></ul><p><img src="http://t-blog-images.aijs.top/img/6da0a3d9b63b47e64a127320597900eb.gif"><br>Bruno 还可支持单业务的全局配置，也就是说如果你是组件化工程结构，那么你可以定义每个业务组件的特有风格。</p><ol start="4"><li>物料承载、教程指引</li></ol><p>Bruno 官网承载产品设计物料、组件配套文档、Demo 下载、搜索等基础能力，同时配有教程指引开发也可操作 Sketch 插件设计页面，实现零设计资源介入。</p><p><img src="http://t-blog-images.aijs.top/img/ea334037633605e094d03338cc151045.gif"><br>Bruno 官网: <a href="https://bruno.ke.com/">https://bruno.ke.com</a></p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><ol><li>丰富和完善组件</li></ol><p>目前 Bruno 组件涵盖种类可以覆盖常见使用场景，满足企业建立自有品牌形象 App 需求。未来我们会根据业务发展和产品升级不断迭代组件，丰富产品内容提升视觉体验。</p><ol start="2"><li>提升落地效率</li></ol><p>我们不止关注组件的设计与研发，组件落地也是提升产研效率至关重要的环节，因此我们对 Sketch MeaXure 做了二次改造，实现组件自动化标注。同时贝壳产研团队把自动化标注能力线上化，进一步提升组件落地效率。</p><p>3、UI 自动化走查</p><p>贝壳产研团队也在探索 UI 自动化走查方向，期望解放设计侧走查人力，让设计师更多投入对产品的洞察理解，创造优质设计，提升视觉体验。</p>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> flutter </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm开发wiki编辑器问题总结</title>
      <link href="//post/2022-05-19npm-pkg.html"/>
      <url>//post/2022-05-19npm-pkg.html</url>
      
        <content type="html"><![CDATA[<h2 id="原架构"><a href="#原架构" class="headerlink" title="原架构"></a>原架构</h2><p><img src="http://t-blog-images.aijs.top/img/wiki-ui.webp"></p><h2 id="重构后"><a href="#重构后" class="headerlink" title="重构后"></a>重构后</h2><p><img src="http://t-blog-images.aijs.top/img/slate-wiki.webp"></p><h2 id="tsconfig-ts"><a href="#tsconfig-ts" class="headerlink" title="tsconfig.ts"></a>tsconfig.ts</h2><pre class="line-numbers language-none"><code class="language-none">&#123;  &#x2F;&#x2F; 编译选项  &quot;compilerOptions&quot;: &#123;    &#x2F;&#x2F; 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码    &quot;target&quot;: &quot;es5&quot;,    &#x2F;&#x2F; 指定要包含在编译中的 library    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;90e83adb44&#x2F;lib&#x2F;lib.dom.iterable.d.ts    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],    &#x2F;&#x2F; 允许 ts 编译器编译 js 文件    &quot;allowJs&quot;: true,    &#x2F;&#x2F; 跳过类型声明文件的类型检查    &quot;skipLibCheck&quot;: true,    &#x2F;&#x2F; es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异    &quot;esModuleInterop&quot;: true,    &#x2F;&#x2F; 允许通过 import x from &#39;y&#39; 即使模块没有显式指定 default 导出    &quot;allowSyntheticDefaultImports&quot;: true,    &#x2F;&#x2F; 开启严格模式    &quot;strict&quot;: true,    &#x2F;&#x2F; 对文件名称强制区分大小写    &quot;forceConsistentCasingInFileNames&quot;: true,    &#x2F;&#x2F; 为 switch 语句启用错误报告    &quot;noFallthroughCasesInSwitch&quot;: true,    &#x2F;&#x2F; 生成代码的模块化标准    &quot;module&quot;: &quot;esnext&quot;,    &#x2F;&#x2F; 模块解析（查找）策略    &quot;moduleResolution&quot;: &quot;node&quot;,    &#x2F;&#x2F; 允许导入扩展名为.json的模块    &quot;resolveJsonModule&quot;: true,    &#x2F;&#x2F; 是否将没有 import&#x2F;export 的文件视为旧（全局而非模块化）脚本文件    &quot;isolatedModules&quot;: true,    &#x2F;&#x2F; 编译时不生成任何JS文件（只进行类型检查）    &quot;noEmit&quot;: true,    &#x2F;&#x2F; 指定将 JSX 编译成什么形式    &quot;jsx&quot;: &quot;react-jsx&quot;  &#125;,  &#x2F;&#x2F; 指定允许 ts 处理的目录  &quot;include&quot;: [&quot;src&quot;]&#125;&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_62118859&#x2F;article&#x2F;details&#x2F;124543485</code></pre><h2 id="Cannot-read-properties-of-null"><a href="#Cannot-read-properties-of-null" class="headerlink" title="Cannot read properties of null"></a>Cannot read properties of null</h2><pre class="line-numbers language-none"><code class="language-none">react.development.js:1621 Uncaught TypeError: Cannot read properties of null</code></pre><hr/><h2 id="ahooks-版本"><a href="#ahooks-版本" class="headerlink" title="ahooks 版本"></a>ahooks 版本</h2><ol><li>useControlledValue</li></ol><pre class="line-numbers language-none"><code class="language-none">Uncaught SyntaxError: The requested module &#39;&#x2F;node_modules&#x2F;.vite&#x2F;deps&#x2F;ahooks.js?v&#x3D;a7b43f7a&#39; does not provide an export named &#39;useControlledValue&#39; (at index.tsx:2:1)</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Deprecated the useControlledValue naming left over from 1.0, please use useControllableValue instead<br><a href="https://github.com/alibaba/hooks/releases?page=5#:~:text=Deprecated%20the%20useControlledValue%20naming%20left%20over%20from%201.0%2C%20please%20use%20useControllableValue%20instead"><a href="https://github.com/alibaba/hooks/releases/tag/v3.0.0-alpha.4">v3.0.0-alpha.4</a></a></p></blockquote><ol start="2"><li>useRequest</li></ol><pre class="line-numbers language-none"><code class="language-none">react_devtools_backend.js:4026 Warning: Failed prop type: The prop &#96;loadMore&#96; is marked as required in &#96;InfiniteScroll&#96;, but its value is &#96;undefined&#96;.</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Removed loadMore related attributes, it is recommended to use useInfiniteScroll to achieve unlimited loading capacity.<br><a href="https://github.com/alibaba/hooks/releases/tag/v3.0.0-alpha.4">v3.0.0-alpha.4</a></p></blockquote><p><a href="http://quanzhan.applemei.com/webStack/TmpJeE1BPT0=">除了 dependencies 和 devDependencies，其他的依赖有什么作用呢</a></p><pre class="line-numbers language-none"><code class="language-none">Pre-bundling dependencies:reactrecoilreact-domreact-router-domantd(...and 29 more)</code></pre><h3 id="本地npm-link处理不了依赖冲突"><a href="#本地npm-link处理不了依赖冲突" class="headerlink" title="本地npm link处理不了依赖冲突"></a>本地<code>npm link</code>处理不了依赖冲突</h3><ul><li>老版本可以运行</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220519183558.webp"></p><ul><li>新版本报错</li><li>原因 ahooks^3.x.x 没有 v2 版本 api</li></ul><hr/><h3 id="发布安装到项目中测试"><a href="#发布安装到项目中测试" class="headerlink" title="发布安装到项目中测试"></a>发布安装到项目中测试</h3><ul><li>发布</li></ul><ol><li>npm 脚本</li></ol><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite --port 3004&quot;,    &quot;start&quot;: &quot;yarn build:css &amp;&amp; webpack serve --config config&#x2F;webpack.dev.config.js&quot;,    &quot;copy:css&quot;: &quot;cp src&#x2F;**&#x2F;*.css dist&#x2F; &amp;&amp; rsync src&#x2F;styles&#x2F;*.css dist&#x2F;styles&#x2F;&quot;,    &quot;build&quot;: &quot;tsc&quot;,    &quot;build:css&quot;: &quot;node-sass src&#x2F; -o src&#x2F; &quot;,    &quot;prepublishOnly&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,    &quot;t&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,    &quot;push:beta&quot;: &quot;npm publish --tag beta&quot;  &#125;,</code></pre><ol start="2"><li>执行脚本<br><code>$ yarn push:beta</code></li><li>发布结果</li></ol><pre class="line-numbers language-none"><code class="language-none">## Current Tags*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           beta (a few seconds ago)*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           latest (a few seconds ago)</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220519183625.webp"><br><img src="http://t-blog-images.aijs.top/img/20220519183638.webp"></p><hr/><h2 id="图片没有渲染，修改，打包重新发布0-0-1-220519beta版本测试"><a href="#图片没有渲染，修改，打包重新发布0-0-1-220519beta版本测试" class="headerlink" title="图片没有渲染，修改，打包重新发布0.0.1-220519beta版本测试"></a>图片没有渲染，修改，打包重新发布<code>0.0.1-220519beta</code>版本测试</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">slate-wiki@0.0.1-220519betanpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D;npm notice name:          @ty-fe&#x2F;slate-wikinpm notice version:       0.0.1-220519betanpm notice filename:      @ty-fe&#x2F;slate-wiki-0.0.1-220519beta.tgznpm notice package size:  228.0 kBnpm notice unpacked size: 1.2 MBnpm notice shasum:        a2991de4933a9e5039ceb7082c5e0a80c2db828cnpm notice integrity:     sha512-iHQKpR2LM+F6Z[...]XDN40tHfwMxNg&#x3D;&#x3D;npm notice total files:   417npm notice+ @ty-fe&#x2F;slate-wiki@0.0.1-220519beta✨  Done in 16.36s.slate-wiki-pro@0.0.1-220519betanpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D;npm notice name:          @ty-fe&#x2F;slate-wiki-pronpm notice version:       0.0.1-220519betanpm notice filename:      @ty-fe&#x2F;slate-wiki-pro-0.0.1-220519beta.tgznpm notice package size:  83.5 kBnpm notice unpacked size: 413.7 kBnpm notice shasum:        85cbe6fbffafc75db16e02427d1eac9b6a906ec3npm notice integrity:     sha512-3viVco6ssb2N3[...]xxisHN9+qYnCA&#x3D;&#x3D;npm notice total files:   205npm notice+ @ty-fe&#x2F;slate-wiki-pro@0.0.1-220519beta✨  Done in 14.68s.</code></pre><hr/><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>传染性<br>slate-wiki-pro,依赖于 slate-wiki。slate-wiki 改动，项目依赖 slate-wiki-pro，需要发 slate-wiki 和 slate-wiki-pro，项目要安装 slate-wiki-pro</li></ol><p><code>是否可以让项目直接依赖slate-wiki、slate-wiki-pro改动哪个发布哪个，互不影响？</code></p><ol start="2"><li>项目很卡</li></ol><p><code>将slate、slate-wiki、slate-wiki-pro使用umd资源，避免重复编译是否可以？</code></p><ol start="3"><li>依赖贼多</li></ol><pre class="line-numbers language-none"><code class="language-none">[######--------------------------------------------------] 49992&#x2F;102014</code></pre><ol start="4"><li>启动没有想象中那么快了</li></ol><p>vite 预编译时间过长 130262ms &#x2F; 1000 &#x2F; 60 大概两分钟，加载编译大概几分钟，慢的吓人</p><pre class="line-numbers language-none"><code class="language-none">vite v2.7.1 dev server running at:&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;&gt; Network: use &#96;--host&#96; to exposeready in 130262ms.  #首次编译vite v2.7.1 dev server running at:&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;&gt; Network: use &#96;--host&#96; to exposeready in 43312ms. #非首次编译</code></pre><hr/><h2 id="代码放仓库"><a href="#代码放仓库" class="headerlink" title="代码放仓库"></a>代码放仓库</h2><ul><li>slate-wiki</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220519183700.webp"></p><p>Command line instructions<br>You can also upload existing files from your computer using the instructions below.</p><p>Git global setup</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;陈海龙&quot;git config --global user.email &quot;haotian.chen@ty.com&quot;</code></pre><p>Create a new repository</p><pre class="line-numbers language-none"><code class="language-none">git clone ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.gitcd slate-wikitouch README.mdgit add README.mdgit commit -m &quot;add README&quot;</code></pre><p>Push an existing folder</p><pre class="line-numbers language-none"><code class="language-none">cd existing_foldergit initgit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.gitgit add .git commit -m &quot;Initial commit&quot;</code></pre><p>Push an existing Git repository</p><pre class="line-numbers language-none"><code class="language-none">cd existing_repogit remote rename origin old-origingit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git</code></pre><ul><li>slate-wiki-pro<br>略<hr/></li></ul><p>深入了解打包，本站请搜<a href="/#/post/2022-05-19npm"><code>npm 版本的依赖</code></a></p><h2 id="react-codemirror-使用版本-react16-插件及项目使用-react18"><a href="#react-codemirror-使用版本-react16-插件及项目使用-react18" class="headerlink" title="react-codemirror 使用版本 react16,插件及项目使用 react18"></a>react-codemirror 使用版本 react16,插件及项目使用 react18</h2><pre class="line-numbers language-none"><code class="language-none">react-dom.development.js:22738 Uncaught TypeError: cm is not a function    at UnControlled.componentDidMount (react-codemirror.tsx:718:19)    at commitLayoutEffectOnFiber (react-dom.development.js:23204:30)    at commitLayoutMountEffects_complete (react-dom.development.js:24578:9)    at commitLayoutEffects_begin (react-dom.development.js:24564:7)    at commitLayoutEffects (react-dom.development.js:24502:3)    at commitRootImpl (react-dom.development.js:26779:5)    at commitRoot (react-dom.development.js:26638:5)    at performSyncWorkOnRoot (react-dom.development.js:26073:3)    at flushSyncCallbacks (react-dom.development.js:12009:22)    at flushSyncCallbacksOnlyInLegacyMode (react-dom.development.js:11988:5)</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220520141611.webp"></p><h2 id="vite-关于-global-is-not-defined-问题"><a href="#vite-关于-global-is-not-defined-问题" class="headerlink" title="vite 关于 global is not defined 问题"></a>vite 关于 global is not defined 问题</h2><p><a href="https://github.com/scniro/react-codemirror2/blob/0f2bb13cad2fb1364eb063cbd7ec9aae726a55eb/src/index.tsx#L7">react-codemirror2 源码</a></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">declare let global: any;declare let require: any;const SERVER_RENDERED &#x3D;  typeof navigator &#x3D;&#x3D;&#x3D; &quot;undefined&quot; ||  (typeof global !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp;    global[&quot;PREVENT_CODEMIRROR_RENDER&quot;] &#x3D;&#x3D;&#x3D; true);let cm;if (!SERVER_RENDERED) &#123;  cm &#x3D; require(&quot;codemirror&quot;);&#125;</code></pre><h2 id="vite-404"><a href="#vite-404" class="headerlink" title="vite 404"></a>vite 404</h2><pre class="line-numbers language-none"><code class="language-none">Could not load content for http:&#x2F;&#x2F;localhost:3005&#x2F;node_modules&#x2F;@ty-fe&#x2F;slate-wiki&#x2F;src&#x2F;slate&#x2F;3rd&#x2F;react-codemirror.tsx(HTTP error: status code 404, net::ERR_HTTP_RESPONSE_CODE_FAILURE)</code></pre><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li>codemirror 在 vite 中运行报错，codemirror 找不到，webpack 打包正常</li></ul>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 版本的依赖</title>
      <link href="//post/2022-05-19npm.html"/>
      <url>//post/2022-05-19npm.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。</p><h1 id="npm-安装机制"><a href="#npm-安装机制" class="headerlink" title="npm 安装机制"></a>npm 安装机制</h1><p>A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。</p><h2 id="A-和-B-同时依赖-C，这个包会被安装在哪里呢？"><a href="#A-和-B-同时依赖-C，这个包会被安装在哪里呢？" class="headerlink" title="A 和 B 同时依赖 C，这个包会被安装在哪里呢？"></a>A 和 B 同时依赖 C，这个包会被安装在哪里呢？</h2><p>假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。执行完毕后，我们会看到 <code>./node_modules</code> 这层目录只含有这两个子目录：</p><pre class="line-numbers language-none"><code class="language-none">node_modules&#x2F; ├─┬ A │ ├── C ├─┬ B │ └── C </code></pre><p>如果使用 npm 3 来进行安装的话，<code>./node_modules</code> 下的目录将会包含三个子目录：</p><pre class="line-numbers language-none"><code class="language-none">node_modules&#x2F; ├─┬ A ├─┬ B ├─┬ C </code></pre><p>为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：</p><h2 id="npm-2-和-npm-3-模块安装机制的差异"><a href="#npm-2-和-npm-3-模块安装机制的差异" class="headerlink" title="npm 2 和 npm 3 模块安装机制的差异"></a>npm 2 和 npm 3 模块安装机制的差异</h2><p>虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异。</p><p>npm 2 在安装依赖包时，采用简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。执行完毕后，我们会看到 .&#x2F;node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：</p><p><img src="http://t-blog-images.aijs.top/img/20220519181427.webp"></p><p>这样的目录有较为明显的好处：</p><p>1）层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；</p><p>2）在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；</p><p>3）如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；</p><p>但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 <code>npm install</code> 后，D 会被重复下载三次，而随着我们的项目越来越复杂，<code>node_modules</code> 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；</p><p>为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。</p><h2 id="npm-3-对于同一依赖的不同版本会怎么处理呢？"><a href="#npm-3-对于同一依赖的不同版本会怎么处理呢？" class="headerlink" title="npm 3 对于同一依赖的不同版本会怎么处理呢？"></a>npm 3 对于同一依赖的不同版本会怎么处理呢？</h2><p>npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):</p><p><img src="http://t-blog-images.aijs.top/img/20220519181500.webp"></p><p>但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：</p><p><img src="http://t-blog-images.aijs.top/img/20220519181517.webp"></p><p>由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。</p><h2 id="为什么会出现-package-lock-json-呢？"><a href="#为什么会出现-package-lock-json-呢？" class="headerlink" title="为什么会出现 package-lock.json 呢？"></a>为什么会出现 package-lock.json 呢？</h2><p>为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。</p><h2 id="package-json-的不足之处"><a href="#package-json-的不足之处" class="headerlink" title="package.json 的不足之处"></a>package.json 的不足之处</h2><p>npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：</p><p>1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 <code>A: &#39;^1.0.5&#39;</code> ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；</p><p>2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 <code>A: &#39;1.0.5&#39;</code> 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。</p><h2 id="针对-package-json-不足的解决方法"><a href="#针对-package-json-不足的解决方法" class="headerlink" title="针对 package.json 不足的解决方法"></a>针对 package.json 不足的解决方法</h2><p>为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。</p><h2 id="package-lock-json-文件的结构"><a href="#package-lock-json-文件的结构" class="headerlink" title="package-lock.json 文件的结构"></a>package-lock.json 文件的结构</h2><p>package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 <a href="https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires">package-lock-json官方文档</a>，主要的结构如下：</p><ul><li><p>version ：包版本，即这个包当前安装在 node_modules 中的版本</p></li><li><p>resolved ：包具体的安装来源</p></li><li><p>integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效</p></li><li><p>requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同</p></li><li><p>dependencies ：结构和外层的 <code>dependencies</code> 结构相同，存储安装在子依赖 <code>node_modules</code> 中的依赖包</p></li></ul><p>需要注意的是，并不是所有的子依赖都有 <code>dependencies</code> 属性，只有子依赖的依赖和当前已安装在根目录的 <code>node_modules</code> 中的依赖冲突之后，才会有这个属性。</p><h2 id="package-lock-json-文件的作用"><a href="#package-lock-json-文件的作用" class="headerlink" title="package-lock.json 文件的作用"></a>package-lock.json 文件的作用</h2><p>在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；</p><p>node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。</p><p>由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。</p><p>在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。</p><h1 id="依赖的区别与使用场景"><a href="#依赖的区别与使用场景" class="headerlink" title="依赖的区别与使用场景"></a>依赖的区别与使用场景</h1><h2 id="npm-目前支持以下几类依赖包管理包括"><a href="#npm-目前支持以下几类依赖包管理包括" class="headerlink" title="npm 目前支持以下几类依赖包管理包括"></a>npm 目前支持以下几类依赖包管理包括</h2><ol><li><p>dependencies</p></li><li><p>devDependencies</p></li><li><p>optionalDependencies 可选择的依赖包</p></li><li><p>peerDependencies 同等依赖</p></li><li><p>bundledDependencies 捆绑依赖包</p></li></ol><p>下面我们来看一下这几种依赖的区别以及各自的应用场景：</p><h2 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h2><p>dependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 <code>npm install XXX --save</code> 下载 dependencies 中的包；</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;devDependencies&quot;:&#123;  &quot;eslint&quot;: &quot;^5.0.0&quot;,  &quot;debug&quot;: &quot;^3.1.0&quot;,&#125;</code></pre><h2 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h2><p>devDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 <code>npm install packageName --save-dev</code> 下载的包都会在 devDependencies 对象中；</p><p>dependencies 和 devDependencies 最大的区别是在打包运行时，执行 <code>npm install</code> 时默认会把所有依赖全部安装，但是如果使用 <code>npm install --production</code> 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。</p><h2 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h2><p>optionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。</p><p>optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">try &#123;   var axios &#x3D; require(&#39;axios&#39;)   var fooVersion &#x3D; require(&#39;axios&#x2F;package.json&#39;).version &#125; catch (er) &#123;   foo &#x3D; null &#125; &#x2F;&#x2F; .. then later in your program .. if (foo) &#123;   foo.doFooThings() &#125; </code></pre><h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h2><p>peerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 <code>ant-design@3.x</code> 的 <code>package.json</code> 中的配置如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;peerDependencies&quot;: &#123;   &quot;react&quot;: &quot;&gt;&#x3D;16.9.0&quot;,   &quot;react-dom&quot;: &quot;&gt;&#x3D;16.9.0&quot;  &#125;, </code></pre><p>假设我们创建了一个名为 project 的项目，在此项目中我们要使用 <code>ant-design@3.x</code> 这个插件，此时我们的项目就必须先安装 React &gt;&#x3D; 16.9.0 和 React-dom &gt;&#x3D; 16.9.0 的版本。</p><p>在 npm 2 中，当我们下载 <code>ant-design@3.x</code> 时，peerDependencies 中指定的依赖会随着 <code>ant-design@3.x</code> 一起被强制安装，所以我们不需要在宿主项目的 <code>package.json</code> 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；</p><h2 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h2><p>这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;   &quot;name&quot;: &quot;project&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;bundleDependencies&quot;: [     &quot;axios&quot;,      &quot;lodash&quot;   ] &#125; </code></pre><p>当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 <code>npm install project-1.0.0.tgz</code> 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;bundleDependencies&quot;: [     &quot;axios&quot;,     &quot;lodash&quot;   ], &quot;dependencies&quot;: &#123;   &quot;axios&quot;: &quot;*&quot;,   &quot;lodash&quot;: &quot;*&quot; &#125;, </code></pre><p>如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.zoo.team/article/npm-details">原文</a></li><li><a href="https://docs.npmjs.com/files/package.json#peerdependencies">package.json官方文档</a></li><li><a href="https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires">package-lock-json官方文档</a></li><li><a href="https://juejin.im/post/6844903582337237006#heading-0">npm文档总结</a></li><li><a href="https://www.npmjs.cn/cli/pack/">npm-pack</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript noEmit</title>
      <link href="//post/2022-05-18ts.html"/>
      <url>//post/2022-05-18ts.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>No Emit -<br>noEmit<br>Do not emit compiler output files like JavaScript source code, source-maps or declarations.<br>不要发出编译器输出文件，如JavaScript源代码、源映射或声明。</p><p>This makes room for another tool like Babel, or swc to handle converting the TypeScript file to a file which can run inside a JavaScript environment.</p><p>You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.</p><p><code>导致outDir不输出</code></p>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slate 学习</title>
      <link href="//post/2022-04-29slate-lean.html"/>
      <url>//post/2022-04-29slate-lean.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://doodlewind.github.io/slate-doc-cn/">slate 中文文档</a><br><a href="https://docs.slatejs.org/">slate 英文文档</a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://doodlewind.github.io/slate-doc-cn/">Slate</a> 是一个 完全 可定制的富文本编辑框架。<br>通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。</p></blockquote><h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。<br>Slate 之所以能做到这一点，是因为它的所有逻辑都是通过一系列的插件实现的。这样，你就再也不会被某项特性 在 或 不在 编辑器【核心】边界之内的问题所困扰了。你可以将它理解为在 React 和 Immutable 基础上，一种可插拔的 contenteditable 实现。另外，它的灵感来自于 Draft.js，Prosemirror 和 Quill 等类库。</p></blockquote><h2 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为什么发明 Slate 呢？好吧…（注意，这部分内容包含了一些我的个人观点！）</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在发明 Slate 之前，我尝试了许多不同的富文本编辑器。我发现虽然它们在编写简单示例时基本没有问题，但一旦想要构建一些类似 Medium、Dropbox Paper 或者 Google Docs 这样的内容，你就会发现一些深层次的问题，比如…</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>编辑器硬编码了文档的结构规范，难以定制</strong>。类似加粗和斜体的结构可以开箱即用，但评论、嵌入内容以及更多的定制性需求呢？</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>对文档的编程式变换非常错综复杂</strong>。用户的编写体验可能不错，但在执行编程式变更时却不必要地复杂，而这对于构建高级的编辑行为至关重要。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>对 HTML、Markdown 等内容的序列化支持看起来像是事后加上的</strong>。这是一个非常常见的使用场景，但要实现将文档转换为 HTML 或 Markdown 的简单功能都需要编写大量的模板代码。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>重新学习一个新的视图层效率不高且十分受限</strong>。各种编辑器在重新发明视图层的轮子，而非使用 React 这样已有的技术方案。你必须学习一套带着自有限制和陷阱的新系统。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>**<code>对协同编辑没有预先设计好的支持</code>**。编辑器内部的数据结构使其无法用于实时、协作的编辑场景中，除非重写编辑器。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>代码仓库是单体的，而非小而可复用的</strong>。许多编辑器没有对外开放本应为开发者所复用的内部工具，以至于不得不重新发明轮子。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>无法构建复杂而存在嵌套关系的文档</strong>。不少编辑器是围绕简单的【扁平】文档结构设计的，这使得表格、嵌入内容和字幕等内容难以理解，有时甚至无法实现。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当然，并非所有的编辑器都存在以上的问题，但如果你已经尝试过一些编辑器，你可能已经踩过类似的坑了。为了摆脱它们在 API 上的限制来达到你期望的用户体验，你得使用各种奇技淫巧，有些体验甚至是完全无法实现的。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>如果你遇到了相似的问题，那么也许你会喜欢上 Slate。让我来介绍一下 Slate 是如何解决这些问题的吧…</p></blockquote><h2 id="提供了什么能力"><a href="#提供了什么能力" class="headerlink" title="提供了什么能力"></a>提供了什么能力</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Slate 尝试通过一些原则来解决 “Why?” 这一节中的问题：</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>作为一等公民的插件</strong>。 在 Slate 中最重要的一点是，插件是一等公民（first-class）的实体——甚至连编辑器的核心逻辑都是通过插件实现的。这意味着你能够 完全地 定制编辑体验，构建出对标 Medium 和 Canvas 那样的复杂编辑器，而无需对抗各种类库的预设条件。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>精简 Schema 的核心</strong>。 Slate 的核心逻辑并不对你所编辑的数据结构做任何假设，这意味着你在需要应对复杂场景时不会被编辑器预置的内容所束缚（译者注：此处 Schema 可理解为类似 XML Schema 的文档结构规范）。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>支持嵌套的文档模型</strong>。 Slate 所使用的文档模型是一棵嵌套的、递归的树，和 DOM 本身十分接近。这使得构建表格和嵌套引用等能够满足进阶需求的复杂组件成为了可能。当然，你同样可以使用单一的层级关系以保证简单性。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>无状态、不可变的数据</strong>。 通过使用 React 和 Immutable.js，我们是基于不可变数据结构，以无状态的方式构建 Slate 编辑器的。这大大降低了理解代码的难度，也节约了大量开发插件的时间。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>直观的 changes</strong>。 Slate 中的内容是通过 “change” 来编辑的，这是一种被设计为支持高阶使用，且极其符合直觉的概念。这样，我们就能够通过它来尽可能简单地编写插件和自定义功能了。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>**<code>为协同编辑准备的数据模型</code>**。 Slate 使用的数据模型——尤其是由 change 更改文档的方式——在设计时就已考虑到对协同编辑的支持。所以，如果你决定为编辑器添加协作功能，你不需要进行彻底的重构。（当然，这还需要你投入更多的努力！）</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>明确的【核心】边界划分。 通过插件优先的架构与精简 Schema 的内核，Slate 对于【核心】和【自定义】有着明确得多的划分，从而保证核心的编辑体验不会为各种边缘情况所困扰。</p></blockquote><h2 id="协同编辑，这个后面会持续关注"><a href="#协同编辑，这个后面会持续关注" class="headerlink" title="协同编辑，这个后面会持续关注"></a>协同编辑，这个后面会持续关注</h2><p><img src="http://t-blog-images.aijs.top/img/20220429152337.png"><br><a href="https://docs.slate-yjs.dev/">slate-yjs</a><br><a href="https://docs.yjs.dev/">yjs</a></p><h2 id="slate-文档不是很多，半小时看完"><a href="#slate-文档不是很多，半小时看完" class="headerlink" title="slate 文档不是很多，半小时看完"></a>slate 文档不是很多，半小时看完</h2><p>主要内容 </p><ul><li>插件定制化</li><li>渲染节点定制化</li><li>按键监听处理</li><li>数据格式编码、反编码</li><li>数据存储</li></ul><h2 id="就这点东西😱"><a href="#就这点东西😱" class="headerlink" title="就这点东西😱"></a>就这点东西😱</h2><p>竟然有些同学凭借slate的使用拿了3.75,赶紧学～</p>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="//post/2022-05-13design_mode.html"/>
      <url>//post/2022-05-13design_mode.html</url>
      
        <content type="html"><![CDATA[<h2 id="先聊用到过哪些，背后的设计模式是什么"><a href="#先聊用到过哪些，背后的设计模式是什么" class="headerlink" title="先聊用到过哪些，背后的设计模式是什么"></a>先聊用到过哪些，背后的设计模式是什么</h2><ol><li>实例化一个 axios 实例，全局都来使用它 <em>单例模式</em></li><li>兄弟组件通信,事件监听 <em>观察者模式</em></li><li>构造函数继承、类的继承 <em>构造函数模式</em></li><li>实例化不同的实例 <em>工厂模式</em></li><li>优化中的<code>事件代理</code><em>代理模式</em></li><li>esm、commonjs<em>模块模式</em></li></ol><p><em>熟悉而又陌生</em>：熟悉的是一直在用，陌生的是学名竟然是这些。我都有点怀疑了，这是真的吗？是真的吗？～～～</p><p><img    src="https://img1.baidu.com/it/u=1902986975,2375222058&fm=253&fmt=auto&app=138&f=JPEG?w=535&h=500"    width=100 style="border-radius: 10px"    /></p>   <div style="font-size: 20px; color: orange;margin-top: 30px">来～来～来～，我们继续。。。</div><h2 id="啥呀"><a href="#啥呀" class="headerlink" title="啥呀"></a>啥呀</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>“设计模式(英语 design pattern)是对面向对象设计中<code>反复出现的问题的解决方案</code>。这个术语是在1990年代由Erich Gamma等人从建筑设计领域<code>引入到</code>计算机科学中来的。”</p></blockquote><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li>作用：访问控制</li><li>场景：事件代理、Proxy、Object.defineProperty</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>定义：唯一实例，全局可访问</li><li>场景：请求实例、全局缓存、线程池、window 对象、登录浮框</li><li>实现：已经创建过的直接返回，不重复创建</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>作用：创建同一类对象</li><li>分类：<em>简单工厂_、_方法工厂</em></li></ul><h3 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1. 简单工厂"></a>1. 简单工厂</h3><ul><li>例如：项目中根据用户权限渲染不同的页面，在不同权限等级用户的构造函数中，保存用户可以看到的页面</li><li>优点：一个正确的参数，就可以获取到所需要的对象，无需知道其创建的具体细节</li><li>缺点：函数会成为一个超级函数，难以维护，简单工厂适用于创建少量对象，对象的逻辑不能复杂</li></ul><h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h3><ul><li>本质：将创建对象的工作，推迟到子类中，这样核心类就变成抽象类</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let UserFactory &#x3D; function (type) &#123;  if (this instanceof UserFactory) &#123;    return new this[type]();  &#125; else &#123;    return new UserFactory(type);  &#125;&#125;;&#x2F;&#x2F; 工厂方法，函数的原型中设置所有对象的构造函数UserFactory.prototype &#x3D; &#123;  SuperAdmin: function () &#123;    this.name &#x3D; &quot;超级管理员&quot;;    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;, &quot;应用管理&quot;, &quot;权限管理&quot;];  &#125;,  Admin: function () &#123;    this.name &#x3D; &quot;管理员&quot;;    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;];  &#125;,  NormalUser: function () &#123;    this.name &#x3D; &quot;普通用户&quot;;    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;];  &#125;,&#125;;&#x2F;&#x2F; 调用let superAdmin &#x3D; new UserFactory(&quot;SuperAdmin&quot;);let admin &#x3D; new UserFactory(&quot;Admin&quot;);let normalUser &#x3D; new UserFactory(&quot;NormalUser&quot;);</code></pre><h3 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3. 抽象工厂"></a>3. 抽象工厂</h3><ul><li></li></ul><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><h2 id="👀-观察者模式"><a href="#👀-观察者模式" class="headerlink" title="👀 观察者模式"></a>👀 观察者模式</h2><ul><li>定义： 对象间的一种一对多的依赖关系</li><li>作用：一个对象状态发生变化时，所有依赖他的对象，都将得到通知</li><li>优点：解耦</li><li>组成：发布者、订阅者</li><li>场景：事件监听、eventBus</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">document.body.addEventListener(&quot;click&quot;, function () &#123;&#125;, false);</code></pre><h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><ul><li>作用：避免全局污染，按需暴露</li><li>实现：多采用闭包</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var Person &#x3D; (function () &#123;  var name &#x3D; &quot;xxx&quot;;  function sayName(params) &#123;    console.log(name);  &#125;  return &#123;    name,    sayName,  &#125;;&#125;)();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ant design form设置值 !== 获取值</title>
      <link href="//post/2022-05-13react.html"/>
      <url>//post/2022-05-13react.html</url>
      
        <content type="html"><![CDATA[<h2 id="有意思的事"><a href="#有意思的事" class="headerlink" title="有意思的事"></a>有意思的事</h2><ul><li>今天维护项目遇到一个有意思的事，直观感受，设置值，再取出来，貌似没毛病<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">  &#x2F;&#x2F; ...  const [values, setValues] &#x3D; useState&lt;Record&lt;string, any&gt;&gt;()  const &#123; applyStartTime, applyEndTime, attendanceType, staffId &#125; &#x3D; values || &#123;&#125;  const getDetail &#x3D; usePersistFn(async () &#x3D;&gt; &#123;    &#x2F;&#x2F; ...略    const obj: Record&lt;string, any&gt; &#x3D; &#123;      staffId: applyStaff.staffId,      attendanceType: res.result.attendanceType,      applyStartTime: &#123;        value: moment(res.result.applyStartTime),        half: res.result.startDayType,      &#125;,      applyEndTime: &#123;        value: moment(res.result.applyEndTime),        half: res.result.endDayType,      &#125;,      applyReason,      applyAttachments,    &#125;    &#x2F;&#x2F; ...略    form.setFieldsValue(obj)    setValues(form.getFieldsValue())  &#125;)  &#x2F;&#x2F; ...略  const &#123; total, loading: totalLoading &#125; &#x3D; useCaculateDays(    &#123;      start: applyStartTime,      end: applyEndTime,    &#125;,    staffId,    attendanceType,  )  &#x2F;&#x2F; ...略  &#x2F;&#x2F; AnualForm组件  &lt;Form.Item name&#x3D;&quot;applyStartTime&quot; label&#x3D;&quot;起始日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;      &lt;HalftDatePicker predict&#x3D;&#123;&#123; lessThan: end?.value &#125;&#125; &#x2F;&gt;    &lt;&#x2F;Form.Item&gt;  &lt;Form.Item name&#x3D;&quot;applyEndTime&quot; label&#x3D;&quot;结束日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;    &lt;HalftDatePicker predict&#x3D;&#123;&#123; moreThan: start?.value &#125;&#125; &#x2F;&gt;  &lt;&#x2F;Form.Item&gt;  type IValue &#x3D; &#123;    value?: moment.Moment    half: 1 | 2  &#125; &#x2F;&#x2F; HalftDatePicker组件const HalftDatePicker: React.ForwardRefRenderFunction&lt;any, PickerProps&lt;moment.Moment&gt; &amp; &#123;  value?: IValue  onChange?: (v?: IValue) &#x3D;&gt; void  predict?: &#123;    lessThan?: moment.Moment    moreThan?: moment.Moment    holiday?: boolean  &#125;&#125;&gt; &#x3D; (props, ref) &#x3D;&gt; &#123;  &#x2F;&#x2F; ...略&#125;</code></pre></li></ul><p>代码的目的是： </p><ol><li>请求详情</li><li>装配数据，更新values</li><li>useCaculateDays 通过后台动态计算有效工作日，返回total请假天数，</li><li>渲染total到表单对应位置</li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>经过一点一点回溯调试，发现 useCaculateDays 没请求，被判断拦截掉了，往上找找，</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">form.setFieldsValue(obj)setValues(form.getFieldsValue())</code></pre><h3 id="打上日志"><a href="#打上日志" class="headerlink" title="打上日志"></a>打上日志</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; ...略console.log(&quot;obj&quot;,obj);form.setFieldsValue(obj)console.log(&quot;obj1&quot;,form.getFieldsValue());setValues(obj)</code></pre><p>发现<code>obj</code>键值内容不等于<code>obj1</code></p><ul><li>obj</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;staffId&quot;: &quot;02333&quot;,    &quot;attendanceType&quot;: 11,    &quot;applyStartTime&quot;: &#123;        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,        &quot;half&quot;: 1    &#125;,    &quot;applyEndTime&quot;: &#123;        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,        &quot;half&quot;: 2    &#125;,    &quot;applyReason&quot;: &quot;&quot;,    &quot;applyAttachments&quot;: []&#125;</code></pre><ul><li>obj1<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;staffId&quot;: &quot;02333&quot;,    &quot;attendanceType&quot;: 11,    &quot;applyReason&quot;: &quot;&quot;,    &quot;applyAttachments&quot;: []&#125;</code></pre></li></ul><p><em>猜想</em></p><ul><li>会不会<code>form.setFieldsValue</code>异步？查了下api是同步的<em>排除这种可能</em></li><li>断点调试过程中，也会遇到表单渲染一半的情况，<code>AnualForm组件</code>是条件渲染，如果这块表单没有渲染出来，通过<code>form.getFieldsValue</code>就拿不到</li></ul><h3 id="修改代码验证下猜想"><a href="#修改代码验证下猜想" class="headerlink" title="修改代码验证下猜想"></a>修改代码验证下猜想</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">console.log(&quot;obj&quot;,obj);form.setFieldsValue(obj)console.log(&quot;obj1&quot;,form.getFieldsValue());setTimeout(() &#x3D;&gt; &#123;  setValues(form.getFieldsValue())  &#125;, 5000);&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/Kapture%202022-05-13%20at%2016.01.46.gif" width=300 /><h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">form.setFieldsValue(obj)setValues(obj)</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ModHeader</title>
      <link href="//post/2022-05-13modeheader.html"/>
      <url>//post/2022-05-13modeheader.html</url>
      
        <content type="html"><![CDATA[<h2 id="通过不同请求头字段标识请求不同的环境"><a href="#通过不同请求头字段标识请求不同的环境" class="headerlink" title="通过不同请求头字段标识请求不同的环境"></a>通过不同请求头字段标识请求不同的环境</h2><img src="http://t-blog-images.aijs.top/img/20220513145839.webp" width=400 /><h3 id="Requesr-Headers"><a href="#Requesr-Headers" class="headerlink" title="Requesr Headers"></a>Requesr Headers</h3><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Accept: *&#x2F;*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,zh-TW;q&#x3D;0.7Cache-Control: no-cacheConnection: keep-alivecontent-type: application&#x2F;json; charset&#x3D;utf-8Cookie: perfLang&#x3D;zh; envtag: ladon-1        Host: localhost:3119Pragma: no-cacheReferer: http:&#x2F;&#x2F;localhost:3119&#x2F;sec-ch-ua: &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;101&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;101&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;macOS&quot;</code></pre><h3 id="不生效了"><a href="#不生效了" class="headerlink" title="不生效了"></a>不生效了</h3><p>理论上是没问题，应该是由于某些原因导致这个插件内部运行出了问题，具体什么问题不知<br><em>处理：</em>将浏览器重启动后,请求头<code>envtag: ladon-1</code>增加成功</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-性能优化1</title>
      <link href="//post/2022-05-12performance.html"/>
      <url>//post/2022-05-12performance.html</url>
      
        <content type="html"><![CDATA[<h2 id="优化的指标"><a href="#优化的指标" class="headerlink" title="优化的指标"></a>优化的指标</h2><p>白屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器出现第一个元素<br>首屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器第一屏渲染完成</p><p>影响白屏时间的因素：网络，服务端性能，前端页面结构设计。<br>影响首屏时间的因素：白屏时间，资源下载执行时间。</p><p>通常在 head 解析完，body 开始渲染此时是白屏结束<br>白屏时间 &#x3D; firstPaint - performance.timing.navigationStart || pageStartTime</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>首屏模块标签标记， 你觉得首屏完成的地方插入脚本</li><li>同级首屏内加载最慢的图片&#x2F;iframe</li></ol><p>这个图看不懂没关系，往下看，后面会以简书代码和掘金来验证这幅图的正确性</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9sejV6LmNvbS9hc3NldHMvaW1nL3BlcmZvcm1hbmNlLnBuZw?x-oss-process=image/format,png"></p><p><strong>缺失部分：secureConnectionStart</strong></p><h2 id="直观感受下"><a href="#直观感受下" class="headerlink" title="直观感受下"></a>直观感受下</h2><img src="http://t-blog-images.aijs.top/img/202207290919904.webp" /><p>注意下面的一行小字： <a href="https://web.dev/custom-metrics/?utm_source=devtools#server-timing-api" target="_blank" >the Server Timing API</a></p><h2 id="输入-url-发生了什么"><a href="#输入-url-发生了什么" class="headerlink" title="输入 url 发生了什么"></a>输入 url 发生了什么</h2><ul><li>1、当浏览器地址中输入 url 后，<code>navigationStart</code>如果之前有前一个网页（与当前页面不一定同域）unload 的时间戳,如果无前一个网页 unload ，则与 fetchStart 值相等,</li><li>2、接着，是否有重定向（<code>redirect</code> ）</li><li>3、接着，准备用 HTTP 抓取文档的内容（<code>fetchStart</code>）查看<code>APP Cache</code><ul><li>域名查询（<code>domainLookupStart、domainLookupEnd</code>）</li><li>TCP 连接（<code>connectStart、connectEnd</code>）,如果是安全链接，在 connectEnd 之前，会有 SSL 连接(secureConnectionStart)</li></ul></li><li>4、接着，HTTP 请求（<code>requestStart、responseStart、responseEnd</code>）,如果有缓存，在 responseStart 之前，会有 cacheStart，如果之前有网页，还涉及到网页的 unload，在 cacheStart 之前，会有<code>unloadStart、unloadEnd</code></li><li>5、接着，dom 解析<ul><li><code>domLoading</code>Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</li><li><code>domInteractive</code>Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件</li><li><code>domContentLoadedEventStart、domContentLoadedEventEnd </code>DOM 解析完成后，<ul><li>网页内资源加载开始，并将抛出 readystatechange 相关事件</li><li>网页内资源加载完成，并将抛出 readystatechange 相关事件</li></ul></li><li><code>domComplete</code>Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</li><li><code>loadEventStart</code>load 事件发送给文档，也即 load 回调函数开始执行</li><li><code>loadEventEnd</code>load 事件的回调函数执行完毕的时间</li><li>说明：dom 解析过程，HTML 生成 dom 树，解析 CSS 文件生成 CSSOM 树，DOM 树和 CSSOM 树生成 render 树，也就是渲染树， render 树中对每个节点进行布局，计算每个元素的大小，确定其在屏幕中的位置，绘制。根据 render 树和布局将显示页面</li></ul></li></ul><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>左边红线代表的是网络传输层面的过程，右边红线代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析，DOM 树构建，布局，绘制等等。</p><p><em>1. prompt for unload</em></p><ul><li>navigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。<br><em>2. 前一个网页卸载</em></li><li>unloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。</li><li>unloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。<br><em>3. 重定向</em></li><li>redirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。</li><li>redirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。<br><em>4. 使用 HTTP 请求</em></li><li>fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。<br><em>5. 域名解析</em></li><li>domainLookupStart&#x2F;domainLookupEnd: DNS 域名查询开始&#x2F;结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等<br><em>6. tcp 链接</em></li><li>connectStart: HTTP（TCP）开始&#x2F;重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。<br><em>7. ssl 建立</em></li><li>secureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。</li><li>connectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。<br><em>8. 读取文档</em></li><li>requestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。<br><em>9. 响应</em></li><li>responseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。</li><li>responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。<br><em>10. 解析 dom</em></li><li>domLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。<br><em>11. dom 可交互</em></li><li>domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。<br><em>12. 页面内资源加载</em></li><li>domContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。</li><li>domContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。<br><em>13. dom 树解析完成</em></li><li>domComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。<br><em>14. load 事件</em></li><li>loadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。</li><li>loadEventEnd: load 事件的回调函数执行完毕的时间。</li></ul><h2 id="Performance-接口"><a href="#Performance-接口" class="headerlink" title="Performance 接口"></a>Performance 接口</h2><p>Performance 接口可以获取到当前页面与性能相关的信息。</p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><strong>数据先不要关注时间循序，后面我们会从多个角度来验证顺序</strong></p></div><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;timeOrigin&quot;: 1652338539312.5,  &#x2F;&#x2F; 顺序已经排好了  &quot;timing&quot;: &#123;    &#x2F;&#x2F; 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等    &quot;navigationStart&quot;: 1652338539312,    &#x2F;&#x2F; 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0    &quot;redirectStart&quot;: 0,    &#x2F;&#x2F; 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0    &quot;redirectEnd&quot;: 0,    &#x2F;&#x2F; 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前    &quot;fetchStart&quot;: 1652338539316,    &#x2F;&#x2F; DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等    &quot;domainLookupStart&quot;: 1652338539353,    &#x2F;&#x2F; DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等    &quot;domainLookupEnd&quot;: 1652338539353,    &#x2F;&#x2F; HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间    &quot;connectStart&quot;: 1652338539353,    &#x2F;&#x2F; HTTPS 连接开始的时间，如果不是安全连接，则值为 0    &quot;secureConnectionStart&quot;: 1652338539401,    &#x2F;&#x2F; HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间    &#x2F;&#x2F; 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过    &quot;connectEnd&quot;: 1652338539504,    &#x2F;&#x2F; HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存    &#x2F;&#x2F; 连接错误重连时，这里显示的也是新建立连接的时间    &quot;requestStart&quot;: 1652338539505,    &#x2F;&#x2F; HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存    &quot;responseStart&quot;: 1652338539807,    &#x2F;&#x2F; 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0    &quot;unloadEventStart&quot;: 0,    &#x2F;&#x2F; 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳    &quot;unloadEventEnd&quot;: 0,    &#x2F;&#x2F; HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存    &quot;responseEnd&quot;: 1652338539828,    &#x2F;&#x2F; 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件    &quot;domLoading&quot;: 1652338539823,    &#x2F;&#x2F; 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件    &#x2F;&#x2F; 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源    &quot;domInteractive&quot;: 1652338540574,    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载开始的时间    &#x2F;&#x2F; 在 DOMContentLoaded 事件抛出前发生    &quot;domContentLoadedEventStart&quot;: 1652338540574,    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）    &quot;domContentLoadedEventEnd&quot;: 1652338540575,    &#x2F;&#x2F; load 事件发送给文档，也即 load 回调函数开始执行的时间    &#x2F;&#x2F; 注意如果没有绑定 load 事件，值为 0    &quot;loadEventStart&quot;: 1652338542489,    &#x2F;&#x2F; load 事件的回调函数执行完毕的时间    &quot;loadEventEnd&quot;: 1652338542492,    &#x2F;&#x2F; DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件    &quot;domComplete&quot;: 1652338542489  &#125;,  &quot;navigation&quot;: &#123;    &#x2F;&#x2F; 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）    &#x2F;&#x2F; 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面    &#x2F;&#x2F; 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）    &#x2F;&#x2F; 255 即 TYPE_UNDEFINED    非以上方式进入的页面    &quot;type&quot;: 0,    &quot;redirectCount&quot;: 0 &#x2F;&#x2F; &#x2F;&#x2F; 如果有重定向的话，页面通过几次重定向跳转而来  &#125;&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function getPerfermanceTiming() &#123;  let t &#x3D; performance.timing;  &#x2F;&#x2F; 重定向结束时间 - 重定向开始时间  let redirect &#x3D; t.redirectEnd - t.redirectStart;  &#x2F;&#x2F; DNS 查询开始时间 - fetech start 时间  let appCache &#x3D; t.domainLookupStart - t.fetchStart;  &#x2F;&#x2F; DNS 查询结束时间 - DNS 查询开始时间  let dns &#x3D; t.domainLookupEnd - t.domainLookupStart;  &#x2F;&#x2F; 完成 TCP 连接握手时间 - TCP 连接开始时间  let tcp &#x3D; t.connectEnd - t.connectStart;  &#x2F;&#x2F; 从请求开始到接收到第一个响应字符的时间  let ttfb &#x3D; t.responseStart - t.requestStart;  &#x2F;&#x2F; 资源下载时间，响应结束时间 - 响应开始时间  let contentDL &#x3D; t.responseEnd - t.responseStart;  &#x2F;&#x2F; 从请求开始到响应结束的时间  let httpTotal &#x3D; t.responseEnd - t.requestStart;  &#x2F;&#x2F; 从页面开始到 domContentLoadedEventEnd  let domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;  &#x2F;&#x2F; 从页面开始到 loadEventEnd  let loaded &#x3D; t.loadEventEnd - t.navigationStart;  let result &#x3D; [    &#123; key: &quot;Redirect&quot;, desc: &quot;网页重定向的耗时&quot;, value: redirect &#125;,    &#123; key: &quot;AppCache&quot;, desc: &quot;检查本地缓存的耗时&quot;, value: appCache &#125;,    &#123; key: &quot;DNS&quot;, desc: &quot;DNS查询的耗时&quot;, value: dns &#125;,    &#123; key: &quot;TCP&quot;, desc: &quot;TCP连接的耗时&quot;, value: tcp &#125;,    &#123;      key: &quot;Waiting(TTFB)&quot;,      desc: &quot;从客户端发起请求到接收到响应的时间 &#x2F; Time To First Byte&quot;,      value: ttfb,    &#125;,    &#123;      key: &quot;Content Download&quot;,      desc: &quot;下载服务端返回数据的时间&quot;,      value: contentDL,    &#125;,    &#123; key: &quot;HTTP Total Time&quot;, desc: &quot;http请求总耗时&quot;, value: httpTotal &#125;,    &#123;      key: &quot;DOMContentLoaded&quot;,      desc: &quot;dom加载完成的时间&quot;,      value: domContentloaded,    &#125;,    &#123; key: &quot;Loaded&quot;, desc: &quot;页面load的总耗时&quot;, value: loaded &#125;,  ];  return result;&#125;getPerfermanceTiming();</code></pre><hr/><h2 id="聊下性能计算"><a href="#聊下性能计算" class="headerlink" title="聊下性能计算"></a>聊下性能计算</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 计算加载时间function getPerformanceTiming() &#123;  var performance &#x3D; window.performance;  if (!performance) &#123;    &#x2F;&#x2F; 当前浏览器不支持    console.log(&quot;你的浏览器不支持 performance 接口&quot;);    return;  &#125;  var t &#x3D; performance.timing;  var times &#x3D; &#123;&#125;;  &#x2F;&#x2F;【重要】页面加载完成的时间  &#x2F;&#x2F;【原因】这几乎代表了用户等待页面可用的时间  times.loadPage &#x3D; t.loadEventEnd - t.navigationStart;  &#x2F;&#x2F;【重要】解析 DOM 树结构的时间  &#x2F;&#x2F;【原因】反省下你的 DOM 树嵌套是不是太多了！  times.domReady &#x3D; t.domComplete - t.responseEnd;  &#x2F;&#x2F;【重要】重定向的时间  &#x2F;&#x2F;【原因】拒绝重定向！比如，http:&#x2F;&#x2F;example.com&#x2F; 就不该写成 http:&#x2F;&#x2F;example.com  times.redirect &#x3D; t.redirectEnd - t.redirectStart;  &#x2F;&#x2F;【重要】DNS 查询时间  &#x2F;&#x2F;【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？  &#x2F;&#x2F; 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000000633364)  times.lookupDomain &#x3D; t.domainLookupEnd - t.domainLookupStart;  &#x2F;&#x2F;【重要】读取页面第一个字节的时间  &#x2F;&#x2F;【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？  &#x2F;&#x2F; TTFB 即 Time To First Byte 的意思  &#x2F;&#x2F; 维基百科：https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time_To_First_Byte  times.ttfb &#x3D; t.responseStart - t.navigationStart;  &#x2F;&#x2F;【重要】内容加载完成的时间  &#x2F;&#x2F;【原因】页面内容经过 gzip 压缩了么，静态资源 css&#x2F;js 等压缩了么？  times.request &#x3D; t.responseEnd - t.requestStart;  &#x2F;&#x2F;【重要】执行 onload 回调函数的时间  &#x2F;&#x2F;【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？  times.loadEvent &#x3D; t.loadEventEnd - t.loadEventStart;  &#x2F;&#x2F; DNS 缓存时间  times.appcache &#x3D; t.domainLookupStart - t.fetchStart;  &#x2F;&#x2F; 卸载页面的时间  times.unloadEvent &#x3D; t.unloadEventEnd - t.unloadEventStart;  &#x2F;&#x2F; TCP 建立连接完成握手的时间  times.connect &#x3D; t.connectEnd - t.connectStart;  return times;&#125;</code></pre><h2 id="聊下性能优化"><a href="#聊下性能优化" class="headerlink" title="聊下性能优化"></a>聊下性能优化</h2><p><strong>假设你对 performance API 很熟悉</strong></p><ul><li>减少重定向次数</li><li>DNS 查询时间：HTML5 Prefetch 预查询</li><li>TCP 连接: http1.1 开启 connect: keep-alive, http2.0， 如果可以的话 <strong>http3.0 可以看本站另一篇文章</strong></li><li>资源压缩：gzip、brotli、图片压缩、tree-shaking、console、CDN 移除</li><li>资源整合：减少请求次数、减少网络请求，雪碧图（虽然 http2 提供了<strong>多路复用</strong>[多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制,单个连接上可以并行交错的请求和响应，之间互不干扰,但是数量猛增，服务器要处理，多多少少也耗性能]的能力，而且现在还有使用的常见，比聊天表情，飞书也在用）</li><li>资源加载：CDN、强缓存和协商缓存、按需加载</li><li>DOM 解析：自上而下，script 标签放在底部，css 放在上面，无论是 html 还是 css 的层级，应尽量少的解析，解析消耗性能</li><li>渲染时候：回流和重绘、懒加载、虚拟列表</li></ul><h2 id="两个事例"><a href="#两个事例" class="headerlink" title="两个事例"></a>两个事例</h2><p><strong>飞书雪碧图</strong></p><ul><li>为什么拿飞书桌端数据来说（之前开发桌面端 Electron，扒拉过飞书应用包的数据)</li></ul><img src="http://t-blog-images.aijs.top/img/20220606170307.webp" width=200 style="object-fit:content"/><p><strong>百度每个表情单独一个图</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1698186471530126269&wfr=spider&for=pc" target="_blank" >chrome 调试 看请求</a></p><img src="http://t-blog-images.aijs.top/img/202210251717341.webp" /><p><strong>京东移动端 dns-prefetch</strong></p><ul><li>为什么拿京东数据来说（之前爬取过京东移动端数据开发 RN)</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220606172316.webp"></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;head&gt;  &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;    window.alert &#x3D; console.log;  &lt;&#x2F;script&gt;  &lt;script&gt;    window._PFM_TIMING &#x3D; [[1351, new Date()]]; &#x2F;&#x2F;TODO  &lt;&#x2F;script&gt;  &lt;meta    name&#x3D;&quot;viewport&quot;    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0&quot;  &#x2F;&gt;  &lt;title&gt;多快好省，购物上京东！&lt;&#x2F;title&gt;  &lt;!-- 强缓存Cache-Control --&gt;  &lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;max-age&#x3D;180&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;  &lt;!-- 京东 &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt; 写重复了 --&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;m.360buyimg.com&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;  &lt;meta    name&#x3D;&quot;viewport&quot;    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0, shrink-to-fit&#x3D;no, viewport-fit&#x3D;cover&quot;  &#x2F;&gt;  &lt;!-- X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能  DNS 预读取是一项使浏览器主动去执行域名解析的功能--&gt;  &lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img11.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img10.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img12.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img13.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img14.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img20.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img30.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;wq.360buyimg.com&quot; &#x2F;&gt;&lt;&#x2F;head&gt;</code></pre><h2 id="performance-数据能干啥用？"><a href="#performance-数据能干啥用？" class="headerlink" title="performance 数据能干啥用？"></a>performance 数据能干啥用？</h2><p>（开发者）熟悉 Chrome 开发者工具的朋友应该知道：在开发环境下，其实我们自己打开 Chrome 的开发者工具，切换到网络面板，就能很详细的看到网页性能相关的数据。</p><p>（网站用户）但当我们需要统计分析用户打开我们网页时的性能如何时，我们将 performance 原始信息或通过简单计算后的信息 (如上面写到的 getPerformanceTiming()) 上传到服务器，配合其他信息（如 HTTP 请求头信息），就完美啦~</p><h2 id="来看下简书"><a href="#来看下简书" class="headerlink" title="来看下简书"></a>来看下简书</h2><ul><li>链接 <a href="https://www.jianshu.com/p/464593cea4dc" target="_blank" >简书</a> ,打开控制台可以看到输出结果一个数组（<strong>如果简书没将此日志去除</strong>）</li><li>简书代码</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window.addEventListener(&quot;load&quot;, function () &#123;  setTimeout(function () &#123;    var e &#x3D; window.performance;    if (e) &#123;      var t &#x3D; e.getEntriesByType(&quot;navigation&quot;)[0],        r &#x3D; 0;      t || (r &#x3D; (t &#x3D; e.timing).navigationStart);      var n &#x3D; [        &#123;          key: &quot;Redirect&quot;,          desc: &quot;\u7f51\u9875\u91cd\u5b9a\u5411\u7684\u8017\u65f6&quot;,          value: t.redirectEnd - t.redirectStart,        &#125;,        &#123;          key: &quot;AppCache&quot;,          desc: &quot;\u68c0\u67e5\u672c\u5730\u7f13\u5b58\u7684\u8017\u65f6&quot;,          value: t.domainLookupStart - t.fetchStart,        &#125;,        &#123;          key: &quot;DNS&quot;,          desc: &quot;DNS\u67e5\u8be2\u7684\u8017\u65f6&quot;,          value: t.domainLookupEnd - t.domainLookupStart,        &#125;,        &#123;          key: &quot;TCP&quot;,          desc: &quot;TCP\u8fde\u63a5\u7684\u8017\u65f6&quot;,          value: t.connectEnd - t.connectStart,        &#125;,        &#123;          key: &quot;Waiting(TTFB)&quot;, &#x2F;&#x2F; TTFB：Time To First Byte          desc: &quot;\u4ece\u5ba2\u6237\u7aef\u53d1\u8d77\u8bf7\u6c42\u5230\u63a5\u6536\u5230\u54cd\u5e94\u7684\u65f6\u95f4 &#x2F; Time To First Byte&quot;,          value: t.responseStart - t.requestStart,        &#125;,        &#123;          key: &quot;Content Download&quot;,          desc: &quot;\u4e0b\u8f7d\u670d\u52a1\u7aef\u8fd4\u56de\u6570\u636e\u7684\u65f6\u95f4&quot;,          value: t.responseEnd - t.responseStart,        &#125;,        &#123;          key: &quot;HTTP Total Time&quot;,          desc: &quot;http\u8bf7\u6c42\u603b\u8017\u65f6&quot;,          value: t.responseEnd - t.requestStart,        &#125;,        &#123;          key: &quot;DOMContentLoaded&quot;,          desc: &quot;dom\u52a0\u8f7d\u5b8c\u6210\u7684\u65f6\u95f4&quot;,          value: t.domContentLoadedEventEnd - r,        &#125;,        &#123;          key: &quot;Loaded&quot;,          desc: &quot;\u9875\u9762load\u7684\u603b\u8017\u65f6&quot;,          value: t.loadEventEnd - r,        &#125;,      ];      if (Math.random() &gt; 0.75) &#123;        var s &#x3D; window.location,          i &#x3D; s.href,          c &#x3D; s.pathname,          u &#x3D; navigator.userAgent,          d &#x3D; i.split(&quot;?&quot;)[0];        o.a          .post(&quot;https:&#x2F;&#x2F;tr.jianshu.com&#x2F;fe&#x2F;1&#x2F;mon&#x2F;atf&quot;, &#123;            app: &quot;shakespeare-performance&quot;,            url: d,            ua: u,            path: c,            stats_ttfb: t.responseStart - t.requestStart,            stats_domLoaded: t.domContentLoadedEventEnd - r,            stats_loaded: t.loadEventEnd - r,          &#125;)          .then(a.a)          .catch(a.a);      &#125;      console &amp;&amp; console.log &amp;&amp; console.log(n);    &#125;  &#125;, 0);&#125;);</code></pre><h2 id="简书截图"><a href="#简书截图" class="headerlink" title="简书截图"></a>简书截图</h2><p><img src="http://t-blog-images.aijs.top/img/20220605112219.webp"></p><h2 id="domContentLoaded-与-loaded"><a href="#domContentLoaded-与-loaded" class="headerlink" title="domContentLoaded 与 loaded"></a>domContentLoaded 与 loaded</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 从页面开始到 domContentLoadedEventEndlet domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;&#x2F;&#x2F; 从页面开始到 loadEventEndlet loaded &#x3D; t.loadEventEnd - t.navigationStart;</code></pre><p><strong>domContentLoadedEventEnd 比 loaded 先触发</strong></p><p><img src="http://t-blog-images.aijs.top/img/20220605133905.webp"></p><hr/><h2 id="掘金页面"><a href="#掘金页面" class="headerlink" title="掘金页面"></a>掘金页面</h2><ul><li><p>话说已经到了 6 月 6 号，闲逛掘金，遇到面试题：<code>从输入url到页面展示发生了什么</code>，突然想起个 performance,就拿掘金的一个页面来验证这幅图</p><p><img src="http://t-blog-images.aijs.top/img/20220606151451.webp"></p></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：此代码放到 dayjs 网站的 Sources&#x2F;Snippets 中执行，利用全局的 dayjs，无需引入 dayjs</div><p><a href="https://dayjs.fenxianglu.cn/category/display.html#%E6%A0%BC%E5%BC%8F%E5%8C%96" target="_blank" >dayjs 网站</a></p><p><img src="http://t-blog-images.aijs.top/img/20220606152413.webp"></p><ul><li>代码是为了对 performance.timing 按照时间值进行排序，排序结果大致是执行的顺序，稍微有出入，会手动做调整</li><li>代码如下：</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var timing &#x3D; &#123;  connectStart: 1654499041800,  navigationStart: 1654499041744,  loadEventEnd: 1654499043641,  domLoading: 1654499042279,  secureConnectionStart: 1654499041820,  fetchStart: 1654499041746,  domContentLoadedEventStart: 1654499042718,  responseStart: 1654499042247,  responseEnd: 1654499042304,  domInteractive: 1654499042495,  domainLookupEnd: 1654499041800,  redirectStart: 0,  requestStart: 1654499041849,  unloadEventEnd: 1654499042267,  unloadEventStart: 1654499042267,  domComplete: 1654499043640,  domainLookupStart: 1654499041750,  loadEventStart: 1654499043641,  domContentLoadedEventEnd: 1654499042718,  redirectEnd: 0,  connectEnd: 1654499041849,&#125;;&#x2F;&#x2F; YYYY-MM-DD HH:一定一致，这个就不看了var fmt &#x3D; &quot;mm:ss:SSS&quot;;var arr &#x3D; [];var sort_obj &#x3D; &#123;&#125;;function fmt_sort_key(obj) &#123;  for (let [key, value] of Object.entries(obj)) &#123;    arr.push(&#123;      key,      value,    &#125;);  &#125;  const sortArr &#x3D; arr.sort((a, b) &#x3D;&gt; a.value - b.value);  const fmtSortArr &#x3D; sortArr.map((item) &#x3D;&gt; &#123;    if (!item.value) return item;    return &#123;      ...item,      value: dayjs(item.value).format(fmt),    &#125;;  &#125;);  console.log(fmtSortArr);&#125;fmt_sort_key(timing);</code></pre><h2 id="非无痕首次访问"><a href="#非无痕首次访问" class="headerlink" title="非无痕首次访问"></a>非无痕首次访问</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const timing &#x3D; &#123;  connectStart: 1654391072118,  navigationStart: 1654391071928,  loadEventEnd: 1654391076402,  domLoading: 1654391072670,  secureConnectionStart: 1654391072118,  fetchStart: 1654391071969,  domContentLoadedEventStart: 1654391074189,  responseStart: 1654391072621,  responseEnd: 1654391072664,  domInteractive: 1654391073865,  domainLookupEnd: 1654391072118,  redirectStart: 0,  requestStart: 1654391072199,  &#x2F;&#x2F; 没有之前页面的卸载  unloadEventEnd: 0,  unloadEventStart: 0,  domComplete: 1654391076400,  domainLookupStart: 1654391072118,  loadEventStart: 1654391076400,  domContentLoadedEventEnd: 1654391074189,  redirectEnd: 0,  connectEnd: 1654391072199,&#125;;&#x2F;&#x2F; 时间戳 1654391072118： connectStart、secureConnectionStart、domainLookupStart、domainLookupEnd ，这个值是相同的&#x2F;&#x2F; 把上述 timing 使用dayjs进行转化，看下每个key对应的time,对于0是没有进行的操作，我们跳过不处理（知道没进行）var timingfmt &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;04:31:928&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;04:31:969&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;04:32:199&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;04:32:199&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;04:32:621&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;04:32:664&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;04:32:670&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;04:33:865&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;04:34:189&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;04:34:189&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;04:36:400&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;04:36:400&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;04:36:402&quot; &#125;,];</code></pre><p><strong>我们看下结果 2022-06-05 09:04，年月日时分都是一致的，我们只关心三位的毫秒数</strong></p><h2 id="非无痕第二次访问"><a href="#非无痕第二次访问" class="headerlink" title="非无痕第二次访问"></a>非无痕第二次访问</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const timing2 &#x3D; &#123;  connectStart: 1654494048918,  navigationStart: 1654494048902,  loadEventEnd: 1654494054146,  domLoading: 1654494049851,  secureConnectionStart: 0, &#x2F;&#x2F; 走缓存  fetchStart: 1654494048918,  domContentLoadedEventStart: 1654494051380,  responseStart: 1654494049430,  responseEnd: 1654494049514,  domInteractive: 1654494051115,  domainLookupEnd: 1654494048918,  redirectStart: 0,  requestStart: 1654494048942,  &#x2F;&#x2F; 有之前页面卸载  unloadEventEnd: 1654494049537,  unloadEventStart: 1654494049536,  domComplete: 1654494054143,  domainLookupStart: 1654494048918,  loadEventStart: 1654494054143,  domContentLoadedEventEnd: 1654494051381,  redirectEnd: 0,  connectEnd: 1654494048918,&#125;;var timingfmt2 &#x3D; [  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;40:48:902&quot; &#125;,  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;40:48:942&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;40:49:430&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;40:49:514&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: &quot;40:49:536&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;40:49:537&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;40:49:851&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;40:51:115&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;40:51:380&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;40:51:381&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;40:54:143&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;40:54:143&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;40:54:146&quot; &#125;,];</code></pre><h2 id="非无痕-f5-手动刷新"><a href="#非无痕-f5-手动刷新" class="headerlink" title="非无痕 f5 手动刷新"></a>非无痕 f5 手动刷新</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var timing3 &#x3D; &#123;  connectStart: 1654495600379,  navigationStart: 1654495600360,  loadEventEnd: 1654495604101,  domLoading: 1654495601005,  secureConnectionStart: 1654495600389,  fetchStart: 1654495600364,  domContentLoadedEventStart: 1654495601947,  responseStart: 1654495600935,  responseEnd: 1654495600989,  domInteractive: 1654495601794,  domainLookupEnd: 1654495600379,  redirectStart: 0,  requestStart: 1654495600404,  unloadEventEnd: 1654495600971,  unloadEventStart: 1654495600970,  domComplete: 1654495604099,  domainLookupStart: 1654495600379,  loadEventStart: 1654495604099,  domContentLoadedEventEnd: 1654495601947,  redirectEnd: 0,  connectEnd: 1654495600403,&#125;;var timingfmt3 &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;06:40:360&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;06:40:364&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;06:40:379&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;06:40:379&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;06:40:379&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;06:40:389&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;06:40:403&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;06:40:404&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;06:40:935&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: &quot;06:40:970&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;06:40:971&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;06:40:989&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;06:41:005&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;06:41:794&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;06:41:947&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;06:41:947&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;06:44:099&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;06:44:099&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;06:44:101&quot; &#125;,];</code></pre><h2 id="无痕模式首次"><a href="#无痕模式首次" class="headerlink" title="无痕模式首次"></a>无痕模式首次</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var timing4 &#x3D; &#123;  connectStart: 1654496795083,  navigationStart: 1654496795041,  loadEventEnd: 1654496799718,  domLoading: 1654496795428,  secureConnectionStart: 1654496795093,  fetchStart: 1654496795050,  domContentLoadedEventStart: 1654496796111,  responseStart: 1654496795420,  responseEnd: 1654496795469,  domInteractive: 1654496795680,  domainLookupEnd: 1654496795083,  redirectStart: 0,  requestStart: 1654496795123,  unloadEventEnd: 0,  unloadEventStart: 0,  domComplete: 1654496799718,  domainLookupStart: 1654496795057,  loadEventStart: 1654496799718,  domContentLoadedEventEnd: 1654496796111,  redirectEnd: 0,  connectEnd: 1654496795123,&#125;;var timing4fmt &#x3D; [  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;26:35:041&quot; &#125;,  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;26:35:050&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;26:35:057&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;26:35:083&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;26:35:083&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;26:35:093&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;26:35:123&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;26:35:123&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;26:35:420&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;26:35:428&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;26:35:469&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;26:35:680&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;26:36:111&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;26:36:111&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;26:39:718&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;26:39:718&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;26:39:718&quot; &#125;,];</code></pre><h2 id="无痕模式刷新"><a href="#无痕模式刷新" class="headerlink" title="无痕模式刷新"></a>无痕模式刷新</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var timing5 &#x3D; &#123;  connectStart: 1654496848681,  navigationStart: 1654496848679,  loadEventEnd: 1654496850263,  domLoading: 1654496848983,  secureConnectionStart: 0,  fetchStart: 1654496848681,  domContentLoadedEventStart: 1654496849277,  responseStart: 1654496848959,  responseEnd: 1654496849017,  domInteractive: 1654496849096,  domainLookupEnd: 1654496848681,  redirectStart: 0,  requestStart: 1654496848702,  unloadEventEnd: 1654496848979,  unloadEventStart: 1654496848979,  domComplete: 1654496850262,  domainLookupStart: 1654496848681,  loadEventStart: 1654496850262,  domContentLoadedEventEnd: 1654496849277,  redirectEnd: 0,  connectEnd: 1654496848681,&#125;;var timing5fmt &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;27:28:679&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;27:28:681&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;27:28:702&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;27:28:959&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;27:28:979&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: &quot;27:28:979&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;27:28:983&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;27:29:017&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;27:29:096&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;27:29:277&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;27:29:277&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;27:30:262&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;27:30:262&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;27:30:263&quot; &#125;,];</code></pre><h2 id="无痕模式刷新-disable-cache"><a href="#无痕模式刷新-disable-cache" class="headerlink" title="无痕模式刷新 + disable-cache"></a>无痕模式刷新 + disable-cache</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var timing6 &#x3D; &#123;  connectStart: 1654496917781,  navigationStart: 1654496917780,  loadEventEnd: 1654496921224,  domLoading: 1654496918186,  secureConnectionStart: 0,  fetchStart: 1654496917781,  domContentLoadedEventStart: 1654496918836,  responseStart: 1654496918156,  responseEnd: 1654496918293,  domInteractive: 1654496918654,  domainLookupEnd: 1654496917781,  redirectStart: 0,  requestStart: 1654496917784,  unloadEventEnd: 1654496918182,  unloadEventStart: 1654496918182,  domComplete: 1654496921224,  domainLookupStart: 1654496917781,  loadEventStart: 1654496921224,  domContentLoadedEventEnd: 1654496918836,  redirectEnd: 0,  connectEnd: 1654496917781,&#125;;var timing6fmt &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;28:37:780&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;28:37:784&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;28:38:156&quot; &#125;,  &#x2F;&#x2F; 和 timing5fmt比较，之前页面的卸载，非常快  &#123; key: &quot;unloadEventStart&quot;, value: &quot;28:38:182&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;28:38:182&quot; &#125;,  &#x2F;&#x2F; 注意 domLoading 和 responseEnd,这两个，顺序不定  &#123; key: &quot;domLoading&quot;, value: &quot;28:38:186&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;28:38:293&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;28:38:654&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;28:38:836&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;28:38:836&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;28:41:224&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;28:41:224&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;28:41:224&quot; &#125;,];</code></pre><p>这个操作竟然有一个 base64 编码图片依然被缓存了,浏览器 disable-cache 对于有些内存缓存的图片竟然是无效的.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Request URL: data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCCRequest Method: GETStatus Code: 200 OK (from memory cache)Referrer Policy: strict-origin-when-cross-origin</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220606143138.webp"></p><h2 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h2><p>在实际的解析过程中，并不是客户端的每一次访问都需要委托递归服务器进行迭代查询，</p><ol><li>而是先搜索浏览器自身的 DNS 缓存，如果有，解析到此为止；</li><li>如果 DNS 缓存中没有结果就会读取操作系统中的 HOSTS 文件查找对应的映射关系，如果有到此完成；</li><li>如果没有，再请求递归服务器，进行全球递归查询。从中我们可以看出 DNS 缓存是获取域名解析记录的第一步骤。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/z9061/article/details/101454438" target="_blank" >Web 性能优化-首屏和白屏时间</a></p><p><a href="http://www.alloyteam.com/2015/09/explore-performance/" target="_blank" >初探 performance – 监控网页与程序性能</a></p><p><a href="https://blog.csdn.net/abuanden/article/details/114530985" target="_blank" >简述浏览器渲染机制</a></p><p><a href="https://baijiahao.baidu.com/s?id=1722369549920506968&wfr=spider&for=pc" target="_blank" >浅谈 DNS 缓存的作用和影响</a></p><p><a href="https://www.jianshu.com/p/0f2158726daf" target="_blank" >TTFB</a></p><p><a href="https://cn.bluehost.com/blog/?p=14093" target="_blank" >什么是网站 TTFB？以及 6 个优化 TTFB 的方法</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API" target="_blank" >Web 开发技术&gt;Web API 接口参考&gt;Resource Timing API&gt;Using the Resource Timing API</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> performance </tag>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode插件 paste code to snippets</title>
      <link href="//post/2022-05-11vscode.html"/>
      <url>//post/2022-05-11vscode.html</url>
      
        <content type="html"><![CDATA[<h2 id="粘贴代码，生成用户代码片段"><a href="#粘贴代码，生成用户代码片段" class="headerlink" title="粘贴代码，生成用户代码片段"></a>粘贴代码，生成用户代码片段</h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol><li>其他插件具有<code>共性</code>，而<code>不具特性 </code>，每次写代码，要么用第三方插件，现成的代码片段，时常不能满足日常开发需要</li><li>自定义代码片段，手写 <code>费时费力</code>，一般步骤，粘贴、修改、格式化</li><li>其他插件类似vscode宏变量的使用少之又少， 要么将开源插件定制化，要么重新开发</li><li>快捷变量记不住</li></ol><h2 id="paste-code-to-snippets-优点："><a href="#paste-code-to-snippets-优点：" class="headerlink" title="paste code to snippets 优点："></a>paste code to snippets 优点：</h2><ol><li>高度定制化</li><li>跨语言（任何vscode支持的语言，都可在对应类型片段文件中进行增加）</li><li>使用简单 （复制、唤起命令、挖孔）</li><li>快捷提示完全自定义（想怎么写就怎么写）</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="http://t-blog-images.aijs.top/img/Kapture%202022-05-11%20at%2009.39.01.gif"></p><ol><li>复制要生成的代码片段</li><li>cmd + shift + p</li><li>找到要生成代码片段的文件后缀</li><li>执行 paste code to snippets</li><li>下次使用</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>如果配置了代码片段，没有提示, 查看<code>settings.json</code>对应</p></li><li><p>打开 <code>settings.json</code> 命令： <code>command + shift + p</code>, 搜 <code>&gt;settings</code><br><strong>以markdown为例</strong> 默认只读配置在升级后变成了false</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; Configure settings to be overridden for the markdown language.&quot;[markdown]&quot;:  &#123;&quot;editor.unicodeHighlight.ambiguousCharacters&quot;: false,&quot;editor.unicodeHighlight.invisibleCharacters&quot;: false,&quot;editor.wordWrap&quot;: &quot;on&quot;,&quot;editor.quickSuggestions&quot;: false  &#x2F;&#x2F; 改为true&#125;,</code></pre></li><li><p>修改<br><img src="http://t-blog-images.aijs.top/img/20220602184856.webp"></p></li></ul><h2 id="有想法"><a href="#有想法" class="headerlink" title="有想法"></a>有想法</h2><p>TODO: 之前代码片段复制之后是手动粘贴到对应的片段文件中的，我有个想法，既然我复制文件的文件类型我已经知道了，我复制的代码和输出的片段代码也已经处理了，那么之后我就能实现<code>复制某个文件的代码，自动同步到对应的片段文件中，如果不需要定制化，也不用打开片段文件修改了</code></p><p>TODO:想到这里我又有一个想法，既然我每次要命令，然后再找啊找，我可以用一个快捷键<code>&quot;复制&quot;</code>的同时，唤起要定制的代码片段对应的类型文件，直接进去，不用弯弯绕绕的</p><p>TODO: github copilot收费了，我们是不是可以把这个代码功能生成片段仓库，进行团队共享，类似github copilot，我们不做AI,做匹配是不是也可以</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-HTTP3</title>
      <link href="//post/2022-05-11http.html"/>
      <url>//post/2022-05-11http.html</url>
      
        <content type="html"><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><img src="https://www.upyun.com/static/img/title@3x.5597f51.png" />HTTP/3 的基础即谷歌多年探索的基于 UDP 的 QUIC 协议。与 TCP 相比，使用 UDP 可以提供更大的灵活性，并且可以使 QUIC 完全于用户空间中实现——对协议实现的更新不像 TCP 那样需要绑定到操作系统更新。使用 QUIC，可以简单地将 HTTP 级别的流映射到 QUIC 流的顶部，从而继承 HTTP/2 的所有优点，而不会产生队头阻塞。HTTP/3 虽仍处于草案状态，但很多用户已经跃跃欲试。</blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>HTTP&#x2F;3 利用 QUIC 加速 HTTP 请求，QUIC 提供比 TCP 和 TLS 更高的加密和性能</li><li>QUIC 是一种默认加密的新传输协议，旨在加快 HTTP 传输速度以及使其更加安全</li><li><span style="color: red">HTTP&#x2F;3 基于 UDP，如果数据包丢失，只会中断一个流，而不会中断所有流，提高了同时获取多个对象的性能</span></li><li>支持 0-RTT，消除服务器的 TLS 确认，使后续连接的启动速度更快</li></ol><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>下图表示 HTTP&#x2F;2 和 HTTP&#x2F;3 多路复用两个请求时，数据包丢失及其影响（请求及其相关的响应分别为深蓝和浅蓝色）</p><p>HTTP&#x2F;2 多路复用 2 个请求。响应被分解为多个数据包，一旦一个数据包丢失了，两个请求都被阻止。<br><img src="https://www.upyun.com/static/img/http_3%20&%20QUIC.d73f941.gif" /><br>HTTP&#x2F;3 复用 2 个请求。虽然浅色的数据包丢失了，但是深色的数据包传输得很好。<br><img src="https://www.upyun.com/static/img/http2.27d52a1.gif" /><br>在相同丢包率的条件下，HTTP&#x2F;3 和 HTTP&#x2F;2 性能测试对比如下<br>测试环境：服务端（HTTP&#x2F;3 with cubic &amp; HTTP&#x2F;2 with bbr）、客户端（cubic）<br><img src="https://www.upyun.com/static/img/%E5%BB%BA%E8%BF%9E%E6%97%B6%E9%97%B4.35656db.png" /><br><img src="https://www.upyun.com/static/img/%E8%AF%B7%E6%B1%82%E6%97%B6%E9%97%B41x.7069918.png" /></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://www.upyun.com/tech/tags/HTTP3" target="_blank" >查看更多</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP/3" target="_blank" >HTTP&#x2F;3</a></p><p><a href="https://zh.wikipedia.org/wiki/QUIC" target="_blank" >QUIC</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slate wiki-ui评论功能光标乱跳</title>
      <link href="//post/2022-04-29slate.html"/>
      <url>//post/2022-04-29slate.html</url>
      
        <content type="html"><![CDATA[<h2 id="bug-复现"><a href="#bug-复现" class="headerlink" title="bug 复现"></a>bug 复现</h2><pre class="line-numbers language-none"><code class="language-none">bug复现 (node:29) UnhandledPromiseRejectionWarning: Error: Forbidden at &amp;#x2F;code&amp;#x2F;client&amp;#x2F;.next&amp;#x2F;server&amp;#x2F;pages&amp;#x2F;_app-a05...</code></pre><p><img src="https://t-blog-images.aijs.top/img/Kapture%202022-04-29%20at%2015.41.56.gif"></p><p>在 vite react 项目上，输入汉字的同时按住删除键，光标会乱跳</p><h3 id="排查-1"><a href="#排查-1" class="headerlink" title="排查 1:"></a>排查 1:</h3><p>wiki（esm）组件问题，检查 wiki-ui 组件库，运行正常</p><pre class="line-numbers language-none"><code class="language-none">&quot;react&quot;: &quot;^16.8.0&quot;,&quot;react-dom&quot;: &quot;^16.8.0&quot;,</code></pre><h3 id="排查-2"><a href="#排查-2" class="headerlink" title="排查 2:"></a>排查 2:</h3><p>vite 加载 wiki-ui 组件时候，因为 vite 只能处理 esm，在 vite.config.ts, esbuildOptions 自定义插件进行处理<br>wiki-ui，不是很懂，换个角度</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">esbuildOptions: &#123;  plugins: [    &#123;      name: &#39;originjs:commonjs&#39;,      setup(build) &#123;        build.onLoad(          &#123;            filter: &#x2F;@敏感数据-fe\&#x2F;wiki-ui\&#x2F;dist&#x2F;,            namespace: &#39;file&#39;,          &#125;,          async (&#123; path: id &#125;) &#x3D;&gt; &#123;            const code &#x3D; readFileSync(id).toString()            const result &#x3D; transformRequire(code, id)            return &#123;              contents: result,              loader: &#39;js&#39;,            &#125;          &#125;,        ),          build.onLoad(            &#123;              filter: &#x2F;@敏感数据-fe\&#x2F;wiki-ui\&#x2F;dist\&#x2F;components\&#x2F;iconfont&#x2F;,              namespace: &#39;file&#39;,            &#125;,            async (&#123; path: id &#125;) &#x3D;&gt; &#123;              const code &#x3D; readFileSync(id).toString()              const result &#x3D; transformRequire(code, id)              return &#123;                contents: result,                loader: &#39;js&#39;,              &#125;            &#125;,          )      &#125;,    &#125;,    esbuildPluginMonacoEditorNls(&#123;      locale: Languages.zh_hans,    &#125;),  ],&#125;,</code></pre><h3 id="排查-3"><a href="#排查-3" class="headerlink" title="排查 3:"></a>排查 3:</h3><p>将 wiki-ui 组件放到 umijs 应用中运行</p><pre class="line-numbers language-none"><code class="language-none"># 搭建个项目# 移动demo组件到新项目# 运行，发现有相同的问题</code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="1-dom"><a href="#1-dom" class="headerlink" title="1.dom"></a>1.dom</h4><p>输入过程中点击删除操作，那么在这个过程中，输入的内容是在<code>contenteditable=&quot;true&quot; </code>中运行</p><pre class="line-numbers language-none"><code class="language-none">&lt;div data-gramm&#x3D;&quot;false&quot; role&#x3D;&quot;textbox&quot; spellcheck&#x3D;&quot;false&quot; class&#x3D;&quot;slash-slate-core&quot; id&#x3D;&quot;SLASH_SLATE_CORE&quot; data-app-id&#x3D;&quot;5A9BEA&quot; autocorrect&#x3D;&quot;false&quot; autocapitalize&#x3D;&quot;false&quot; data-slate-editor&#x3D;&quot;true&quot; data-slate-node&#x3D;&quot;value&quot; contenteditable&#x3D;&quot;true&quot; style&#x3D;&quot;position: relative; outline: none; white-space: pre-wrap; overflow-wrap: break-word;&quot;&gt;&lt;p data-slate-node&#x3D;&quot;element&quot;&gt;&lt;span data-slate-node&#x3D;&quot;text&quot;&gt;&lt;span data-slate-leaf&#x3D;&quot;true&quot;&gt;&lt;span data-slate-string&#x3D;&quot;true&quot;&gt;12121212哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈h h h h h h h h h h h h hs f s d f&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="2-合成事件"><a href="#2-合成事件" class="headerlink" title="2.合成事件"></a>2.合成事件</h4><p>应该会走合成事件，合成事件之后会执行渲染，web 端走的是 react-dom，比对正常运行的项目，和新项目的版本</p><pre class="line-numbers language-none"><code class="language-none"># react 17版本# react-dom 17版本</code></pre><h4 id="3-react"><a href="#3-react" class="headerlink" title="3.react"></a>3.react</h4><p>先进行<code>react</code>降版本 <code>16.14.0</code>，检查合成事件是否有问题，降版本后，运行，问题同样存在，大概可以断定是<code>react-dom</code>渲染出了问题，</p><h4 id="4-react-dom"><a href="#4-react-dom" class="headerlink" title="4.react-dom"></a>4.react-dom</h4><p>对<code>react-dom</code>降低版本到<code>16.14.0</code>, 后运行正常，那么问题应该在<code>react-dom</code>上</p><h4 id="5-github-版本-16-14-0"><a href="#5-github-版本-16-14-0" class="headerlink" title="5.github 版本 16.14.0"></a>5.github 版本 16.14.0</h4><p>两个版本有什么不同：查看<code>react</code>发布日志，16.14.0 之后的一个版本是<a href="https://github.com/facebook/react/releases#:~:text=17.0.0%20(October%2020%2C%202020)">17.0.0 (October 20, 2020)</a> 看上去与事件和渲染相关的东西不多</p><pre class="line-numbers language-none"><code class="language-none">Use browser focusin and focusout for onFocus and onBlur. (@trueadm in #19186)Make all Capture events use the browser capture phase. (@trueadm in #19221)Throw if forwardRef or memo component returns undefined. (@gaearon in #19550)Remove event pooling. (@trueadm in #18969)Fix onBeforeInput reporting an incorrect event.type. (@eps1lon in #19561)Fix event.relatedTarget reported as undefined in Firefox. (@claytercek in #19607)Fix rendering into a shadow root. (@Jack-Works in #15894)Fix movementX&#x2F;Y polyfill with capture events. (@gaearon in #19672)Artifactsreact: https:&#x2F;&#x2F;unpkg.com&#x2F;react@17.0.1&#x2F;umd&#x2F;react-art: https:&#x2F;&#x2F;unpkg.com&#x2F;react-art@17.0.1&#x2F;umd&#x2F;react-dom: https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@17.0.1&#x2F;umd&#x2F;react-is: https:&#x2F;&#x2F;unpkg.com&#x2F;react-is@17.0.1&#x2F;umd&#x2F;react-test-renderer: https:&#x2F;&#x2F;unpkg.com&#x2F;react-test-renderer@17.0.1&#x2F;umd&#x2F;scheduler: https:&#x2F;&#x2F;unpkg.com&#x2F;scheduler@0.20.1&#x2F;umd&#x2F;</code></pre><h4 id="6-github-版本-18-1-0"><a href="#6-github-版本-18-1-0" class="headerlink" title="6.github 版本 18.1.0"></a>6.github 版本 18.1.0</h4><p>在往后找最新的版本，发现在<a href="https://github.com/facebook/react/releases#:~:text=Compare-,18.1.0%20(April%2026%2C%202022),-Latest">18.1.0 (April 26, 2022)</a>，改了一堆<code>react-dom</code>的 bug,看上去也没相关的</p><pre class="line-numbers language-none"><code class="language-none">Fix the false positive warning about react-dom&#x2F;client when using UMD bundle. (@alireza-molaee in #24274)Fix suppressHydrationWarning to work in production too. (@gaearon in #24271)Fix componentWillUnmount firing twice inside of Suspense. (@acdlite in #24308)Fix some transition updates being ignored. (@acdlite in #24353)Fix useDeferredValue causing an infinite loop when passed an unmemoized value. (@acdlite in #24247)Fix throttling of revealing Suspense fallbacks. (@sunderls in #24253)Fix an inconsistency in whether the props object is the same between renders. (@Andarist and @acdlite in #24421)Fix a missing warning about a setState loop in useEffect. (@gaearon in #24298)Fix a spurious hydration error. (@gnoff in #24404)Warn when calling setState in useInsertionEffect. (@gaearon in #24295)Ensure the reason for hydration errors is always displayed. (@gaearon in #24276)</code></pre><h3 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;react&quot;: &quot;^16.14.0&quot;,&quot;react-dom&quot;: &quot;16.14.0&quot;,</code></pre><h3 id="这个演示代码正常"><a href="#这个演示代码正常" class="headerlink" title="这个演示代码正常"></a>这个演示代码正常</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;embed  type&#x3D;&quot;text&#x2F;html&quot;  src&#x3D;&quot;https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview&quot;  width&#x3D;&quot;100%&quot;  height&#x3D;&quot;200&quot;&#x2F;&gt;&lt;!--加载太慢，复制地址查看吧--&gt;&lt;!--https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview--&gt;</code></pre><h2 id="懵逼。。。"><a href="#懵逼。。。" class="headerlink" title="懵逼。。。"></a>懵逼。。。</h2><p>从头开始</p><pre class="line-numbers language-none"><code class="language-none">待办事项中的评论功能（组件问题）光标乱跳的问题；0. 项目 + wiki-ui 异常1. 单运行wiki-ui demo 正常2. 运行slate + umijs 正常3. 运行wiki-ui  + umijs 异常4. slate 与  wiki-ui  不一样在于slate版本5. wiki-ui 做了什么事情： 定制化一些节点展示，光标的渲染和wiki-ui无关</code></pre><h2 id="贫僧先去-slate-官网化缘，回来再战"><a href="#贫僧先去-slate-官网化缘，回来再战" class="headerlink" title="贫僧先去 slate 官网化缘，回来再战"></a>贫僧先去 slate 官网<code>化缘</code>，回来再战</h2><p><a href="http://localhost:4000/#/post/2022-04-29slate-lean">slate-lean</a></p><h2 id="化缘归来"><a href="#化缘归来" class="headerlink" title="化缘归来"></a>化缘归来</h2><p>问题怎么解决</p>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-跨域问题</title>
      <link href="//post/2022-05-09cors.html"/>
      <url>//post/2022-05-09cors.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>浏览器安全策略限制跨域访问</p><p>内容安全策略是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><p>维基百科：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>内容安全策略（英语：Content Security Policy，简称 CSP）是一种计算机安全标准，旨在防御跨站脚本、点击劫持等代码注入攻击，阻止恶意内容在受信网页环境中执行。这一标准是 W3C 网络应用安全工作组的候选推荐标准，被现代网页浏览器广泛支持</p></blockquote><ol><li>使用方式<br>为使 CSP 可用, 你需要配置你的网络服务器返回 Content-Security-Policy，或者在 HTML <meta> 元素种也可配置该策略, 例如：</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta  http-equiv&#x3D;&quot;Content-Security-Policy&quot;  content&#x3D;&quot;default-src &#39;self&#39;; img-src https:&#x2F;&#x2F;*; child-src &#39;none&#39;;&quot;&#x2F;&gt;</code></pre><ol start="2"><li>配置示例<br>（1）一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Content-Security-Policy: default-src &#39;self&#39;</code></pre><p>（2）一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)</p><pre class="line-numbers language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre><p>（3）一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码。</p><pre class="line-numbers language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;;img-src *;media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:</p><p>图片可以从任何地方加载(注意 “*“ 通配符)。<br>多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。<br>可运行脚本仅允许来自于 userscripts.example.com。</p><p>作者：菜鸡前端<br>链接：<a href="https://www.jianshu.com/p/a45924e99a6d">https://www.jianshu.com/p/a45924e99a6d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ul><li>脚本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">listen 80; # 监听的端⼝   add_header &#39;Access-Control-Allow-Origin&#39; &#39;$http_origin&#39; ;   add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39; ;   add_header &#39;Access-Control-Allow-Methods&#39; &#39;PUT,POST,GET,DELETE,OPTIONS&#39; ;   add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,Content-Length,Authorization,Accept,X-Requested-With&#39; ;</code></pre><ul><li>实际操作</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220509181853.webp"></p><h3 id="jsonp-方式-lt-动态-script-gt"><a href="#jsonp-方式-lt-动态-script-gt" class="headerlink" title="jsonp 方式 &lt;动态 script&gt;"></a>jsonp 方式 &lt;动态 script&gt;</h3><p>最经典的跨域⽅案 jsonp jsonp 本质上是⼀个 Hack，它利⽤ <code>&lt;script&gt;</code> 标签不受同源策略限制的特性进⾏跨域操作。</p><p>jsonp 优点： 实现简单 兼容性⾮常好</p><p>jsonp 的缺点：</p><p>只⽀持 get 请求（因为<code> &lt;script&gt;</code> 标签只能 get）<br>有安全性问题，容易遭受 xss 攻击<br>需要服务端配合 jsonp 进⾏⼀定程度的改造</p><p>jsonp 的实现：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function JSONP(&#123; url, params, callbackKey, callback &#125;) &#123;  &#x2F;&#x2F; 在参数⾥制定 callback 的名字  params &#x3D; params || &#123;&#125;;  params[callbackKey] &#x3D; &quot;callback&quot;;  &#x2F;&#x2F; 预留 callback  window.callback &#x3D; callback;  &#x2F;&#x2F; 拼接参数字符串  const paramKeys &#x3D; Object.keys(params);  const paramString &#x3D; paramKeys.map((key) &#x3D;&gt; &#96;$&#123;key&#125;&#x3D;$&#123;params[key]&#125;&#96;).join(&quot;&amp;&quot;);  &#x2F;&#x2F; 插⼊ DOM 元素  const script &#x3D; document.createElement(&quot;script&quot;);  script.setAttribute(&quot;src&quot;, &#96;$&#123;url&#125;?$&#123;paramString&#125;&#96;);  document.body.appendChild(script);&#125;JSONP(&#123;  url: &quot;http:&#x2F;&#x2F;s.weibo.com&#x2F;ajax&#x2F;jsonp&#x2F;suggestion&quot;,  params: &#123;    key: &quot;test&quot;,  &#125;,  callbackKey: &quot;callback&quot;,  callback(result) &#123;    console.log(result.data);  &#125;,&#125;);</code></pre><p>jsonp 服务端改造</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var http &#x3D; require(&quot;http&quot;);var urllib &#x3D; require(&quot;url&quot;);var port &#x3D; 10011;var data &#x3D; &#123; name: &quot;jifeng&quot;, company: &quot;tb&quot; &#125;;http  .createServer(function (req, res) &#123;    var params &#x3D; urllib.parse(req.url, true);    console.log(params);    if (params.query &amp;&amp; params.query.callback &#x2F;**对应客户端 *&#x2F;) &#123;      &#x2F;&#x2F;console.log(params.query.callback);      var str &#x3D; params.query.callback + &quot;(&quot; + JSON.stringify(data) + &quot;)&quot;; &#x2F;&#x2F;jsonp      res.end(str);    &#125; else &#123;      res.end(JSON.stringify(data)); &#x2F;&#x2F;普通的json    &#125;  &#125;)  .listen(port, function () &#123;    console.log(&quot;server is listening on port &quot; + port);  &#125;);</code></pre><h3 id="服务端设置，类似-nginx"><a href="#服务端设置，类似-nginx" class="headerlink" title="服务端设置，类似 nginx"></a>服务端设置，类似 nginx</h3><p>cors 是⽬前主流的跨域解决⽅案，跨域资源共享(CORS) 是⼀种机制，它使⽤额外的 HTTP 头来告诉浏览器 让运⾏在⼀ 个 origin (domain) 上的 Web 应⽤被准许访问来⾃不同源服务器上的指定的资源。当⼀个资源从与该资源本身所在的服 务器不同的域、协议或端⼝请求⼀个资源时，资源会发起⼀个跨域 HTTP 请求。 如果你⽤ express，可以这样在后端设置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;CORS middlewarevar allowCrossDomain &#x3D; function (req, res, next) &#123;  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http:&#x2F;&#x2F;example.com&quot;);  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,PUT,POST,DELETE&quot;);  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);  &#x2F;&#x2F; 预检的存活时间  res.setHeader(&quot;Access-Control-Max-Age&quot;, 60);  next();&#125;;&#x2F;&#x2F;...app.configure(function () &#123;  app.use(express.bodyParser());  app.use(express.cookieParser());  app.use(express.session(&#123; secret: &quot;cool beans&quot; &#125;));  app.use(express.methodOverride());  app.use(allowCrossDomain);  app.use(app.router);  app.use(express.static(__dirname + &quot;&#x2F;public&quot;));&#125;);</code></pre><p>在⽣产环境中建议⽤成熟的开源中间件解决问题。</p><p>不同的 nodejs 框架设置方式不同，一般跨域问题几乎框架官网必备，查下就晓得如何配置了，但本质都是改变相应头</p><h3 id="其他（不常用）"><a href="#其他（不常用）" class="headerlink" title="其他（不常用）"></a>其他（不常用）</h3><ol><li>HTML5 XMLHttpRequest 有⼀个 API，<code>postMessage()</code>⽅法允许来⾃不同源的脚本采⽤异步⽅式进⾏有限的通信， 可以实现跨⽂本档、多窗⼝、跨域消息传递。</li></ol><details class="custom-details"><summary>Details</summary><p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.html  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;frame&quot; onload&#x3D;&quot;load()&quot;&gt;&lt;&#x2F;iframe&gt; &#x2F;&#x2F;等它加载完触发一个事件  &#x2F;&#x2F;内嵌在http:&#x2F;&#x2F;localhost:3000&#x2F;a.html    &lt;script&gt;      function load() &#123;        let frame &#x3D; document.getElementById(&#39;frame&#39;)        frame.contentWindow.postMessage(&#39;我爱你&#39;, &#39;http:&#x2F;&#x2F;localhost:4000&#39;) &#x2F;&#x2F;发送数据        window.onmessage &#x3D; function(e) &#123; &#x2F;&#x2F;接受返回数据          console.log(e.data) &#x2F;&#x2F;我不爱你        &#125;      &#125;    &lt;&#x2F;script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; b.htmlwindow.onmessage &#x3D; function (e) &#123;  console.log(e.data); &#x2F;&#x2F;我爱你  e.source.postMessage(&quot;我不爱你&quot;, e.origin);&#125;;</code></pre></p></details><ol start="2"><li><code>WebSocket</code> 是⼀种双向通信协议，在建⽴连接之后，WebSocket 的 server 与 client 都能主动向对⽅发送或接收数 据，连接建⽴好了之后 client 与 server 之间的双向通信就与 HTTP ⽆关了，因此可以跨域。</li><li><code>window.name + iframe</code>：window.name 属性值在不同的⻚⾯（甚⾄不同域名）加载后依旧存在，并且可以⽀持⾮常 ⻓的 name 值，我们可以利⽤这个特点进⾏跨域。</li></ol><details class="custom-details"><summary>Details</summary><p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.html(http:&#x2F;&#x2F;localhost:3000&#x2F;b.html) &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;c.html&quot; frameborder&#x3D;&quot;0&quot; onload&#x3D;&quot;load()&quot; id&#x3D;&quot;iframe&quot;&gt;&lt;&#x2F;iframe&gt; &lt;script&gt;   let first &#x3D; true   &#x2F;&#x2F; onload事件会触发2次，第1次加载跨域页，并留存数据于window.name   function load() &#123;     if(first)&#123;     &#x2F;&#x2F; 第1次onload(跨域页)成功后，切换到同域代理页面       let iframe &#x3D; document.getElementById(&#39;iframe&#39;);       iframe.src &#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html&#39;;       first &#x3D; false;     &#125;else&#123;     &#x2F;&#x2F; 第2次onload(同域b.html页)成功后，读取同域window.name中数据       console.log(iframe.contentWindow.name);     &#125;   &#125; &lt;&#x2F;script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; c.html(http:&#x2F;&#x2F;localhost:4000&#x2F;c.html)&lt;script&gt;window.name &#x3D; &#39;我不爱你&#39;&lt;&#x2F;script&gt;</code></pre><p>通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p></p></details><ol start="4"><li><code>location.hash + iframe</code>：a.html 欲与 c.html 跨域相互通信，通过中间⻚ b.html 来实现。 三个⻚⾯，不同域之间利⽤ iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</li></ol><details class="custom-details"><summary>动态创建 iframe</summary><p>具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。<br>同样的，a.html 和 b.html 是同域的，都是 <a href="http://localhost:3000;而">http://localhost:3000;而</a> c.html 是 <a href="http://localhost:4000/">http://localhost:4000</a></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.html &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;c.html#iloveyou&quot;&gt;&lt;&#x2F;iframe&gt; &lt;script&gt;   window.onhashchange &#x3D; function () &#123; &#x2F;&#x2F;检测hash的变化     console.log(location.hash);   &#125; &lt;&#x2F;script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; b.html&lt;script&gt;  window.parent.parent.location.hash &#x3D; location.hash  &#x2F;&#x2F;b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面&lt;&#x2F;script&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; c.htmlconsole.log(location.hash);let iframe &#x3D; document.createElement(&quot;iframe&quot;);iframe.src &#x3D; &quot;http:&#x2F;&#x2F;localhost:3000&#x2F;b.html#idontloveyou&quot;;document.body.appendChild(iframe);</code></pre></p></details><ol start="5"><li><code>document.domain + iframe</code>： 该⽅式只能⽤于⼆级域名相同的情况下，⽐如 a.test.com 和 b.test.com 适⽤于该⽅ 式，我们只需要给⻚⾯添加 document.domain &#x3D;’test.com’ 表示⼆级域名都相同就可以实现跨域，两个⻚⾯都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</li></ol><details class="custom-details"><summary>Details</summary><p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; a.html&lt;body&gt; helloa  &lt;iframe src&#x3D;&quot;http:&#x2F;&#x2F;b.zf1.cn:3000&#x2F;b.html&quot; frameborder&#x3D;&quot;0&quot; onload&#x3D;&quot;load()&quot; id&#x3D;&quot;frame&quot;&gt;&lt;&#x2F;iframe&gt;  &lt;script&gt;    document.domain &#x3D; &#39;zf1.cn&#39;    function load() &#123;      console.log(frame.contentWindow.a);    &#125;  &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; b.html&lt;body&gt;  hellob  &lt;script&gt;document.domain &#x3D; &#39;zf1.cn&#39; var a &#x3D; 100;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></p></details><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/6844903767226351623#heading-19" target="_blank" >九种跨域方式实现原理（完整版）</a></p><p><a href="https://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" >Content Security Policy 入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题汇总</title>
      <link href="//post/2022-05-08interview.html"/>
      <url>//post/2022-05-08interview.html</url>
      
        <content type="html"><![CDATA[<h2 id="值得收藏的链接"><a href="#值得收藏的链接" class="headerlink" title="值得收藏的链接"></a>值得收藏的链接</h2><ol><li><p><a target="_blank" href="https://juejin.cn/user/1381458394494461">码上通天</a></p></li><li><p><a target="_blank" href="https://juejin.cn/post/6844904019165446158#heading-42">面试完 50 个人后我写下这篇总结</a></p></li><li><p><a target="_blank" href="https://juejin.cn/post/6844903897610321934">if 我是前端团队 Leader，怎么制定前端协作规范?</a></p></li><li><p><a target="_blank" href="https://juejin.cn/post/7061588533214969892">做了一份前端面试复习计划，保熟～</a></p></li><li><p><a href="https://blog.csdn.net/weixin_43834338/article/details/115207151" target="_blank" >url 解析过程</a></p></li><li><p><a href="https://juejin.cn/collection/6845243838185881614" target="_blank" >zoomdong 面经</a></p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-js变量和作用域</title>
      <link href="//post/2022-05-08varible.html"/>
      <url>//post/2022-05-08varible.html</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="var-let-const区别"><a href="#var-let-const区别" class="headerlink" title="var let const区别"></a>var let const区别</h3><ul><li><strong>变量提升</strong>：var 存在变量提升，let、const也会变量提升，但是会有暂时性死区（let、const存在暂时性死区）</li><li><strong>作用域的限制</strong>：var不受作用域的限制，而let、const受当前作用域的限制</li><li><strong>重复声明</strong>：var可以重复声明，let、const不可以</li><li><strong>const是常量</strong>，必须有初始值，否则报错，不能更改，但是可以更改对象内部属性</li></ul><h3 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h3><ul><li>js中的变量分为两种：<ul><li>全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；</li><li>而局部变量就只能在函数的内部才能够调用的变量。</li></ul></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a&#x3D;10;function show()&#123;  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10  var b&#x3D;2;  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2&#125;show();console.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;b is no defined</code></pre><p>　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。</p><p><em>另外需要特别注意的是：</em></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a&#x3D;10;function show()&#123;  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10  b&#x3D;2;  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2&#125;show();console.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;outside b:2</code></pre><p>对比两段代码，<em>如果你在声明b&#x3D;2时没有写var，那么b就隐式地声明为全局变量</em>，在函数外面还是能够被调用到的。<br>虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了<em>缺点</em>：</p><ol><li>一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li><li>影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，</li><li>可移植性: 同时也降低了函数的可移植性。<br><strong>因此我们在定义变量时一般要尽可能少的定义全局变量。</strong></li></ol><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>函数声明优先于变量声明</p></blockquote><p>　　下面我们通过一段代码来说明.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a; function a()&#123;&#125;console.log(typeof a); &#x2F;&#x2F;function&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function a()&#123;&#125;var a; console.log(typeof a); &#x2F;&#x2F;function&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。&#x2F;&#x2F; 因此函数声明优先于变量的声明。&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function a()&#123;&#125;var a&#x3D;&#39;xyf&#39;; console.log(typeof a); &#x2F;&#x2F;string&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var a&#x3D;&#39;xyf&#39;; function a()&#123;&#125;console.log(typeof a); &#x2F;&#x2F;string&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function a()&#123;&#125;var a;a&#x3D;&#39;xyf&#39;;console.log(typeof a); &#x2F;&#x2F;string&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>　js中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>　js中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>  let const<em>有块级作用域</em>。函数作用域是比较容易理解的，那么什么是块级作用域呢？<br>  <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;var a &#x3D; 1&#125;console.log(a)VM2355:1 1</code></pre><br>  <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;let a &#x3D;1&#125;console.log(a)VM2079:1 Uncaught ReferenceError: a is not defined</code></pre></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p></blockquote><p>　　理解了块级作用域，来看一下下面的小例子。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(v); &#x2F;&#x2F;undefinedvar v &#x3D; &quot;world&quot;;　　&#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</code></pre><p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p><p>由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var v;console.log(v); &#x2F;&#x2F;undefinedv &#x3D; &quot;world&quot;;&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。&#x2F;&#x2F;下面我们把变量v放到一个方法中去：</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if(true)&#123;  var v &#x3D; &quot;hello&quot;;&#125;console.log(v); &#x2F;&#x2F;hello&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。</code></pre><p>函数作用域<br>　　我们再把变量v放到函数中去：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function show()&#123;  var v&#x3D;&#39;world&#39;;&#125;show();console.log(v); &#x2F;&#x2F;undefined</code></pre><p>　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var v&#x3D;&#39;hello&#39;;function show()&#123;  console.log(v); &#x2F;&#x2F;undefined  var v&#x3D;&#39;world&#39;;&#125;show();</code></pre><p>　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var v&#x3D;&#39;hello&#39;;function show()&#123;var v;console.log(v); &#x2F;&#x2F;undefinedv&#x3D;&#39;world&#39;;&#125;show();</code></pre><p>　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var v &#x3D; &quot;hello&quot;;(function()&#123;  console.log(v);  var v &#x3D; &quot;world&quot;;&#125;)();</code></pre><p>　　在这里自执行函数形成了函数作用域</p><p>需要注意的是<br>变量提升只提升函数的声明，并不提升函数的定义</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">show(); &#x2F;&#x2F;show is not a functionvar show&#x3D;function()&#123;&#x2F;&#x2F;...&#125;show(); &#x2F;&#x2F;成功运行</code></pre><p>　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>函数有两种定义方式，一种是<code>函数声明</code>，另一种是<code>函数表达式</code>。那么什么是函数声明什么是函数表达式呢？</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;函数声明function show()&#123;&#x2F;&#x2F;....&#125;&#x2F;&#x2F;函数表达式var show&#x3D;function()&#123;&#x2F;&#x2F;...&#125;</code></pre><p>乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。</p><ul><li>js的解析器对<code>函数声明</code>和<code>函数表达式</code>并不是一视同仁的对待的，有点“种族歧视”的意思在里面。</li><li><code>函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了</code>，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。</li><li><code>而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，</code>因此，调用函数表达式要在定义后进行使用。</li></ul><img src="http://t-blog-images.aijs.top/img/202209201228344.webp" /><p><a href="https://blog.csdn.net/weixin_46112649/article/details/126376367" target="_blank" >见</a></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p><a href="https://juejin.cn/post/6844904019165446158">https://juejin.cn/post/6844904019165446158</a></p><p><a href="https://doc.yonyoucloud.com/doc/wiki/project/javascript-depth-understanding/function-expression.html" target="_blank" >见</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更好的沉淀</title>
      <link href="//post/2022-04-28%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA.html"/>
      <url>//post/2022-04-28%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>工作日常经验性总结放哪？</li><li>存电脑，电脑坏了重做系统没了，</li><li>放到电脑备忘录，卧槽，怎么没及时更新</li><li>放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移</li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul><li>hexo 由于有丰富的插件和主题，使用及部署方便，备受欢迎</li><li>自己购买服务器部署，服务器到期后续费很贵</li><li>放到第三方博客上，好一点的像简书，每天发布限制两篇，可控性太差</li></ul><h2 id="hexo-主题"><a href="#hexo-主题" class="headerlink" title="hexo 主题"></a>hexo 主题</h2><p>这里使用 <code>aurora</code></p><pre class="line-numbers language-none"><code class="language-none">theme: aurora</code></pre><p><a href="https://tridiamond.tech/">tridiamond</a><br><a href="https://github.com/AlphaHinex/AlphaHinex.github.io">AlphaHinex</a></p><h2 id="阿里云-oss"><a href="#阿里云-oss" class="headerlink" title="阿里云 oss"></a>阿里云 oss</h2><ul><li>图片资源放到 github 上，访问较慢，为了提升体验，将资源放到 oss 上，权限配置为公开，可被任何用户访问</li></ul><h2 id="阿里云域名"><a href="#阿里云域名" class="headerlink" title="阿里云域名"></a>阿里云域名</h2><ul><li>域名访问比较方便，图片资源只有在使用域名的情况下，各资源可以预览，而不仅仅是下载</li></ul><h2 id="PicGo-图床「贼好用，"><a href="#PicGo-图床「贼好用，" class="headerlink" title="PicGo 图床「贼好用，"></a>PicGo 图床「贼好用，</h2><ul><li>思考：除此之外，因为其开源我们可以学习下作者是如何处理插件的」</li><li>为博客中 md 文档提供图片链接，放到阿里云 oss 上</li><li>上传成功<br><img src="http://t-blog-images.aijs.top/img/20220428101247.png?x-oss-process=image/resize,h_300,w_500"></li><li>因为开发过 electron，第一想到的是我要 debug,打开控制台</li><li>域名配错不可访问<br><img src="http://t-blog-images.aijs.top/img/20220428104003.png?x-oss-process=image/resize,h_300,w_500"><br><img src="http://t-blog-images.aijs.top/img/20220428104024.png?x-oss-process=image/resize,h_300,w_500"></li><li>遇到图片,作为程序猿第一反应要优化「压缩」<code>compress</code></li><li>插件下载<br><img src="http://t-blog-images.aijs.top/img/20220428104511.png?x-oss-process=image/resize,h_300,w_500" alt="下载插件"></li><li>插件启用<br><img src="http://t-blog-images.aijs.top/img/20220428104919.png?x-oss-process=image/resize,h_300,w_500" alt="需要启动插件，不器用没有效果"></li><li>插件是否生效了<br><img src="http://t-blog-images.aijs.top/img/20220428105126.png?x-oss-process=image/resize,h_300,w_500" alt="压缩后的校验"></li><li>插件列表<br><a href="https://github.com/PicGo/Awesome-PicGo">github 链接</a></li></ul><h2 id="书写文章-hexo-页面不热重载？"><a href="#书写文章-hexo-页面不热重载？" class="headerlink" title="书写文章 hexo 页面不热重载？"></a>书写文章 hexo 页面不热重载？</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn add global browser-syncyarn add hexo-browsersync</code></pre><h2 id="启用评论"><a href="#启用评论" class="headerlink" title="启用评论"></a>启用评论</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># For local development only!gitalk:  enable: false  autoExpand: true  clientID: &quot;&quot;  clientSecret: &quot;&quot;  repo: &quot;dev-blog-comments&quot;  owner: &quot;TriDiamond&quot;  admin: [&quot;TriDiamond&quot;]  id: uid  language: en  distractionFreeMode: true  recentComment: true  proxy: &quot;&quot;# Valine comment plugin (recommended!)# see https:&#x2F;&#x2F;valine.js.org&#x2F;quickstart.htmlvaline:  enable: true  app_id: 去申请  app_key: 去申请  avatar: &quot;http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;avatar.jpeg&quot;  placeholder: Leave your thoughts behind~  visitor: true  lang: en  avatarForce: false  meta: [&quot;nick&quot;, &quot;mail&quot;]  requiredFields: []  admin: &quot;海龙&quot;  recentComment: true</code></pre><h2 id="图片增加水印"><a href="#图片增加水印" class="headerlink" title="图片增加水印"></a>图片增加水印</h2><p><strong>配置及效果</strong><br><img src="http://t-blog-images.aijs.top/img/20220524104857.webp"></p><h2 id="picgo-生成代码"><a href="#picgo-生成代码" class="headerlink" title="picgo 生成代码"></a>picgo 生成代码</h2><ul><li>可选不同的代码方式<img src="http://t-blog-images.aijs.top/img/20220526230443.png"/></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p>每次发布后，github page 自定义域名会丢失</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在_posts 目录下建立 CNAME 文件 填写上自己的域名</p></blockquote></li><li><p>图床 picGo，上传了图片，在 oss 上查看也成功了，但是 picGo 相册中没有展示</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>/Users/chenhailong/Library/Application Support/picgo</code>目录下，删除 <code>rm picgo.db</code>,重新启动<br>见<a href="https://github.com/Molunerfinn/PicGo/issues/781">issue #781</a></p></blockquote></li><li><p>调整博客文件时间，运行后文章排序并没有改变，需要清理根目录下<code>db.json</code></p></li><li><p>部分 tag 找不到相关[tagName].json</p><p><strong>本地</strong></p><img src="http://t-blog-images.aijs.top/img/20220624092901.webp" /><img src="http://t-blog-images.aijs.top/img/20220624092941.webp" />**线上**<img src="http://t-blog-images.aijs.top/img/20220624093041.webp" /><img src="http://t-blog-images.aijs.top/img/20220624093127.webp" /></li></ol><p><a href="https://blog.zhheo.com/p/5511910d.html" target="_blank" >Hexo 改变 tag 因为大小写问题而 404 的解决方法</a></p><ol start="5"><li>release 失败</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">致命错误：无法访问 &#39;https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;841660202.github.io&#x2F;&#39;：LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.htmlError: Spawn failed    at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:51:21)    at ChildProcess.emit (node:events:369:20)    at Process.ChildProcess._handle.onexit (node:internal&#x2F;child_process:290:12)INFO Thanks for using Aurora v1.5.5INFO Check out the repo at: https:&#x2F;&#x2F;github.com&#x2F;auroral-ui&#x2F;hexo-theme-aurora ELIFECYCLE  Command failed with exit code 2.</code></pre><p><strong>有个空的 shell 文件夹，导致打包报错</strong></p><h2 id="aurora-主题-bug"><a href="#aurora-主题-bug" class="headerlink" title="aurora 主题 bug"></a><code>aurora</code> 主题 bug</h2><p>作者是没空修改的</p><ol><li>文章详情<code>categories</code>，无法点击</li><li>首页<code>categories</code>不展示</li><li><code>categories</code> 路由找不到</li><li>当代码类似的东西很长很长时，样式错乱</li></ol><p><strong>源码</strong></p><p><a href="/#/post/2022-06-24aurora" target="_blank" >见 hexo-theme-aurora 源码修改</a></p><h2 id="hexo-toc-有误"><a href="#hexo-toc-有误" class="headerlink" title="hexo toc 有误"></a>hexo toc 有误</h2><p><strong>toc 链接 hash</strong></p><img src="http://t-blog-images.aijs.top/img/20220715095258.webp" /><p><strong>接口返回</strong></p><img src="http://t-blog-images.aijs.top/img/20220715104417.webp" /><p><strong>编译结果</strong></p><img src="http://t-blog-images.aijs.top/img/20220715110208.webp" /><p><strong>hexo 源代码</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i &#x3D; 0, len &#x3D; data.length; i &lt; len; i++) &#123;    const el &#x3D; data[i];    const &#123; level, id, text &#125; &#x3D; el;    const href &#x3D; id ? &#96;#$&#123;encodeURL(id)&#125;&#96; : null; &#x2F;&#x2F; href被编码了，而markdown标题没有编码，导致url的hash无法使用....    result +&#x3D; &#96;&lt;li class&#x3D;&quot;$&#123;className&#125;-item $&#123;className&#125;-level-$&#123;level&#125;&quot;&gt;&#96;;    if (href) &#123;      result +&#x3D; &#96;&lt;a class&#x3D;&quot;$&#123;className&#125;-link&quot; href&#x3D;&quot;$&#123;href&#125;&quot;&gt;&#96;;    &#125; else &#123;      result +&#x3D; &#96;&lt;a class&#x3D;&quot;$&#123;className&#125;-link&quot;&gt;&#96;;    &#125;&#125;&#x2F;&#x2F; 编译输出：&lt;ol class&#x3D;&quot;toc&quot;&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack-%E4%B8%8E-grunt%E3%80%81gulp-%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack 与 grunt、gulp 的不同？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack%E3%80%81rollup%E3%80%81parcel%E3%80%81vite-%E4%BC%98%E5%8A%A3%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack、rollup、parcel、vite 优劣？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-Loader%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;有哪些常⻅的 Loader？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-Plugin%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;有哪些常⻅的 Plugin？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%88%86%E5%88%AB%E4%BB%8B%E7%BB%8D-bundle%EF%BC%8Cchunk%EF%BC%8Cmodule-%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;分别介绍 bundle，chunk，module 是什么&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#Loader-%E5%92%8C-Plugin-%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;Loader 和 Plugin 的不同？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack 的构建流程是什么?&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%8F%8F%E8%BF%B0%E2%BC%80%E4%B8%8B%E7%BC%96%E5%86%99-loader-%E6%88%96-plugin-%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;描述⼀下编写 loader 或 plugin 的思路？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;webpack 的热更新原理？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E2%BD%A4-webpack-%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;⽤ webpack 来优化前端性能&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%A6%82%E4%BD%95%E6%8F%90%E2%BE%BC-webpack-%E7%9A%84%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;如何提⾼ webpack 的打包速度?&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%A6%82%E4%BD%95%E6%8F%90%E2%BE%BC-webpack-%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;如何提⾼ webpack 的构建速度？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%8D%95%E2%BB%9A%E5%BA%94%E2%BD%A4%EF%BC%9F%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%A4%9A%E2%BB%9A%E5%BA%94%E2%BD%A4%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;怎么配置单⻚应⽤？怎么配置多⻚应⽤？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#source-map-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;source map 是什么？生产环境怎么用？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;模块打包原理知道吗？&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;toc-item toc-level-2&quot;&gt;&lt;a class&#x3D;&quot;toc-link&quot; href&#x3D;&quot;#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5&quot;&gt;&lt;span class&#x3D;&quot;toc-text&quot;&gt;参考链接&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt;</code></pre><p>问题是找到了，先不改，没得空～</p><p><strong>去除编码可行性</strong></p><p><strong>以 webpack 官网为例：有中文妥妥滴，hexo 官方编了个码，整了个 bug</strong></p><img src="http://t-blog-images.aijs.top/img/20220715111450.webp" /><h2 id="aurora-使用-history-模式"><a href="#aurora-使用-history-模式" class="headerlink" title="aurora 使用 history 模式"></a>aurora 使用 history 模式</h2><p>我的想法：不同页面使用 history 模式，页面内标题滚动使用 hash。<br><code>router.beforeEach</code>在 hash 改变时候也能检测到，这个地方会触发 loading，但没有重新发送请求，也需要做调整</p><h2 id="vscode-md-自动格式化"><a href="#vscode-md-自动格式化" class="headerlink" title="vscode md 自动格式化"></a>vscode md 自动格式化</h2><p><a href="https://github.com/prettier/prettier-vscode/issues/402#issuecomment-493739397" target="_blank" >issue</a></p><img src="http://t-blog-images.aijs.top/img/202210151008255.png" /><p><strong>日志输出</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">[&quot;INFO&quot; - 10:08:24 AM] Prettier Options:&#123;  &quot;arrowParens&quot;: &quot;always&quot;,  &quot;bracketSpacing&quot;: true,  &quot;endOfLine&quot;: &quot;lf&quot;,  &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;,  &quot;insertPragma&quot;: false,  &quot;singleAttributePerLine&quot;: false,  &quot;bracketSameLine&quot;: false,  &quot;jsxBracketSameLine&quot;: false,  &quot;jsxSingleQuote&quot;: false,  &quot;printWidth&quot;: 80,  &quot;proseWrap&quot;: &quot;preserve&quot;,  &quot;quoteProps&quot;: &quot;as-needed&quot;,  &quot;requirePragma&quot;: false,  &quot;semi&quot;: true,  &quot;singleQuote&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;trailingComma&quot;: &quot;es5&quot;,  &quot;useTabs&quot;: false,  &quot;vueIndentScriptAndStyle&quot;: false,  &quot;filepath&quot;: &quot;&#x2F;Users&#x2F;chenhailong&#x2F;Desktop&#x2F;841660202.github.io&#x2F;source&#x2F;_posts&#x2F;2022-04-28博客创建.md&quot;,  &quot;parser&quot;: &quot;markdown&quot;&#125;[&quot;INFO&quot; - 10:08:24 AM] Formatting completed in 71ms.</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总体而言 picgo 已经很好了，有几点可以优化</p><ul><li>已有图片二次重新上传压缩功能</li><li>窗口实在是太小了，正常情况下可以手动拖拽改变大小</li><li>插件列表插件卡片部分重叠</li></ul><h2 id="文章书写参照"><a href="#文章书写参照" class="headerlink" title="文章书写参照"></a>文章书写参照</h2><p>AlphaHinex.github.io-develop</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lerna调试开源库遇到的问题</title>
      <link href="//post/2022-05-05lerna.html"/>
      <url>//post/2022-05-05lerna.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">yarn install --mutex network:42424 --non-interactive👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ lerna --version4.0.0👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn global add lerna@3.19.0    Usage Error: The &#39;yarn global&#39; commands have been removed in 2.x - consider using &#39;yarn dlx&#39; or a third-party plugin instead$ yarn run [--inspect] [--inspect-brk] &lt;scriptName&gt; ...👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn --version              3.0.1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC存储空间不足问题</title>
      <link href="//post/2022-05-05mac.html"/>
      <url>//post/2022-05-05mac.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://t-blog-images.aijs.top/img/20220505165350.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-String</title>
      <link href="//post/2022-05-03string.html"/>
      <url>//post/2022-05-03string.html</url>
      
        <content type="html"><![CDATA[<h3 id="转化为驼峰命名"><a href="#转化为驼峰命名" class="headerlink" title="转化为驼峰命名"></a>转化为驼峰命名</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>var s1 = &quot;get-element-by-id&quot;</code></p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var f &#x3D; function (s) &#123;  return s.replace(&#x2F;-\w&#x2F;g, function (x) &#123;    return x.splice(1).toUpperCase();  &#125;);&#125;;</code></pre><h3 id="模版引擎实现"><a href="#模版引擎实现" class="headerlink" title="模版引擎实现"></a>模版引擎实现</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let template &#x3D; &quot;我是&#123;&#123;name&#125;&#125;,年龄&#123;&#123;age&#125;&#125;,性别&#123;&#123;sex&#125;&#125;&quot;;let data &#x3D; &#123;  name: &quot;姓名&quot;,  age: 18,&#125;;render(template, data); &#x2F;&#x2F;我是姓名,年龄18,性别undefinedfunction render(template, data) &#123;  &#x2F;&#x2F; 模版字符串正则  const reg &#x3D; &#x2F;\&#123;\&#123;(\w+)\&#125;\&#125;&#x2F;;  &#x2F;&#x2F; 判断模版里是否有模版字符串  if (reg.test(template)) &#123;    &#x2F;&#x2F; 查找当前模版里第一个模版字符串的字符    const name &#x3D; reg.exec(template)[1];    &#x2F;&#x2F; 将第一个模版字符串渲染    template &#x3D; template.replace(reg, data[name]);    &#x2F;&#x2F; 递归的渲染并返回渲染后的结构    return render(template, data);  &#125;  return template;&#125;</code></pre><h3 id="解析-URL-Params-为对象"><a href="#解析-URL-Params-为对象" class="headerlink" title="解析 URL Params 为对象"></a>解析 URL Params 为对象</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let url &#x3D;  &quot;http:&#x2F;&#x2F;www.domain.com&#x2F;?user&#x3D;anonymouse&amp;id&#x3D;123&amp;id&#x3D;456&amp;city&#x3D;%E5%8C%97%E4%BA%AC&amp;enabled&quot;;&#x2F;** * 结果 * &#123; *  user: &#39;anonymouse&#39;, *  id: [123,456], &#x2F;&#x2F; 重复出现的key，要转化成数组 *  city: &#39;北京&#39;, &#x2F;&#x2F; 中文需要解码 *  enabled: true &#x2F;&#x2F; 未指定值的key，约定为true * * * &#125; * **&#x2F;function parseParam(url) &#123;  const paramsStr &#x3D; &#x2F;.+\?(.+)$&#x2F;.exec(url)[1];  const paramsArr &#x3D; paramsArr.split(&quot;&amp;&quot;);  let paramsObj &#x3D; &#123;&#125;;  paramsArr.forEach((param) &#x3D;&gt; &#123;    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;      let [key, val] &#x3D; param.split(&quot;&#x3D;&quot;); &#x2F;&#x2F; 拆分键&#x2F;值      val &#x3D; decodeURLComponent(val); &#x2F;&#x2F; 汉字解码      val &#x3D; &#x2F;^\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 数字转化      if (paramsObj.hasOwnProperty(key)) &#123;        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 重复key转数组      &#125; else &#123;        paramsObj[key] &#x3D; val;      &#125;    &#125; else &#123;      paramsObj[key] &#x3D; true; &#x2F;&#x2F; 处理约定    &#125;  &#125;);&#125;</code></pre><h3 id="查找字符串中，出现最多的字符和个数"><a href="#查找字符串中，出现最多的字符和个数" class="headerlink" title="查找字符串中，出现最多的字符和个数"></a>查找字符串中，出现最多的字符和个数</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let str &#x3D; &quot;abcabcabcbbcccc&quot;;let num &#x3D; 0;let char &#x3D; &quot;&quot;;&#x2F;&#x2F; 先排序，后用正则处理个数str &#x3D; str.split(&quot;&quot;).sort().join(&quot;&quot;);let re &#x3D; &#x2F;(\w)\1+&#x2F;g;str.replace(re, ($0, $1) &#x3D;&gt; &#123;  if (num &lt; $0.length) &#123;    num &#x3D; $0.length;    char &#x3D; $1;  &#125;&#125;);</code></pre><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a &#x3D; &quot;34&quot;;b &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回2a &#x3D; &quot;35&quot;;b &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回 -1a &#x3D; &quot;355&quot;;b &#x3D; &quot;1234355&quot;; &#x2F;&#x2F; 返回5function isContain(a, b) &#123;  for (let i in b) &#123;    if (a[0] &#x3D;&#x3D;&#x3D; b[i]) &#123;      let tmp &#x3D; true; &#x2F;&#x2F; 标记：满足      for (let j in a) &#123;        if (a[j] !&#x3D;&#x3D; b[~~i + ~~j]) &#123;          tmp &#x3D; false; &#x2F;&#x2F; 标记：不满足        &#125;      &#125;      if (tmp) &#123;        return i;      &#125;    &#125;  &#125;  return -1;&#125;</code></pre><h3 id="实现千分位分隔符"><a href="#实现千分位分隔符" class="headerlink" title="实现千分位分隔符"></a>实现千分位分隔符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 保留三位小数paraseToMoney(1234.56); &#x2F;&#x2F; return &#39;1,234.56&#39;paraseToMoney(123456789); &#x2F;&#x2F; return 123,456,789paraseToMoney(1087654.321); &#x2F;&#x2F; return 1,087,654.321function paraseToMoney(params) &#123;  num &#x3D; parseFloat(num.toFixed(3));  let [integer, decimal] &#x3D; String.prototype.split.call(num, &quot;.&quot;);  integer &#x3D; integer.replace(&#x2F;\d(?&#x3D;(\d&#123;3&#125;))+$&#x2F;, &quot;$&amp;,&quot;);  return integer + &quot;.&quot; + (decimal ?? &quot;&quot;);&#125;</code></pre><h3 id="判断是否是电话号码"><a href="#判断是否是电话号码" class="headerlink" title="判断是否是电话号码"></a>判断是否是电话号码</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function isPhone(str) &#123;  let regx &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;;  return regx.test(str);&#125;</code></pre><h3 id="判断是否是邮箱"><a href="#判断是否是邮箱" class="headerlink" title="判断是否是邮箱"></a>判断是否是邮箱</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; @之前必须有内容只能是 数字、字母(大小写)、下划线(_)、减号(-)、点（.）&#x2F;&#x2F; @之后和最后一个点（.）之间必须有内容且只能是 数字、字母(大小写)、下划线(_)、减号(-)，&#x2F;&#x2F; 两个点不能挨着&#x2F;&#x2F; 最后一个点（.）之后，必须有内容只能是 数字、字母（大小写），长度大于等于两个字节，小于等于6个字节&#x2F;&#x2F; 按照规则写function isEmail(email) &#123;  var regx &#x3D;    &#x2F;^[a-zA-Z0-9_.\-]+@[a-zA-Z0-9\-]+(\.[a-zA-Z0-9\-]+)*\.[a-zA-Z0-9]&#123;2,6&#125;$&#x2F;;  return regx.test(email);&#125;isEmail(&quot;841660202@qq.com&quot;); &#x2F;&#x2F; true&#x2F;&#x2F; 简写优化function isEmail2(email) &#123;  var regx &#x3D; &#x2F;^[\w_.\-]+@[\w\-]+(\.[\w\-]+)*\.[\w]&#123;2,6&#125;$&#x2F;;  return regx.test(email);&#125;isEmail2(&quot;841660202@qq.com&quot;); &#x2F;&#x2F; true</code></pre><p><a href="https://wenku.baidu.com/view/8b6256a3d7d8d15abe23482fb4daa58da0111cd2.html" target="_blank" >参考</a></p><p><a href="https://www.jianshu.com/p/bc2e7c0f5bfc#:~:text=%5Cw%20%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D%E5%AD%97%E7%AC%A6%EF%BC%8C%E7%AD%89%E4%BB%B7%E4%BA%8E%5Ba%2DzA%2DZ0%2D9%5D" target="_blank" >\w 查找单词字符，等价于[a-zA-Z0-9]</a></p><h3 id="校验身份证"><a href="#校验身份证" class="headerlink" title="校验身份证"></a>校验身份证</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 15位数字 或者是17+1位(数字，大小x)function isCard(number) &#123;  var regx &#x3D; &#x2F;(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;;  return regx.test(number);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计引发的血案</title>
      <link href="//post/2022-04-29nextjs.html"/>
      <url>//post/2022-04-29nextjs.html</url>
      
        <content type="html"><![CDATA[<h2 id="记录个bug-并在此文中规避"><a href="#记录个bug-并在此文中规避" class="headerlink" title="记录个bug,并在此文中规避"></a>记录个bug,并在此文中规避</h2><p>此处记下 hexo-theme-aurora 源码bug，有空时候帮他改</p><pre class="line-numbers language-none"><code class="language-none">.article .article-content p &#123;    font-size: .875rem;    line-height: 1.25rem;    margin-bottom: 0.5rem;    padding-bottom: 1rem;    word-break: break-all;&#125;</code></pre><h2 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h2><p><img src="http://t-blog-images.aijs.top/img/20220429103417.png"><br><img src="http://t-blog-images.aijs.top/img/20220429103946.png"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)    at async Promise.all (index 3)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 19)(node:29) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)    at async Promise.all (index 3)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 44)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)    at async Promise.all (index 2)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)    at async Promise.all (index 3)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)    at async Promise.all (index 2)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)</code></pre><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [resp] &#x3D; await Promise.all([  getLoginInfo(ctx),  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),  CommonModel.effects.getDataReport(req, ctx),])if (resp.success) &#123;  UserModal.actions.setUser(resp.result, req)&#125;</code></pre><h2 id="增加异常捕获"><a href="#增加异常捕获" class="headerlink" title="增加异常捕获"></a>增加异常捕获</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [resp] &#x3D; await Promise.all([  getLoginInfo(ctx),  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),  CommonModel.effects.getDataReport(req, ctx),]).catch(e&#x3D;&gt;&#123;  console.log(&quot;发生错误&quot;)  console.log(e)&#125;)</code></pre><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志仅 <code>Forbidden</code> 有效信息，大概是接口</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">发生错误Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:13144:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:12208:22)</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>因为acl 企业权限整了180天（顶配），时不时就出现系统瘫痪的情况，<code>日常</code>、<code>线上</code>都有此问题这架构设计的，估计没谁了。完全可以改成离职后，系统自动将用户禁权即可</li><li>除此之外，sso也有个通病，三个月没改过密码，用户账户无法登录，需要重新密码方可登录</li></ol>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信： 图片附件无法预览的问题</title>
      <link href="//post/2022-04-19wework-preview.html"/>
      <url>//post/2022-04-19wework-preview.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://t-blog-images.aijs.top/img/11460713-13685d46ead24558.png"></p><ul><li>背景：安卓预览正常，部分iOS预览有问题（大部分手机都是正常的）<pre class="line-numbers language-none"><code class="language-none">downloadAttachment(downloadUrl).then(res &#x3D;&gt; &#123;      if (getWechatUserAgent(navigator.userAgent)) &#123; &#x2F;&#x2F; 判断是企业微信        const blob &#x3D; new Blob([res]);        wx.previewFile(&#123;          url: location.origin + downloadUrl, &#x2F;&#x2F; 需要预览文件的地址(必填，可以使用相对路径)          name: attachment.name, &#x2F;&#x2F; 需要预览文件的文件名，必须有带文件格式的后缀，例如.doc(不填的话取url的最后部分，最后部分是个包含格式后缀的文件名)          size: blob.size &#x2F;&#x2F; 需要预览文件的字节大小(必填，而且大小必须正确，否则会打开失败)        &#125;);        Toast.loading(i18n.loading, false)        return      &#125;      var reader &#x3D; new FileReader();      reader.readAsDataURL(res);   &#x2F;&#x2F; 转换为base64，可以直接放入a标签href      reader.onload &#x3D; function (e) &#123;        const anchorEle &#x3D; document.createElement(&#39;a&#39;)        document.body.appendChild(anchorEle)        anchorEle.href &#x3D; e?.target?.result as any        anchorEle.download &#x3D; attachment.name        anchorEle.click()        document.body.removeChild(anchorEle)      &#125;      Toast.loading(i18n.loading, false)    &#125;).catch(() &#x3D;&gt; &#123;      Toast.loading(i18n.loading, false)    &#125;)</code></pre><code>自研移动端</code>、<code>web端</code>、<code>企业微信桌面端</code>都没问题，当然喽，每一个端展示效果是不一样的，代码也不一样。排查了耗费一定时间。</li></ul><ol><li>排查 企业微信版本， 比对后发现，和正常使用的微信版本一致</li><li>排查手机版本不一致，客户iphone12和 系统版本15.1，我们开发人员是14.+，所以我把我的手机升级到最新，我的手机升级后是正常的，那么可能是数据问题，数据</li><li>排查数据，这是老系统的数据，和新系统数据走不同的业务代码，经排查也没问题</li><li>排查<code>size</code>如果不准确也会出现上述问题，由于预发环境获取票据的信息与线上是不一致的，所以无法在预发进行排查，能做的事保证代码执行到<code> const blob = new Blob([res]);</code>，并且能够获取到正确的size，所以进行了alert调试，这个在手机上比较直观，当然也可以<code>vconsole</code>【暂不考虑,因为之前开发人员没加，部门被砍掉，很多人被裁员了，所有项目都我来维护，没时间，不整了】，调试结果是size: 88214,各个手机都一样，用户手机也是88214，故排除size</li><li>最后可能问题在于，用户手机上版本与手机不匹配，有兼容性bug，尝试升级企业微信，最后解决</li></ol><br/><p>总结：如果考虑直接升级用户app版本，或许在第三步就解决问题了，我的iphoneX也不用升级到15.3了</p>]]></content>
      
      
      <categories>
          
          <category> 企业微信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 企业微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs 结合 knife4j</title>
      <link href="//post/2022-02-29node.html"/>
      <url>//post/2022-02-29node.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/nest-knife4j">nest-knife4j</a><br><a href="https://github.com/xiaoymin/swagger-bootstrap-ui">knife4j github</a><br><a href="https://xiaoym.gitee.io/knife4j/documentation/">knife4j 文档</a><br><code>knife4j</code>可以理解为<code>一套swagger皮肤</code>，不使用knife4j默认是<code>swagger 1</code>版本的样式<br><img src="http://t-blog-images.aijs.top/img/11460713-6cda8a0126f7ee78.png"></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs文件上传</title>
      <link href="//post/2022-02-28node.html"/>
      <url>//post/2022-02-28node.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><a href="https://www.jianshu.com/p/28f8dd9a732e">Nestjs 上传文件</a><br><a href="https://www.cnblogs.com/ajanuw/p/9575278.html">Nestjs 上传文件</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 拖拽兼容</title>
      <link href="//post/2022-02-27react.html"/>
      <url>//post/2022-02-27react.html</url>
      
        <content type="html"><![CDATA[<h2 id="拖拽在web-pc-端、iframe、h5移动端"><a href="#拖拽在web-pc-端、iframe、h5移动端" class="headerlink" title="拖拽在web pc 端、iframe、h5移动端"></a>拖拽在web pc 端、iframe、h5移动端</h2><h3 id="存在差异"><a href="#存在差异" class="headerlink" title="存在差异"></a>存在差异</h3><ul><li>web pc 端支持：<code>onMouseDown</code>、<code>onMouseUp</code>、<code>onMousemove</code>、<code>onDragStart</code>、<code>onDragEnd</code>、<code>nDragOver</code></li><li>iframe web pc 端支持：<code>onMouseDown</code>、<code>onMouseUp</code>、<code>onMousemove</code></li><li>h5移动端支持：<code>onTouchStart</code>、<code>onTouchEnd</code>、<code>onTouchmove</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default function Draggable(props: Props) &#123;  const &#123; children, style, className, onDragFinish, onDraggingStart, onPositionGet, boundary &#x3D; &#123; x: MARGIN_TO_PAGE, y: MARGIN_TO_PAGE &#125; &#125; &#x3D; props  const [dragging, setDragging] &#x3D; useState(false)  const [attaching, setAttaching] &#x3D; useState(false)  const [top, setTop] &#x3D; useState(0)  const [left, setLeft] &#x3D; useState(0)  const ghostRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()  const elRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()  const onDragStart &#x3D; useCallback((e: DragEvent&lt;HTMLDivElement&gt; | TouchEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123;    let x    let y    if (isDrag(e)) &#123;      if (e.target !&#x3D;&#x3D; elRef.current) &#123;        return      &#125;      e.dataTransfer.setDragImage(emptyImg, 0, 0)      x &#x3D; e.clientX      y &#x3D; e.clientY    &#125; else &#123;      if (!e.target || !(e.target instanceof HTMLElement)) &#123;        return      &#125;      if (!parentHasClass(e.target, [rootStyles.feedbackRoot])) &#123;        return      &#125;      x &#x3D; e.touches[0].clientX      y &#x3D; e.touches[0].clientY    &#125;    e.stopPropagation()    const rect &#x3D; e.currentTarget.getBoundingClientRect()    const offsetX &#x3D; x - rect.x    const offsetY &#x3D; y - rect.y    setTop(rect.y)    setLeft(rect.x)    setDragging(true)    if (isDrag(e)) &#123;      dragoverHandle &#x3D; (event: DragEvent) &#x3D;&gt; &#123;        if (event.clientX || event.clientY) &#123;          setTop(event.clientY - offsetY)          setLeft(event.clientX - offsetX)        &#125;      &#125;      &#x2F;&#x2F; firefox 中，ondrag 拿不到鼠标的坐标，所以这里使用 document 的 dragover      document.addEventListener(&#39;dragover&#39;, dragoverHandle)    &#125; else &#123;      dragoverHandle &#x3D; (event: TouchEvent) &#x3D;&gt; &#123;        const touch &#x3D; event.touches[0]        if (touch.clientX || touch.clientY) &#123;          setTop(touch.clientY - offsetY)          setLeft(touch.clientX - offsetX)        &#125;      &#125;      document.addEventListener(&#39;touchmove&#39;, dragoverHandle)    &#125;    onDraggingStart()  &#125;, [])  const onDragEnd &#x3D; useCallback((event) &#x3D;&gt; &#123;    if (!ghostRef.current) &#123;      setDragging(false)      return    &#125;    const rect &#x3D; ghostRef.current.getBoundingClientRect()    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)    setTop(abs.top)    setLeft(abs.left)    setAttaching(true)    if (isDrag(event)) &#123;      document.removeEventListener(&#39;dragover&#39;, dragoverHandle)    &#125; else &#123;      document.removeEventListener(&#39;touchmove&#39;, dragoverHandle)    &#125;    &#x2F;&#x2F; onPosition &amp;&amp; onPosition(rel) &#x2F;&#x2F; 其他业务    dragoverHandle &#x3D; null    setTimeout(() &#x3D;&gt; &#123;      onDragFinish(rel)      setAttaching(false)      setDragging(false)    &#125;, 300)  &#125;, [])  const onMousedown &#x3D; useCallback((e) &#x3D;&gt; &#123;    const x &#x3D; e.clientX    const y &#x3D; e.clientY    const rect &#x3D; e.currentTarget.getBoundingClientRect()    const offsetX &#x3D; x - rect.x    const offsetY &#x3D; y - rect.y    setTop(rect.y)    setLeft(rect.x)    setDragging(true)    if (e.preventDefault) &#123;      e.preventDefault()    &#125; else &#123;      e.returnValue &#x3D; false    &#125;    document.onmousemove &#x3D; function (ev: any) &#123;      const _event &#x3D; ev || window.event      const endx &#x3D; _event.clientX - offsetX      const endy &#x3D; _event.clientY - offsetY      setTop(endy)      setLeft(endx)    &#125;  &#125;, [])  const onMouseup &#x3D; useCallback((e) &#x3D;&gt; &#123;    if (!ghostRef.current) &#123;      setDragging(false)      return    &#125;    const rect &#x3D; ghostRef.current.getBoundingClientRect()    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)    setTop(abs.top)    setLeft(abs.left)    setAttaching(true)    document.onmousemove &#x3D; null    onPositionGet &amp;&amp; onPositionGet(rel)    setTimeout(() &#x3D;&gt; &#123;      onDragFinish(rel)      setAttaching(false)      setDragging(false)    &#125;, 300)  &#125;, []) &#x2F;&#x2F; 能力检测  if (&#39;dragover&#39; in document.documentElement || &#39;ontouchstart&#39; in document.documentElement) &#123;    return (      &lt;div        style&#x3D;&#123;style&#125;        className&#x3D;&#123;className&#125;        draggable        onTouchStart&#x3D;&#123;onDragStart&#125;        onTouchEnd&#x3D;&#123;onDragEnd&#125;        onDragStart&#x3D;&#123;onDragStart&#125;        onDragEnd&#x3D;&#123;onDragEnd&#125;        onDragOver&#x3D;&#123;prevent&#125;        ref&#x3D;&#123;elRef&#125;      &gt;        &lt;div          style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;          className&#x3D;&#123;cn(&#123;            [styles.dragging]: dragging,            [styles.attaching]: attaching,          &#125;)&#125;          ref&#x3D;&#123;ghostRef&#125;        &gt;          &#123;children&#125;        &lt;&#x2F;div&gt;      &lt;&#x2F;div&gt;    )  &#125;  return (    &lt;div      style&#x3D;&#123;style&#125;      className&#x3D;&#123;className&#125;      draggable      onMouseDown&#x3D;&#123;onMousedown&#125;      onMouseUp&#x3D;&#123;onMouseup&#125;      ref&#x3D;&#123;elRef&#125;    &gt;      &lt;div        style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;        className&#x3D;&#123;cn(&#123;          [styles.dragging]: dragging,          [styles.attaching]: attaching,        &#125;)&#125;        ref&#x3D;&#123;ghostRef&#125;      &gt;        &#123;children&#125;      &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;  )&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React DOM</title>
      <link href="//post/2022-05-04react.html"/>
      <url>//post/2022-05-04react.html</url>
      
        <content type="html"><![CDATA[<h2 id="17-0-0-October-20-2020"><a href="#17-0-0-October-20-2020" class="headerlink" title="17.0.0 (October 20, 2020)"></a>17.0.0 (October 20, 2020)</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Delegate events to roots instead of document<br>来看下<a href="https://www.bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document">原因</a></p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>React自首次发布以来一直在自动执行事件委派。它直接在文档节点上为每个事件类型附加一个处理程序。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>虽然它提高了应用程序的性能，但由于文档节点上的事件委派，已经报告了许多问题。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为了演示其中一个问题，让我们以select下拉列表为例。<br>下面示例中的CountryDropDown是用于国家选择的React组件，它将被呈现给id为React root的div。react DOM容器封装在id为main的div中，该div有一个包含stopPropagation（）的更改事件。</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!--Div&#39;s change event contains stopPropagation()--&gt;&lt;div id&#x3D;&quot;main&quot;&gt;  &lt;!--Div where react component will be rendered --&gt;  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">class CountryDropDown extends React.Component &#123;  state &#x3D; &#123;    country: &#39;&#39;,  &#125;  const handleChange &#x3D; e &#x3D;&gt; &#123;    this.setState(&#123; country: e.target.value &#125;);  &#125;  render() &#123;    return (      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;        &lt;thead&gt;          &lt;tr&gt;            &lt;th&gt;Country&lt;&#x2F;th&gt;            &lt;th&gt;Selected country&lt;&#x2F;th&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;thead&gt;        &lt;tbody&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;select value&#x3D;&#123;this.state.country&#125;                onChange&#x3D;&#123;this.handleChange&#125;              &gt;                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;              &lt;&#x2F;select&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &#123;this.state.country&#125;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;tbody&gt;      &lt;&#x2F;table&gt;    );  &#125;&#125;ReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>将更改事件附加到主div</p></blockquote><pre class="line-numbers language-none"><code class="language-none">document.getElementById(&quot;main&quot;).addEventListener(  &quot;change&quot;,  function (e) &#123;    e.stopPropagation();  &#125;,  false);</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当选择一个国家时，我们无法看到所选的国家</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>此意外行为的原因是附加到文档节点的onChange dropdown事件。包含e.stopPropagation（）的主div的change事件阻止了下拉菜单的onChange事件。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为了解决此类问题，React 17不再在文档级别附加事件处理程序。相反，它将它们附加到根DOM容器中，React树将被渲染到该容器中。<br><img src="https://www.bigbinary.com/blog_images/react17/react_17_event_delegation.png"></p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在React 17中进行更改后，事件被附加到根DOM容器，React树被呈现到该容器中。在我们的示例中，onChange事件的下拉列表将附加到id为react root的div。当选择任何国家&#x2F;地区呈现预期行为时，将触发此事件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentry错误日志获取</title>
      <link href="//post/2021-06-20sentry.html"/>
      <url>//post/2021-06-20sentry.html</url>
      
        <content type="html"><![CDATA[<ul><li>先上图</li></ul><p><img src="http://t-blog-images.aijs.top/img/11460713-94dac7337bf8ed4f.png"></p><p><img src="http://t-blog-images.aijs.top/img/11460713-2d4eb13808a7a16a.png"></p><p>This is a quick getting started guide. For in-depth instructions on integrating Sentry with React, view <a href="https://docs.sentry.io/platforms/javascript/guides/react/">our complete documentation</a>.</p><p>To instrument your React application with Sentry, first install the <code>@sentry/react</code> and <code>@sentry/tracing</code> packages:</p><pre class="line-numbers language-none"><code class="language-none"># Using yarnyarn add @sentry&#x2F;react @sentry&#x2F;tracing# Using npmnpm install --save @sentry&#x2F;react @sentry&#x2F;tracing</code></pre><p>Next, import and initialize the Sentry module as early as possible, before initializing React:</p><pre class="line-numbers language-none"><code class="language-none">import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import * as Sentry from &quot;@sentry&#x2F;react&quot;;import &#123; Integrations &#125; from &quot;@sentry&#x2F;tracing&quot;;import App from &quot;.&#x2F;App&quot;;Sentry.init(&#123;  dsn: &quot;https:&#x2F;&#x2F;a5f1c39789b24bb7a434868b677e0c65@&#x2F;1063&quot;,  integrations: [new Integrations.BrowserTracing()],  &#x2F;&#x2F; Set tracesSampleRate to 1.0 to capture 100%  &#x2F;&#x2F; of transactions for performance monitoring.  &#x2F;&#x2F; We recommend adjusting this value in production  tracesSampleRate: 1.0,&#125;);ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&quot;root&quot;));&#x2F;&#x2F; Can also use with React Concurrent Mode&#x2F;&#x2F; ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App &#x2F;&gt;);</code></pre><p>The above configuration captures both error and performance data. To reduce the volume of performance data captured, change <code>tracesSampleRate</code> to a value between 0 and 1.</p><p>After this step, Sentry will report any uncaught exceptions triggered by your application.</p><p>You can trigger your first event from your development environment by raising an exception somewhere within your application. An example of this would be rendering a button whose <code>onClick</code> handler attempts to invoke a method that does not exist:</p><pre class="line-numbers language-none"><code class="language-none">return &lt;button onClick&#x3D;&#123;methodDoesNotExist&#125;&gt;Break the world&lt;&#x2F;button&gt;;</code></pre><p>Once you’ve verified the library is initialized properly and sent a test event, consider visiting our <a href="https://docs.sentry.io/platforms/javascript/guides/react/">complete React docs</a>. There you’ll find additional instructions for surfacing valuable context from React error boundaries, React Router, Redux, and more.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 自动生成 .d.ts</title>
      <link href="//post/2021-06-10scss2type.html"/>
      <url>//post/2021-06-10scss2type.html</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-Module-Typed"><a href="#CSS-Module-Typed" class="headerlink" title="CSS Module Typed"></a>CSS Module Typed</h2><p><strong>vscode 插件列表中有好多个，不要安装错了</strong></p><p><img src="http://t-blog-images.aijs.top/img/20220607152316.webp"></p><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=awwit.typed-css-modules-plugin">link</a></p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Install deps first:</p><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p><code>npm install typed-css-modules</code></p><h3 id="if-you-need-less"><a href="#if-you-need-less" class="headerlink" title="if you need less"></a>if you need less</h3><p><code>npm install less</code></p><h3 id="if-you-need-scss-x2F-sass"><a href="#if-you-need-scss-x2F-sass" class="headerlink" title="if you need scss&#x2F;sass"></a>if you need scss&#x2F;sass</h3><p><code>npm install sass</code></p><h3 id="if-you-need-stylus"><a href="#if-you-need-stylus" class="headerlink" title="if you need stylus"></a>if you need stylus</h3><p><code>npm install stylus</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Modules can be installed globally. yarn is supported.</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>To switch the package manager (npm or yarn), you need to change the settings npm.packageManager of the built-in module vscode.npm.</p></blockquote><h3 id="Configuring"><a href="#Configuring" class="headerlink" title="Configuring"></a>Configuring</h3><p>By default, the option to automatically format .d.ts files using eslint is enabled. You can disable this feature through the setting “typed-css-modules.eslint.enable”: false.</p><p>Usage<br>put</p><p><code>// @type</code></p><p>or</p><p><code>/* @type */</code></p><p>ahead of your .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl file, and save, you will get a d.ts file in same directory.</p><h3 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h3><p><img src="https://s2.ax1x.com/2019/01/31/k1yTT1.gif"></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">&#x2F;* @type *&#x2F;.root &#123;  padding: 16px;  min-height: 100%;  .empty-wrapper &#123;    height: 380px;    display: flex;    flex-direction: column;    align-items: center;    justify-content: center;  &#125;  &gt; h3 &#123;    font-size: inherit;    margin-bottom: 4px;  &#125;  .toolbar-wrapper &#123;    position: relative;    .toolbar &#123;      position: absolute;      margin: 12px 0;      z-index: 1;      &amp;.static &#123;        position: static;      &#125;      &gt; *:not(:first-child) &#123;        margin-left: 8px;      &#125;    &#125;  &#125;  .buttons &#123;    button &#123;      margin-right: 8px;    &#125;  &#125;&#125;.use-select &#123;  width: 300px;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">declare const styles: &#123;  readonly root: string;  readonly &quot;empty-wrapper&quot;: string;  readonly &quot;toolbar-wrapper&quot;: string;  readonly toolbar: string;  readonly static: string;  readonly buttons: string;  readonly &quot;use-select&quot;: string;&#125;;export &#x3D; styles;</code></pre><h3 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Creates .d.ts files from css-modules .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl files.</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Error: vscode-typed-css-modules: Cannot find global module ‘typed-css-modules’</p></blockquote><pre class="line-numbers language-none"><code class="language-none">npm install -g typed-css-modules</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="//post/2021-03-20hexo.html"/>
      <url>//post/2021-03-20hexo.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode GitHub Copilot</title>
      <link href="//post/2022-05-08vscode.html"/>
      <url>//post/2022-05-08vscode.html</url>
      
        <content type="html"><![CDATA[<h2 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h2><a href="https://copilot.github.com/" target="_blank"><img src="https://copilot.github.com/head2x.png"  width= 100/></a><p>Your AI pair programmer</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="https://copilot.github.com/">官网</a></h3><p><img src="https://copilot.github.com/diagram.png"></p><h3 id="支持开发工具"><a href="#支持开发工具" class="headerlink" title="支持开发工具"></a>支持开发工具</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>support Visual Studio Code, Neovim, and IntelliJ-based IDEs like JetBrains IntelliJ IDEA, Android Studio or PyCharm.</p></blockquote><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul><li>需要人员审批通过，等[1-2 工作日]</li></ul><p><a href="https://github.com/features/copilot/signup">注册&#x2F;结果查看</a><br><img src="http://t-blog-images.aijs.top/img/20220526184023.webp"></p><p><strong>我等到了5月25号才通过</strong>，好像有两周的样子😂</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Join the GitHub Copilot waitlist<br>Access is limited to a small group of testers during the technical preview of GitHub Copilot. Sign up today for your chance to try it out and help us improve.</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>You’re already on the waitlist for GitHub Copilot! We’ll notify you when we’ve enabled it on your account. Make sure your primary email address is up-to-date so we can notify you.</p></blockquote><h3 id="vscode-安装插件-Copilot"><a href="#vscode-安装插件-Copilot" class="headerlink" title="vscode 安装插件 Copilot"></a>vscode 安装插件 <code>Copilot</code></h3><p><img src="http://t-blog-images.aijs.top/img/20220508111956.webp"></p><h3 id="读源码的利器"><a href="#读源码的利器" class="headerlink" title="读源码的利器"></a>读源码的利器</h3><p><img src="http://t-blog-images.aijs.top/img/20220527093323.webp"></p><h3 id="写文档的利器"><a href="#写文档的利器" class="headerlink" title="写文档的利器"></a>写文档的利器</h3><ul><li>我这里需要某种格式的翻译效果<br><img src="http://t-blog-images.aijs.top/img/Kapture%202022-06-08%20at%2017.46.08.gif"></li></ul><h3 id="不幸的事"><a href="#不幸的事" class="headerlink" title="不幸的事"></a>不幸的事</h3><p><a href="https://github.com/pricing#i-work-on-open-source-projects-can-i-get-access-to-github-copilot-for-free">收费了</a></p><img src="http://t-blog-images.aijs.top/img/20220622154707.webp" /><img src="https://img1.baidu.com/it/u=2626775378,76936048&fm=253&fmt=auto&app=138&f=JPEG?w=300&h=300"/>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
            <tag> AI编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 包发布相关</title>
      <link href="//post/2022-04-28npm.html"/>
      <url>//post/2022-04-28npm.html</url>
      
        <content type="html"><![CDATA[<h2 id="npm-包发布"><a href="#npm-包发布" class="headerlink" title="npm 包发布"></a>npm 包发布</h2><pre class="line-numbers language-none"><code class="language-none">npm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; npm notice name:          @tutu-fe&#x2F;wiki-ui                        npm notice version:       0.1.1-beta                              npm notice filename:      @tutu-fe&#x2F;wiki-ui-0.1.1-beta.tgz         npm notice package size:  85.7 kB                                 npm notice unpacked size: 449.9 kB                                npm notice shasum:        973f5eb8d74de04c34b8e9c94536f8924b1f9570npm notice integrity:     sha512-Uyo3zS0eaMOYE[...]60Ywmrmb&#x2F;brxQ&#x3D;&#x3D;npm notice total files:   205                                     npm notice npm ERR! code E403npm ERR! 403 403 Forbidden - PUT https:&#x2F;&#x2F;registry- - [maintainers_error] haotian.chen does not in maintainer listnpm ERR! 403 In most cases, you or one of your dependencies are requestingnpm ERR! 403 a package version that is forbidden by your security policy, ornpm ERR! 403 on a server you do not have access to.npm ERR! A complete log of this run can be found in:npm ERR!     &#x2F;Users&#x2F;haotian&#x2F;.npm&#x2F;_logs&#x2F;2022-04-28T09_58_10_365Z-debug.log</code></pre><h2 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;maintainers&quot;: [  &quot;davishua&quot;,å  &quot;haotian.chen&quot;],</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://t-blog-images.aijs.top/img/20220428180656.png"><br><img src="http://t-blog-images.aijs.top/img/20220428180602.png"></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钉钉授权-单token刷新</title>
      <link href="//post/2019-10-31dd-auth.html"/>
      <url>//post/2019-10-31dd-auth.html</url>
      
        <content type="html"><![CDATA[<h2 id="钉钉授权"><a href="#钉钉授权" class="headerlink" title="钉钉授权"></a>钉钉授权</h2><p> 钉钉小程序，单token防止进行token刷新</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 刷新tokenfunction refreshToken(corpId, cb) &#123;  dd.getAuthCode(&#123;    success: async (res) &#x3D;&gt; &#123;      const params &#x3D; &#123;        authCode: res.authCode,        corpId,      &#125;;      dd.stopPullDownRefresh();      const resAuth &#x3D; await authDing(params);      &#x2F;&#x2F; 只有授权成功情况下才可以      if (resAuth.code &#x3D;&#x3D;&#x3D; &quot;000000&quot;) &#123;        saveToken(resAuth.data.token);        setLastTokenTime(new Date().getTime().toString());        if (cb) &#123;          cb();        &#125;      &#125; else &#123;        showToastFail(JSON.stringify(resAuth));      &#125;    &#125;,    fail: (err) &#x3D;&gt; &#123;      showToastFail(JSON.stringify(err));    &#125;,  &#125;);&#125;&#x2F;** * 钉钉授权 * corpId 企业钉钉组织id * callBack 授权成功后的回调 * *&#x2F;export function ddAuth(corpId, callBack) &#123;  const currentTime &#x3D; new Date().getTime();  const lastTokenTime &#x3D; getLastTokenTime() || 0;  &#x2F;&#x2F; 发布  if (config.release) &#123;    try &#123;      &#x2F;&#x2F; 大于23小时，重新授权      if (currentTime - +lastTokenTime &gt; 23 * 60 * 60 * 1000) &#123;        refreshToken(corpId, callBack);        console.log(&quot;重新授权&quot;);      &#125; else &#123;        &#x2F;&#x2F; 小于23小时，大于6小时，刷新        callBack();        &#x2F;&#x2F; 刷新token        if (currentTime - +lastTokenTime &gt; 6 * 60 * 60 * 1000) &#123;          refreshToken(corpId);        &#125;      &#125;    &#125; catch (error) &#123;      showToastFail(error);    &#125;    &#x2F;&#x2F; 开发调试  &#125; else &#123;    callBack();    &#x2F;&#x2F; showToastFail(&quot;开发登录超时，重新登录&quot;)  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 钉钉小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钉钉小程序 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git public key</title>
      <link href="//post/2016-06-20git.html"/>
      <url>//post/2016-06-20git.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.name &quot;hailong.chen&quot;[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.email &quot;841660202@qq.com&quot;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>SSH<br>SSH keys<br>SSH key 可以让你在你的电脑和 Code 服务器之间建立安全的加密连接。 先执行以下语句来判断是否已经存在本地公钥：<br><code>cat ~/.ssh/id_rsa.pub</code><br>如果你看到一长串以  ssh-rsa 或  ssh-dsa 开头的字符串, 你可以跳过  ssh-keygen 的步骤。<br>提示: 最好的情况是一个密码对应一个 ssh key，但是那不是必须的。你完全可以跳过创建密码这个步骤。请记住设置的密码并不能被修改或获取。<br>你可以按如下命令来生成 ssh key<br><code>ssh-keygen -t rsa -C &quot;841660202@qq.com&quot;</code><br>这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击 Enter 键去使用默认值。<br>用以下命令获取你生成的公钥：<br><code>cat ~/.ssh/id_rsa.pub</code><br>复制这个公钥放到你的个人设置中的 SSH&#x2F;My SSH Keys 下，请完整拷贝从 ssh-开始直到你的用户名和主机名为止的内容。<br>如果打算拷贝你的公钥到你的粘贴板下，请参考你的操作系统使用以下的命令：<br>Windows:<br><code>clip &lt; ~/.ssh/id_rsa.pub</code><br>Mac:<br><code>pbcopy &lt; ~/.ssh/id_rsa.pub</code><br>GNU&#x2F;Linux (requires xclip):<br><code>xclip -sel clip &lt; ~/.ssh/id_rsa.pub</code><br>Applications<br>Eclipse<br>如何在 Eclipse 中添加 ssh key: <a href="https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_Configuration">https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_Configuration</a><br>Tip: Non-default OpenSSH key file names or locations<br>如果，不管你有什么理由，当你决定去用一个非默认的位置或文件名去存放你的 ssh key。你必须配置好你的 ssh 客户端以找到你的 ssh 私钥去连接 Code 服务器，对于 OpenSSH 客户端，这个通常是在~&#x2F;.ssh&#x2F;config 类似的位置配置的：<br>Host my-git.company.com<br>RSAAuthentication yes<br>IdentityFile ~&#x2F;my-ssh-key-directory&#x2F;company-com-private-key-filename</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Last login: Sun Apr 17 16:06:15 on consoleN&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.You need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.N&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.You need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.The default interactive shell is now zsh.To update your account to use zsh, please run &#96;chsh -s &#x2F;bin&#x2F;zsh&#96;.For more details, please visit https:&#x2F;&#x2F;support.apple.com&#x2F;kb&#x2F;HT208050.chenhailong@chenhailongdeMacBook-Pro:~$ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop-bash: &#x2F;Users&#x2F;chenhailong&#x2F;Desktop: is a directorychenhailong@chenhailongdeMacBook-Pro:~$ cd &#x2F;Users&#x2F;chenhailong&#x2F;Desktopchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.gitCloning into &#39;841660202.github.io&#39;...The authenticity of host &#39;github.com (20.205.243.166)&#39; can&#39;t be established.ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU.This key is not known by any other namesAre you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;github.com&#39; (ED25519) to the list of known hosts.git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.gitCloning into &#39;841660202.github.io&#39;...git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub-bash: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directorychenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pubcat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directorychenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.name &quot;hailong.chen&quot;chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.email &quot;841660202@qq.com&quot;chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pubcat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directorychenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ ssh-keygen -t rsa -C &quot;841660202@qq.com&quot;Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsaYour public key has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pubThe key fingerprint is:SHA256:bdtIDeRXGKxGTEa&#x2F;Ex3QdPtVoOUiwuiq7YKjKrLakbU 841660202@qq.comThe key&#39;s randomart image is:+---[RSA 3072]----+|         +&#x3D;.o**.o||       o +o.o*.oo||      . o.+.* o..||     .   oo&#x3D; +  o||    . . S.+ +   .||   o o   o + .   || .o E     o .    ||&#x3D;..+             ||@oooo            |+----[SHA256]-----+chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pubchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.gitCloning into &#39;841660202.github.io&#39;...remote: Enumerating objects: 441, done.remote: Counting objects: 100% (441&#x2F;441), done.remote: Compressing objects: 100% (216&#x2F;216), done.remote: Total 441 (delta 208), reused 401 (delta 168), pack-reused 0Receiving objects: 100% (441&#x2F;441), 1.34 MiB | 1.05 MiB&#x2F;s, done.Resolving deltas: 100% (208&#x2F;208), done.chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$</code></pre><h2 id="设置-github-SSH-keys"><a href="#设置-github-SSH-keys" class="headerlink" title="设置 github SSH keys"></a>设置 github SSH keys</h2><p><a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p><h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><p>图 1</p><img src="http://t-blog-images.aijs.top/img/202208112025638.png" /><p>图 2</p><img src="http://t-blog-images.aijs.top/img/202208112027160.png" /><ol><li><code>git config --global user.email &lt;&gt;</code></li><li>删除重新配置 如图2</li><li>清理 git 缓存<code>git clean -f</code></li><li>重新提交</li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC Iterm2美化终端</title>
      <link href="//post/2017-07-09item2.html"/>
      <url>//post/2017-07-09item2.html</url>
      
        <content type="html"><![CDATA[<h2 id="MAC-环境"><a href="#MAC-环境" class="headerlink" title="MAC 环境"></a>MAC 环境</h2><p><strong>注意：以下内容仅限 MAC,其他环境，请自行谷歌</strong></p><h2 id="oh-my-zsh-插件推荐"><a href="#oh-my-zsh-插件推荐" class="headerlink" title="oh-my-zsh 插件推荐 :"></a>oh-my-zsh 插件推荐 :</h2><ul><li>autojump 这个没用起来，使用没什么效果 🥹</li><li>zsh-autosuggestion 命令行输入有提示，（命令下载失败，手动下载，拷贝到 <code>~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code>）</li><li>zsh-syntax-highlighting</li></ul><h2 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h2><p><strong>1.使用 brew 安装</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install oh-my-zsh</code></pre><p><strong>2. 手动安装</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zshcp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc</code></pre><h2 id="安装-autojump"><a href="#安装-autojump" class="headerlink" title="安装 autojump"></a>安装 autojump</h2><p><strong>1.安装</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew install autojump</code></pre><p><strong>2.配置</strong><br><code>code ~/.zshrc</code>，把以下代码加到尾部</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用brew安装的[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.shsource $ZSH&#x2F;oh-my-zsh.sh# 使用git安装的[[ -s ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh</code></pre><p><strong>3.刷新配置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source ~&#x2F;.zshrc</code></pre><h2 id="安装-zsh-autosuggestion"><a href="#安装-zsh-autosuggestion" class="headerlink" title="安装 zsh-autosuggestion"></a>安装 zsh-autosuggestion</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions</code></pre><h2 id="安装-zsh-syntax-highlighting"><a href="#安装-zsh-syntax-highlighting" class="headerlink" title="安装 zsh-syntax-highlighting"></a>安装 zsh-syntax-highlighting</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting</code></pre><h2 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h2><p>最后用 <code>source ~/.zshrc</code> 命令更新配置文件</p><h2 id="zshrc-配置如下："><a href="#zshrc-配置如下：" class="headerlink" title=".zshrc 配置如下："></a>.zshrc 配置如下：</h2><ul><li>自己电脑配置，下面截图是办公电脑截图</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># If you come from bash you might have to change your $PATH.# export PATH&#x3D;$HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:$PATH# Path to your oh-my-zsh installation.export ZSH&#x3D;&quot;$HOME&#x2F;.oh-my-zsh&quot;# Set name of the theme to load --- if set to &quot;random&quot;, it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;ThemesZSH_THEME&#x3D;&quot;robbyrussell&quot;# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME&#x3D;random will cause zsh to load# a theme from this variable instead of looking in $ZSH&#x2F;themes&#x2F;# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES&#x3D;( &quot;robbyrussell&quot; &quot;agnoster&quot; )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE&#x3D;&quot;true&quot;# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE&#x3D;&quot;true&quot;# Uncomment one of the following lines to change the auto-update behavior# zstyle &#39;:omz:update&#39; mode disabled  # disable automatic updates# zstyle &#39;:omz:update&#39; mode auto      # update automatically without asking# zstyle &#39;:omz:update&#39; mode reminder  # just remind me to update when it&#39;s time# Uncomment the following line to change how often to auto-update (in days).# zstyle &#39;:omz:update&#39; frequency 13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS&#x3D;&quot;true&quot;# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS&#x3D;&quot;true&quot;# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE&#x3D;&quot;true&quot;# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION&#x3D;&quot;true&quot;# Uncomment the following line to display red dots whilst waiting for completion.# You can also set it to another string to have that shown instead of the default red dots.# e.g. COMPLETION_WAITING_DOTS&#x3D;&quot;%F&#123;yellow&#125;waiting...%f&quot;# Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)# COMPLETION_WAITING_DOTS&#x3D;&quot;true&quot;# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY&#x3D;&quot;true&quot;# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# &quot;mm&#x2F;dd&#x2F;yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;# or set a custom format using the strftime function format specifications,# see &#39;man strftime&#39; for details.# HIST_STAMPS&#x3D;&quot;mm&#x2F;dd&#x2F;yyyy&quot;# Would you like to use another custom folder than $ZSH&#x2F;custom?# ZSH_CUSTOM&#x3D;&#x2F;path&#x2F;to&#x2F;new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in $ZSH&#x2F;plugins&#x2F;# Custom plugins may be added to $ZSH_CUSTOM&#x2F;plugins&#x2F;# Example format: plugins&#x3D;(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.# 插件信息plugins&#x3D;(  git  zsh-syntax-highlighting  zsh-autosuggestions  autojump)source $ZSH&#x2F;oh-my-zsh.sh[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.shsource $ZSH&#x2F;oh-my-zsh.sh# User configurationPROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d $ &quot;# PROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[magenta]%&#125;$ &quot;PROMPT+&#x3D;&#39;%&#123;$reset_color%&#125;&#39;ZSH_THEME_GIT_PROMPT_PREFIX&#x3D;&quot;%&#123;$fg_bold[blue]%&#125;&quot;ZSH_THEME_GIT_PROMPT_SUFFIX&#x3D;&quot;%&#123;$reset_color%&#125; &quot;ZSH_THEME_GIT_PROMPT_DIRTY&#x3D;&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;ZSH_THEME_GIT_PROMPT_CLEAN&#x3D;&quot;%&#123;$fg[blue]%&#125;)&quot;# 参考 https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b84d8b7b134e# codevalue# %T系统时间（时：分）# %*系统时间（时：分：秒）# %D系统日期（年-月-日）# %n用户名# %B - %b开始到结束使用粗体打印# %U - %u开始到结束使用下划线打印# %c仅当前文件夹路径# %d当前目录路径完整# %~当前目录相对于～的相对路径# %M计算机的主机名# %m计算机的主机名（在第一个句号之前截断# %l当前的tty# export MANPATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;man:$MANPATH&quot;# You may need to manually set your language environment# export LANG&#x3D;en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then#   export EDITOR&#x3D;&#39;vim&#39;# else#   export EDITOR&#x3D;&#39;mvim&#39;# fi# Compilation flags# export ARCHFLAGS&#x3D;&quot;-arch x86_64&quot;# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run &#96;alias&#96;.## Example aliases# alias zshconfig&#x3D;&quot;mate ~&#x2F;.zshrc&quot;# alias ohmyzsh&#x3D;&quot;mate ~&#x2F;.oh-my-zsh&quot;</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><img src="http://t-blog-images.aijs.top/img/202208192302460.png" /><p><strong>根目录执行完,只能规避提示，不能解决问题</strong></p><pre class="line-numbers language-none"><code class="language-none">compaudit | xargs chmod g-w,o-w</code></pre><img src="http://t-blog-images.aijs.top/img/202208192304357.png" /><p><strong>重新安装 zsh 解决问题</strong><br><a href="https://www.jianshu.com/p/677a9bb1ac29" target="_blank" >fixed： 重新安装 zsh</a></p><pre class="line-numbers language-none"><code class="language-none">brew install zsh</code></pre><h2 id="推荐博客左岸博客"><a href="#推荐博客左岸博客" class="headerlink" title="推荐博客左岸博客"></a>推荐博客<a href="https://www.zrahh.com/archives/167.html">左岸博客</a></h2><h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p><img src="http://t-blog-images.aijs.top/img/11460713-14c8ef376aabe04a.png"><br><img src="http://t-blog-images.aijs.top/img/11460713-ef2da0af46da7712.png"><br><img src="http://t-blog-images.aijs.top/img/11460713-e49ed15245409774.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layoffs</title>
      <link href="//post/2022-03-25Layoffs.html"/>
      <url>//post/2022-03-25Layoffs.html</url>
      
        <content type="html"><![CDATA[<h2 id="一家上市公司近期「B业」人数变化"><a href="#一家上市公司近期「B业」人数变化" class="headerlink" title="一家上市公司近期「B业」人数变化"></a>一家上市公司近期「B业」人数变化</h2><p><img src="http://t-blog-images.aijs.top/img/11460713-98eaa0e7b6e68c6f.png" alt="2022-03-30"><br><img src="http://t-blog-images.aijs.top/img/11460713-f2c5edfe1032663d.png" alt="2022-03-31"><br><img src="http://t-blog-images.aijs.top/img/11460713-0d1febc4e52867bd.png" alt="2022-04-01"><br><img src="http://t-blog-images.aijs.top/img/11460713-3c855f37997fca9d.png" alt="2022-04-02"><br><img src="http://t-blog-images.aijs.top/img/11460713-33ab1685e98181c5.png" alt="2022-04-07"><br><img src="http://t-blog-images.aijs.top/img/11460713-f6178de2c725ba0d.png" alt="2022-04-08"><br><img src="http://t-blog-images.aijs.top/img/11460713-1c49e477ebebdb04.png" alt="2022-04-11"><br><img src="http://t-blog-images.aijs.top/img/11460713-ff83505b93a40211.png" alt="2022-04-12"><br><img src="http://t-blog-images.aijs.top/img/11460713-6e26dc81d1bc1bb5.png" alt="2022-04-13"><br><img src="http://t-blog-images.aijs.top/img/11460713-6f19d0ccbc1470d1.png" alt="2022-04-14"><br><img src="http://t-blog-images.aijs.top/img/11460713-5fa4eb0d60075e10.png" alt="2022-04-15"><br><img src="http://t-blog-images.aijs.top/img/11460713-a75f3fa3bc0cc9ad.png" alt="2022-04-20"><br><img src="http://t-blog-images.aijs.top/img/11460713-2cb92c5f9a24df72.png" alt="2022-04-21"><br><img src="http://t-blog-images.aijs.top/img/11460713-ea85739148839bd2.png" alt="image.png"><br><img src="http://t-blog-images.aijs.top/img/11460713-cc82a2680e69dccd.png" alt="2022-04-26"><br><img src="http://t-blog-images.aijs.top/img/11460713-fdd722c44a598a88.png" alt="2022-04-27"><br><img src="http://t-blog-images.aijs.top/img/11460713-35395fd4c9b459ea.png" alt="2022-04-28"><br><img src="http://t-blog-images.aijs.top/img/20220505093216.webp" alt="2022-05-05"><br><img src="http://t-blog-images.aijs.top/img/20220509134022.webp" alt="2022-05-09"><br><img src="http://t-blog-images.aijs.top/img/20220510180811.webp" alt="2022-05-10"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Layoffs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs服务端技术栈</title>
      <link href="//post/2021-06-30node.html"/>
      <url>//post/2021-06-30node.html</url>
      
        <content type="html"><![CDATA[<h2 id="NestJS中文文档"><a href="#NestJS中文文档" class="headerlink" title="NestJS中文文档"></a>NestJS中文文档</h2><p><a href="https://nestjs.bootcss.com/">NestJS中文文档</a><br><a href="https://docs.nestjs.cn/">NestJS中文文档</a><br><a href="https://github.com/nestjs/nest">github</a> 42.2K</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>A progressive Node.js framework for building efficient, scalable, and enterprise-grade server-side applications on top of TypeScript &amp; JavaScript (ES6, ES7, ES8) 🚀</p></blockquote><h2 id="TypeORM"><a href="#TypeORM" class="headerlink" title="TypeORM"></a>TypeORM</h2><p><a href="https://typeorm.biunav.com/zh/#%E5%AE%89%E8%A3%85">TypeORM中文文档</a><br><a href="https://github.com/typeorm/typeorm">github地址</a> 26.3K</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>ORM for TypeScript and JavaScript (ES7, ES6, ES5). Supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, SAP Hana, WebSQL databases. Works in NodeJS, Browser, Ionic, Cordova and Electron platforms.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web office预览</title>
      <link href="//post/2021-09-07web.html"/>
      <url>//post/2021-09-07web.html</url>
      
        <content type="html"><![CDATA[<p>第一步<br>将文件上传到你的服务器里，并支持url下载这个文件。<br>第二步<br>访问：<a href="http://view.officeapps.live.com/op/view.aspx?src=%E8%A6%81%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6%E7%9A%84url%E5%9C%B0%E5%9D%80%EF%BC%88%E8%AE%B0%E5%BE%97url%E7%BC%96%E7%A0%81%E5%93%A6%EF%BC%89">http://view.officeapps.live.com/op/view.aspx?src=要预览文件的url地址（记得url编码哦）</a><br>第三步<br>可以使用iframe嵌入你的系统<br>更多<br>详情查看：<a href="https://www.microsoft.com/en-us/microsoft-365/blog/2013/04/10/office-web-viewer-view-office-documents-in-a-browser/?eu=true">https://www.microsoft.com/en-us/microsoft-365/blog/2013/04/10/office-web-viewer-view-office-documents-in-a-browser/?eu=true</a><br><img src="http://t-blog-images.aijs.top/img/11460713-93b26693cac5c2d8.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-dev</title>
      <link href="//post/2021-11-02node.html"/>
      <url>//post/2021-11-02node.html</url>
      
        <content type="html"><![CDATA[<h2 id="在幕后用ts-node调整node-dev"><a href="#在幕后用ts-node调整node-dev" class="headerlink" title="在幕后用ts-node调整node-dev"></a>在幕后用ts-node调整node-dev</h2><ul><li>作用：在幕后用ts-node调整node-dev</li><li>优点：<ul><li>任意依赖的文件改变时候，重启node process，但是共享ts编译线程。</li><li>因为不需要每次ts-node编译的实例化，而提升性能</li></ul></li><li>配置项：</li><li>注意事项：</li><li>截图：<br><img src="http://t-blog-images.aijs.top/img/11460713-10cfe41335cfeb5d.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简书迁移到OSS</title>
      <link href="//post/2022-04-27mv-blog-jianshu.html"/>
      <url>//post/2022-04-27mv-blog-jianshu.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre class="line-numbers language-none"><code class="language-none">cat .&#x2F;* |grep uploadimages.jianshu.io &gt; image.txtmkdir img3dcd img3dwget -i ..&#x2F;image.txtsed -i&#39;&#39; -e &#39;s&#x2F;!\[image.png\](&#x2F;&#x2F;g&#39; image.txtsed -i&#39;&#39; -e &#39;s&#x2F;)&#x2F;&#x2F;g&#39; image.txt</code></pre><h2 id="迁移简书图片下载后重命名"><a href="#迁移简书图片下载后重命名" class="headerlink" title="迁移简书图片下载后重命名"></a>迁移简书图片下载后重命名</h2><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;bin&#x2F;shfor eachfile in &#96;ls -B&#96;do    # echo $&#123;eachfile%%\%3F*&#125; # 截掉最后.txt    # $ % https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b3bdc3b3968e  filename&#x3D;$&#123;eachfile%%\%3F*&#125;  filehead&#x3D;&#96;echo $eachfile | awk -F \%3F &#39;&#123;print $1 &#125;&#39;&#96;  filelast&#x3D;&#96;echo $eachfile | awk -F \%3F &#39;&#123;print $2 &#125;&#39;&#96;  # mv $filename.txt $&#123;filelast&#125;_$filehead.txt  # https:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1726788915185806701&amp;wfr&#x3D;spider&amp;for&#x3D;pc  echo &#39;--&#39;  # echo $filename  echo $filehead #分割字符左边部分  echo $filelast #分割字符右边部分  # 右边文件存在的情况下才处理  if [ &quot;$filelast&quot; !&#x3D; &quot;&quot; ]  then    echo &#39;执行rename &#39;    mv $eachfile $filehead  fidone</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
