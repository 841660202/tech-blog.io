<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>待办事项</title>
      <link href="//post/todo.html"/>
      <url>//post/todo.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 1. headless-recorder&#x2F;&#x2F; 2. lightHouse https:&#x2F;&#x2F;blog.csdn.net&#x2F;tangdou369098655&#x2F;article&#x2F;details&#x2F;122531766&#x2F;&#x2F; 3. 博客封面生成&#x2F;&#x2F; 4. 装饰器模式 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;decorator&#x2F;&#x2F; 5. iconfont自定义图标 （链接放错了，以后补上，线删掉了）&#x2F;&#x2F; 6. 函数式编程 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;function-production&#x2F;&#x2F; 7. 换肤 https:&#x2F;&#x2F;www.zoo.team&#x2F;article&#x2F;theme-scss&#x2F;&#x2F; 8.[x] vscode setting sync 另一台电脑配置无法同步到本电脑&#x2F;&#x2F; 9.[x]item2本机重新配置&#x2F;&#x2F; 10.[x]vscode 代码片段在md上失效了&#x2F;&#x2F; 11.[x]typescript 工具类型源码&#x2F;&#x2F; 12. react源码&#x2F;&#x2F; 13. ocr桌面端工具 可以借鉴：想使用 tauri 搞，没遇到好的截屏&#x2F;&#x2F;                     1. https:&#x2F;&#x2F;github.com&#x2F;wulkano&#x2F;Kap  react + Electron开发&#x2F;&#x2F;                     2. vscode插件 ImageToText&#x2F;&#x2F; 14.react源码 debugger https:&#x2F;&#x2F;blog.csdn.net&#x2F;lin_fightin&#x2F;article&#x2F;details&#x2F;125136985?spm&#x3D;1001.2014.3001.5502&#x2F;&#x2F; 15. 如何让一个知识点分析图动起来？&#x2F;&#x2F; 16. paste code to snippets 可以进一步优化</code></pre><p>未完成的事项：<br><img src="http://t-blog-images.aijs.top/img/20220610103503.webp"></p><p><a href="https://github.com/pipipi-pikachu/PPTist">ppt</a></p><h2 id="好的博客"><a href="#好的博客" class="headerlink" title="好的博客"></a>好的博客</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 1.JerryWang_汪子熙  https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;99b8712e8850</code></pre><h2 id="其他记录-未整理"><a href="#其他记录-未整理" class="headerlink" title="其他记录 未整理"></a>其他记录 未整理</h2><p><a href="https://juejin.cn/post/7107189225509879838">ahooks 中那些控制“时机”的hook都是怎么实现的？</a></p>]]></content>
      
      
      <categories>
          
          <category> Todo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题汇总</title>
      <link href="//post/2022-06-16interview.html"/>
      <url>//post/2022-06-16interview.html</url>
      
        <content type="html"><![CDATA[<img src="https://img0.baidu.com/it/u=4204937089,859074527&fm=253&fmt=auto&app=138&f=JPEG?w=255&h=255" /><p><a href="https://www.nowcoder.com/discuss/763567" target="_blank" >小红书前端面经</a></p><p><a href="https://juejin.cn/post/7013953652578582558?share_token=ad9faad3-d177-4d34-9228-086d1d192112" target="_blank" >前端两年经验，历时一个月的面经和总结</a></p><h2 id="HTTP-与-TCP"><a href="#HTTP-与-TCP" class="headerlink" title="HTTP 与 TCP"></a>HTTP 与 TCP</h2><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117303320" target="_blank" >HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 对 HTTP 的改进</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117248731?spm=1001.2014.3001.5502" target="_blank" >TCP 三次握手</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117251247?spm=1001.2014.3001.5502" target="_blank" >TCP 四次挥手</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117257895?spm=1001.2014.3001.5502" target="_blank" >TCP 重传机制</a></p><p><a href="https://blog.csdn.net/SuNew_bee/article/details/117263730?spm=1001.2014.3001.5502" target="_blank" >流量控制</a></p><p><a href="https://www.likecs.com/show-204397172.html" target="_blank" >HTTP 请求和 TCP 链接的对应关系</a></p><p><a href="https://blog.csdn.net/sinat_41696687/article/details/123458338" target="_blank" >彻底搞懂进程与线程之间的联系</a></p><p><a href="https://zhuanlan.zhihu.com/p/420055986" target="_blank" >TLS&#x2F;SSL</a></p><p><a href="https://juejin.cn/post/6871060072936505352" target="_blank" >TLS&#x2F;SSL</a></p><p><a href="https://baijiahao.baidu.com/s?id=1633945802472340217&wfr=spider&for=pc" target="_blank" >CDN</a></p><h2 id="身份信息"><a href="#身份信息" class="headerlink" title="身份信息"></a>身份信息</h2><p><a href="https://zhuanlan.zhihu.com/p/482474619" target="_blank" >JWT 史上最全面试题(大厂常问)</a></p><p><a href="https://zhuanlan.zhihu.com/p/66037342" target="_blank" >单站点登录</a></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><a href="https://blog.csdn.net/Dax1_/article/details/123185260" target="_blank" >总结 ES6 中 Map 和 Set 的特点与比较</a></p><p><a href="https://www.itheima.com/news/20201110/183621.html" target="_blank" >从 async&#x2F;await 面试题看宏观任务和微观任务</a></p><p><a href="https://www.jianshu.com/p/844e293d90a7" target="_blank" >箭头函数和普通函数的区别</a></p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p><a href="http://t.zoukankan.com/Zzbj-p-13923489.html" target="_blank" > 强缓存、协商缓存发生在8中的哪些阶段</a></p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p><a href="https://www.jianshu.com/p/274a9b3200b4" target="_blank" >BFC与清除浮动</a><br>根节点、浮动、定位[]、display[相关]、表格、网格、多列，总之是把一些子元素圈起来形成封闭的盒子，践行BFC的原则[独立、对外不影响（不重叠）]</p><p><a href="https://blog.csdn.net/NCZB007/article/details/108440570" target="_blank" >.clearfix::after(清除浮动)中各个属性及值详细解说</a></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://www.nowcoder.com/exam/oj?tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295" target="_blank" >刷算法</a></p><h2 id="稳操胜券"><a href="#稳操胜券" class="headerlink" title="稳操胜券"></a>稳操胜券</h2><p><a href="http://dljz.nicethemes.cn/news/show-13202.html" target="_blank" >看完这篇文章保你面试稳操胜券 ——（必考题）javaScript 篇</a></p><p><a href="https://copyfuture.com/blogs-details/20211119150923474f" target="_blank" >看完这篇文章保你面试稳操胜券——基础篇（html&#x2F;css)</a></p><p><a href="https://www.wangt.cc/2021/11/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E4%BF%9D%E4%BD%A0%E9%9D%A2%E8%AF%95%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8-vue%E7%AF%87/" target="_blank" >看完这篇文章保你面试稳操胜券-vue 篇</a></p><p><a href="https://copyfuture.com/blogs-details/20211118131747765L" target="_blank" >读完这篇保你面试稳操胜券——前端面试题“骨灰级”总结<br></a></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p><a href="https://zhuanlan.zhihu.com/p/472733451" target="_blank" >Webpack | TreeShaking 工作原理</a></p><p><a href="https://juejin.cn/post/6844903924806189070" target="_blank" >Webpack优化——将你的构建效率提速翻倍</a></p><p><a href="https://juejin.cn/post/6844903685407916039" target="_blank" >Webpack揭秘——走向高阶前端的必经之路</a></p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><a href="https://juejin.cn/post/6844903655330562062" target="_blank" >网站性能优化实战——从12.67s到1.06s的故事</a></p><h2 id="好博客"><a href="#好博客" class="headerlink" title="好博客"></a>好博客</h2><p><a href="https://blog.csdn.net/JHXL_?type=blog" target="_blank" >几何心凉</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http错误信息</title>
      <link href="//post/2022-06-15http.html"/>
      <url>//post/2022-06-15http.html</url>
      
        <content type="html"><![CDATA[<h2 id="http-错误信息"><a href="#http-错误信息" class="headerlink" title="http 错误信息"></a>http 错误信息</h2><pre class="line-numbers language-none"><code class="language-none">Request URL: http:&#x2F;&#x2F;localhost:8888&#x2F;api&#x2F;redline&#x2F;content_management&#x2F;api&#x2F;kbs&#x2F;search&#x2F;contentListRequest Method: POSTStatus Code: 403 ForbiddenRemote Address: [::1]:8888Referrer Policy: strict-origin-when-cross-origin</code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;code&quot;: &quot;102&quot;,  &quot;message&quot;: &quot;ACL not allowed!&quot;,  &quot;rs&quot;: &#123;    &quot;possessionApplyUrl&quot;: &quot;https:&#x2F;&#x2F;acl.fast-inside.xxxxxx:7799&#x2F;#&#x2F;dataPermission&#x2F;roleApplication?projectCode&#x3D;content-management&amp;resourceCode&#x3D;POST:&#x2F;api&#x2F;kbs&#x2F;search&#x2F;contentList&quot;,    &quot;resourceName&quot;: &quot;api_kbs_search_contentList&quot;  &#125;,  &quot;failure&quot;: true,  &quot;success&quot;: false&#125;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">return fetch(API_URL, options)  .then(checkStatus)  .then(parseJSON)  .then((result) &#x3D;&gt; &#123;    const &#123; success &#125; &#x3D; result;    if (!success &amp;&amp; !&#x2F;\&#x2F;api\&#x2F;jira&#x2F;.test(API_URL)) &#123;      return Promise.reject(result);    &#125;    return result;  &#125;)  .catch((e) &#x3D;&gt; &#123;    console.log(&#96;error API_URL :::$&#123;url&#125; $&#123;API_URL&#125;&#96;);    logger.info(&#96;API_URL :::$&#123;url&#125; $&#123;API_URL&#125;&#96;);    logger.info(&#96;Error ::: $&#123;e&#125;&#96;);    &#x2F;&#x2F; 会走到这里，这里只能获取到403相关信息，获取不到响应的内容  &#125;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pinia源码</title>
      <link href="//post/2022-06-14vue-pinia.html"/>
      <url>//post/2022-06-14vue-pinia.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>了解了 playground，现在我们来看看 pinia 源码，那些 api 和方法。这么用做了什么事情</p><p><code>this.$patch</code><a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/stores/counter.ts#L49" target="_blank" >playgound</a></p><p><code>defineStore</code></p><ul><li>第一个参数是唯一字符串，用来标识 store，第二个参数是一个函数，返回一个 store 对象 <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/stores/nasa-pod.ts#L6" target="_blank" >playground</a></li><li>第一个参数直接是配置项 <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/stores/jokesUsePromised.ts#L6" target="_blank" >playgound</a></li></ul><p>组件中直接通过<code>useXXStore获取store</code> <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/views/NasaPOD.vue#L52" target="_blank" >playground</a></p><p><code>state</code>怎么就是个函数，而且这个函数可以让我们自定义 store 的初始值<br><code>$dispose</code> <a href="https://github.com/vuejs/pinia/blob/2eb123d8114ceb4fad46ac019844a1967d9a9135/packages/playground/src/views/NasaPOD.vue#L49" target="_blank" >playgound</a></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">onUnmounted(() &#x3D;&gt; &#123;  userStore.$dispose();  cartStore.$dispose();  counterStore.$dispose();&#125;);</code></pre><p><code>import &#123; storeToRefs &#125; from &#39;pinia&#39;</code></p><p>以及 playground 没没有用到的 api</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const partialStore &#x3D; &#123;  _p: pinia,  &#x2F;&#x2F; _s: scope,  $id,  $onAction: addSubscription.bind(null, actionSubscriptions),  $patch,  $reset,  $subscribe,  $dispose,&#125; as _StoreWithState&lt;Id, S, G, A&gt;;const store: Store&lt;Id, S, G, A&gt; &#x3D; reactive(partialStore); &#x2F;&#x2F; 简化了，不考虑中间任何细节pinia._s.set($id, store);</code></pre><ul><li>$reset:该api是$patch的语法糖，只不过传递的参数是初始的state函数的执行结果，源码中<code>const newState = state? state() : &#123;&#125;</code></li><li>$patch：patch就是一次递归对value覆盖的过程</li><li>$subscribe： 有点类似观察者，当调用subscribe时，会将当前的状态信息保存到subscriptions</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><a href="https://www.jianshu.com/p/2acc2d043d35" target="_blank" >pinia源码解读–实现流程</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/2acc2d043d35" target="_blank" >pinia 源码解读–实现流程</a><br><a href="https://github.com/vuejs/pinia" target="_blank" >pinia</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia中的vue-demi源码</title>
      <link href="//post/2022-06-15vue-demi.html"/>
      <url>//post/2022-06-15vue-demi.html</url>
      
        <content type="html"><![CDATA[<h2 id="pinia-中的-vue-demi"><a href="#pinia-中的-vue-demi" class="headerlink" title="pinia 中的 vue-demi"></a>pinia 中的 vue-demi</h2><p>Vue Demi 是一个让你可以开发同时支持 Vue2 和 3 的通用的 Vue 库的开发工具，而无需担心用户安装的版本。</p><p>当用户要创建一个 Vue 插件&#x2F;库时，只需将 vue-demi 安装为依赖项并将其导入，然后像之前一样发布你的插件&#x2F;库，用户的软件包就会变得通用。</p><p>Vue Demi 使用了 NPM 钩子 postinstall。当用户安装所有包后，脚本将开始检查已安装的 Vue 版本，并根据 Vue 版本返回对应的代码。在使用 Vue 2 时，如果没有安装@vue&#x2F;composition-api，它也会自动安装.</p><p><strong>以前</strong></p><p>以前，要创建支持两个目标版本的 Vue 库，我们会使用不同的分支来分离对每个版本的支持。对于现有库来说，这是一个很好的方法，因为它们的代码库通常更稳定。<br>缺点是，你需要维护两个代码库，这让你的工作量翻倍。对于想要支持 Vue 的两个目标版本的新 Vue 库来说，我不推荐这种方法。实施两次功能请求和错误修复根本就不理想。</p><p><strong>现在</strong></p><p>这就是 Vue Demi 的用武之地。Vue Demi 通过为两个目标版本提供通用支持来解决这个问题，这意味着您只需构建一次即可获得两个目标版本的所有优点，从而获得两全其美的优势。</p><h2 id="核心代码目录"><a href="#核心代码目录" class="headerlink" title="核心代码目录"></a>核心代码目录</h2><pre class="line-numbers language-none"><code class="language-none">├── lib│   ├── index.cjs│   ├── index.d.ts│   ├── index.iife.js│   ├── index.mjs│   ├── v2│   │   ├── index.cjs│   │   ├── index.d.ts│   │   └── index.mjs│   ├── v2.7│   │   ├── index.cjs│   │   ├── index.d.ts│   │   └── index.mjs│   └── v3│       ├── index.cjs│       ├── index.d.ts│       └── index.mjs├── package.json└── scripts    ├── postinstall.js    ├── switch-cli.js    └── utils.js</code></pre><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p><strong>package.json</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;vue-demi&quot;,  &quot;version&quot;: &quot;0.13.1&quot;,  &quot;scripts&quot;: &#123;    &quot;postinstall&quot;: &quot;node .&#x2F;scripts&#x2F;postinstall.js&quot;, &#x2F;&#x2F; 钩子npm install结束后会执行    &quot;release&quot;: &quot;npx bumpp --tag --commit --push &amp;&amp; npm publish&quot;  &#125;,  &quot;peerDependencies&quot;: &#123;    &quot;@vue&#x2F;composition-api&quot;: &quot;^1.0.0-rc.1&quot;,    &quot;vue&quot;: &quot;^3.0.0-0 || ^2.6.0&quot;  &#125;,  &quot;peerDependenciesMeta&quot;: &#123;    &quot;@vue&#x2F;composition-api&quot;: &#123;      &quot;optional&quot;: true    &#125;  &#125;&#125;</code></pre><p><strong>scripts&#x2F;postinstall.js</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const &#123; switchVersion, loadModule &#125; &#x3D; require(&quot;.&#x2F;utils&quot;);const Vue &#x3D; loadModule(&quot;vue&quot;); &#x2F;&#x2F; 加载vue, 通过Vue.version获取版本if (!Vue || typeof Vue.version !&#x3D;&#x3D; &quot;string&quot;) &#123;  console.warn(    &#39;[vue-demi] Vue is not found. Please run &quot;npm install vue&quot; to install.&#39;  );&#125; else if (Vue.version.startsWith(&quot;2.7.&quot;)) &#123;  switchVersion(2.7); &#x2F;&#x2F; 切换到2.7版本，拷贝内容到lib&#x2F;v2.7目录&#125; else if (Vue.version.startsWith(&quot;2.&quot;)) &#123;  switchVersion(2); &#x2F;&#x2F; 切换到2.7版本，拷贝内容到lib&#x2F;v2目录，并执行安装@vue&#x2F;composition-api，更新相关内容,执行v2api更新&#125; else if (Vue.version.startsWith(&quot;3.&quot;)) &#123;  &#x2F;&#x2F; 切换到3.0版本，拷贝内容到lib&#x2F;v3目录  switchVersion(3);&#125; else &#123;  console.warn(&#96;[vue-demi] Vue version v$&#123;Vue.version&#125; is not suppported.&#96;);&#125;</code></pre><p><strong>loadModule</strong>与<strong>switchVersion</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const fs &#x3D; require(&quot;fs&quot;);const path &#x3D; require(&quot;path&quot;);const dir &#x3D; path.resolve(__dirname, &quot;..&quot;, &quot;lib&quot;);&#x2F;&#x2F; loadModulefunction loadModule(name) &#123;  try &#123;    return require(name);  &#125; catch (e) &#123;    return undefined;  &#125;&#125;function copy(name, version, vue) &#123;  vue &#x3D; vue || &quot;vue&quot;;  const src &#x3D; path.join(dir, &#96;v$&#123;version&#125;&#96;, name);  const dest &#x3D; path.join(dir, name);  let content &#x3D; fs.readFileSync(src, &quot;utf-8&quot;);  content &#x3D; content.replace(&#x2F;&#39;vue&#39;&#x2F;g, &#96;&#39;$&#123;vue&#125;&#39;&#96;);  &#x2F;&#x2F; unlink for pnpm, #92  try &#123;    fs.unlinkSync(dest); &#x2F;&#x2F; 删除旧的文件  &#125; catch (error) &#123;&#125;  &#x2F;&#x2F; 写入新的文件  fs.writeFileSync(dest, content, &quot;utf-8&quot;);&#125;&#x2F;&#x2F; 更新vue2apifunction updateVue2API() &#123;  const ignoreList &#x3D; [&quot;version&quot;, &quot;default&quot;];  const VCA &#x3D; loadModule(&quot;@vue&#x2F;composition-api&quot;);  if (!VCA) &#123;    console.warn(      &#39;[vue-demi] Composition API plugin is not found. Please run &quot;npm install @vue&#x2F;composition-api&quot; to install.&#39;    );    return;  &#125;  const exports &#x3D; Object.keys(VCA).filter((i) &#x3D;&gt; !ignoreList.includes(i));  const esmPath &#x3D; path.join(dir, &quot;index.mjs&quot;);  let content &#x3D; fs.readFileSync(esmPath, &quot;utf-8&quot;);  &#x2F;&#x2F;源码仓库结果 @link https:&#x2F;&#x2F;github.com&#x2F;vueuse&#x2F;vue-demi&#x2F;blob&#x2F;813a8dadf3a8f12b3b4a1369ff2b8da6c813d97e&#x2F;lib&#x2F;v2&#x2F;index.mjs#L2  content &#x3D; content.replace(    &#x2F;\&#x2F;\*\*VCA-EXPORTS\*\*\&#x2F;[\s\S]+\&#x2F;\*\*VCA-EXPORTS\*\*\&#x2F;&#x2F;m,    &#96;&#x2F;**VCA-EXPORTS**&#x2F;export &#123; $&#123;exports.join(      &quot;, &quot;    )&#125; &#125; from &#39;@vue&#x2F;composition-api&#x2F;dist&#x2F;vue-composition-api.mjs&#39;&#x2F;**VCA-EXPORTS**&#x2F;&#96;  );  fs.writeFileSync(esmPath, content, &quot;utf-8&quot;);&#125;&#x2F;&#x2F; switchVersion 拷贝入口到对应的版本目录function switchVersion(version, vue) &#123;  copy(&quot;index.cjs&quot;, version, vue);  copy(&quot;index.mjs&quot;, version, vue);  copy(&quot;index.d.ts&quot;, version, vue);  &#x2F;&#x2F; 如果是v2还需要更新api  if (version &#x3D;&#x3D;&#x3D; 2) updateVue2API();&#125;module.exports.loadModule &#x3D; loadModule;module.exports.switchVersion &#x3D; switchVersion;</code></pre><h2 id="再来看下暴露的-api"><a href="#再来看下暴露的-api" class="headerlink" title="再来看下暴露的 api"></a>再来看下暴露的 api</h2><p><strong>pinia 中源码引用</strong></p><p><strong>pinia&#x2F;packages&#x2F;pinia&#x2F;src&#x2F;storeToRefs.ts</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123;  isReactive,  isRef,  isVue2,  toRaw,  toRef,  ToRefs,  toRefs,&#125; from &quot;vue-demi&quot;;</code></pre><p><strong>pinia&#x2F;packages&#x2F;pinia&#x2F;src&#x2F;rootStore.ts</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123;  App,  EffectScope,  getCurrentInstance,  inject,  InjectionKey,  Ref,&#125; from &quot;vue-demi&quot;;</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; @link https:&#x2F;&#x2F;github.com&#x2F;vueuse&#x2F;vue-demi&#x2F;blob&#x2F;813a8dadf3a8f12b3b4a1369ff2b8da6c813d97e&#x2F;lib&#x2F;index.mjs#L27export * from &quot;vue&quot;;&#x2F;&#x2F; 除了暴露版本vue-demi产生的api还将vue的api也暴露了出来，在开发第三方包的时候，可以按照不同的版本，调用不同的apiexport &#123; Vue, Vue2, isVue2, isVue3, install &#125;;</code></pre><p>由上面的源码<code>export * from &quot;vue&quot;;</code>,我们可以从vue-demi中获取所有的api，这也是pinia中频繁使用<code>vue-demi</code>，却不见<code>vue</code>的原因</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_40021015/article/details/123658502" target="_blank" >vue Demi 同时支持 vue2 和 vue3</a><br><a href="https://madewith.cn/502" target="_blank" >https://madewith.cn/502</a><br><a href="https://github.com/vueuse/vue-demi" target="_blank" >vue-demi</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia源码分析 playground</title>
      <link href="//post/2022-06-13vue-pinia.html"/>
      <url>//post/2022-06-13vue-pinia.html</url>
      
        <content type="html"><![CDATA[<h2 id="playground-运行"><a href="#playground-运行" class="headerlink" title="playground 运行"></a>playground 运行</h2><p>是一个标准的 vue 项目</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;scripts&quot;: &#123;  &quot;release&quot;: &quot;node scripts&#x2F;release.mjs&quot;,  &quot;size&quot;: &quot;pnpm run -r size&quot;,  &quot;build&quot;: &quot;pnpm run -r build&quot;,  &quot;docs:build&quot;: &quot;pnpm run docs:api &amp;&amp; pnpm run -r docs:build --filter .&#x2F;packages&#x2F;docs&quot;,  &quot;play&quot;: &quot;pnpm run -r play&quot;,  &quot;build:dts&quot;: &quot;pnpm run -r build:dts --parallel&quot;,  &quot;lint&quot;: &quot;prettier -c --parser typescript \&quot;packages&#x2F;*&#x2F;&#123;src,__tests__,e2e&#125;&#x2F;**&#x2F;*.[jt]s?(x)\&quot;&quot;,  &quot;lint:fix&quot;: &quot;pnpm run lint --write&quot;,  &quot;test&quot;: &quot;pnpm run test:types &amp;&amp; pnpm run test:jest &amp;&amp; pnpm run -r test &amp;&amp; pnpm run build &amp;&amp; pnpm run build:dts &amp;&amp; pnpm test:dts&quot;,  &quot;test:jest&quot;: &quot;jest --coverage&quot;,  &quot;test:types&quot;: &quot;tsc --build .&#x2F;tsconfig.json&quot;,  &quot;test:dts&quot;: &quot;pnpm run -r test:dts&quot;,  &quot;docs:api&quot;: &quot;pnpm run -r docs:api --filter .&#x2F;packages&#x2F;docs&quot;&#125;</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>注意 node 版本 <code>The engine &quot;node&quot; is incompatible with this module. Expected version &quot;^12.20.0 || ^14.13.1 || &gt;=16.0.0&quot;.</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">👑 ~&#x2F;Desktop&#x2F;pinia git:(v2) $ yarn yarn install v1.4.0     node&#x2F;14.17.4   ο node&#x2F;15.14.0     node&#x2F;16.13.1 Use up&#x2F;down arrow keys to select a version, return key to install, d to delete, q to quit info No lockfile found. [1&#x2F;4] 🔍  Resolving packages... warning conventional-changelog-cli &gt; tempfile &gt; uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https:&#x2F;&#x2F;v8.dev&#x2F;blog&#x2F;math-random for details. warning workspace-aggregator-d3702d10-5118-458d-9b17-8c5b340f31d0 &gt; @pinia&#x2F;nuxt &gt; @nuxt&#x2F;types &gt; @types&#x2F;autoprefixer &gt; @types&#x2F;browserslist@4.15.0: This is a stub types definition. browserslist provides its own type definitions, so you do not need this installed. warning workspace-aggregator-d3702d10-5118-458d-9b17-8c5b340f31d0 &gt; @pinia&#x2F;nuxt &gt; @nuxt&#x2F;types &gt; @types&#x2F;webpack &gt; @types&#x2F;anymatch@3.0.0: This is a stub types definition. anymatch provides its own type definitions, so you do not need this installed. [2&#x2F;4] 🚚  Fetching packages... error execa@6.1.0: The engine &quot;node&quot; is incompatible with this module. Expected version &quot;^12.20.0 || ^14.13.1 || &gt;&#x3D;16.0.0&quot;. error An unexpected error occurred: &quot;Found incompatible module&quot;. info If you think this is a bug, please open a bug report with the information provided in &quot;&#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;pinia&#x2F;yarn-error.log&quot;. info Visit https:&#x2F;&#x2F;yarnpkg.com&#x2F;en&#x2F;docs&#x2F;cli&#x2F;install for documentation about this command. 👑 ~&#x2F;Desktop&#x2F;pinia git:(v2) $ sudo n Password:   installed : v16.13.1 (with npm 8.1.2)</code></pre></p></div><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 全局安装pnpmnpm install -g pnpm# 根目录yarn</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn build &amp;&amp; yarn play</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>如果不运行 <code>yarn build</code>,你将看到如下报错信息，原因是<code>playgound/vite.config.ts</code>，内部写了<code>copyPiniaPlugin</code></p><p>[plugin:vite:import-analysis] Failed to resolve entry for package “pinia”. The package may have incorrect main&#x2F;module&#x2F;exports specified in its package.json: Failed to resolve entry for package “pinia”. The package may have incorrect main&#x2F;module&#x2F;exports specified in its package.json</div><h2 id="playgound-x2F-vite-config-ts"><a href="#playgound-x2F-vite-config-ts" class="headerlink" title="playgound&#x2F;vite.config.ts"></a>playgound&#x2F;vite.config.ts</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineConfig, Plugin &#125; from &quot;vite&quot;;import vue from &quot;@vitejs&#x2F;plugin-vue&quot;;import &#123; promises as fs &#125; from &quot;fs&quot;;import path from &quot;path&quot;;&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;export default defineConfig(&#123;  plugins: [vue(), copyPiniaPlugin()],  define: &#123;    &#x2F;&#x2F; __DEV__: &#39;true&#39;,    &#x2F;&#x2F; __BROWSER__: &#39;true&#39;,    __TEST__: &quot;false&quot;,  &#125;,  resolve: &#123;    &#x2F;&#x2F; alias: &#123;    &#x2F;&#x2F;   &#39;@vue&#x2F;composition-api&#39;: &#39;vue-demi&#39;,    &#x2F;&#x2F; &#125;,    dedupe: [&quot;vue-demi&quot;, &quot;vue&quot;],  &#125;,  optimizeDeps: &#123;    &#x2F;&#x2F; pinia项排除    exclude: [&quot;vue-demi&quot;, &quot;@vueuse&#x2F;shared&quot;, &quot;@vueuse&#x2F;core&quot;, &quot;pinia&quot;],  &#125;,&#125;);&#x2F;&#x2F; 拷贝pinia到项目中，避免编译function copyPiniaPlugin(): Plugin &#123;  return &#123;    name: &quot;copy-pinia&quot;,    async generateBundle() &#123;      const filePath &#x3D; path.resolve(__dirname, &quot;..&#x2F;pinia&#x2F;dist&#x2F;pinia.mjs&quot;); &#x2F;&#x2F; 注意这里，不执行 yarn build 这里是没有数据的，yarn play会报错      &#x2F;&#x2F; throws if file doesn&#39;t exist      await fs.access(filePath);      this.emitFile(&#123;        type: &quot;asset&quot;,        fileName: &quot;pinia.mjs&quot;,        source: await fs.readFile(filePath, &quot;utf-8&quot;),      &#125;);    &#125;,  &#125;;&#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220613184319.webp"></p><h2 id="playground-x2F-index-html"><a href="#playground-x2F-index-html" class="headerlink" title="playground&#x2F;index.html"></a>playground&#x2F;index.html</h2><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;!-- html解析规则--&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;    &lt;!-- 关键字符集 --&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;    &lt;!-- 方便手机端调整分辨率 --&gt;    &lt;title&gt;🍍 Pinia playground&lt;&#x2F;title&gt;    &lt;link      rel&#x3D;&quot;stylesheet&quot;      href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;@exampledev&#x2F;new.css@1&#x2F;new.min.css&quot;    &#x2F;&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;fonts.xz.style&#x2F;serve&#x2F;inter.css&quot; &#x2F;&gt;    &lt;!-- 一开始以为是 首屏优化，加载动画 运行后发现，并不是，仅仅是样式而已，代码中使用v-if 或v-else-if渲染加载动画--&gt;    &lt;!--       JokesPromised.vue       NasaPOD.vue       NasaPODwrc.vue     --&gt;    &lt;style&gt;      @keyframes spinner &#123;        to &#123;          transform: rotate(360deg);        &#125;      &#125;      .spinner:before &#123;        content: &quot;&quot;;        box-sizing: border-box;        position: absolute;        top: 50%;        left: 50%;        width: 30px;        height: 30px;        margin-top: -15px;        margin-left: -15px;        border-radius: 50%;        border: 1px solid #ccc;        border-top-color: #07d;        animation: spinner 0.6s linear infinite;      &#125;    &lt;&#x2F;style&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;!-- vue根节点 --&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;    &lt;!-- 模块加载 --&gt;    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.ts&quot;&gt;&lt;&#x2F;script&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h2 id="api-目录"><a href="#api-目录" class="headerlink" title="api 目录"></a>api 目录</h2><p>一些小练习，demo 之类的东西，我有点不明白的是，<code>pinia/packages/playground/src/api</code>下使用了<code>mande</code>,不能直接用<code>fetch</code>吗?</p><ul><li><code>mande</code><strong>Requires fetch support.</strong></li><li>Weekly Downloads 530 😓</li><li>Unpacked Size 47.3 kB<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为了炫技而写的，所以我没有用<code>fetch</code>，而是用了<code>mande</code>。——此处 AI 自动生成</p></blockquote></li></ul><h2 id="composables-目录"><a href="#composables-目录" class="headerlink" title="composables 目录"></a>composables 目录</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; useCachedRequest.ts&#x2F;&#x2F; pinia&#x2F;packages&#x2F;playground&#x2F;src&#x2F;composables&#x2F;useCachedRequest.tsexport function useCachedRequest&lt;T, U&gt;(  keySource: Ref&lt;U&gt;,  getter: (key: U) &#x3D;&gt; Promise&lt;T&gt; &#x2F;&#x2F; 这应该是一个接口) &#123;  const data &#x3D; ref&lt;T&gt;(); &#x2F;&#x2F; 存数据  const isLoading &#x3D; ref(false); &#x2F;&#x2F; 加载动画  const isReady &#x3D; ref(false); &#x2F;&#x2F; 是否已加载数据  const error &#x3D; ref&lt;Error | undefined&gt;(); &#x2F;&#x2F; 有没有出错  const cache &#x3D; new Map&lt;U, T&gt;(); &#x2F;&#x2F; 使用map实现缓存  onScopeDispose(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 清理缓存    cache.clear();  &#125;);  watchEffect(async () &#x3D;&gt; &#123;    const key &#x3D; unref(keySource);    isReady.value &#x3D; false; &#x2F;&#x2F; 是不是已拿到数据    isLoading.value &#x3D; true; &#x2F;&#x2F; 加载动画    if (cache.has(key)) &#123;      data.value &#x3D; cache.get(key)!;      isReady.value &#x3D; true;    &#125;    getter(key)      .then((newData) &#x3D;&gt; &#123;        cache.set(key, newData);        data.value &#x3D; newData;        isReady.value &#x3D; true;      &#125;)      .catch((err) &#x3D;&gt; &#123;        error.value &#x3D; err;      &#125;)      .finally(() &#x3D;&gt; &#123;        isLoading.value &#x3D; false;      &#125;);  &#125;);  return &#123; data, error, isLoading, isReady &#125;; &#x2F;&#x2F; 最后将这些值返回&#125;</code></pre><hr/><h2 style="text-aligin:center">小插曲</h2><p><strong>onScopeDispose</strong></p><p>这个 api 没见过，搜下其他人是怎么理解的</p><p>在 vue3.2 中新增了一个属性 EffectScope，官方文档的解释比较简单，只说是一个高级属性，并没有具体的示例。</p><p>antfu 大神的 vueuse 框架源码，里面大量使用 EffectScope，所以研究了一下这个属性的使用方法。</p><h2 id="什么是-EffectScope"><a href="#什么是-EffectScope" class="headerlink" title="什么是 EffectScope?"></a>什么是 EffectScope?</h2><p>下面是官方文档解释，感觉有点敷衍</p><p>Effect scope is an advanced API primarily intended for library authors. For details on how to leverage this API, please consult its corresponding RFC(opens new window).<br>这个 api 是高级的，主要用于库的开发者。更多详情，请参考其对应的 RFC(新窗口打开)。</p><p>RFC 关于 EffectScopeApi 的解释</p><p>在 Vue 的 setup 中，响应会在开始初始化的时候被收集，在实例被卸载的时候，响应就会自动的被取消追踪了，这时一个很方便的特性。但是，当我们在组件外使用或者编写一个独立的包时，这会变得非常麻烦。当在单独的文件中，我们该<strong>如何停止 computed &amp; watch 的响应式依赖呢？</strong></p><p>实际上 EffectScope 按我的理解就是副作用生效的作用域。</p><p>vue3 对响应式的监听是通过 effect 实现的，当我们的组件销毁的时候 vue 会自动取消该组件的 effect。</p><p>那么如果我们想要自己控制 effect 生效与否呢？ 比如我只想在莫种特定情况下才监听摸个 ref，其他情况下不想监听该怎么做？</p><p>vue3.2 之前</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;（vue-RFC示例代码）const disposables &#x3D; [];const counter &#x3D; ref(0);const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);disposables.push(() &#x3D;&gt; stop(doubled.effect));const stopWatch1 &#x3D; watchEffect(() &#x3D;&gt; &#123;  console.log(&#96;counter: $&#123;counter.value&#125;&#96;);&#125;);disposables.push(stopWatch1);const stopWatch2 &#x3D; watch(doubled, () &#x3D;&gt; &#123;  console.log(doubled.value);&#125;);disposables.push(stopWatch2);</code></pre><h2 id="EffectScope-如何实现"><a href="#EffectScope-如何实现" class="headerlink" title="EffectScope 如何实现"></a>EffectScope 如何实现</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; effect, computed, watch, watchEffect created inside the scope will be collectedconst scope &#x3D; effectScope();scope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  watch(doubled, () &#x3D;&gt; console.log(doubled.value));  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; to dispose all effects in the scopescope.stop();</code></pre><p>示例;</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const scope &#x3D; effectScope();let counter &#x3D; ref(0);setInterval(() &#x3D;&gt; &#123;  counter.value++;&#125;, 1000);scope.run(() &#x3D;&gt; &#123;  watchEffect(() &#x3D;&gt; console.log(&#96;counter: $&#123;counter.value&#125;&#96;));&#125;);&#x2F;*log:counter: 0counter: 1counter: 2counter: 3counter: 4counter: 5*&#x2F;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const scope &#x3D; effectScope();let counter &#x3D; ref(0);setInterval(() &#x3D;&gt; &#123;  counter.value++;&#125;, 1000);scope.run(() &#x3D;&gt; &#123;  watchEffect(() &#x3D;&gt; console.log(&#96;counter: $&#123;counter.value&#125;&#96;));&#125;);scope.stop();&#x2F;*log:counter: 0*&#x2F;</code></pre><p>基本使用<br>新建一个 scope:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const scope &#x3D; effectScope();</code></pre><p>一个 scope 可以执行一个 run 函数（接受一个函数作为参数，并返回该函数的返回值），并且捕获所有在该函数执行过程中创建的 effect ，包括可以创建 effect 的 API，例如 computed , watch , watchEffect :</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">scope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  watch(doubled, () &#x3D;&gt; console.log(doubled.value));  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; the same scope can run multiple timesscope.run(() &#x3D;&gt; &#123;  watch(counter, () &#x3D;&gt; &#123;    &#x2F;*...*&#x2F;  &#125;);&#125;);</code></pre><p>当调用 scope.stop(), 所有被捕获的 effect 都会被取消，包括 nested Scopes 也会被递归取消</p><h2 id="Nested-Scopes"><a href="#Nested-Scopes" class="headerlink" title="Nested Scopes"></a>Nested Scopes</h2><p>嵌套 scope 也会被他们的父级 scope 收集。并且当父级 scope 销毁的时候，所有的后代 scope 也会被递归销毁。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const scope &#x3D; effectScope();scope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  &#x2F;&#x2F; not need to get the stop handler, it will be collected by the outer scope  effectScope().run(() &#x3D;&gt; &#123;    watch(doubled, () &#x3D;&gt; console.log(doubled.value));  &#125;);  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; dispose all effects, including those in the nested scopesscope.stop();</code></pre><h2 id="Detached-Nested-Scopes"><a href="#Detached-Nested-Scopes" class="headerlink" title="Detached Nested Scopes"></a>Detached Nested Scopes</h2><p>effectScope 接受一个参数可以在分离模式（detached mode）下创建。 detached scope 不会被父级 collect。</p><p>这一特性同时解决了一个 Issues lazy Initialization。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let nestedScope;const parentScope &#x3D; effectScope();parentScope.run(() &#x3D;&gt; &#123;  const doubled &#x3D; computed(() &#x3D;&gt; counter.value * 2);  &#x2F;&#x2F; with the detected flag,  &#x2F;&#x2F; the scope will not be collected and disposed by the outer scope  nestedScope &#x3D; effectScope(true &#x2F;* detached *&#x2F;);  nestedScope.run(() &#x3D;&gt; &#123;    watch(doubled, () &#x3D;&gt; console.log(doubled.value));  &#125;);  watchEffect(() &#x3D;&gt; console.log(&quot;Count: &quot;, doubled.value));&#125;);&#x2F;&#x2F; disposes all effects, but not &#96;nestedScope&#96;parentScope.stop();&#x2F;&#x2F; stop the nested scope only when appropriatenestedScope.stop();</code></pre><p>onScopeDispose<br>全局钩子函数 onScopeDispose 提供了类似于 onUnmounted 的功能，不同的是它工作在 scope 中而不是当前 instance。</p><p>这使得 composable functions 可以通过他们的 scope 清除他们的副作用。</p><p>由于 setup() 默认会为当前 instance 创建一个 scope，所以当没有明确声明一个 scope 的时候，onScopeDispose 等同于 onUnmounted。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; onScopeDispose &#125; from &quot;vue&quot;;const scope &#x3D; effectScope();scope.run(() &#x3D;&gt; &#123;  onScopeDispose(() &#x3D;&gt; &#123;    console.log(&quot;cleaned!&quot;);  &#125;);&#125;);scope.stop(); &#x2F;&#x2F; logs &#39;cleaned!&#39;</code></pre><p>Getting the current Scope</p><p>通过 getCurrentScope() 可以获取当前 scope</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; getCurrentScope &#125; from &quot;vue&quot;;getCurrentScope(); &#x2F;&#x2F; EffectScope | undefined</code></pre><p>实战<br>示例：Shared Composable<br>一些 composables 会设置全局副作用，例如如下的 useMouse() function:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function useMouse() &#123;  const x &#x3D; ref(0);  const y &#x3D; ref(0);  window.addEventListener(&quot;mousemove&quot;, handler);  function handler(e) &#123;    x.value &#x3D; e.x;    y.value &#x3D; e.y;  &#125;  onUnmounted(() &#x3D;&gt; &#123;    window.removeEventListener(&quot;mousemove&quot;, handler);  &#125;);  return &#123; x, y &#125;;&#125;</code></pre><p>如果在多个组件中调用 useMouse () ，则每个组件将附加一个 mouseemove 监听器，并创建自己的 x 和 y refs 副本。我们应该能够通过在多个组件之间共享相同的侦听器集和 refs 来提高效率，但是我们做不到，因为每个 onUnmounted 调用都耦合到一个组件实例。</p><p>我们可以使用分离作用域和 onScopeDispose 来实现这一点, 首先，我们需要用 onScopeDispose 替换 onUnmounted</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">- onUnmounted(() &#x3D;&gt; &#123;* onScopeDispose(() &#x3D;&gt; &#123;  window.removeEventListener(&#39;mousemove&#39;, handler)  &#125;)</code></pre><p>这仍然有效，因为 Vue 组件现在也在作用域内运行其 setup () ，该作用域将在组件卸载时释放。</p><p>然后，我们可以创建一个工具函数来管理父范围订阅:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function createSharedComposable(composable) &#123;  let subscribers &#x3D; 0;  let state, scope;  const dispose &#x3D; () &#x3D;&gt; &#123;    if (scope &amp;&amp; --subscribers &lt;&#x3D; 0) &#123;      scope.stop();      state &#x3D; scope &#x3D; null;    &#125;  &#125;;  &#x2F;&#x2F; 这里只有在第一次运行的时候创建一个 state, 后面所有的组件就不会再创建新的 state，而是共用一个 state  return (...args) &#x3D;&gt; &#123;    subscribers++;    if (!state) &#123;      scope &#x3D; effectScope(true);      state &#x3D; scope.run(() &#x3D;&gt; composable(...args));    &#125;    onScopeDispose(dispose);    return state;  &#125;;&#125;</code></pre><p>现在我们就可以使用这个 shared 版本的 useMouse</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const useSharedMouse &#x3D; createSharedComposable(useMouse);</code></pre><p>通过这个例子，不禁想到，是否可以通过这种模式模拟 vuex 的能力？我们是否可以通过 shared composables 更加灵活的达到全局状态管理的目的呢？</p><p>作者：zifeiyu<br>链接：<a href="https://juejin.cn/post/7019241635942760455">https://juejin.cn/post/7019241635942760455</a></p><p>总结：说了一大堆，大概意思是提供在组件外进行副作用清理的 api，这也是为什么说给库的开发者使用</p><hr/><h2 id="stores-目录，对应-v2-的-vuex"><a href="#stores-目录，对应-v2-的-vuex" class="headerlink" title="stores 目录，对应 v2 的 vuex"></a>stores 目录，对应 v2 的 vuex</h2><p>一个购物车的例子</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; .&#x2F;&#x2F; ├── cart.ts&#x2F;&#x2F; ├── counter.ts&#x2F;&#x2F; ├── counterSetup.ts&#x2F;&#x2F; ├── demo-counter.ts&#x2F;&#x2F; ├── jokes-swrv.ts&#x2F;&#x2F; ├── jokes.ts&#x2F;&#x2F; ├── jokesUsePromised.ts&#x2F;&#x2F; ├── nasa-pod.ts&#x2F;&#x2F; ├── nasa.ts&#x2F;&#x2F; └── user.ts</code></pre><p><strong>user.ts</strong></p><p>定义 useUserStore，id 为‘user’, state 两个字段，<br>actions 1. 登录，调用的是 apiLogin 接口，调用成功后进行数据<code>this.$patch</code>批量更新<br>actions 2. 退出登录</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore &#x3D; defineStore(&quot;user&quot;, &#123;  state: () &#x3D;&gt; (&#123;    name: &quot;Eduardo&quot;,    isAdmin: true,  &#125;),  actions: &#123;    &#x2F;**     * Attempt to login a user     *&#x2F;    async login(user: string, password: string) &#123;      const userData &#x3D; await apiLogin(user, password);      this.$patch(&#123;        name: user,        ...userData,      &#125;);    &#125;,    logout() &#123;      this.$patch(&#123;        name: &quot;&quot;,        isAdmin: false,      &#125;);      &#x2F;&#x2F; we could do other stuff like redirecting the user    &#125;,  &#125;,&#125;);&#x2F;** * Simulate a login 模拟登录 *&#x2F;function apiLogin(a: string, p: string) &#123;  if (a &#x3D;&#x3D;&#x3D; &quot;ed&quot; &amp;&amp; p &#x3D;&#x3D;&#x3D; &quot;ed&quot;) return Promise.resolve(&#123; isAdmin: true &#125;); &#x2F;&#x2F; 管理员  if (p &#x3D;&#x3D;&#x3D; &quot;ed&quot;) return Promise.resolve(&#123; isAdmin: false &#125;); &#x2F;&#x2F; 非管理员  return Promise.reject(new Error(&quot;invalid credentials&quot;)); &#x2F;&#x2F; 游客未认证&#125;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; counter.tsimport &#123; acceptHMRUpdate, defineStore &#125; from &quot;pinia&quot;;const delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t));export const useCounter &#x3D; defineStore(&#123;  id: &quot;counter&quot;,  state: () &#x3D;&gt; (&#123;    n: 2,    incrementedTimes: 0,    decrementedTimes: 0,    numbers: [] as number[],  &#125;),  getters: &#123;    double: (state) &#x3D;&gt; state.n * 2,  &#125;,  actions: &#123;    increment(amount &#x3D; 1) &#123;      if (typeof amount !&#x3D;&#x3D; &quot;number&quot;) &#123;        amount &#x3D; 1;      &#125;      this.incrementedTimes++;      this.n +&#x3D; amount;    &#125;,    changeMe() &#123;      console.log(&quot;change me to test HMR&quot;);    &#125;,    async fail() &#123;      const n &#x3D; this.n;      await delay(1000);      this.numbers.push(n);      await delay(1000);      if (this.n !&#x3D;&#x3D; n) &#123;        throw new Error(&quot;Someone changed n!&quot;);      &#125;      return n;    &#125;,    async decrementToZero(interval: number &#x3D; 300, usePatch &#x3D; true) &#123;      if (this.n &lt;&#x3D; 0) return;      while (this.n &gt; 0) &#123;        if (usePatch) &#123;          this.$patch(&#123;            &#x2F;&#x2F; 这个就比较奇怪了，我严重怀疑这里的(usePatch &#x3D; true 与 usePatch &#x3D; false)数据不一致            n: this.n - 1,            decrementedTimes: this.decrementedTimes + 1,          &#125;);          &#x2F;&#x2F; this.$patch(state &#x3D;&gt; &#123;          &#x2F;&#x2F;   state.n--          &#x2F;&#x2F;   state.decrementedTimes++          &#x2F;&#x2F; &#125;)        &#125; else &#123;          this.n -&#x3D; 1;        &#125;        await delay(interval);      &#125;    &#125;,  &#125;,&#125;);&#x2F;&#x2F; 这个地方没看懂.if (import.meta.hot) &#123;  &#x2F;&#x2F; @link: https:&#x2F;&#x2F;www.jb51.net&#x2F;article&#x2F;244749.htm  &#x2F;&#x2F; import.meta 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象，它包含了这个模块的信息。  &#x2F;&#x2F; Pinia 是 vuex 新替代方案。Pinia 中热更新实现，借助 import.meta。  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot));&#125;</code></pre><p>counterSetup.ts 结合 vue 做了很多操作，最后只返回了一个 state,没有 getters,actions<br>以下为 state 上的方法</p><ul><li>double,</li><li>increment,</li><li>fail,</li><li>changeMe,</li><li>decrementToZero,</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; counterSetupimport &#123; computed, toRefs, reactive &#125; from &quot;vue&quot;;import &#123; acceptHMRUpdate, defineStore &#125; from &quot;pinia&quot;;const delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t));export const useCounter &#x3D; defineStore(&quot;counter-setup&quot;, () &#x3D;&gt; &#123;  const state &#x3D; reactive(&#123;    &#x2F;&#x2F; vue    n: 0,    incrementedTimes: 0,    decrementedTimes: 0,    numbers: [] as number[],  &#125;);  const double &#x3D; computed(() &#x3D;&gt; state.n * 2); &#x2F;&#x2F; vue  function increment(amount &#x3D; 1) &#123;    if (typeof amount !&#x3D;&#x3D; &quot;number&quot;) &#123;      amount &#x3D; 1;    &#125;    state.incrementedTimes++;    state.n +&#x3D; amount;  &#125;  function changeMe() &#123;    console.log(&quot;change me to test HMR&quot;);  &#125;  &#x2F;&#x2F;  async function fail() &#123;    const n &#x3D; state.n;    await delay(1000);    state.numbers.push(n);    await delay(1000);    if (state.n !&#x3D;&#x3D; n) &#123;      throw new Error(&quot;Someone changed n!&quot;);    &#125;    return n;  &#125;  &#x2F;&#x2F; 定时器直到减少到0  async function decrementToZero(interval: number &#x3D; 300) &#123;    if (state.n &lt;&#x3D; 0) return;    while (state.n &gt; 0) &#123;      state.n -&#x3D; 1;      state.decrementedTimes +&#x3D; 1;      await delay(interval);    &#125;  &#125;  return &#123;    ...toRefs(state), &#x2F;&#x2F; vue将 state 转换为 refs， TODO：toRefs这个之后可以看下源码做了怎样的处理    double,    increment,    fail,    changeMe,    decrementToZero,  &#125;;&#125;);if (import.meta.hot) &#123;  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot));&#125;</code></pre><p>demo-counter.ts 只返回一个箭头函数简写的state</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; demo-counter.tsimport &#123; defineStore, acceptHMRUpdate &#125; from &#39;pinia&#39;const delay &#x3D; (t: number) &#x3D;&gt; new Promise((r) &#x3D;&gt; setTimeout(r, t))&#x2F;&#x2F; just to ignore the not used errordelay(0)export const useCounter &#x3D; defineStore(&#39;demo-counter&#39;, &#123;  state: () &#x3D;&gt; (&#123;    n: 0,  &#125;),&#125;)if (import.meta.hot) &#123;  import.meta.hot.accept(acceptHMRUpdate(useCounter, import.meta.hot))&#125;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; jokes-swrv.tsimport &#123; ref, toRaw, watch &#125; from &#39;vue&#39;import &#123; acceptHMRUpdate, defineStore &#125; from &#39;pinia&#39;import &#123; getRandomJoke, Joke &#125; from &#39;..&#x2F;api&#x2F;jokes&#39;import useSWRV from &#39;swrv&#39; &#x2F;&#x2F; @link https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;swrvexport const useJokesSetup &#x3D; defineStore(&#39;jokes-swrv-setup&#39;, () &#x3D;&gt; &#123;  &#x2F;&#x2F; const current &#x3D; ref&lt;null | Joke&gt;(null)  const history &#x3D; ref&lt;Joke[]&gt;([])  &#x2F;&#x2F; useSWRV vue组合式网络请求，之前了解代码&#96;pinia&#x2F;packages&#x2F;playground&#x2F;src&#x2F;api&#96; 中使用了‘mande’，做网络请求，我想这应该是作者为了给开发者提供更多的场景来学习pinia  const &#123; data, error, mutate &#125; &#x3D; useSWRV(&#39;jokes&#39;, getRandomJoke)  &#x2F;&#x2F; 监听data变化  watch(data, (joke) &#x3D;&gt; &#123;    console.log(&#39;changed from within the store&#39;, joke)    if (joke) &#123;      &#x2F;&#x2F; 响应式数据，  history是响应式的，需要用.value来操作      history.value.push(toRaw(joke))    &#125;  &#125;)  return &#123; current: data, error, history, fetchJoke: mutate &#125;&#125;)if (import.meta.hot) &#123;  &#x2F;&#x2F; import.meta.hot.accept(acceptHMRUpdate(useJokes, import.meta.hot))  import.meta.hot.accept(acceptHMRUpdate(useJokesSetup, import.meta.hot))&#125;</code></pre><p> jokes.ts 文件下，写了useJokes 和 useJokesSetup</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; jokes.tsimport &#123; ref, unref &#125; from &#39;vue&#39;import &#123; acceptHMRUpdate, defineStore &#125; from &#39;pinia&#39;import &#123; getRandomJoke, Joke &#125; from &#39;..&#x2F;api&#x2F;jokes&#39;export const useJokes &#x3D; defineStore(&#39;jokes&#39;, &#123;  state: () &#x3D;&gt; (&#123;    current: null as null | Joke,    jokes: [] as Joke[],    &#x2F;&#x2F; hello: true,  &#125;),  actions: &#123;    async fetchJoke() &#123;      if (        this.current &amp;&amp;        &#x2F;&#x2F; if the request below fails, avoid adding it twice        &#x2F;&#x2F; 如果请求失败，就不要添加进历史记录        !this.jokes.includes(this.current)      ) &#123;        this.jokes.push(this.current)      &#125;      &#x2F;&#x2F; NOTE: Avoid patching an object because it&#39;s recursive      &#x2F;&#x2F; 注意：不要更新一个对象，因为它是递归的      &#x2F;&#x2F; this.$patch(&#123; current: await getRandomJoke() &#125;)      this.current &#x3D; await getRandomJoke()    &#125;,  &#125;,&#125;)export const useJokesSetup &#x3D; defineStore(&#39;jokes-setup&#39;, () &#x3D;&gt; &#123;  const current &#x3D; ref&lt;null | Joke&gt;(null)  const history &#x3D; ref&lt;Joke[]&gt;([])  async function fetchJoke() &#123;    const cur &#x3D; unref(current.value)    if (      cur &amp;&amp;      &#x2F;&#x2F; if the request below fails, avoid adding it twice      !history.value.find((joke) &#x3D;&gt; joke.id &#x3D;&#x3D;&#x3D; cur.id)    ) &#123;      history.value.push(cur)    &#125;    current.value &#x3D; await getRandomJoke()    return current.value  &#125;  return &#123; current, history, fetchJoke &#125;&#125;)if (import.meta.hot) &#123;  import.meta.hot.accept(acceptHMRUpdate(useJokes, import.meta.hot))  &#x2F;&#x2F; import.meta.hot.accept(acceptHMRUpdate(useJokesSetup, import.meta.hot))&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript event</title>
      <link href="//post/2022-06-13event.html"/>
      <url>//post/2022-06-13event.html</url>
      
        <content type="html"><![CDATA[<h2 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h2><pre class="line-numbers language-none"><code class="language-none">react_devtools_backend.js:4026 Warning: This synthetic event is reused for performance reasons. If you&#39;re seeing this, you&#39;re accessing the property &#96;target&#96; on a released&#x2F;nullified synthetic event. This is set to null. If you must keep the original synthetic event around, use event.persist(). See https:&#x2F;&#x2F;fb.me&#x2F;react-event-pooling for more information.</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">event.persist();</code></pre><h2 id="代码描述及修改"><a href="#代码描述及修改" class="headerlink" title="代码描述及修改"></a>代码描述及修改</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++const handleConfirmUpload &#x3D; useCallback(async (event, index: number) &#x3D;&gt; &#123;  event.persist(); &#x2F;&#x2F; 不加此处，导致上述问题  setConfirmFileReplace(true);  fileReplaceCache.current &#x3D; &#123;    event,    index,  &#125;;&#125;, []);&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++const handleCloseFileReplace &#x3D; useCallback(async () &#x3D;&gt; &#123;  setConfirmFileReplace(false);  fileReplaceCache.current &#x3D; null;&#125;, []);&#x2F;&#x2F; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++const handleConfirmFileReplace &#x3D; useCallback(async () &#x3D;&gt; &#123;  if (fileReplaceCache.current) &#123;    handleUploadChange(      fileReplaceCache.current?.event,      fileReplaceCache.current?.index    );  &#125;&#125;, [fileReplaceCache.current]);&#x2F;&#x2F; 为了保证此函数内部不变const handleUploadChange &#x3D; useCallback(async (event, index: number) &#x3D;&gt; &#123;  const files &#x3D; event.target?.files;  if (!files || files?.length &#x3D;&#x3D;&#x3D; 0) return;&#125;, []);</code></pre><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>点击 <a href="https://fb.me/react-event-pooling" target="_blank" >查看链接提示</a></p><p><strong>Event Pooling</strong></p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>This page is only relevant for React 16 and earlier, and for React Native.<br>这个页面只适用于 React 16 和更早的版本，以及 React Native。<br>React 17 on the web does not use event pooling.<br>React17 在web中没有使用事件循环<br>Read more about this change in React 17.</div><p>The SyntheticEvent objects are pooled. This means that the SyntheticEvent object will be reused and all properties will be nullified after the event handler has been called. For example, this won’t work:<br><em>SyntheticEvent对象被合并。这意味着将重用SyntheticEvent对象，并且在调用事件处理程序后，所有属性都将为null。例如，这将不起作用：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function handleChange(e) &#123;  &#x2F;&#x2F; This won&#39;t work because the event object gets reused.  &#x2F;&#x2F; 这不起作用，因为事件对象被重用了。  setTimeout(() &#x3D;&gt; &#123;    console.log(e.target.value); &#x2F;&#x2F; Too late! 太迟了  &#125;, 100);&#125;</code></pre><p>If you need to access event object’s properties after the event handler has run, you need to call e.persist():<br><em>如果需要在事件处理程序运行后访问事件对象的属性，则需要调用<code>e.persist()</code>：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function handleChange(e) &#123;  &#x2F;&#x2F; Prevents React from resetting its properties:  &#x2F;&#x2F; 阻止React重置其属性  e.persist();  setTimeout(() &#x3D;&gt; &#123;    console.log(e.target.value); &#x2F;&#x2F; Works 没问题  &#125;, 100);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Pinia</title>
      <link href="//post/2022-06-10vue-pinia.html"/>
      <url>//post/2022-06-10vue-pinia.html</url>
      
        <content type="html"><![CDATA[<h2 id="Pinia-特点"><a href="#Pinia-特点" class="headerlink" title="Pinia 特点"></a>Pinia 特点</h2><p><strong>💡 Intuitive</strong><br><code>直观的</code><br>Stores are as familiar as components. API designed to let you write well organized stores.<br><code>存储和组件是一样的。API设计了让你写好组织的存储。</code></p><p><strong>🔑 Type Safe</strong><br><code>类型安全的</code><br>Types are inferred, which means stores provide you with autocompletion even in JavaScript!<br><code>类型可推测，这意味着存储提供了你在JavaScript中自动完成的功能！</code></p><p><strong>⚙️ Devtools support</strong><br><code>开发工具支持</code><br>Pinia hooks into Vue devtools to give you an enhanced development experience in both Vue 2 and Vue 3.<br><code>Pinia钩子进入Vue开发工具，让你在Vue 2和Vue 3中获得强化开发经验。</code></p><p><strong>🔌 Extensible</strong><br><code>可扩展的</code><br>React to store changes to extend Pinia with transactions, local storage synchronization, etc.<br><code>通过事务、本地存储同步等来响应存储更改以扩展Pinia。</code></p><p><strong>🏗 Modular by design</strong><br><code>设计模块化</code><br>Build multiple stores and let your bundler code split them automatically.<br><code>构建多个存储，让你的bundler代码分开它们自动。</code></p><p><strong>📦 Extremely light</strong><br><code>非常轻量的</code><br>Pinia weighs around 1kb, you will forget it’s even there!<br><code>Pinia约1kb，你会忘记它在那里！</code></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><code>介绍</code></p><p><VueSchoolLink  href="https://vueschool.io/lessons/introduction-to-pinia"  title="Get started with Pinia"/></p><p>Pinia <a href="https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e">started</a> as an experiment to redesign what a Store for Vue could look like with the <a href="https://github.com/vuejs/composition-api">Composition API</a> around November 2019. Since then, the initial principles are still the same, but Pinia works for both Vue 2 and Vue 3 <strong>and doesn’t require you to use the composition API</strong>. The API is the same for both except for <em>installation</em> and <em>SSR</em>, and these docs are targeted to Vue 3 <strong>with notes about Vue 2</strong> whenever necessary so it can be read by Vue 2 and Vue 3 users!</p><p><em>译：Pinia 从 2019 年 11 月左右开始尝试重新设计 Vue store 的合成 API。从那时起，最初的原则仍然是一样的，但 Pinia 同时适用于 Vue 2 和 Vue 3，不需要您使用合成 API。除了安装和 SSR 之外，这两个 API 都是相同的，这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的说明，以便 Vue 2 和 Vue 3 用户可以阅读！</em></p><p><strong>Why should I use Pinia?</strong></p><p><code>为什么我应该使用Pinia？</code></p><p>Pinia is a store library for Vue, it allows you to share a state across components&#x2F;pages. If you are familiar with the Composition API, you might be thinking you can already share a global state with a simple <code>export const state = reactive(&#123;&#125;)</code>. This is true for single page applications but <strong>exposes your application to <a href="https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution">security vulnerabilities</a></strong> if it is server side rendered. But even in small single page applications, you get a lot from using Pinia:</p><p><em>译：Pinia 是一个 Vue 的存储库，它允许你在组件&#x2F;页面之间共享状态。如果你熟悉合成 API，你可能会认为你可以通过简单的<code>export const state = reactive(&#123;&#125;)</code>共享全局状态。这是对于单页应用的真实情况，但</em> **如果它是服务器端渲染，它会暴露您的应用程序到<a href="https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution">安全漏洞</a>**。<em>但即使是小的单页应用，使用 Pinia 也很多：</em></p><ul><li>Devtools support <em>开发工具支持</em><ul><li>A timeline to track actions, mutations <em>追踪行动、突变的时间表</em></li><li>Stores appear in components where they are used <em>存储出现在使用它们的组件中</em></li><li>Time travel and easier debugging <em>时间旅行和更容易调试</em></li></ul></li><li>Hot module replacement <em>快速更新</em><ul><li>Modify your stores without reloading your page <em>在不重新加载页面的情况下修改你的存储</em></li><li>Keep any existing state while developing <em>在开发时保持任何现有状态</em></li></ul></li><li>Plugins: extend Pinia features with plugins <em>功能扩展：使用插件扩展 Pinia 功能</em></li><li>Proper TypeScript support or <strong>autocompletion</strong> for JS users *对于 JS 用户的正确的 TypeScript 支持或<strong>自动完成*</strong></li><li>Server Side Rendering Support <em>完美的服务器端渲染支持</em></li></ul><p><strong>Basic example</strong></p><p><code>基本示例</code><br>This is what using pinia looks like in terms of API (make sure to check the <a href="./getting-started.md">Getting Started</a> for complete instructions). You start by creating a store:<br><em>译：这是为什么使用 pinia 看起来像 API（请检查<a href="./getting-started.md">开始</a>以获取完整的指令）。你首先创建一个存储：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; stores&#x2F;counter.jsimport &#123; defineStore &#125; from &quot;pinia&quot;;export const useCounterStore &#x3D; defineStore(&quot;counter&quot;, &#123;  state: () &#x3D;&gt; &#123;    return &#123; count: 0 &#125;;  &#125;,  &#x2F;&#x2F; could also be defined as  &#x2F;&#x2F; state: () &#x3D;&gt; (&#123; count: 0 &#125;)  actions: &#123;    increment() &#123;      this.count++;    &#125;,  &#125;,&#125;);</code></pre><p>And then you <em>use</em> it in a component:<br><em>译：然后你在组件中<code>使用</code>它：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useCounterStore &#125; from &quot;@&#x2F;stores&#x2F;counter&quot;;export default &#123;  setup() &#123;    const counter &#x3D; useCounterStore();    counter.count++;    &#x2F;&#x2F; with autocompletion ✨    counter.$patch(&#123; count: counter.count + 1 &#125;);    &#x2F;&#x2F; or using an action instead    counter.increment();  &#125;,&#125;;</code></pre><p>You can even use a function (similar to a component <code>setup()</code>) to define a Store for more advanced use cases:<br><em>译：你也可以使用函数（与组件<code>setup()</code>相似）来定义一个存储以更高级的使用情况：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const useCounterStore &#x3D; defineStore(&quot;counter&quot;, () &#x3D;&gt; &#123;  const count &#x3D; ref(0);  function increment() &#123;    count.value++;  &#125;  return &#123; count, increment &#125;;&#125;);</code></pre><p>If you are still not into <code>setup()</code> and Composition API, don’t worry, Pinia also support a similar set of <a href="https://vuex.vuejs.org/guide/state.html#the-mapstate-helper"><em>map helpers</em> like Vuex</a>. You define stores the same way but then use <code>mapStores()</code>, <code>mapState()</code>, or <code>mapActions()</code>:<br><em>译：如果你还不是<code>setup()</code>和 Composition API 的熟悉，不用担心，Pinia 也支持<a href="https://vuex.vuejs.org/guide/state.html#the-mapstate-helper">Vuex 的<em>map helpers</em>（如 Vuex）</a>。你定义存储的方式相同，然后使用<code>mapStores()</code>, <code>mapState()</code>,或<code>mapActions()</code>：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const useCounterStore &#x3D; defineStore(&quot;counter&quot;, &#123;  state: () &#x3D;&gt; (&#123; count: 0 &#125;),  getters: &#123;    double: (state) &#x3D;&gt; state.count * 2,  &#125;,  actions: &#123;    increment() &#123;      this.count++;    &#125;,  &#125;,&#125;);const useUserStore &#x3D; defineStore(&quot;user&quot;, &#123;  &#x2F;&#x2F; ...&#125;);export default &#123;  computed: &#123;    &#x2F;&#x2F; other computed properties    &#x2F;&#x2F; ...    &#x2F;&#x2F; gives access to this.counterStore and this.userStore    ...mapStores(useCounterStore, useUserStore),    &#x2F;&#x2F; gives read access to this.count and this.double    ...mapState(useCounterStore, [&quot;count&quot;, &quot;double&quot;]),  &#125;,  methods: &#123;    &#x2F;&#x2F; gives access to this.increment()    ...mapActions(useCounterStore, [&quot;increment&quot;]),  &#125;,&#125;;</code></pre><p>You will find more information about each <em>map helper</em> in the core concepts.<br><em>译：你将找到更多关于每个<em>map helper</em>的信息。</em></p><p><strong>Why <em>Pinia</em></strong></p><p><em>为什么叫 Pinia</em></p><p>Pinia (pronounced <code>/piːnjʌ/</code>, like “peenya” in English) is the closest word to <em>piña</em> (<em>pineapple</em> in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It’s also a delicious tropical fruit indigenous to South America.</p><p><em>Pinia 发音 <code>/piːnjʌ/</code>，类似于英语中的“柠檬”，它是一个有效的包名。一个柠檬是实际上是一组单个花朵结合在一起，以创建多个水果。与存储相似，每一个都是单独出生的，但是他们都是最终连接在一起的。它也是一个在南美洲的美食。</em></p><p><strong>A more realistic example</strong></p><p><em>译：更真实的例子</em><br>Here is a more complete example of the API you will be using with Pinia <strong>with types even in JavaScript</strong>. For some people, this might be enough to get started without reading further but we still recommend checking the rest of the documentation or even skipping this example and coming back once you have read about all of the <em>Core Concepts</em>.<br><em>译：这是一个更完整的例子，你将使用 Pinia<strong>类型在 JavaScript</strong>。对于一些人，这可能是足够开始而不需要阅读更多，但我们仍然建议检查其余的文档或跳过这个例子，然后回来一次你已经阅读了所有的<strong>核心概念</strong>。</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; defineStore &#125; from &quot;pinia&quot;;export const todos &#x3D; defineStore(&quot;todos&quot;, &#123;  state: () &#x3D;&gt; (&#123;    &#x2F;** @type &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125; *&#x2F;    todos: [],    &#x2F;** @type &#123;&#39;all&#39; | &#39;finished&#39; | &#39;unfinished&#39;&#125; *&#x2F;    filter: &quot;all&quot;,    &#x2F;&#x2F; type will be automatically inferred to number    &#x2F;&#x2F; 类型将自动推断为number    nextId: 0,  &#125;),  getters: &#123;    finishedTodos(state) &#123;      &#x2F;&#x2F; autocompletion! ✨      &#x2F;&#x2F; 自动完成      return state.todos.filter((todo) &#x3D;&gt; todo.isFinished);    &#125;,    unfinishedTodos(state) &#123;      return state.todos.filter((todo) &#x3D;&gt; !todo.isFinished);    &#125;,    &#x2F;**     * @returns &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125;     *&#x2F;    filteredTodos(state) &#123;      if (this.filter &#x3D;&#x3D;&#x3D; &quot;finished&quot;) &#123;        &#x2F;&#x2F; call other getters with autocompletion ✨        &#x2F;&#x2F; 调用其他getters自动完成        return this.finishedTodos;      &#125; else if (this.filter &#x3D;&#x3D;&#x3D; &quot;unfinished&quot;) &#123;        return this.unfinishedTodos;      &#125;      return this.todos;    &#125;,  &#125;,  actions: &#123;    &#x2F;&#x2F; any amount of arguments, return a promise or not    &#x2F;&#x2F; 任意数量的参数，返回一个promise或不    addTodo(text) &#123;      &#x2F;&#x2F; you can directly mutate the state      &#x2F;&#x2F; 你可以直接修改状态      this.todos.push(&#123; text, id: this.nextId++, isFinished: false &#125;);    &#125;,  &#125;,&#125;);</code></pre><p><strong>Comparison with Vuex</strong></p><p><em>译：与 Vuex 比较</em></p><p>Pinia started out as an exploration of what the next iteration of Vuex could look like, incorporating many ideas from core team discussions for Vuex 5. Eventually, we realized that Pinia already implements most of what we wanted in Vuex 5, and decided to make it the new recommendation instead.<br><em>译：Pinia 开始了一个探索 Vuex 的下一个迭代，并且将大量的想法从 Vuex 5 的核心团队讨论中提取。最终，我们认为 Pinia 已经实现了大部分我们想要的 Vuex 5，并且决定改变它的推荐。</em><br>Compared to Vuex, Pinia provides a simpler API with less ceremony, offers Composition-API-style APIs, and most importantly, has solid type inference support when used with TypeScript.<br><em>译：与 Vuex 比较，Pinia 提供了更简单的 API，提供了组合 API 的 API，并且在使用 TypeScript 时有实体类型支持。</em></p><p><strong>RFCs</strong></p><p><em>译：RFCs</em></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>RFCs 涵盖了 Vue 的最基本的四个部分，截至目前为止，已经有 38 个 PR 提交（26 个仍在讨论中），这些提议中既有 Vue 作者自己的提议，也有开发者的提议。</p><ul><li>Vue core</li><li>Vue Router</li><li>Vuex</li><li>Vue CLI</li></ul></blockquote><p>Initially Pinia didn’t go through any RFC. I tested out ideas based on my experience developing applications, reading other people’s code, working for clients who use Pinia, and answering questions on Discord.<br>This allowed me to provide a solution that works and is adapted to a variety of cases and application sizes. I used to publish often and made the library evolve while keeping its core API the same.<br><em>译：初始 Pinia 没有通过任何 RFC。我测试了基于我的经验开发应用程序，阅读其他人的代码，为使用 Pinia 的客户工作，并在 Discord 上回答问题。这让我提供了一个解决方案，它工作并适合各种情况和应用程序大小。我经常发布，并在保持核心 API 相同的情况下，使库发展。</em><br>Now that Pinia has become the default state management solution, it is subject to the same RFC process as other core libraries in the Vue ecosystem and its API has entered a stable state.<br><em>译：现在，Pinia 已经成为 Vue 的核心状态管理解决方案，它与 Vue 社区中其他核心库的 RFC 进行了相同的处理，并且它的 API 已经进入了一个稳定状态。</em></p><p><strong>Comparison with Vuex 3.x&#x2F;4.x</strong></p><p><em>译：与 Vuex 3.x&#x2F;4.x 比较</em></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Vuex 3.x is Vuex for Vue 2 while Vuex 4.x is for Vue 3<br>Vuex 3.x 是 Vuex 2 的 Vuex，而 Vuex 4.x 是 Vue 3 的 Vuex<br>Pinia API is very different from Vuex ≤4, namely:<br><em>译：Pinia API 与 Vuex 3.x&#x2F;4.x 比较，主要区别是：</em></p></blockquote><ul><li><em>mutations</em> no longer exist. They were very often perceived as <strong><em>extremely</em> verbose</strong>. They initially brought devtools integration but that is no longer an issue.<br><code>- mutations 不再存在。它们初始上抛了开发工具集成，但这不再是问题。</code></li><li>No need to create custom complex wrappers to support TypeScript, everything is typed and the API is designed in a way to leverage TS type inference as much as possible.<br><code>- 没有需要创建自定义复杂的包装来支持TypeScript，所有的都是类型化的，API设计了一个让你最大限度地利用TS类型推断的方式。</code></li><li>No more magic strings to inject, import the functions, call them, enjoy autocompletion!<br><code>- 没有更多的魔法字符串注入，导入函数，调用它们，享受自动完成！</code></li><li>No need to dynamically add stores, they are all dynamic by default and you won’t even notice. Note you can still manually use a store to register it whenever you want but because it is automatic you don’t need to worry about it.<br><code>- 没有需要动态添加存储，它们都是默认的动态的，你也不会发现。请注意，你仍然可以手动使用存储来注册它，但是因为它是自动的，你不需要担心它。</code></li><li>No more nested structuring of <em>modules</em>. You can still nest stores implicitly by importing and <em>using</em> a store inside another but Pinia offers a flat structuring by design while still enabling ways of cross composition among stores. <strong>You can even have circular dependencies of stores</strong>.<br><code>- 没有更多的嵌套结构的_模块_。你仍然可以嵌套存储通过导入并使用存储在另一个存储中，但Pinia提供了一个平面的结构，而且还允许在存储之间跨越组合。**你还可以有圆形依赖的存储**。</code></li><li>No <em>namespaced modules</em>. Given the flat architecture of stores, “namespacing” stores is inherent to how they are defined and you could say all stores are namespaced.<br><code>- 没有_命名空间模块_。给定存储的平面建构，“命名空间”存储是因为它们定义的方式而具有的，你可以说所有的存储都是命名空间。</code><br>For more detailed instructions on how to convert an existing Vuex ≤4 project to use Pinia, see the <a href="./cookbook/migration-vuex.md">Migration from Vuex Guide</a>.<br><em>译：为了更加详细的指导如何将现有的 Vuex ≤4 项目转换为使用 Pinia，请参阅<a href="./cookbook/migration-vuex.md">Migration from Vuex Guide</a>。</em></li></ul><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a><a href="https://pinia.vuejs.org/getting-started.html#installation">起步</a></h2><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>Install <code>pinia</code> with your favorite package manager:<br><em>译：使用你喜欢的包管理器安装 <code>pinia</code> ：</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn add pinia# or with npmnpm install pinia</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>If your app is using Vue 2, you also need to install the composition api: <code>@vue/composition-api</code>. If you are using Nuxt, you should follow <a href="https://pinia.vuejs.org/ssr/nuxt.html">these instructions</a>.<br><em>译：如果你的应用使用 Vue 2，你还需要安装组合 api：<code>@vue/composition-api</code>。如果你使用 Nuxt，你应该遵循<a href="https://pinia.vuejs.org/ssr/nuxt.html">这些指导</a>。</em></p></div><p>If you are using the Vue CLI, you can instead give this <a href="https://github.com/wobsoriano/vue-cli-plugin-pinia"><strong>unofficial plugin</strong></a> a try.<br>_译：如果你使用 Vue CLI，你可以试试这个 [<strong>非官方插件</strong>](</p><p>Create a pinia (the root store) and pass it to the app:<br><em>译：创建一个 pinia （根存储）并将其传递给应用：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; createPinia &#125; from &quot;pinia&quot;;app.use(createPinia());</code></pre><p>If you are using Vue 2, you also need to install a plugin and inject the created <code>pinia</code> at the root of the app:<br><em>译：如果你使用 Vue 2，你还需要安装一个插件并将创建的 <code>pinia</code> 注入到应用的根中：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; createPinia, PiniaVuePlugin &#125; from &quot;pinia&quot;;Vue.use(PiniaVuePlugin);const pinia &#x3D; createPinia();new Vue(&#123;  el: &quot;#app&quot;,  &#x2F;&#x2F; other options...  &#x2F;&#x2F; ...  &#x2F;&#x2F; note the same &#96;pinia&#96; instance can be used across multiple Vue apps on the same page  &#x2F;&#x2F; 注意，同一个 &#96;pinia&#96; 实例可以在同一个页面上的多个 Vue 应用中使用  pinia,&#125;);</code></pre><p>This will also add devtools support. In Vue 3, some features like time traveling and editing are still not supported because vue-devtools doesn’t expose the necessary APIs yet but the devtools have way more features and the developer experience as a whole is far superior. In Vue 2, Pinia uses the existing interface for Vuex (and can therefore not be used alongside it).<br><em>译：这也会添加 devtools 支持。在 Vue 3 中，某些功能（例如时间旅行和编辑）仍然不支持，因为 vue-devtools 不暴露了必要的 API，但是 devtools 有更多的功能，开发者体验整体更优。在 Vue 2 中，Pinia 使用现有的 Vuex 接口（因此不能与它一起使用）。</em></p><h3 id="What-is-a-Store"><a href="#What-is-a-Store" class="headerlink" title="What is a Store?"></a>What is a Store?</h3><p>A Store (like Pinia) is an entity holding state and business logic that isn’t bound to your Component tree. In other words, <strong>it hosts global state</strong>. It’s a bit like a component that is always there and that everybody can read off and write to. It has <strong>three concepts</strong>, the <a href="./core-concepts/state.md">state</a>, <a href="./core-concepts/getters.md">getters</a> and <a href="./core-concepts/actions.md">actions</a> and it’s safe to assume these concepts are the equivalent of <code>data</code>, <code>computed</code> and <code>methods</code> in components.<br><em>译：一个存储（像 Pinia）是一个持有状态和业务逻辑的实体，它不是绑定到你的组件树上的。也就是说，<strong>它持有全局状态</strong>。它是一个总是存在的组件，每个人都可以读取并写入。它有 <strong>三个概念</strong>，<a href="./core-concepts/state.md">state</a>，<a href="./core-concepts/getters.md">getters</a> 和 <a href="./core-concepts/actions.md">actions</a>，并且我们假设这三个概念是组件的 <code>data</code>，<code>computed</code> 和 <code>methods</code> 的等价。</em></p><h3 id="When-should-I-use-a-Store"><a href="#When-should-I-use-a-Store" class="headerlink" title="When should I use a Store"></a>When should I use a Store</h3><p>A store should contain data that can be accessed throughout your application. This includes data that is used in many places, e.g. User information that is displayed in the navbar, as well as data that needs to be preserved through pages, e.g. a very complicated multi-step form.<br><em>译：一个存储应该包含可以在整个应用程序中访问的数据。这包括在多个地方使用的数据，例如在导航栏中显示的用户信息，以及需要在页面中保留的数据，例如一个复杂的多步骤表单。</em><br>On the other hand, you should avoid including in the store local data that could be hosted in a component instead, e.g. the visibility of an element local to a page.<br><em>译：另一方面，你应该避免在存储中包含在组件中存储的本地数据，例如页面中的一个元素的可见性。</em><br>Not all applications need access to a global state, but if yours need one, Pinia will make your life easier.<br><em>译：不是所有应用都需要访问全局状态，但如果你的应用需要一个，Pinia 将使你的生活更加方便。</em></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><strong>Defining a Store</strong></p><p><VueSchoolLink  href="https://vueschool.io/lessons/define-your-first-pinia-store"  title="Learn how to define and use stores in Pinia"/></p><p>Before diving into core concepts, we need to know that a store is defined using <code>defineStore()</code> and that it requires a <strong>unique</strong> name, passed as the first argument:<br><em>译：在深入核心概念之前，我们需要知道一个存储由 <code>defineStore()</code> 定义并且需要一个 <strong>唯一的</strong> 名称作为第一个参数：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; defineStore &#125; from &quot;pinia&quot;;&#x2F;&#x2F; useStore could be anything like useUser, useCart&#x2F;&#x2F; the first argument is a unique id of the store across your applicationexport const useStore &#x3D; defineStore(&quot;main&quot;, &#123;  &#x2F;&#x2F; other options...&#125;);</code></pre><p>This <em>name</em>, also referred as <em>id</em>, is necessary and is used by Pinia to connect the store to the devtools. Naming the returned function <em>use…</em> is a convention across composables to make its usage idiomatic.<br>_译：这个名称，也称为 <em>id_，是必需的并且用于连接存储到 devtools。命名返回的函数 <em>use…</em> 是一个组合使用的惯例，使用它的用法简单易懂。</em><br><strong>Using the store</strong></p><p>We are <em>defining</em> a store because the store won’t be created until <code>useStore()</code> is called inside of <code>setup()</code>:<br><em>译：我们正在定义一个存储，因为只有在<code>setup（）</code>内部调用<code>useStore（）</code>才能创建该存储</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useStore &#125; from &quot;@&#x2F;stores&#x2F;counter&quot;;export default &#123;  setup() &#123;    const store &#x3D; useStore();    return &#123;      &#x2F;&#x2F; you can return the whole store instance to use it in the template      &#x2F;&#x2F; 你可以在模板中返回整个存储实例来使用它      store,    &#125;;  &#125;,&#125;;</code></pre><p>You can define as many stores as you want and <strong>you should define each store in a different file</strong> to get the most out of pinia (like automatically allow your bundle to code split and TypeScript inference).<br><em>译 ：你可以定义多个存储，你应该在不同的文件中定义每个存储来获得 pinia 的最大效用（例如自动允许你的 bundle 分割和 TypeScript 推断）。</em><br>If you are not using <code>setup</code> components yet, <a href="https://pinia.vuejs.org/cookbook/options-api.html">you can still use Pinia with <em>map helpers</em></a>.<br><em>译：如果你还没有使用 <code>setup</code> 组件，你仍然可以使用 Pinia 与 [map 助手]（<a href="https://pinia.vuejs.org/cookbook/options-api.html%EF%BC%89%E3%80%82">https://pinia.vuejs.org/cookbook/options-api.html）。</a></em><br>Once the store is instantiated, you can access any property defined in <code>state</code>, <code>getters</code>, and <code>actions</code> directly on the store. We will see these in detail in the next pages but autocompletion will help you.<br><em>译：一旦存储被实例化，你可以直接在存储上访问 <code>state</code>，<code>getters</code> 和 <code>actions</code> 中定义的属性。我们将在下一页中详细讲解，但是自动补全将帮助你。</em><br>Note that <code>store</code> is an object wrapped with <code>reactive</code>, meaning there is no need to write <code>.value</code> after getters but, like <code>props</code> in <code>setup</code>, <strong>we cannot destructure it</strong>:<br><em>译：请注意，存储是一个 <code>reactive</code> 包装的对象，因此不需要写 <code>.value</code> 后面的 getters，但是，像 <code>setup</code> 中的 <code>props</code>，我们不能解构它</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default defineComponent(&#123;  setup() &#123;    const store &#x3D; useStore();    &#x2F;&#x2F; ❌ This won&#39;t work because it breaks reactivity it&#39;s the same as destructuring from &#96;props&#96;    &#x2F;&#x2F; 这不会工作，因为它会破坏可观察性，它是相同的为 &#96;props&#96; 构造的    const &#123; name, doubleCount &#125; &#x3D; store;    name; &#x2F;&#x2F; &quot;eduardo&quot;    doubleCount; &#x2F;&#x2F; 2    return &#123;      &#x2F;&#x2F; will always be &quot;eduardo&quot;      &#x2F;&#x2F; 将始终是 &quot;eduardo&quot;      name,      &#x2F;&#x2F; will always be 2      &#x2F;&#x2F; 将始终是 2      doubleCount,      &#x2F;&#x2F; this one will be reactive      &#x2F;&#x2F; 这个将是可观察的      doubleValue: computed(() &#x3D;&gt; store.doubleCount),    &#125;;  &#125;,&#125;);</code></pre><p>In order to extract properties from the store while keeping its reactivity, you need to use <code>storeToRefs()</code>. It will create refs for every reactive property. This is useful when you are only using state from the store but not calling any action. Note you can destructure actions directly from the store as they are bound to the store itself too:<br><em>译：为了从存储中提取属性而保持其可观察性，你需要使用 <code>storeToRefs()</code>。它会创建每个可观察属性的 ref。这对于只使用存储中的状态但不调用任何行为时非常有用。请注意，你可以直接从存储中解构 actions，因为它们都是绑定到存储本身的。</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; storeToRefs &#125; from &quot;pinia&quot;;export default defineComponent(&#123;  setup() &#123;    const store &#x3D; useStore();    &#x2F;&#x2F; &#96;name&#96; and &#96;doubleCount&#96; are reactive refs    &#x2F;&#x2F; This will also create refs for properties added by plugins    &#x2F;&#x2F; but skip any action or non reactive (non ref&#x2F;reactive) property    const &#123; name, doubleCount &#125; &#x3D; storeToRefs(store);    &#x2F;&#x2F; the increment action can be just extracted    const &#123; increment &#125; &#x3D; store;    return &#123;      name,      doubleCount,      increment,    &#125;;  &#125;,&#125;);</code></pre><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><VueSchoolLink  href="https://vueschool.io/lessons/access-state-from-a-pinia-store"  title="Learn all about state in Pinia"/></p><p>The state is, most of the time, the central part of your store. People often start by defining the state that represents their app. In Pinia the state is defined as a function that returns the initial state. This allows Pinia to work in both Server and Client Side.<br><em>大多数时候，state是你store的中心。人们通常从定义代表其应用程序的状态开始。在Pinia中，状态定义为返回初始状态的函数。这允许Pinia在服务器端和客户端都工作。</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; defineStore &#125; from &quot;pinia&quot;;const useStore &#x3D; defineStore(&quot;storeId&quot;, &#123;  &#x2F;&#x2F; arrow function recommended for full type inference  state: () &#x3D;&gt; &#123;    return &#123;      &#x2F;&#x2F; all these properties will have their type inferred automatically      counter: 0,      name: &quot;Eduardo&quot;,      isAdmin: true,    &#125;;  &#125;,&#125;);</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>If you are using Vue 2, the data you create in <code>state</code> follows the same rules as the <code>data</code> in a Vue instance, ie the state object must be plain and you need to call <code>Vue.set()</code> when <strong>adding new</strong> properties to it. <strong>See also: <a href="https://v2.vuejs.org/v2/api/#data">Vue#data</a></strong>.<br><em>如果你使用 Vue 2，在 <code>state</code> 中创建的数据遵循 Vue 实例中的 <code>data</code> 的规则，即 state 对象必须是纯粹的，并且需要在 <strong>添加新的</strong> 属性时调用 <code>Vue.set()</code>。请参见 <a href="https://v2.vuejs.org/v2/api/#data">Vue#data</a>。</em></p></div><p><strong>Accessing the <code>state</code></strong></p><p>By default, you can directly read and write to the state by accessing it through the <code>store</code> instance:<br><em>默认情况下，你可以直接读取和写入状态，通过访问 <code>store</code> 实例来访问它：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const store &#x3D; useStore();store.counter++;</code></pre><p><strong>Resetting the state</strong></p><p>You can <em>reset</em> the state to its initial value by calling the <code>$reset()</code> method on the store:<br><em>你可以通过调用 <code>$reset()</code> 方法来重置状态：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const store &#x3D; useStore();store.$reset();</code></pre><p><strong>Usage with the Options API</strong></p><p><VueSchoolLink  href="https://vueschool.io/lessons/access-pinia-state-in-the-options-api"  title="Access Pinia State via the Options API"/></p><p>For the following examples, you can assume the following store was created:<br><em>为了下面的例子，你可以假设以下的存储已创建：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; Example File Path:&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.jsimport &#123; defineStore &#125; from &quot;pinia&quot;;const useCounterStore &#x3D; defineStore(&quot;counterStore&quot;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),&#125;);</code></pre><p>If you are not using the Composition API, and you are using <code>computed</code>, <code>methods</code>, …, you can use the <code>mapState()</code> helper to map state properties as readonly computed properties:<br><em>如果你不使用 Composition API，并且使用 <code>computed</code>、<code>methods</code> 等，你可以使用 <code>mapState()</code> 帮助器来映射状态属性为只读的计算属性：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; mapState &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  computed: &#123;    &#x2F;&#x2F; gives access to this.counter inside the component    &#x2F;&#x2F; same as reading from store.counter    ...mapState(useCounterStore, [&#39;counter&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName    ...mapState(useCounterStore, &#123;      myOwnName: &#39;counter&#39;,      &#x2F;&#x2F; you can also write a function that gets access to the store      double: store &#x3D;&gt; store.counter * 2,      &#x2F;&#x2F; it can have access to &#96;this&#96; but it won&#39;t be typed correctly...      magicValue(store) &#123;        return store.someGetter + this.counter + this.double      &#125;,    &#125;),  &#125;,&#125;</code></pre><p><strong>Modifiable state</strong></p><p>If you want to be able to write to these state properties (e.g. if you have a form), you can use <code>mapWritableState()</code> instead. Note you cannot pass a function like with <code>mapState()</code>:<br><em>如果你想要写入这些状态属性（例如，如果你有一个表单），你可以使用 <code>mapWritableState()</code>。注意，你不能传递一个函数类似于 <code>mapState()</code>：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; mapWritableState &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  computed: &#123;    &#x2F;&#x2F; gives access to this.counter inside the component and allows setting it    &#x2F;&#x2F; this.counter++    &#x2F;&#x2F; same as reading from store.counter    ...mapWritableState(useCounterStore, [&#39;counter&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName    ...mapWritableState(useCounterStore, &#123;      myOwnName: &#39;counter&#39;,    &#125;),  &#125;,&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>You don’t need <code>mapWritableState()</code> for collections like arrays unless you are replacing the whole array with <code>cartItems = []</code>, <code>mapState()</code> still allows you to call methods on your collections.<br><em>注意，你不需要 <code>mapWritableState()</code> 为集合类型（例如数组），除非你想要替换整个数组为 <code>cartItems = []</code>，<code>mapState()</code> 仍然允许你调用集合的方法。</em></p></div><p><strong>Mutating the state</strong></p><!-- TODO: disable this with `strictMode` --><p>Apart from directly mutating the store with <code>store.counter++</code>, you can also call the <code>$patch</code> method. It allows you to apply multiple changes at the same time with a partial <code>state</code> object:<br><em>除了直接通过 <code>store.counter++</code> 来修改存储，你也可以调用 <code>$patch()</code> 方法。它允许你同时使用一个部分 <code>state</code> 对象来应用多个变更：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">store.$patch(&#123;  counter: store.counter + 1,  name: &quot;Abalam&quot;,&#125;);</code></pre><p>However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the <code>$patch</code> method also accepts a function to group this kind of mutations that are difficult to apply with a patch object:<br><em>但是，一些变更非常难或者昂贵地应用，因为它们需要创建一个新的集合。因此，<code>$patch</code> 方法也接受一个函数来组织这种难以应用的变更：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">cartStore.$patch((state) &#x3D;&gt; &#123;  state.items.push(&#123; name: &quot;shoes&quot;, quantity: 1 &#125;);  state.hasChanged &#x3D; true;&#125;);</code></pre><!-- TODO: disable this with `strictMode`, `{ noDirectPatch: true }` --><p>The main difference here is that <code>$patch()</code> allows you to group multiple changes into one single entry in the devtools. Note <strong>both, direct changes to <code>state</code> and <code>$patch()</code> appear in the devtools</strong> and can be time travelled (not yet in Vue 3).<br>_主要的区别是，<code>$patch()</code> 允许你将多个变更组成一个单独的条目在 devtools 中。注意 **两者都会在 devtools 中出现，并且可以被时间轴追踪（尚未在 Vue 3 中）。_<br><strong>Replacing the <code>state</code></strong></p><p>You can replace the whole state of a store by setting its <code>$state</code> property to a new object:<br><em>你可以通过设置存储的 <code>$state</code> 属性来替换它的状态：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">store.$state &#x3D; &#123; counter: 666, name: &quot;Paimon&quot; &#125;;</code></pre><p>You can also replace the whole state of your application by changing the <code>state</code> of the <code>pinia</code> instance. This is used during <a href="../ssr/#state-hydration">SSR for hydration</a>.<br><em>你也可以通过更改 <code>pinia</code> 实例的 <code>state</code> 来替换整个应用的状态。这用于 <a href="../ssr/#state-hydration">SSR for hydration</a>。</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">pinia.state.value &#x3D; &#123;&#125;;</code></pre><p><strong>Subscribing to the state</strong></p><p>You can watch the state and its changes through the <code>$subscribe()</code> method of a store, similar to Vuex’s <a href="https://vuex.vuejs.org/api/#subscribe">subscribe method</a>. The advantage of using <code>$subscribe()</code> over a regular <code>watch()</code> is that <em>subscriptions</em> will trigger only once after <em>patches</em> (e.g. when using the function version from above).<br><em>你可以通过存储的 <code>$subscribe()</code> 方法来订阅状态，与 Vuex 的 <a href="https://vuex.vuejs.org/api/#subscribe">subscribe 方法</a> 类似。使用 <code>$subscribe()</code> 方法来订阅状态，优势在于它会在变更后只触发一次订阅（例如，使用上面的函数版本）。</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">cartStore.$subscribe((mutation, state) &#x3D;&gt; &#123;  &#x2F;&#x2F; import &#123; MutationType &#125; from &#39;pinia&#39;  mutation.type; &#x2F;&#x2F; &#39;direct&#39; | &#39;patch object&#39; | &#39;patch function&#39;  &#x2F;&#x2F; same as cartStore.$id  mutation.storeId; &#x2F;&#x2F; &#39;cart&#39;  &#x2F;&#x2F; only available with mutation.type &#x3D;&#x3D;&#x3D; &#39;patch object&#39;  mutation.payload; &#x2F;&#x2F; patch object passed to cartStore.$patch()  &#x2F;&#x2F; persist the whole state to the local storage whenever it changes  localStorage.setItem(&quot;cart&quot;, JSON.stringify(state));&#125;);</code></pre><p>By default, <em>state subscriptions</em> are bound to the component where they are added (if the store is inside a component’s <code>setup()</code>). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass <code>&#123; detached: true &#125;</code> as the second argument to <em>detach</em> the <em>state subscription</em> from the current component:<br><em>默认情况下，_状态订阅_会绑定到添加它的组件（如果存储在组件的 <code>setup()</code> 中）。意味着，它会在组件卸载后自动删除。如果你想要在组件卸载后保持它们，可以将 <code>&#123; detached: true &#125;</code> 作为第二个参数传递给 <em>detach</em> <em>状态订阅</em> 从当前组件：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default &#123;  setup() &#123;    const someStore &#x3D; useSomeStore();    &#x2F;&#x2F; this subscription will be kept after the component is unmounted    someStore.$subscribe(callback, &#123; detached: true &#125;);    &#x2F;&#x2F; ...  &#125;,&#125;;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>You can watch the whole state on the <code>pinia</code> instance:<br>你可以监听整个pinia实例的状态，这个状态是一个对象，包含了所有的store的状态。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">watch(  pinia.state,  (state) &#x3D;&gt; &#123;    &#x2F;&#x2F; persist the whole state to the local storage whenever it changes    localStorage.setItem(&quot;piniaState&quot;, JSON.stringify(state));  &#125;,  &#123; deep: true &#125;);</code></pre></p></div><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p><VueSchoolLink  href="https://vueschool.io/lessons/getters-in-pinia"  title="Learn all about getters in Pinia"/></p><p>Getters are exactly the equivalent of <a href="https://v3.vuejs.org/guide/reactivity-computed-watchers.html#computed-values">computed values</a> for the state of a Store. They can be defined with the <code>getters</code> property in <code>defineStore()</code>. They receive the <code>state</code> as the first parameter <strong>to encourage</strong> the usage of arrow function:<br><em>获取器是状态的计算值。它们可以通过 <code>defineStore()</code> 中的 <code>getters</code> 属性来定义。它们会接收 <code>state</code>（使用箭头函数） 作为第一个参数，：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  getters: &#123;    doubleCount: (state) &#x3D;&gt; state.counter * 2,  &#125;,&#125;)</code></pre><p>Most of the time, getters will only rely on the state, however, they might need to use other getters. Because of this, we can get access to the <em>whole store instance</em> through <code>this</code> when defining a regular function <strong>but it is necessary to define the type of the return type (in TypeScript)</strong>. This is due to a known limitation in TypeScript and <strong>doesn’t affect getters defined with an arrow function nor getters not using <code>this</code></strong>:<br><em>大多数情况下，获取器只依赖于状态，但它们可能需要使用其他获取器。因此，我们可以通过 <code>this</code> 访问到整个存储实例（但是需要在TypeScript中定义返回类型），这是因为已知的限制，不影响使用箭头函数或不使用<code>this</code>的获取器：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  getters: &#123;    &#x2F;&#x2F; automatically infers the return type as a number    &#x2F;&#x2F; 自动推断返回类型为数字    doubleCount(state) &#123;      return state.counter * 2    &#125;,    &#x2F;&#x2F; the return type **must** be explicitly set    &#x2F;&#x2F;  返回类型 **必须** 被显式设置    doublePlusOne(): number &#123;      &#x2F;&#x2F; autocompletion and typings for the whole store ✨      &#x2F;&#x2F; 对于整个store自动完成和类型推断 ✨      return this.doubleCount + 1    &#125;,  &#125;,&#125;)</code></pre><p>Then you can access the getter directly on the store instance:<br><em>然后你可以直接在存储实例上访问获取器：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&lt;template&gt;  &lt;p&gt;Double count is &#123;&#123; store.doubleCount &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  setup() &#123;    const store &#x3D; useStore()    return &#123; store &#125;  &#125;,&#125;&lt;&#x2F;script&gt;</code></pre><h2 id="Accessing-other-getters"><a href="#Accessing-other-getters" class="headerlink" title="Accessing other getters"></a>Accessing other getters</h2><p>As with computed properties, you can combine multiple getters. Access any other getter via <code>this</code>. Even if you are not using TypeScript, you can hint your IDE for types with the <a href="https://jsdoc.app/tags-returns.html">JSDoc</a>:<br><em>如同计算属性，你可以将多个获取器组合在一起。通过 <code>this</code> 访问其他获取器。即使你不使用TypeScript，你也可以通过<a href="https://jsdoc.app/tags-returns.html">JSDoc</a>提示你的IDE类型：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  getters: &#123;    &#x2F;&#x2F; type is automatically inferred because we are not using &#96;this&#96;    &#x2F;&#x2F; 类型自动推断，因为我们不使用&#96;this&#96;    doubleCount: (state) &#x3D;&gt; state.counter * 2,    &#x2F;&#x2F; here we need to add the type ourselves (using JSDoc in JS). We can also    &#x2F;&#x2F; use this to document the getter    &#x2F;&#x2F; 在这里我们需要自己添加类型（使用JSDoc在JS）。我们也可以用这个来描述获取器    &#x2F;**     * Returns the counter value times two plus one.     *     * @returns &#123;number&#125;     *&#x2F;    doubleCountPlusOne() &#123;      &#x2F;&#x2F; autocompletion ✨      return this.doubleCount + 1    &#125;,  &#125;,&#125;)</code></pre><h2 id="Passing-arguments-to-getters"><a href="#Passing-arguments-to-getters" class="headerlink" title="Passing arguments to getters"></a>Passing arguments to getters</h2><p><em>Getters</em> are just <em>computed</em> properties behind the scenes, so it’s not possible to pass any parameters to them. However, you can return a function from the <em>getter</em> to accept any arguments:<br><em>获取器是组件的计算属性，因此不能传递任何参数。然而，你可以从获取器返回一个函数，接受任何参数：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  getters: &#123;    getUserById: (state) &#x3D;&gt; &#123;      return (userId) &#x3D;&gt; state.users.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)    &#125;,  &#125;,&#125;)</code></pre><p>and use in component:<br><em>在组件中使用：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&lt;script&gt;export default &#123;  setup() &#123;    const store &#x3D; useStore()    return &#123; getUserById: store.getUserById &#125;  &#125;,&#125;&lt;&#x2F;script&gt;&lt;template&gt;  &lt;p&gt;User 2: &#123;&#123; getUserById(2) &#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;template&gt;</code></pre><p>Note that when doing this, <strong>getters are not cached anymore</strong>, they are simply functions that you invoke. You can however cache some results inside of the getter itself, which is uncommon but should prove more performant:<br><em>注意，当这做的时候，<strong>获取器不再缓存了</strong>，它们是一个函数，你可以在获取器内部缓存一些结果，这是一种比较常见的情况，但是应该更有效率：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  getters: &#123;    getActiveUserById(state) &#123;      const activeUsers &#x3D; state.users.filter((user) &#x3D;&gt; user.active)      return (userId) &#x3D;&gt; activeUsers.find((user) &#x3D;&gt; user.id &#x3D;&#x3D;&#x3D; userId)    &#125;,  &#125;,&#125;)</code></pre><h2 id="Accessing-other-stores-getters"><a href="#Accessing-other-stores-getters" class="headerlink" title="Accessing other stores getters"></a>Accessing other stores getters</h2><p>To use another store getters, you can directly <em>use it</em> inside of the <em>getter</em>:<br><em>要使用另一个存储获取器，可以直接在获取器中_使用它_：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useOtherStore &#125; from &#39;.&#x2F;other-store&#39;export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    &#x2F;&#x2F; ...  &#125;),  getters: &#123;    otherGetter(state) &#123;      const otherStore &#x3D; useOtherStore()      return state.localData + otherStore.data    &#125;,  &#125;,&#125;)</code></pre><h2 id="Usage-with-setup"><a href="#Usage-with-setup" class="headerlink" title="Usage with setup()"></a>Usage with <code>setup()</code></h2><p>You can directly access any getter as a property of the store (exactly like state properties):<br><em>你可以直接在存储中作为属性访问任何获取器（精准地如同状态属性）：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default &#123;  setup() &#123;    const store &#x3D; useStore()    store.counter &#x3D; 3    store.doubleCount &#x2F;&#x2F; 6  &#125;,&#125;</code></pre><h2 id="Usage-with-the-Options-API"><a href="#Usage-with-the-Options-API" class="headerlink" title="Usage with the Options API"></a>Usage with the Options API</h2><p><VueSchoolLink  href="https://vueschool.io/lessons/access-pinia-getters-in-the-options-api"  title="Access Pinia Getters via the Options API"/></p><p>For the following examples, you can assume the following store was created:<br><em>对于下面的例子，你可以假设以下存储已创建：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; Example File Path:&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.jsimport &#123; defineStore &#125; from &#39;pinia&#39;,const useCounterStore &#x3D; defineStore(&#39;counterStore&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0  &#125;),  getters: &#123;    doubleCounter(state) &#123;      return state.counter * 2    &#125;  &#125;&#125;)</code></pre><h3 id="With-setup"><a href="#With-setup" class="headerlink" title="With setup()"></a>With <code>setup()</code></h3><p>While Composition API is not for everyone, the <code>setup()</code> hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!<br><em>而不是所有人都需要使用组合API，<code>setup()</code>钩子可以让Pinia更容易地在Options API中使用。没有额外的映射助手函数需要！</em></p><h2 id="这是一个优点"><a href="#这是一个优点" class="headerlink" title="这是一个优点"></a>这是一个优点</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  setup() &#123;    const counterStore &#x3D; useCounterStore()    return &#123; counterStore &#125;  &#125;,  computed: &#123;    quadrupleCounter() &#123;      return this.counterStore.doubleCounter * 2    &#125;,  &#125;,&#125;</code></pre><h3 id="Without-setup"><a href="#Without-setup" class="headerlink" title="Without setup()"></a>Without <code>setup()</code></h3><p>You can use the same <code>mapState()</code> function used in the <a href="./state.md#options-api">previous section of state</a> to map to getters:<br><em>你可以使用在<a href="./state.md#options-api">上一节状态</a>中使用的<code>mapState()</code>函数来映射到获取器：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; mapState &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  computed: &#123;    &#x2F;&#x2F; gives access to this.doubleCounter inside the component    &#x2F;&#x2F; same as reading from store.doubleCounter    ...mapState(useCounterStore, [&#39;doubleCount&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName    ...mapState(useCounterStore, &#123;      myOwnName: &#39;doubleCounter&#39;,      &#x2F;&#x2F; you can also write a function that gets access to the store      double: store &#x3D;&gt; store.doubleCount,    &#125;),  &#125;,&#125;</code></pre><h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><p><VueSchoolLink  href="https://vueschool.io/lessons/synchronous-and-asynchronous-actions-in-pinia"  title="Learn all about actions in Pinia"/></p><p>Actions are the equivalent of <a href="https://v3.vuejs.org/guide/data-methods.html#methods">methods</a> in components. They can be defined with the <code>actions</code> property in <code>defineStore()</code> and <strong>they are perfect to define business logic</strong>:<br><em>在<code>defineStore()</code>中定义的<code>actions</code>属性是组件的方法，它们可以用来定义业务逻辑：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const useStore &#x3D; defineStore(&#39;main&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0,  &#125;),  actions: &#123;    increment() &#123;      this.counter++    &#125;,    randomizeCounter() &#123;      this.counter &#x3D; Math.round(100 * Math.random())    &#125;,  &#125;,&#125;)</code></pre><p>Like <a href="./getters.md">getters</a>, actions get access to the <em>whole store instance</em> through <code>this</code> with <strong>full typing (and autocompletion ✨) support</strong>. <strong>Unlike getters, <code>actions</code> can be asynchronous</strong>, you can <code>await</code> inside of actions any API call or even other actions! Here is an example using <a href="https://github.com/posva/mande">Mande</a>. Note the library you use doesn’t matter as long as you get a <code>Promise</code>, you could even use the native <code>fetch</code> function (browser only):<br><em>像<a href="./getters.md">获取器</a>一样，actions可以通过<code>this</code>访问整个存储实例，<strong>它们可以是异步的</strong>，你可以在actions中使用<code>await</code>任何API调用或者可以使用其他actions！这里是一个使用[Mande](</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; mande &#125; from &#39;mande&#39;const api &#x3D; mande(&#39;&#x2F;api&#x2F;users&#39;)export const useUsers &#x3D; defineStore(&#39;users&#39;, &#123;  state: () &#x3D;&gt; (&#123;    userData: null,    &#x2F;&#x2F; ...  &#125;),  actions: &#123;    async registerUser(login, password) &#123;      try &#123;        this.userData &#x3D; await api.post(&#123; login, password &#125;)        showTooltip(&#96;Welcome back $&#123;this.userData.name&#125;!&#96;)      &#125; catch (error) &#123;        showTooltip(error)        &#x2F;&#x2F; let the form component display the error        return error      &#125;    &#125;,  &#125;,&#125;)</code></pre><p>You are also completely free to set whatever arguments you want and return anything. When calling actions, everything will be automatically inferred!<br><em>你可以设置任何参数和返回任何东西，当调用actions时，所有的东西都会自动推断！</em><br>Actions are invoked like methods:<br><em>actions像方法被调用：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default defineComponent(&#123;  setup() &#123;    const main &#x3D; useMainStore()    &#x2F;&#x2F; call the action as a method of the store    main.randomizeCounter()    return &#123;&#125;  &#125;,&#125;)</code></pre><h2 id="Accessing-other-stores-actions"><a href="#Accessing-other-stores-actions" class="headerlink" title="Accessing other stores actions"></a>Accessing other stores actions</h2><p>To use another store, you can directly <em>use it</em> inside of the <em>action</em>:<br><em>要使用另一个存储，你可以直接在_action_中使用它：</em></p><h2 id="这比react好用，可以嵌套"><a href="#这比react好用，可以嵌套" class="headerlink" title="这比react好用，可以嵌套"></a>这比react好用，可以嵌套</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useAuthStore &#125; from &#39;.&#x2F;auth-store&#39;export const useSettingsStore &#x3D; defineStore(&#39;settings&#39;, &#123;  state: () &#x3D;&gt; (&#123;    preferences: null,    &#x2F;&#x2F; ...  &#125;),  actions: &#123;    async fetchUserPreferences() &#123;      const auth &#x3D; useAuthStore()      if (auth.isAuthenticated) &#123;        this.preferences &#x3D; await fetchPreferences()      &#125; else &#123;        throw new Error(&#39;User must be authenticated&#39;)      &#125;    &#125;,  &#125;,&#125;)</code></pre><h2 id="Usage-with-setup-1"><a href="#Usage-with-setup-1" class="headerlink" title="Usage with setup()"></a>Usage with <code>setup()</code></h2><p>You can directly call any action as a method of the store:<br><em>你可以直接调用任何action作为store的方法：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default &#123;  setup() &#123;    const store &#x3D; useStore()    store.randomizeCounter()  &#125;,&#125;</code></pre><h2 id="Usage-with-the-Options-API-1"><a href="#Usage-with-the-Options-API-1" class="headerlink" title="Usage with the Options API"></a>Usage with the Options API</h2><p><VueSchoolLink  href="https://vueschool.io/lessons/access-pinia-actions-in-the-options-api"  title="Access Pinia Getters via the Options API"/></p><p>For the following examples, you can assume the following store was created:<br><em>对于下面的例子，你可以假设以下的存储已经创建：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; Example File Path:&#x2F;&#x2F; .&#x2F;src&#x2F;stores&#x2F;counterStore.jsimport &#123; defineStore &#125; from &#39;pinia&#39;,const useCounterStore &#x3D; defineStore(&#39;counterStore&#39;, &#123;  state: () &#x3D;&gt; (&#123;    counter: 0  &#125;),  actions: &#123;    increment() &#123;      this.counter++    &#125;  &#125;&#125;)</code></pre><h3 id="With-setup-1"><a href="#With-setup-1" class="headerlink" title="With setup()"></a>With <code>setup()</code></h3><p>While Composition API is not for everyone, the <code>setup()</code> hook can make using Pinia easier to work with in the Options API. No extra map helper functions needed!<br><em>Composition API不是所有人都能用，但是<code>setup()</code>钩子可以让Pinia更加简单地使用在Options API中，不需要额外的映射功能！</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  setup() &#123;    const counterStore &#x3D; useCounterStore()    return &#123; counterStore &#125;  &#125;,  methods: &#123;    incrementAndPrint() &#123;      this.counterStore.increment()      console.log(&#39;New Count:&#39;, this.counterStore.count)    &#125;,  &#125;,&#125;</code></pre><h3 id="Without-setup-1"><a href="#Without-setup-1" class="headerlink" title="Without setup()"></a>Without <code>setup()</code></h3><p>If you would prefer not to use Composition API at all, you can use the <code>mapActions()</code> helper to map actions properties as methods in your component:<br><em>如果你想不使用Composition API，你可以使用<code>mapActions()</code>助手来将actions属性映射为组件的方法：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; mapActions &#125; from &#39;pinia&#39;import &#123; useCounterStore &#125; from &#39;..&#x2F;stores&#x2F;counterStore&#39;export default &#123;  methods: &#123;    &#x2F;&#x2F; gives access to this.increment() inside the component    &#x2F;&#x2F; same as calling from store.increment()    ...mapActions(useCounterStore, [&#39;increment&#39;])    &#x2F;&#x2F; same as above but registers it as this.myOwnName()    ...mapActions(useCounterStore, &#123; myOwnName: &#39;doubleCounter&#39; &#125;),  &#125;,&#125;</code></pre><h2 id="Subscribing-to-actions"><a href="#Subscribing-to-actions" class="headerlink" title="Subscribing to actions"></a>Subscribing to actions</h2><p>It is possible to observe actions and their outcome with <code>store.$onAction()</code>. The callback passed to it is executed before the action itself. <code>after</code> handle promises and allows you to execute a function after the action resolves. In a similar way, <code>onError</code> allows you execute a function if the action throws or rejects. These are useful for tracking errors at runtime, similar to <a href="https://v3.vuejs.org/guide/tooling/deployment.html#tracking-runtime-errors">this tip in the Vue docs</a>.<br><em>可以使用<code>store.$onAction()</code>来观察actions和它们的结果。传入的回调会在action自身之前执行。<code>after</code>处理promises，允许你在action解决之后执行一个函数。同样，<code>onError</code>允许你在action抛出或者reject之后执行一个函数。这些是用于跟踪运行时错误的好方法，类似于<a href="https://v3.vuejs.org/guide/tooling/deployment.html#tracking-runtime-errors">这个提示在Vue文档</a>。</em><br>Here is an example that logs before running actions and after they resolve&#x2F;reject.<br><em>这是一个例子，它会在执行actions之前和之后解决&#x2F;reject。</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const unsubscribe &#x3D; someStore.$onAction(  (&#123;    name, &#x2F;&#x2F; name of the action    store, &#x2F;&#x2F; store instance, same as &#96;someStore&#96;    args, &#x2F;&#x2F; array of parameters passed to the action    after, &#x2F;&#x2F; hook after the action returns or resolves    onError, &#x2F;&#x2F; hook if the action throws or rejects  &#125;) &#x3D;&gt; &#123;    &#x2F;&#x2F; a shared variable for this specific action call    &#x2F;&#x2F; 共享变量，这个特定的action调用    const startTime &#x3D; Date.now()    &#x2F;&#x2F; this will trigger before an action on &#96;store&#96; is executed    &#x2F;&#x2F; 这将触发在&#96;store&#96;上执行action之前    console.log(&#96;Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#39;, &#39;)&#125;].&#96;)    &#x2F;&#x2F; this will trigger if the action succeeds and after it has fully run.    &#x2F;&#x2F; 这将触发如果action成功并且完成运行。    &#x2F;&#x2F; it waits for any returned promised    &#x2F;&#x2F;  它等待任何返回的promised    after((result) &#x3D;&gt; &#123;      console.log(        &#96;Finished &quot;$&#123;name&#125;&quot; after $&#123;          Date.now() - startTime        &#125;ms.\nResult: $&#123;result&#125;.&#96;      )    &#125;)    &#x2F;&#x2F; this will trigger if the action throws or returns a promise that rejects    &#x2F;&#x2F;  这将触发如果action抛出或者返回一个promise，reject    onError((error) &#x3D;&gt; &#123;      console.warn(        &#96;Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\nError: $&#123;error&#125;.&#96;      )    &#125;)  &#125;)&#x2F;&#x2F; manually remove the listener&#x2F;&#x2F; 手动移除监听器unsubscribe()</code></pre><p>By default, <em>action subscriptions</em> are bound to the component where they are added (if the store is inside a component’s <code>setup()</code>). Meaning, they will be automatically removed when the component is unmounted. If you want to keep them after the component is unmounted, pass <code>true</code> as the second argument to <em>detach</em> the <em>action subscription</em> from the current component:<br><em>默认情况下，action订阅是绑定到添加它们的组件（如果store在组件的setup中）。意思是，它们会在组件被卸载后自动移除。如果你想要保持它们在组件被卸载后，将第二个参数传递给_detach_action订阅_从当前组件：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default &#123;  setup() &#123;    const someStore &#x3D; useSomeStore()    &#x2F;&#x2F; this subscription will be kept after the component is unmounted    someStore.$onAction(callback, true)    &#x2F;&#x2F; ...  &#125;,&#125;</code></pre><h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><p>Pinia stores can be fully extended thanks to a low level API. Here is a list of things you can do:<br><em>Pinia stores可以完全扩展，通过一个低级API。这是一个列表，你可以做的事情：</em></p><ul><li>Add <code>new properties</code> to stores <em>给stores添加新的属性</em></li><li>Add <code>new options</code> when defining stores <em>在定义stores时添加新的选项</em></li><li>Add <code>new methods</code> to stores <em>给stores添加新的方法</em></li><li>Wrap <code>existing methods</code> <em>包装现有的方法</em></li><li>Change or even cancel <code>actions</code> <em>改变或取消actions</em></li><li>Implement side effects like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">Local Storage</a> <em>实现副作用效果，例如localStorage</em></li><li>Apply <strong>only</strong> to specific stores <em>只应用到特定的stores</em></li></ul><p>Plugins are added to the pinia instance with <code>pinia.use()</code>. The simplest example is adding a static property to all stores by returning an object:<br><em>插件是添加到pinia实例的<code>pinia.use()</code>。最简单的例子是添加一个静态属性到所有stores，通过返回一个对象：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; createPinia &#125; from &#39;pinia&#39;&#x2F;&#x2F; add a property named &#96;secret&#96; to every store that is created after this plugin is installed&#x2F;&#x2F; this could be in a different filefunction SecretPiniaPlugin() &#123;  return &#123; secret: &#39;the cake is a lie&#39; &#125;&#125;const pinia &#x3D; createPinia()&#x2F;&#x2F; give the plugin to piniapinia.use(SecretPiniaPlugin)&#x2F;&#x2F; in another fileconst store &#x3D; useStore()store.secret &#x2F;&#x2F; &#39;the cake is a lie&#39;</code></pre><p>This is useful to add global objects like the router, modal, or toast managers.<br><em>这是有用的，例如router、modal或toast管理器</em></p><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>A Pinia plugin is a function that optionally returns properties to be added to a store. It takes one optional argument, a <em>context</em>:<br><em>一个Pinia插件是一个可选的返回属性的函数。它只接受一个可选的参数，一个_context_：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export function myPiniaPlugin(context) &#123;  context.pinia &#x2F;&#x2F; the pinia created with &#96;createPinia()&#96;   context.app &#x2F;&#x2F; the current app created with &#96;createApp()&#96; (Vue 3 only)  context.store &#x2F;&#x2F; the store the plugin is augmenting  context.options &#x2F;&#x2F; the options object defining the store passed to &#96;defineStore()&#96;  &#x2F;&#x2F; ...&#125;</code></pre><p>This function is then passed to <code>pinia</code> with <code>pinia.use()</code>:<br><em>这个函数是通过<code>pinia.use()</code>传递给<code>pinia</code>：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">pinia.use(myPiniaPlugin)</code></pre><p>Plugins are only applied to stores <strong>created after <code>pinia</code> is passed to the app</strong>, otherwise they won’t be applied.<br><em>插件只应用到stores <strong>在<code>pinia</code>被传递给app后创建</strong>，否则它们不会应用</em></p><h2 id="Augmenting-a-Store"><a href="#Augmenting-a-Store" class="headerlink" title="Augmenting a Store"></a>Augmenting a Store</h2><p>You can add properties to every store by simply returning an object of them in a plugin:<br><em>你可以通过返回一个对象来给每个store添加属性</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">pinia.use(() &#x3D;&gt; (&#123; hello: &#39;world&#39; &#125;))</code></pre><p>You can also set the property directly on the <code>store</code> but <strong>if possible use the return version so they can be automatically tracked by devtools</strong>:<br><em>你也可以直接给store设置属性，但是<strong>如果可能，请使用返回版本，以便它们可以被自动追踪</strong></em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.hello &#x3D; &#39;world&#39;&#125;)</code></pre><p>Any property <em>returned</em> by a plugin will be automatically tracked by devtools so in order to make <code>hello</code> visible in devtools, make sure to add it to <code>store._customProperties</code> <strong>in dev mode only</strong> if you want to debug it in devtools:<br>_任何插件返回的属性都会被自动追踪被devtools追踪，所以要让hello可见在devtools，请在dev模式下，如果你想要调试它在devtools，请在store.<em>customProperties中添加它：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; from the example abovepinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.hello &#x3D; &#39;world&#39;  &#x2F;&#x2F; make sure your bundler handle this. webpack and vite should do it by default  &#x2F;&#x2F; 确定你的bundler处理这个。默认情况webpack和vite应该做它  if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39;) &#123;    &#x2F;&#x2F; add any keys you set on the store    &#x2F;&#x2F; 在store上添加任何你设置的键    store._customProperties.add(&#39;hello&#39;)  &#125;&#125;)</code></pre><p>Note that every store is wrapped with <a href="https://v3.vuejs.org/api/basic-reactivity.html#reactive"><code>reactive</code></a>, automatically unwrapping any Ref (<code>ref()</code>, <code>computed()</code>, …) it contains:<br><em>注意，每个store都会被包裹在<a href="https://v3.vuejs.org/api/basic-reactivity.html#reactive"><code>reactive</code></a>，自动解开任何Ref（<code>ref()</code>, <code>computed()</code>, …）它包含：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const sharedRef &#x3D; ref(&#39;shared&#39;)pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; each store has its individual &#96;hello&#96; property  &#x2F;&#x2F; 每个store都有它自己的&#96;hello&#96;属性  store.hello &#x3D; ref(&#39;secret&#39;)  &#x2F;&#x2F; it gets automatically unwrapped  &#x2F;&#x2F; 这会被自动解开  store.hello &#x2F;&#x2F; &#39;secret&#39;  &#x2F;&#x2F; all stores are sharing the value &#96;shared&#96; property  &#x2F;&#x2F; 所有store共享&#96;shared&#96;属性  store.shared &#x3D; sharedRef  store.shared &#x2F;&#x2F; &#39;shared&#39;&#125;)</code></pre><p>This is why you can access all computed properties without <code>.value</code> and why they are reactive.<br><em>这是为什么你可以不使用<code>.value</code>来访问所有计算属性，并且它们是反应性的</em></p><h3 id="Adding-new-state"><a href="#Adding-new-state" class="headerlink" title="Adding new state"></a>Adding new state</h3><p>If you want to add new state properties to a store or properties that are meant to be used during hydration, <strong>you will have to add it in two places</strong>:<br><em>如果你想要给store或者想要在同构时使用的属性，你需要在两处添加：</em></p><ul><li>On the <code>store</code> so you can access it with <code>store.myState</code> <em>在store上你可以通过<code>store.myState</code>访问它</em></li><li>On <code>store.$state</code> so it can be used in devtools and, <strong>be serialized during SSR</strong>. <em>在store.$state上你可以访问它在devtools和，<strong>在SSR时会被序列化</strong></em></li></ul><p>On top of that, you will certainly have to use a <code>ref()</code> (or other reactive API) in order to share the value across different accesses:<br><em>在顶部，你必须使用<code>ref()</code>（或其他反应性API）来共享值：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; toRef, ref &#125; from &#39;vue&#39;pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  &#x2F;&#x2F; to correctly handle SSR, we need to make sure we are not overriding an  &#x2F;&#x2F; existing value  &#x2F;&#x2F; 为了正确处理SSR，我们需要确保我们不会覆盖现有值  if (!Object.prototype.hasOwnProperty(store.$state, &#39;hasError&#39;)) &#123;    &#x2F;&#x2F; hasError is defined within the plugin, so each store has their individual    &#x2F;&#x2F; state property    &#x2F;&#x2F; hasError是在插件中定义的，所以每个store都有它自己的状态属性    const hasError &#x3D; ref(false)    &#x2F;&#x2F; setting the variable on &#96;$state&#96;, allows it be serialized during SSR    &#x2F;&#x2F; 设置它在&#96;$state&#96;，这样它可以在SSR时被序列化    store.$state.hasError &#x3D; hasError  &#125;  &#x2F;&#x2F; we need to transfer the ref from the state to the store, this way  &#x2F;&#x2F; both accesses: store.hasError and store.$state.hasError will work  &#x2F;&#x2F; and share the same variable  &#x2F;&#x2F; 我们需要将ref从状态传递给store，这样两个访问：store.hasError和store.$state.hasError都可以使用，并且共享相同的变量  &#x2F;&#x2F; See https:&#x2F;&#x2F;vuejs.org&#x2F;api&#x2F;reactivity-utilities.html#toref  store.hasError &#x3D; toRef(store.$state, &#39;hasError&#39;)  &#x2F;&#x2F; in this case it&#39;s better not to return &#96;hasError&#96; since it  &#x2F;&#x2F; will be displayed in the &#96;state&#96; section in the devtools  &#x2F;&#x2F; anyway and if we return it, devtools will display it twice.  &#x2F;&#x2F; 在这种情况下，我们不应该返回&#96;hasError&#96;，因为它将在devtools的&#96;state&#96;部分显示两次&#125;)</code></pre><p>Note that state changes or additions that occur within a plugin (that includes calling <code>store.$patch()</code>) happen before the store is active and therefore <strong>do not trigger any subscriptions</strong>.<br><em>注意，在插件中（包括调用<code>store.$patch()</code>）发生的状态变化或添加（包括调用<code>store.$patch()</code>）<strong>不会触发任何订阅</strong>。</em><br>:::warning<br>If you are using <strong>Vue 2</strong>, Pinia is subject to the <a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">same reactivity caveats</a> as Vue. You will need to use <code>set</code> from <code>@vue/composition-api</code> when creating new state properties like <code>secret</code> and <code>hasError</code>:<br><em>如果你使用<strong>Vue 2</strong>，Pinia将受到<a href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats">同类型反应性问题</a>。你需要使用<code>set</code>来创建新的状态属性，如<code>secret</code>和<code>hasError</code>：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; set, toRef &#125; from &#39;@vue&#x2F;composition-api&#39;pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  if (!Object.prototype.hasOwnProperty(store.$state, &#39;hello&#39;)) &#123;    const secretRef &#x3D; ref(&#39;secret&#39;)    &#x2F;&#x2F; If the data is meant to be used during SSR, you should    &#x2F;&#x2F; set it on the &#96;$state&#96; property so it is serialized and    &#x2F;&#x2F; picked up during hydration    &#x2F;&#x2F; 如果数据是在SSR时使用的，你应该将它设置在&#96;$state&#96;属性，这样它将被序列化并在同构时被提取    set(store.$state, &#39;secret&#39;, secretRef)  &#125;  &#x2F;&#x2F; set it directly on the store too so you can access it  &#x2F;&#x2F; both ways: &#96;store.$state.secret&#96; &#x2F; &#96;store.secret&#96;  &#x2F;&#x2F; 在store上直接设置它，这样你可以在两种方式：&#96;store.$state.secret&#96; &#x2F; &#96;store.secret&#96;  set(store, &#39;secret&#39;, toRef(store.$state, &#39;secret&#39;))  store.secret &#x2F;&#x2F; &#39;secret&#39;&#125;)</code></pre><p>:::</p><h2 id="Adding-new-external-properties"><a href="#Adding-new-external-properties" class="headerlink" title="Adding new external properties"></a>Adding new external properties</h2><p>When adding external properties, class instances that come from other libraries, or simply things that are not reactive, you should wrap the object with <code>markRaw()</code> before passing it to pinia. Here is an example adding the router to every store:<br><em>当添加外部属性时，类实例来自其他库，或者只是不反应性的东西，你应该在传递之前使用<code>markRaw()</code>。这是一个例子，将路由添加到每个store：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; markRaw &#125; from &#39;vue&#39;&#x2F;&#x2F; adapt this based on where your router is&#x2F;&#x2F; 基于你的路由在这里适配import &#123; router &#125; from &#39;.&#x2F;router&#39;pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.router &#x3D; markRaw(router)&#125;)</code></pre><h2 id="Calling-subscribe-inside-plugins"><a href="#Calling-subscribe-inside-plugins" class="headerlink" title="Calling $subscribe inside plugins"></a>Calling <code>$subscribe</code> inside plugins</h2><p>You can use <a href="./state.md#subscribing-to-the-state">store.$subscribe</a> and <a href="./actions.md#subscribing-to-actions">store.$onAction</a> inside plugins too:<br><em>你可以在插件中使用<a href="./state.md#subscribing-to-the-state">store.$subscribe</a>和<a href="./actions.md#subscribing-to-actions">store.$onAction</a>：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.$subscribe(() &#x3D;&gt; &#123;    &#x2F;&#x2F; react to store changes    &#x2F;&#x2F; 响应store变化  &#125;)  store.$onAction(() &#x3D;&gt; &#123;    &#x2F;&#x2F; react to store actions    &#x2F;&#x2F; 响应store动作  &#125;)&#125;)</code></pre><h2 id="Adding-new-options"><a href="#Adding-new-options" class="headerlink" title="Adding new options"></a>Adding new options</h2><p>It is possible to create new options when defining stores to later on consume them from plugins. For example, you could create a <code>debounce</code> option that allows you to debounce any action:<br><em>可以在定义store时创建新的选项，以便以后从插件中消费。例如，你可以创建一个<code>debounce</code>选项，允许你将任何动作debounce：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">defineStore(&#39;search&#39;, &#123;  actions: &#123;    searchContacts() &#123;      &#x2F;&#x2F; ...    &#125;,  &#125;,  &#x2F;&#x2F; this will be read by a plugin later on  &#x2F;&#x2F; 将被插件后面读取  debounce: &#123;    &#x2F;&#x2F; debounce the action searchContacts by 300ms    &#x2F;&#x2F; 延迟动作searchContacts 300ms    searchContacts: 300,  &#125;,&#125;)</code></pre><p>The plugin can then read that option to wrap actions and replace the original ones:<br><em>插件可以读取这个选项，以便包装动作并替换原始动作：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; use any debounce libraryimport debounce from &#39;lodash&#x2F;debounce&#39;pinia.use((&#123; options, store &#125;) &#x3D;&gt; &#123;  if (options.debounce) &#123;    &#x2F;&#x2F; we are overriding the actions with new ones    &#x2F;&#x2F; 我们覆盖了动作 compose    return Object.keys(options.debounce).reduce((debouncedActions, action) &#x3D;&gt; &#123;      debouncedActions[action] &#x3D; debounce(        store[action],        options.debounce[action]      )      return debouncedActions    &#125;, &#123;&#125;)  &#125;&#125;)</code></pre><p>Note that custom options are passed as the 3rd argument when using the setup syntax:<br><em>注意，自定义选项会作为第三个参数传递给setup语法：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">defineStore(  &#39;search&#39;,  () &#x3D;&gt; &#123;    &#x2F;&#x2F; ...  &#125;,  &#123;    &#x2F;&#x2F; this will be read by a plugin later on    &#x2F;&#x2F; 将被插件后面读取    debounce: &#123;      &#x2F;&#x2F; debounce the action searchContacts by 300ms      &#x2F;&#x2F; 延迟动作searchContacts 300ms      searchContacts: 300,    &#125;,  &#125;)</code></pre><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>Everything shown above can be done with typing support, so you don’t ever need to use <code>any</code> or <code>@ts-ignore</code>.<br><em>所有上面的都可以使用类型支持，所以你永远不需要使用<code>any</code>或<code>@ts-ignore</code>。</em></p><h3 id="Typing-plugins"><a href="#Typing-plugins" class="headerlink" title="Typing plugins"></a>Typing plugins</h3><p>A Pinia plugin can be typed as follows:<br><em>一个Pinia插件可以如下类型：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; PiniaPluginContext &#125; from &#39;pinia&#39;export function myPiniaPlugin(context: PiniaPluginContext) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><h3 id="Typing-new-store-properties"><a href="#Typing-new-store-properties" class="headerlink" title="Typing new store properties"></a>Typing new store properties</h3><p>When adding new properties to stores, you should also extend the <code>PiniaCustomProperties</code> interface.<br><em>当添加新的属性到store时，你应该同时扩展<code>PiniaCustomProperties</code>接口。</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface PiniaCustomProperties &#123;    &#x2F;&#x2F; by using a setter we can allow both strings and refs    &#x2F;&#x2F; 使用setter，我们可以允许字符串和refs    set hello(value: string | Ref&lt;string&gt;)    get hello(): string    &#x2F;&#x2F; you can define simpler values too    &#x2F;&#x2F; 你也可以定义简单的值    simpleNumber: number  &#125;&#125;</code></pre><p>It can then be written and read safely:<br><em>然后可以安全的写和读：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">pinia.use((&#123; store &#125;) &#x3D;&gt; &#123;  store.hello &#x3D; &#39;Hola&#39;  store.hello &#x3D; ref(&#39;Hola&#39;)  store.simpleNumber &#x3D; Math.random()  &#x2F;&#x2F; @ts-expect-error: we haven&#39;t typed this correctly  store.simpleNumber &#x3D; ref(Math.random())&#125;)</code></pre><p><code>PiniaCustomProperties</code> is a generic type that allows you to reference properties of a store. Imagine the following example where we copy over the initial options as <code>$options</code> (this would only work for option stores):<br><em><code>PiniaCustomProperties</code>是一个泛型类型，允许你引用store的属性。假设我们将初始选项复制到<code>$options</code>（这只对选项store有效）：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">pinia.use((&#123; options &#125;) &#x3D;&gt; (&#123; $options: options &#125;))</code></pre><p>We can properly type this by using the 4 generic types of <code>PiniaCustomProperties</code>:<br><em>我们可以通过使用<code>PiniaCustomProperties</code>的4个泛型类型来确定类型：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface PiniaCustomProperties&lt;Id, S, G, A&gt; &#123;    $options: &#123;      id: Id      state?: () &#x3D;&gt; S      getters?: G      actions?: A    &#125;  &#125;&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>When extending types in generics, they must be named <strong>exactly as in the source code</strong>. <code>Id</code> cannot be named <code>id</code> or <code>I</code>, and <code>S</code> cannot be named <code>State</code>. Here is what every letter stands for:<br><em>在泛型中扩展类型时，它们必须与源代码中的名称完全一致。<code>Id</code>不能命名为<code>id</code>或<code>I</code>，<code>S</code>不能命名为<code>State</code>。这里是每个字母的含义：</em></p><ul><li>S: State</li><li>G: Getters</li><li>A: Actions</li><li>SS: Setup Store &#x2F; Store</li></ul></p></div><h3 id="Typing-new-state"><a href="#Typing-new-state" class="headerlink" title="Typing new state"></a>Typing new state</h3><p>When adding new state properties (to both, the <code>store</code> and <code>store.$state</code>), you need to add the type to <code>PiniaCustomStateProperties</code> instead. Differently from <code>PiniaCustomProperties</code>, it only receives the <code>State</code> generic:<br><em>当添加新的状态属性（到store和store.$state）时，你需要添加类型到<code>PiniaCustomStateProperties</code>，不同于<code>PiniaCustomProperties</code>，它只接收<code>State</code>泛型：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface PiniaCustomStateProperties&lt;S&gt; &#123;    hello: string  &#125;&#125;</code></pre><h3 id="Typing-new-creation-options"><a href="#Typing-new-creation-options" class="headerlink" title="Typing new creation options"></a>Typing new creation options</h3><p>When creating new options for <code>defineStore()</code>, you should extend the <code>DefineStoreOptionsBase</code>. Differently from <code>PiniaCustomProperties</code>, it only exposes two generics: the State and the Store type, allowing you to limit what can be defined. For example, you can use the names of the actions:<br><em>当创建新的选项for<code>defineStore()</code>时，你应该扩展<code>DefineStoreOptionsBase</code>。不同于<code>PiniaCustomProperties</code>，它只公开两个泛型：状态和store类型，允许你限制可以定义。例如，你可以使用actions的名称：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#39;pinia&#39;declare module &#39;pinia&#39; &#123;  export interface DefineStoreOptionsBase&lt;S, Store&gt; &#123;    &#x2F;&#x2F; allow defining a number of ms for any of the actions    &#x2F;&#x2F; 允许定义任意的ms的任何一个actions    debounce?: Partial&lt;Record&lt;keyof StoreActions&lt;Store&gt;, number&gt;&gt;  &#125;&#125;</code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>There is also a <code>StoreGetters</code> type to extract the <em>getters</em> from a Store type. You can also extend the options of <em>setup stores</em> or <em>option stores</em> <strong>only</strong> by extending the types <code>DefineStoreOptions</code> and <code>DefineSetupStoreOptions</code> respectively.<br><em>有一个<code>StoreGetters</code>类型来提取store的_getters_。你也可以扩展_setup stores_或_option stores_的选项，只需扩展types<code>DefineStoreOptions</code>和<code>DefineSetupStoreOptions</code>。</em></p></div><h2 id="Nuxt-js"><a href="#Nuxt-js" class="headerlink" title="Nuxt.js"></a>Nuxt.js</h2><p>When <a href="../ssr/nuxt.md">using pinia alongside Nuxt</a>, you will have to create a <a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins">Nuxt plugin</a> first. This will give you access to the <code>pinia</code> instance:<br><em>当使用pinia与Nuxt一起使用（ssr&#x2F;nuxt.md），你需要先创建一个<a href="https://nuxtjs.org/docs/2.x/directory-structure/plugins">Nuxt plugin</a>。这将会给你访问pinia实例：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; plugins&#x2F;myPiniaPlugin.jsimport &#123; PiniaPluginContext &#125; from &#39;pinia&#39;import &#123; Plugin &#125; from &#39;@nuxt&#x2F;types&#39;function MyPiniaPlugin(&#123; store &#125;: PiniaPluginContext) &#123;  store.$subscribe((mutation) &#x3D;&gt; &#123;    &#x2F;&#x2F; react to store changes    &#x2F;&#x2F; 响应store变化    console.log(&#96;[🍍 $&#123;mutation.storeId&#125;]: $&#123;mutation.type&#125;.&#96;)  &#125;)  &#x2F;&#x2F; Note this has to be typed if you are using TS  &#x2F;&#x2F; 注意，如果你使用TS，这必须是类型化的  return &#123; creationTime: new Date() &#125;&#125;const myPlugin: Plugin &#x3D; (&#123; $pinia &#125;) &#x3D;&gt; &#123;  $pinia.use(MyPiniaPlugin)&#125;export default myPlugin</code></pre><p>Note the above example is using TypeScript, you have to remove the type annotations <code>PiniaPluginContext</code> and <code>Plugin</code> as well as their imports if you are using a <code>.js</code> file.<br><em>注意，上面的例子使用TypeScript，如果你使用了<code>.js</code>文件,你需要移除类型标注<code>PiniaPluginContext</code>和<code>Plugin</code>。</em></p><h1 id="Using-a-store-outside-of-a-component"><a href="#Using-a-store-outside-of-a-component" class="headerlink" title="Using a store outside of a component"></a>Using a store outside of a component</h1><p>Pinia stores rely on the <code>pinia</code> instance to share the same store instance across all calls. Most of the time, this works out of the box by just calling your <code>useStore()</code> function. For example, in <code>setup()</code>, you don’t need to do anything else. But things are a bit different outside of a component.<br>Behind the scenes, <code>useStore()</code> <em>injects</em> the <code>pinia</code> instance you gave to your <code>app</code>. This means that if the <code>pinia</code> instance cannot be automatically injected, you have to manually provide it to the <code>useStore()</code> function.<br>You can solve this differently depending on the kind of application you are writing.<br><em>Pinia 存储依赖于pinia实例来共享同一个store实例。大多数时候，这是通过调用你的useStore()函数来实现的。例如，在setup()中，你不需要做任何其他事情。但是，在一个组件之外，事情是有所不同的。</em></p><h2 id="Single-Page-Applications"><a href="#Single-Page-Applications" class="headerlink" title="Single Page Applications"></a>Single Page Applications</h2><p>If you are not doing any SSR (Server Side Rendering), any call of <code>useStore()</code> after installing the pinia plugin with <code>app.use(pinia)</code> will work:<br><em>如果你不是做任何SSR（服务器端渲染），在安装pinia插件后调用useStore()后，它将会工作：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useUserStore &#125; from &#39;@&#x2F;stores&#x2F;user&#39;import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;&#x2F;&#x2F; ❌  fails because it&#39;s called before the pinia is created&#x2F;&#x2F; ❌  因为它在pinia创建之前被调用const userStore &#x3D; useUserStore()const pinia &#x3D; createPinia()const app &#x3D; createApp(App)app.use(pinia)&#x2F;&#x2F; ✅ works because the pinia instance is now active&#x2F;&#x2F; ✅ 因为pinia实例现在已经激活const userStore &#x3D; useUserStore()</code></pre><p>The easiest way to ensure this is always applied is to <em>defer</em> calls of <code>useStore()</code> by placing them inside functions that will always run after pinia is installed.<br><em>最简单的方法是通过将useStore()函数放在函数中，来保证它总是在pinia安装后才被调用。</em><br>Let’s take a look at this example of using a store inside of a navigation guard with Vue Router:<br><em>看一下使用store在导航守卫中的例子：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; createRouter &#125; from &#39;vue-router&#39;const router &#x3D; createRouter(&#123;  &#x2F;&#x2F; ...&#125;)&#x2F;&#x2F; ❌ Depending on the order of imports this will fail&#x2F;&#x2F; ❌ 取决于导入的顺序，这将会失败const store &#x3D; useStore()router.beforeEach((to, from, next) &#x3D;&gt; &#123;  &#x2F;&#x2F; we wanted to use the store here  &#x2F;&#x2F; 我们想要使用store这里  if (store.isLoggedIn) next()  else next(&#39;&#x2F;login&#39;)&#125;)router.beforeEach((to) &#x3D;&gt; &#123;  &#x2F;&#x2F; ✅ This will work because the router starts its navigation after  &#x2F;&#x2F; the router is installed and pinia will be installed too  &#x2F;&#x2F; ✅ 这将会工作，因为路由开始导航之后，pinia也会被安装  const store &#x3D; useStore()  if (to.meta.requiresAuth &amp;&amp; !store.isLoggedIn) return &#39;&#x2F;login&#39;&#125;)</code></pre><h2 id="SSR-Apps"><a href="#SSR-Apps" class="headerlink" title="SSR Apps"></a>SSR Apps</h2><p>When dealing with Server Side Rendering, you will have to pass the <code>pinia</code> instance to <code>useStore()</code>. This prevents pinia from sharing global state between different application instances.<br><em>在服务器端渲染的应用中，你需要传递pinia实例给useStore()。这将阻止pinia在不同应用实例之间共享全局状态。</em><br>There is a whole section dedicated to it in the <a href="/ssr/index.md">SSR guide</a>, this is just a short explanation:<br><em>在<a href="/ssr/index.md">SSR指南</a>中有一个专门的章节，这只是一个简短的说明：</em></p><h1 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h1><h1 id="Usage-without-setup"><a href="#Usage-without-setup" class="headerlink" title="Usage without setup()"></a>Usage without <code>setup()</code></h1><p>Pinia can be used even if you are not using the composition API (if you are using Vue 2, you still need to install the <code>@vue/composition-api</code> plugin though). While we recommend you to give the Composition API a try and learn it, it might not be the time for you and your team yet, you might be in the process of migrating an application, or any other reason. There are a few functions:<br><em>Pinia可以被使用，即使你不使用组合API（如果你使用Vue 2，你仍然需要安装<code>@vue/composition-api</code>插件）。但是我们建议你试一试组合API，然后学习它，非团队合作，你可能正在迁移一个应用，或者其他任何原因。有一些函数：</em></p><ul><li><a href="#giving-access-to-the-whole-store">mapStores</a></li><li><a href="../core-concepts/state.md#options-api">mapState</a></li><li><a href="../core-concepts/state.md#modifiable-state">mapWritableState</a></li><li>⚠️ <a href="../core-concepts/getters.md#options-api">mapGetters</a> (just for migration convenience, use <code>mapState()</code> instead)</li><li><a href="../core-concepts/actions.md#options-api">mapActions</a></li></ul><h2 id="Giving-access-to-the-whole-store"><a href="#Giving-access-to-the-whole-store" class="headerlink" title="Giving access to the whole store"></a>Giving access to the whole store</h2><p>If you need to access pretty much everything from the store, it might be too much to map every single property of the store… Instead you can get access to the whole store with <code>mapStores()</code>:<br><em>如果你需要访问整个store，可能会太多了，可以使用mapStores()来访问整个store：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; mapStores &#125; from &#39;pinia&#39;&#x2F;&#x2F; given two stores with the following ids&#x2F;&#x2F; 给定两个store，其id为：const useUserStore &#x3D; defineStore(&#39;user&#39;, &#123;  &#x2F;&#x2F; ...&#125;)const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  &#x2F;&#x2F; ...&#125;)export default &#123;  computed: &#123;    &#x2F;&#x2F; note we are not passing an array, just one store after the other    &#x2F;&#x2F; each store will be accessible as its id + &#39;Store&#39;    &#x2F;&#x2F; 注意我们不传递数组，而是一个store一个store    ...mapStores(useCartStore, useUserStore)  &#125;,  methods: &#123;    async buyStuff() &#123;      &#x2F;&#x2F; use them anywhere!      &#x2F;&#x2F; 使用它们任何地方！      if (this.userStore.isAuthenticated()) &#123;        await this.cartStore.buy()        this.$router.push(&#39;&#x2F;purchased&#39;)      &#125;    &#125;,  &#125;,&#125;</code></pre><p>By default, Pinia will add the <code>&quot;Store&quot;</code> suffix to the <code>id</code> of each store. You can customize this behavior by calling the <code>setMapStoreSuffix()</code>:<br><em>默认情况下，Pinia将添加“Store”后缀到每个store的id。你可以通过调用setMapStoreSuffix()来自定义这个行为：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; createPinia, setMapStoreSuffix &#125; from &#39;pinia&#39;&#x2F;&#x2F; completely remove the suffix: this.user, this.cart&#x2F;&#x2F; 完全删除后缀：this.user, this.cartsetMapStoreSuffix(&#39;&#39;)&#x2F;&#x2F; this.user_store, this.cart_store (it&#39;s okay, I won&#39;t judge you)&#x2F;&#x2F; 这个user_store, this.cart_store（也是可以的）setMapStoreSuffix(&#39;_store&#39;)export const pinia &#x3D; createPinia()</code></pre><h2 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>By default, all map helpers support autocompletion and you don’t need to do anything. If you call <code>setMapStoreSuffix()</code> to change the <code>&quot;Store&quot;</code> suffix, you will need to also add it somewhere in a TS file or your <code>global.d.ts</code> file. The most convenient place would be the same place where you call <code>setMapStoreSuffix()</code>:<br><em>默认情况下，所有map helpers都支持自动完成，你不需要做任何事情。如果你调用setMapStoreSuffix()来改变“Store”后缀，你还需要在TS文件或你的global.d.ts文件中添加它。最方便的地方就是在你调用setMapStoreSuffix()的地方：</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; createPinia, setMapStoreSuffix &#125; from &#39;pinia&#39;&#x2F;&#x2F; completely remove the suffix&#x2F;&#x2F; 完全删除后缀setMapStoreSuffix(&#39;&#39;) export const pinia &#x3D; createPinia()declare module &#39;pinia&#39; &#123;  export interface MapStoresCustomization &#123;    &#x2F;&#x2F; set it to the same value as above    &#x2F;&#x2F; 设置为上面的值    suffix: &#39;&#39;  &#125;&#125;</code></pre><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>If you are using a TypeScript declaration file (like <code>global.d.ts</code>), make sure to <code>import &#39;pinia&#39;</code> at the top of it to expose all existing types.<br><em>如果你使用了一个TypeScript声明文件（例如<code>global.d.ts</code>），请在它的顶部导入<code>pinia</code>来对所有现有类型进行暴露。</em></p></div><h1 id="Composing-Stores"><a href="#Composing-Stores" class="headerlink" title="Composing Stores"></a>Composing Stores</h1><p>Composing stores is about having stores that use each other and there is one rule to follow:<br><em>组合store是关于有store使用另一个store的事情，有一条规则要遵守：</em><br>If <strong>two or more stores use each other</strong>, they cannot create an infinite loop through <em>getters</em> or <em>actions</em>. They cannot <strong>both</strong> directly read each other state in their setup function:<br><em>如果两个或多个store使用了另一个store，那么它们不能通过_getters_或_actions_创建无限循环。它们不能同时直接读取另一个store的状态：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const useX &#x3D; defineStore(&#39;x&#39;, () &#x3D;&gt; &#123;  const y &#x3D; useY()  &#x2F;&#x2F; ❌ This is not possible because y also tries to read x.name  &#x2F;&#x2F; ❌ 这是不可能的，因为y也试图读取x的name  y.name  function doSomething() &#123;    &#x2F;&#x2F; ✅ Read y properties in computed or actions    &#x2F;&#x2F; ✅ 读取y属性在computed或actions    const yName &#x3D; y.name    &#x2F;&#x2F; ...  &#125;  return &#123;    name: ref(&#39;I am X&#39;),  &#125;&#125;)const useY &#x3D; defineStore(&#39;y&#39;, () &#x3D;&gt; &#123;  const x &#x3D; useX()  &#x2F;&#x2F; ❌ This is not possible because x also tries to read y.name  &#x2F;&#x2F; ❌ 这是不可能的，因为x也试图读取y的name  x.name  function doSomething() &#123;    &#x2F;&#x2F; ✅ Read x properties in computed or actions    &#x2F;&#x2F; ✅ 读取x属性在computed或actions    const xName &#x3D; x.name    &#x2F;&#x2F; ...  &#125;  return &#123;    name: ref(&#39;I am Y&#39;),  &#125;&#125;)</code></pre><h2 id="Nested-stores"><a href="#Nested-stores" class="headerlink" title="Nested stores"></a>Nested stores</h2><p>Note that if one store uses another store, <strong>there is no need to create a new store in a separate file</strong>, you can directly import it. Think of it as nesting.<br><em>如果一个store使用另一个store，<strong>不需要在一个单独的文件中创建一个新的store</strong>，你可以直接导入它。记住它是嵌套的。</em><br>You can call <code>useOtherStore()</code> at the top of any getter or action:<br><em>你可以在任何getter或action的顶部调用useOtherStore()：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;export const cartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  getters: &#123;    &#x2F;&#x2F; ... other getters    summary(state) &#123;      const user &#x3D; useUserStore()      return &#96;Hi $&#123;user.name&#125;, you have $&#123;state.list.length&#125; items in your cart. It costs $&#123;state.price&#125;.&#96;    &#125;,  &#125;,  actions: &#123;    purchase() &#123;      const user &#x3D; useUserStore()      return apiPurchase(user.id, this.list)    &#125;,  &#125;,&#125;)</code></pre><h2 id="Shared-Getters"><a href="#Shared-Getters" class="headerlink" title="Shared Getters"></a>Shared Getters</h2><p>You can simply call <code>useOtherStore()</code> inside a <em>getter</em>:<br><em>你可以在_getter_中直接调用useOtherStore()：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; defineStore &#125; from &#39;pinia&#39;import &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;export const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  getters: &#123;    summary(state) &#123;      const user &#x3D; useUserStore()      return &#96;Hi $&#123;user.name&#125;, you have $&#123;state.list.length&#125; items in your cart. It costs $&#123;state.price&#125;.&#96;    &#125;,  &#125;,&#125;)</code></pre><h2 id="Shared-Actions"><a href="#Shared-Actions" class="headerlink" title="Shared Actions"></a>Shared Actions</h2><p>The same applies to <em>actions</em>:<br><em>同样适用于_actions_：</em></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; defineStore &#125; from &#39;pinia&#39;import &#123; useUserStore &#125; from &#39;.&#x2F;user&#39;export const useCartStore &#x3D; defineStore(&#39;cart&#39;, &#123;  actions: &#123;    async orderCart() &#123;      const user &#x3D; useUserStore()      try &#123;        await apiOrderCart(user.token, this.items)        &#x2F;&#x2F; another action        this.emptyCart()      &#125; catch (err) &#123;        displayError(err)      &#125;    &#125;,  &#125;,&#125;)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript 数组对象方法实现原理</title>
      <link href="//post/2022-06-10js-arr.html"/>
      <url>//post/2022-06-10js-arr.html</url>
      
        <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><strong>定义</strong></p><ul><li>map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值</li><li>map()方法按照原始数组元素顺序一次处理元素</li></ul><p><strong>注意</strong></p><ul><li>map()不会对空数组进行检测</li><li>map()方法返回的是一个新数组，而不是原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.proptotype.myMap &#x3D; function (fn) &#123;  let arr &#x3D; [];  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    arr.push(fn(this[i], i, this));  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myMap((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item * 2;&#125;);&#x2F;&#x2F; 1 0  [1, 2, 3]&#x2F;&#x2F; 2 1  [1, 2, 3]&#x2F;&#x2F; 3 2  [1, 2, 3]&#x2F;&#x2F; [2, 4, 6]</code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><strong>定义</strong></p><ul><li>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素</li></ul><p><strong>注意</strong></p><ul><li>filter()方法不会对空数组进行遍历</li><li>filter()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myFilter &#x3D; function (fn) &#123;  let arr &#x3D; [];  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (fn(this[i], i, this)) &#123;      arr.push(this[i]);    &#125;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myFilter((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);&#x2F;&#x2F; 1 0  [1, 2, 3]&#x2F;&#x2F; 2 1  [1, 2, 3]&#x2F;&#x2F; 3 2  [1, 2, 3]&#x2F;&#x2F; [2, 3]</code></pre><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><strong>定义</strong></p><ul><li>some()方法用于检测数组中的元素是否满足指定条件</li><li>some()方法会一次执行数组的每个元素，直到找到符合条件的元素为止<ul><li>如果找到符合条件的元素，some()方法就会立即返回 true，剩余的元素不会再执行</li><li>如果没有找到符合条件的元素，some()方法就会返回 false</li></ul></li></ul><p><strong>注意</strong></p><ul><li>some()方法不会对空数组进行遍历</li><li>some()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>some 我们知道是如果找到就返回 true，没有返回 false,那么在 filter 上再改造一下，定义一个遍历为 false,当有一次会回调函数执行的时候返回 true,那么就跳出循环，直接返回。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.mySome &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (fn(this[i], i, this)) &#123;      return true;    &#125;  &#125;  return false;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].mySome((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);</code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><strong>定义</strong></p><ul><li>find()方法返回数组中满足条件的第一个元素</li><li>find()方法会一次执行数组的每个元素，直到找到符合条件的元素为止<ul><li>如果找到符合条件的元素，find()方法就会立即返回该元素，剩余的元素不会再执行</li><li>如果没有找到符合条件的元素，find()方法就会返回 undefined</li></ul></li></ul><p><strong>注意</strong></p><ul><li>find()方法不会对空数组进行遍历</li><li>find()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>当回调函数有一个返回 ture，则赋值并且返回，否则会返回一个未定义的值，undefined。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myFind &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (fn(this[i], i, this)) &#123;      return this[i];    &#125;  &#125;  return undefined;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myFind((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);</code></pre><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><strong>定义</strong></p><ul><li>every()方法用于检测数组中的所有元素是否都满足指定条件</li><li>every()方法会一次执行数组的每个元素，直到找到不符合条件的元素为止<ul><li>如果找到不符合条件的元素，every()方法就会返回 false，剩余的元素不会再执行</li><li>如果没有找到不符合条件的元素，every()方法就会返回 true</li></ul></li></ul><p><strong>注意</strong></p><ul><li>every()方法不会对空数组进行遍历</li><li>every()方法不会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>这个跟 some 其实只是反着来，初始化一个值为 true，只要回调函数有一个值返回 false，那么就会成立从而推出循环并且返回。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myEvery &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    if (!fn(this[i], i, this)) &#123;      return false;    &#125;  &#125;  return true;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myEvery((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);  return item &gt; 1;&#125;);</code></pre><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><strong>定义</strong></p><ul><li>forEach()方法用于遍历数组中的所有元素</li></ul><p><strong>注意</strong></p><ul><li>forEach()方法不会对空数组执行回调函数</li></ul><p><strong>原理</strong></p><ul><li>也是利用 for 循环直接遍历循环执行回调函数即可。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myForEach &#x3D; function (fn) &#123;  for (let i &#x3D; 0; i &lt; this.length; i++) &#123;    fn(this[i], i, this);  &#125;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myForEach((item, index, arr) &#x3D;&gt; &#123;  console.log(item, index, arr);&#125;);</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p><strong>定义</strong></p><ul><li>concat()方法用于连接两个或多个数组</li><li>concat()方法不会改变原始数组</li></ul><p><strong>注意</strong></p><p><strong>原理</strong></p><ul><li>先判断是不是数组，是的话遍历 push，不是的话直接 push，最后返回复制的数组即可。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myConcat &#x3D; function (...args) &#123;  let arr &#x3D; [...this];  for (let i &#x3D; 0; i &lt; args.length; i++) &#123;    if (Array.isArray(args[i])) &#123;      arr &#x3D; arr.concat(args[i]);    &#125; else &#123;      arr.push(args[i]);    &#125;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myConcat([4, 5, 6]);</code></pre><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h2><p><strong>定义</strong></p><ul><li>copyWithin()方法用于将一个数组的元素复制到其他位置</li><li>copyWithin()方法会修改原始数组</li></ul><p><strong>注意</strong></p><ul><li>copyWithin()方法会改变原始数组</li></ul><p><strong>原理</strong></p><ul><li>start、 end 元素拷贝到 target 元素（end - start 有几位，会改变 target 及之后的几位）</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myCopyWithin &#x3D; function (target, start &#x3D; 0, end &#x3D; this.length) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  target &#x3D; target &lt; 0 ? len + target : target;  start &#x3D; start &lt; 0 ? len + start : start;  end &#x3D; end &lt; 0 ? len + end : end;  for (let i &#x3D; start; i &lt; end; i++) &#123;    arr[target + i - start] &#x3D; arr[i];  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3, 4, 5].myCopyWithin(0, 3);&#x2F;&#x2F; 拷贝 4, 5，从0开始覆盖&#x2F;&#x2F; [4, 5, 3, 4, 5]</code></pre><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><strong>定义</strong></p><ul><li>reduce()方法用于从一个数组中的元素求和</li><li>reduce()可以作为一个高阶函数使用，用于函数的 compose</li></ul><p><strong>注意</strong></p><ul><li>reduce()方法不会对空数组执行回调函数</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myReduce &#x3D; function (fn, init) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let i &#x3D; 0;  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;    init &#x3D; arr[0];    i &#x3D; 1;  &#125;  for (; i &lt; len; i++) &#123;    init &#x3D; fn(init, arr[i], i, arr);  &#125;  return init;&#125;;</code></pre><p>使用</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myReduce((prev, curr) &#x3D;&gt; &#123;  return prev + curr;&#125;, 0);</code></pre><h2 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h2><p><strong>定义</strong></p><ul><li>reduceRight()方法用于从一个数组中的元素求和</li><li>reduceRight()可以作为一个高阶函数使用，用于函数的 compose<br><strong>注意</strong></li><li>reduceRight()方法不会对空数组执行回调函数<br><strong>原理</strong></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myReduceRight &#x3D; function (fn, init) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let i &#x3D; len - 1;  if (init &#x3D;&#x3D;&#x3D; undefined) &#123;    init &#x3D; arr[len - 1];    i &#x3D; len - 2;  &#125;  for (; i &gt;&#x3D; 0; i--) &#123;    init &#x3D; fn(init, arr[i], i, arr);  &#125;  return init;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3].myReduceRight((prev, curr) &#x3D;&gt; &#123;  return prev + curr;&#125;, 0);</code></pre><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p><strong>定义</strong></p><ul><li>splice()方法用于删除数组中的一段，并用新元素替代原来的元素</li><li>splice()方法会改变原始数组</li><li>splice()方法会返回被删除的元素</li><li>splice()方法会返回被删除的元素，并且返回被删除的元素的数组</li></ul><p><strong>注意</strong></p><ul><li>splice()方法会改变原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.mySplice &#x3D; function (start, deleteCount, ...args) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  &#x2F;&#x2F; 找开始的位置  start &#x3D; start &lt; 0 ? len + start : start;  &#x2F;&#x2F; 找删除的数量  &#x2F;&#x2F; 如果deleteCount，没有值，则从start开始删除，直到数组结束  deleteCount &#x3D; deleteCount &#x3D;&#x3D;&#x3D; undefined ? len - start : deleteCount;  let newArr &#x3D; arr.slice(0, start); &#x2F;&#x2F; 左  newArr &#x3D; newArr.concat(args); &#x2F;&#x2F; 新  newArr &#x3D; newArr.concat(arr.slice(start + deleteCount)); &#x2F;&#x2F; 右  return newArr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3, 4, 5].mySplice(2, 2, 6, 7);</code></pre><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><strong>定义</strong></p><ul><li>slice()方法用于返回一个数组的一段，并且不会改变原始数组</li><li>slice()方法会返回一个新数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.mySlice &#x3D; function (start &#x3D; 0, end &#x3D; this.length) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  &#x2F;&#x2F; 找开始的位置  start &#x3D; start &lt; 0 ? len + start : start;  &#x2F;&#x2F; 找结束的位置  end &#x3D; end &lt; 0 ? len + end : end;  return arr.slice(start, end);&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var a &#x3D; [1, 2, 3, 4, 5];var b &#x3D; a.splice(2, 2, 6, 7);a;&#x2F;&#x2F; [1, 2, 6, 7, 5]b;&#x2F;&#x2F; [3, 4]</code></pre><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><strong>定义</strong></p><ul><li>sort()方法用于对数组进行排序</li><li>sort()方法会改变原始数组</li><li>sort()方法会返回一个新数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.mySort &#x3D; function (fn) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  &#x2F;&#x2F; 冒泡排序  for (let i &#x3D; 0; i &lt; len; i++) &#123;    for (let j &#x3D; i + 1; j &lt; len; j++) &#123;      if (fn(arr[i], arr[j]) &gt; 0) &#123;        &#x2F;&#x2F; 使用了解构赋值        [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];      &#125;    &#125;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3, 4, 5].mySort((a, b) &#x3D;&gt; &#123;  return a - b;&#125;);</code></pre><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p><strong>定义</strong></p><ul><li>reverse()方法用于反转数组</li><li>reverse()方法会改变原始数组</li></ul><p><strong>原理</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myReverse &#x3D; function () &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let i &#x3D; 0;  let j &#x3D; len - 1;  while (i &lt; j) &#123;    &#x2F;&#x2F; 使用了解构赋值    [arr[i], arr[j]] &#x3D; [arr[j], arr[i]];    i++;    j--;  &#125;  return arr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3, 4, 5].myReverse();</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p><strong>定义</strong></p><ul><li>includes()方法用于判断数组是否包含某个值</li><li>includes()方法会返回一个布尔值</li><li>includes()方法会返回一个布尔值，如果数组包含某个值，则返回 true，否则返回 false<br><strong>原理</strong></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myIncludes &#x3D; function (value) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  for (let i &#x3D; 0; i &lt; len; i++) &#123;    if (arr[i] &#x3D;&#x3D;&#x3D; value) &#123;      return true;    &#125;  &#125;  return false;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3, 4, 5].myIncludes(3);</code></pre><h2 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h2><p><strong>定义</strong></p><ul><li>flat()方法用于将一个数组展开为多个数组</li><li>flat()方法会返回一个新数组</li><li>flat()方法会返回一个新数组，如果数组中的元素是数组，则将数组中的元素展开为一个数组<br><strong>原理</strong></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">Array.prototype.myFlat &#x3D; function (depth &#x3D; 1) &#123;  let arr &#x3D; [...this];  let len &#x3D; arr.length;  let newArr &#x3D; [];  for (let i &#x3D; 0; i &lt; len; i++) &#123;    if (Array.isArray(arr[i])) &#123;      newArr &#x3D; newArr.concat(&#x2F;**&#x2F; arr[i].myFlat(depth - 1) &#x2F;*递归*&#x2F;);    &#125; else &#123;      newArr.push(arr[i]);    &#125;  &#125;  return newArr;&#125;;</code></pre><p><strong>使用</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">[1, 2, 3, 4, 5].myFlat();</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/lin_fightin/article/details/118885988" target="_blank" >js 一些数组对象方法原理实现(手撕 map,filter,every,flat 等)</a> <code>当前文章比此链接代码更精简</code></p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 劫持(函数/数据)</title>
      <link href="//post/2022-06-10j-Data-hijacking.html"/>
      <url>//post/2022-06-10j-Data-hijacking.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数劫持"><a href="#函数劫持" class="headerlink" title="函数劫持"></a>函数劫持</h2><p>函数劫持，在一个函数运行之前就把它劫持下来，添加我们想要的功能。 在函数运行之前，我们可以改变函数的参数，或者改变函数的返回值。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>JavaScript 中的函数劫持是一个增强原有函数的技巧，一般我们用来对原有的 JavaScript 全局方法做一些能力的增强。</p></blockquote><p><strong>函数劫持原理</strong></p><p>函数劫持原理，是在函数运行之前，把函数的原型改变为新的函数，并且把原函数的执行代码放到新函数的执行代码之前。</p><p><strong>函数劫持实现</strong></p><ul><li>使用<code>新的变量</code>保存被劫持函数</li><li><code>新函数中</code>改<code>写被劫持函数</code></li><li><code>新函数中</code> <code>调用原有的函数</code>（保存在变量中的函数）</li></ul><p><strong>基础：两个对象指向同一个地址的时候，修改某个对象的属性，另外一个对象也会随之变化</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">let a &#x3D; &#123;&#125;;let b &#x3D; a;a.name &#x3D; &quot;Gopal&quot;;&#x2F;&#x2F; ture &#123;name: &#39;Gopal&#39;&#125;  &#123;name: &#39;Gopal&#39;&#125;console.log(b &#x3D;&#x3D;&#x3D; a, a, b);</code></pre><p><strong>基础：将新的对象赋值给对象变量的时候，该对象变量就指向了新对象的引用地址，跟旧引用切断关联</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">let a &#x3D; &#123;&#125;;let b &#x3D; a;a &#x3D; &#123; name: &quot;Gopal&quot; &#125;;&#x2F;&#x2F; false &#123;name: &#39;Gopal&#39;&#125; &#123;&#125;console.log(b &#x3D;&#x3D;&#x3D; a, a, b);</code></pre><p><strong>应用场景</strong></p><ul><li>增强你的函数功能<ul><li>如上面的第一个例子，在原有的函数之上，实现特定的逻辑。</li></ul></li><li>追踪 XSS 攻击<ul><li>一般 XSS 攻击会先利用 alert() 等方法输出信息进行测试，这个时候，我们可以对原先的 alert() 进行劫持，向其输入追踪信息的代码，最后才把原函数执行。<pre class="line-numbers language-js" data-language="js"><code class="language-js">function report(caller) &#123;  var img &#x3D; new Image();  img.src &#x3D; &#96;http:&#x2F;&#x2F;www.site.com&#x2F;getReport.php?caller&#x3D;$&#123;encodeURIComponent(    caller  )&#125;&#96;;&#125;var _alert &#x3D; window.alert;window.alert &#x3D; function (s) &#123;  &#x2F;&#x2F; 拿到攻击者相关信息，并上报  report(alert.caller);  _alert(s);&#125;;alert(&quot;test&quot;);</code></pre></li></ul></li></ul><p><strong>劫持 ajax 请求，实现 mock 功能</strong></p><ul><li>mock.js 中，就是通过对原生的 XMLHttpRequest（或 ActiveXObject）进行劫持，判断有没有找到匹配的数据模板，如果找到，则拦截 XHR 请求逻辑，执行自身规则对应的逻辑。如果未找到匹配的数据模板，则采用原生 XHR 发送请求。详细代码看这里。</li></ul><h2 id="数据劫持-defineProperty"><a href="#数据劫持-defineProperty" class="headerlink" title="数据劫持 defineProperty"></a>数据劫持 defineProperty</h2><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>通过设置对象属性 getter 和 setter 来监听属性的变化，可以实现数据劫持。getter 时候进行依赖收集，setter 时候进行数据变更时通知订阅者更新视图。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function defineReactive(obj, key, value) &#123;  observe(value); &#x2F;&#x2F; 递归子属性  Object.defineProperty(obj, key, &#123;    enumerable: true,    configurable: true,    get: function reactiveGetter() &#123;      collectDeps(); &#x2F;&#x2F; 收集依赖      return value;    &#125;,    set: function reactiveSetter(newVal) &#123;      observe(newVal); &#x2F;&#x2F; 若是新值是对象，则递归子属性      if (value !&#x3D;&#x3D; newVal) &#123;        notify(); &#x2F;&#x2F; 通知订阅者更新视图        console.log(&quot;数据变更了&quot;);        value &#x3D; newVal;      &#125;    &#125;,  &#125;);&#125;function observe(obj) &#123;  if (!obj || typeof obj !&#x3D;&#x3D; &quot;object&quot;) &#123;    return;  &#125;  Object.keys(obj).forEach((key) &#x3D;&gt; &#123;    &#x2F;&#x2F; 有递归    defineReactive(obj, key, obj[key]);  &#125;);&#125;var data &#x3D; &#123;  name: &quot;Gopal&quot;,  sex: &quot;male&quot;,&#125;;</code></pre><p><strong>缺点</strong></p><ul><li>无法检测到对象属性的新增或删除</li></ul><p>由于 js 的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过 Object.defineProperty 方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性 或删除属性，这就需要另外处理。</p><ul><li>无法监听数组的变化</li></ul><p>vue 在实现数组的响应式时，使用了一些 hack,把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的 push&#x2F;pop&#x2F;shift&#x2F;unshift&#x2F;splice&#x2F;sort&#x2F;reverse 7 个方法上，其他方法无法监听。<code>目前没读过源码，不晓得这搬来文章内容是否正确</code></p><h2 id="数据劫持-Proxy"><a href="#数据劫持-Proxy" class="headerlink" title="数据劫持 Proxy"></a>数据劫持 Proxy</h2><p>Proxy,字面意思是代理，是 ES6 提供的一个新的 API,用于修改某些操作的默认行为，可以理解为在目标对象之前做一层拦截，外部所有的访问都必须通过这层拦截，通过这层拦截可以做很多事情，比如对数据进行过滤、修改或者收集信息之类。借用 proxy 的巧用的一幅图，它很形象的表达了 Proxy 的作用</p><p>ES6 原生提供的 Proxy 构造函数：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var proxy &#x3D; new Proxy(target, handler);</code></pre><p>其中 obj 为 Proxy 要拦截的对象，handler 用来定制拦截的操作，返回一个新的代理对象 proxy；Proxy 代理特点：</p><ul><li>Proxy 的代理针对的是整个对象，而不是像 Object.defineProperty 针对某个属性。只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 也可以监听数组的变化。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">var proxy &#x3D; new Proxy([1, 2, 3], &#123;  get: function (target, property) &#123;    console.log(target, property);    return target[property];  &#125;,&#125;);proxy[0] &#x3D; 4;proxy.push(5);proxy.length;</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">let handler &#x3D; &#123;  get: function (target, key) &#123;    if (target[key] &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; target[key] !&#x3D;&#x3D; null) &#123;      return new Proxy(target[key], handler);    &#125;    collectDeps(); &#x2F;&#x2F; 收集依赖    return Reflect.get(target, key);  &#125;,  set(target, key, value) &#123;    if (key &#x3D;&#x3D;&#x3D; &quot;length&quot;) return true;    notifyRender(); &#x2F;&#x2F; 通知订阅者更新视图    return Reflect.set(target, key, value);  &#125;,&#125;;let proxy &#x3D; new Proxy(data, handler);proxy.age &#x3D; 18; &#x2F;&#x2F; 支持新增属性let proxy1 &#x3D; new Proxy(&#123; arr: [] &#125;, handler);proxy1.arr[0] &#x3D; &quot;proxy&quot;;</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://juejin.cn/post/7103837916274622494">你还不知道 JavaScript 中的函数劫持么？</a><br><a href="https://wenku.baidu.com/view/a78cb667fd4733687e21af45b307e87101f6f8ea.html">数据劫持</a></p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修补node_modules下源码</title>
      <link href="//post/2022-06-09patch-package.html"/>
      <url>//post/2022-06-09patch-package.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前在简书上记录过，没迁移简书文章，所以重新记录</p><p>由于<code>hexo-theme-aurora</code>代码配色不是很友好，需要自定义配色，又不想改其 github 上代码，直接处理<code>node_modules</code>下的配色文件</p><h2 id="安装-patch-package"><a href="#安装-patch-package" class="headerlink" title="安装 patch-package"></a>安装 patch-package</h2><p>patch-package 包可以通过 npm 进行安装。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i patch-package --save-dev</code></pre><p>或者也可以通过 yarn 进行安装。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yarn add patch-package -D</code></pre><h2 id="修改包代码"><a href="#修改包代码" class="headerlink" title="修改包代码"></a>修改包代码</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;node_modules&#x2F;某包名下，按需修改</code></pre><h2 id="创建补丁"><a href="#创建补丁" class="headerlink" title="创建补丁"></a>创建补丁</h2><p>在修改依赖包内容后，就可以运行 patch-package 创建 patch 文件了。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yarn patch-package 包名 # 使用 yarn</code></pre><p>运行后通常会在项目根目录下的 patches 目录中创建一个名为 包名+version.patch 的文件。将该 patch 文件提交至版本控制中，即可在之后应用该补丁了。<br>例如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ yarn patch-package hexo-theme-aurorayarn run v1.4.0$ &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;.bin&#x2F;patch-package hexo-theme-aurorapatch-package 6.4.7• Creating temporary folder• Installing hexo-theme-aurora@1.5.5 with yarn• Diffing your files with clean files✔ Created file patches&#x2F;hexo-theme-aurora+1.5.5.patch💡 hexo-theme-aurora is on GitHub! To draft an issue based on your patch run    yarn patch-package hexo-theme-aurora --create-issue✨  Done in 5.48s.</code></pre><h2 id="配置-npm-脚本钩子"><a href="#配置-npm-脚本钩子" class="headerlink" title="配置 npm 脚本钩子"></a>配置 npm 脚本钩子</h2><p>完成上述操作后，最后还需要修改 package.json 的内容，在 scripts 中加入”postinstall”: “patch-package”。</p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;  &quot;postinstall&quot;: &quot;patch-package&quot;&#125;</code></pre><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h2 id="清理-node-modules"><a href="#清理-node-modules" class="headerlink" title="清理 node_modules"></a>清理 node_modules</h2><p><strong>项目根目录</strong>别搞错了,简单粗暴点，直接全清掉</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm -rf node_modules &amp;&amp; yarn</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ yarnyarn install v1.4.0[1&#x2F;4] 🔍  Resolving packages...[2&#x2F;4] 🚚  Fetching packages...[3&#x2F;4] 🔗  Linking dependencies...warning &quot;hexo &gt; nunjucks@3.2.3&quot; has unmet peer dependency &quot;chokidar@^3.3.0&quot;.warning &quot;hexo-browsersync &gt; browser-sync &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.warning &quot;hexo-browsersync &gt; browser-sync &gt; socket.io &gt; engine.io &gt; ws@8.2.3&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.warning &quot;hexo-renderer-marked &gt; jsdom@19.0.0&quot; has unmet peer dependency &quot;canvas@^2.5.0&quot;.warning &quot;hexo-renderer-marked &gt; jsdom &gt; ws@8.5.0&quot; has unmet peer dependency &quot;bufferutil@^4.0.1&quot;.warning &quot;hexo-renderer-marked &gt; jsdom &gt; ws@8.5.0&quot; has unmet peer dependency &quot;utf-8-validate@^5.0.2&quot;.warning &quot;hexo-theme-aurora &gt; pinia@2.0.13&quot; has unmet peer dependency &quot;@vue&#x2F;composition-api@^1.4.0&quot;.warning &quot;hexo-theme-aurora &gt; pinia@2.0.13&quot; has unmet peer dependency &quot;typescript@&gt;&#x3D;4.4.4&quot;.warning &quot;hexo-theme-aurora &gt; pinia &gt; vue-demi@0.12.5&quot; has unmet peer dependency &quot;@vue&#x2F;composition-api@^1.0.0-rc.1&quot;.[4&#x2F;4] 📃  Building fresh packages...$ yarn patch-package # 看这里，在运行修补yarn run v1.4.0$ &#x2F;Users&#x2F;haotian&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog&#x2F;node_modules&#x2F;.bin&#x2F;patch-packagepatch-package 6.4.7Applying patches...hexo-theme-aurora@1.5.5 ✔✨  Done in 1.00s.✨  Done in 13.93s.</code></pre><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>将 patches 提交到代码仓库，以后在其他机器上，直接安装依赖包即可。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npx patch-package hexo-theme-aurora</code></pre><p>这个命令使用 npm 运行的，可能不会成功，使用<code>yarn patch-package hexo-theme-aurora</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">👑 ~&#x2F;Desktop&#x2F;other&#x2F;blog&#x2F;technology-blog git:(main) ✗ $ npx patch-package  hexo-theme-aurorapatch-package 6.4.7• Creating temporary folder• Installing hexo-theme-aurora@1.5.5 with yarnwarning package.json: No license fieldwarning No license fielderror An unexpected error occurred: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;axios: ETIMEDOUT&quot;.Error: https:&#x2F;&#x2F;registry.npmjs.org&#x2F;core-js: ETIMEDOUT    at Timeout._onTimeout (&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;yarn&#x2F;lib&#x2F;cli.js:132130:19)    at listOnTimeout (node:internal&#x2F;timers:557:17)</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/auroral-ui/hexo-theme-aurora/issues/168">hexo-theme-aurora&#x2F;issues&#x2F;168</a><br><a href="https://www.npmjs.com/package/patch-package">patch-package</a></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.Typescript 工具类型</title>
      <link href="//post/2022-06-09ts-util-type.html"/>
      <url>//post/2022-06-09ts-util-type.html</url>
      
        <content type="html"><![CDATA[<p>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.<br><code>Typescript提供了一些帮助类型转换的工具类型，这些工具类型可以在全局范围内使用。</code></p><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h2><p>Released: 2.1</p><p>Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.<br><code>构造一个具有所有属性类型的可选属性的类型。这个工具将返回一个表示给定类型的所有子集的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;  description: string;&#125;function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123;  return &#123; ...todo, ...fieldsToUpdate &#125;;&#125;const todo1 &#x3D; &#123;  title: &quot;organize desk&quot;,  description: &quot;clear clutter&quot;,&#125;;const todo2 &#x3D; updateTodo(todo1, &#123;  description: &quot;throw out trash&quot;,&#125;);</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p><ul><li>首先通过 keyof T，遍历出类型 T 的所有属性，然后通过 in 操作符进行遍历，最后在属性后加上?，将属性变为可选属性。</li><li>注意 这个 <code>in</code> 不是<code>收缩类型操作符in</code> ,而是<code>映射类型</code>中的<code>in</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;HEAD&#x2F;src&#x2F;lib&#x2F;es5.d.ts#L1517type Partial&lt;T&gt; &#x3D; &#123;  [P in keyof T]?: T[P];&#125;;</code></pre><h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<Type></h2><p>Released:2.8</p><p>Constructs a type consisting of all properties of Type set to required. The opposite of Partial.<br><code>构造一个具有所有属性类型的必需属性的类型。与Partial相反。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleinterface Props &#123;a?: number;b?: string;&#125;const obj: Props &#x3D; &#123; a: 5 &#125;;const obj2: Required&lt;Props&gt; &#x3D; &#123; a: 5 &#125;;Property &#39;b&#39; is missing in type &#39;&#123; a: number; &#125;&#39; but required in type &#39;Required&lt;Props&gt;&#39;.</code></pre><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 用于将 T 类型的所有属性设置为必选状态，首先通过 keyof T，取出类型 T 的所有属性， 然后通过 in 操作符进行遍历，最后在属性后的 ? 前加上 -，将属性变为必选属性。</p><p>这里顺便讲下-这个符号的作用，这是 TypeScript 2.8 为映射类型增加了添加或删除特定修饰符的能力。具体来说，readonly 和?映射类型中的属性修饰符现在可以加上+或-前缀，以指示应该添加或删除该修饰符，当然一般+号是可以省略的。<a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers:~:text=You%20can%20remove%20or%20add%20these%20modifiers%20by%20prefixing%20with%20%2D%20or%20%2B.%20If%20you%20don%E2%80%99t%20add%20a%20prefix%2C%20then%20%2B%20is%20assumed.">ts 官网 类型操作符&#x2F;映射类型</a></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Required&lt;T&gt; &#x3D; &#123;  [P in keyof T]-?: T[P];&#125;;</code></pre><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<Type></h2><p>Released:2.1</p><p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.<br><code>构造一个具有所有属性类型的只读属性的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;&#125;const todo: Readonly&lt;Todo&gt; &#x3D; &#123;  title: &quot;Delete inactive users&quot;,&#125;;todo.title &#x3D; &quot;Hello&quot;;&#x2F;&#x2F; Cannot assign to &#39;title&#39; because it is a read-only property.</code></pre><p>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a frozen object).<br><code>这个工具是用来表示在运行时将失败的赋值表达式的用途（即尝试重新分配一个冻结对象的属性）。</code><br><strong>Object.freeze</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function freeze&lt;Type&gt;(obj: Type): Readonly&lt;Type&gt;;</code></pre><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>原理：<strong>使用映射类型（Mapped Types）</strong> 接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;  [P in K]: T;&#125;;</code></pre><h2 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys, Type&gt;"></a>Record&lt;Keys, Type&gt;</h2><p>Released:2.1</p><p>Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleinterface CatInfo &#123;  age: number;  breed: string;&#125;type CatName &#x3D; &quot;miffy&quot; | &quot;boris&quot; | &quot;mordred&quot;;const cats: Record&lt;CatName, CatInfo&gt; &#x3D; &#123;  miffy: &#123; age: 10, breed: &quot;Persian&quot; &#125;,  boris: &#123; age: 5, breed: &quot;Maine Coon&quot; &#125;,  mordred: &#123; age: 16, breed: &quot;British Shorthair&quot; &#125;,&#125;;cats.boris;const cats: Record&lt;CatName, CatInfo&gt;;</code></pre><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>使用映射类型（Mapped Types）</strong></p><p>接收两个泛型，K 为 string | number | symbol 可以继承的类型，这三个也是对象 key 所支持的基础类型，然后通过 in 操作符对 K 进行遍历，每一个属性的类型为 T 类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Record&lt;K extends string | number | symbol, T&gt; &#x3D; &#123;  [P in K]: T;&#125;;</code></pre><h2 id="Pick-lt-Type-Keys-gt"><a href="#Pick-lt-Type-Keys-gt" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a>Pick&lt;Type, Keys&gt;</h2><p>Released:2.1</p><p>Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.<br><code>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型。这个工具类型可以被用于映射一个类型的属性到另一个类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;  description: string;  completed: boolean;&#125;type TodoPreview &#x3D; Pick&lt;Todo, &quot;title&quot; | &quot;completed&quot;&gt;;const todo: TodoPreview &#x3D; &#123;  title: &quot;Clean room&quot;,  completed: false,&#125;;todo;&#x2F;&#x2F; const todo: TodoPreview;</code></pre><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>从 T 类型中提取部分属性，作为新的返回类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;  [P in K]: T[P];&#125;;</code></pre><h2 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a>Omit&lt;Type, Keys&gt;</h2><p>Released:3.5</p><p>Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).<br><code>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys(Keys是字符串字面量 或者 字符串字面量的联合类型)</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleinterface Todo &#123;  title: string;  description: string;  completed: boolean;  createdAt: number;&#125;type TodoPreview &#x3D; Omit&lt;Todo, &quot;description&quot;&gt;;const todo: TodoPreview &#x3D; &#123;  title: &quot;Clean room&quot;,  completed: false,  createdAt: 1615544252770,&#125;;todo;&#x2F;&#x2F; const todo: TodoPreview;type TodoInfo &#x3D; Omit&lt;Todo, &quot;completed&quot; | &quot;createdAt&quot;&gt;;const todoInfo: TodoInfo &#x3D; &#123;  title: &quot;Pick up kids&quot;,  description: &quot;Kindergarten closes at 5pm&quot;,&#125;;todoInfo;&#x2F;&#x2F; const todoInfo: TodoInfo</code></pre><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>使用 <strong>keyof 类型操作符号</strong>、<strong>extends</strong>、<strong>类型操作符 Exclude</strong>、 <strong>类型操作符 Pick</strong></p><ul><li>结合 Pick 和 Exclude 方法，提取出不含 K 属性的类型。</li><li>1.keyof T 返回的是联合类型</li><li>2.<a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">extends</a></li><li>3.Exclude&lt;T, K&gt; 返回的是联合类型， 可以接收一个联合类型和一个联合类型，返回一个联合类型</li><li>4.把 K 中的 key, 从 T 中排除掉，剩下的就是 Omit 的类型。</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Omit&lt;T, K extends keyof T&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</code></pre><h2 id="Exclude-lt-UnionType-ExcludedMembers-gt"><a href="#Exclude-lt-UnionType-ExcludedMembers-gt" class="headerlink" title="Exclude&lt;UnionType, ExcludedMembers&gt;"></a>Exclude&lt;UnionType, ExcludedMembers&gt;</h2><p>Released:2.8</p><p>Constructs a type by excluding from UnionType all union members that are assignable to ExcludedMembers.<br><code>用于构造一个类型，它是从UnionType联合类型里面排除了所有可以赋给ExcludedMembers的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Example;type T0 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;;&#x2F;&#x2F; type T0 &#x3D; &quot;b&quot; | &quot;c&quot;;type T1 &#x3D; Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;;&#x2F;&#x2F; type T1 &#x3D; &quot;c&quot;;type T2 &#x3D; Exclude&lt;string | number | (() &#x3D;&gt; void), Function&gt;;&#x2F;&#x2F; type T2 &#x3D; string | number;</code></pre><h2 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a>extends 关键字</h2><p>不学 extends，Exclude 和 Extract，很难理解</p><p>extends 关键字在 TS 编程中出现的频率挺高的，而且<code>不同场景下代表的含义不一样</code>，特此总结一下：</p><ul><li><p>表示继承&#x2F;拓展的含义</p></li><li><p>表示约束的含义</p></li><li><p>表示分配的含义</p></li></ul><hr/><h3 id="表示继承-x2F-拓展"><a href="#表示继承-x2F-拓展" class="headerlink" title="表示继承&#x2F;拓展"></a><strong>表示继承&#x2F;拓展</strong></h3><p>extends 是 ts 里一个很常见的关键字，同时也是 es6 里引入的一个新的关键字。在 js 里，extends 一般和 class 一起使用</p><ul><li>es6 继承父类的方法和属性</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">class Animal &#123;  kind &#x3D; &quot;animal&quot;;  constructor(kind) &#123;    this.kind &#x3D; kind;  &#125;  sayHello() &#123;    console.log(&#96;Hello, I am a $&#123;this.kind&#125;!&#96;);  &#125;&#125;class Dog extends Animal &#123;  constructor(kind) &#123;    super(kind);  &#125;  bark() &#123;    console.log(&quot;wang wang&quot;);  &#125;&#125;const dog &#x3D; new Dog(&quot;dog&quot;);dog.name; &#x2F;&#x2F;  &#x3D;&gt; &#39;dog&#39;dog.sayHello(); &#x2F;&#x2F; &#x3D;&gt; Hello, I am a dog!</code></pre><p>这里 Dog 继承了父类的 sayHello 方法，因为可以在 Dog 实例 dog 上调用。</p><ul><li>ts 继承某个类型<br>在 ts 里，extends 除了可以像 js 继承值，还可以继承&#x2F;扩展类型：</li></ul><pre class="line-numbers language-none"><code class="language-none">interface Animal &#123;  kind: string;&#125;interface Dog extends Animal &#123;  bark(): void;&#125;&#x2F;&#x2F; Dog &#x3D;&gt; &#123; name: string; bark(): void &#125;</code></pre><hr/><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在书写泛型的时候，我们往往需要对类型参数作一定的限制，比如希望传入的参数都有 name 属性的数组我们可以这么写：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getCnames&lt;T extends &#123; name: string &#125;&gt;(entities: T[]): string[] &#123;  return entities.map((entity) &#x3D;&gt; entity.cname);&#125;</code></pre><p>这里 extends 对传入的参数作了一个限制，就是 entities 的每一项可以是一个对象，但是必须含有类型为 string 的 cname 属性。</p><p>再比如，redux 里 dispatch 一个 action，必须包含 type 属性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;841660202&#x2F;redux&#x2F;blob&#x2F;2edd0363271af46e327e118f3d92e78e258bf0cd&#x2F;src&#x2F;types&#x2F;store.ts#L83&#x2F;&#x2F; Dispatchexport interface Dispatch&lt;A extends Action &#x3D; AnyAction&gt; &#123;  &lt;T extends A&gt;(action: T, ...extraArgs: any[]): T;&#125;&#x2F;&#x2F; AnyActionexport interface AnyAction extends Action &#123;  &#x2F;&#x2F; Allows any extra properties to be defined in an action.  [extraProps: string]: any;&#125;&#x2F;&#x2F; Actionexport interface Action&lt;T &#x3D; any&gt; &#123;  type: T;&#125;&#x2F;&#x2F; 上述代码 简化interface Dispatch&lt;T extends &#123; type: string &#125;&gt; &#123;  (action: T): T;&#125;</code></pre><h3 id="条件类型与高阶类型"><a href="#条件类型与高阶类型" class="headerlink" title="条件类型与高阶类型"></a>条件类型与高阶类型</h3><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">SomeType extends OtherType ? TrueType : FalseType;</code></pre><p>When the type on the left of the extendsis assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).<br><code>当左边的类型可以赋值给右边的类型，那么你就会得到第一个分支的类型，否则你就会得到第二个分支的类型。</code></p><p>extends 还有一大用途就是用来判断一个类型是不是可以分配给另一个类型，这在写高级类型的时候非常有用，举个 ????：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Human &#x3D; &#123;  name: string;&#125;;type Duck &#x3D; &#123;  name: string;&#125;;type Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;yes&#39;</code></pre><p>在 vscode 里或者 ts playground 里输入这段代码，你会发现 Bool 的类型是’yes’。这是因为 Human 和 Duck 的类型完全相同，或者说 Human 类型的一切约束条件，Duck 都具备；换言之，类型为 Human 的值可以分配给类型为 Duck 的值（分配成功的前提是，Duck 里面得的类型得有一样的），反之亦然。需要理解的是，这里 A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集。稍微扩展下来详细说明这个问题：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Human &#x3D; &#123;  name: string;  occupation: string;&#125;;type Duck &#x3D; &#123;  name: string;&#125;;type Bool &#x3D; Duck extends Human ? &quot;yes&quot; : &quot;no&quot;; &#x2F;&#x2F; Bool &#x3D;&gt; &#39;no&#39;</code></pre><p>当我们给 Human 加上一个 occupation 属性，发现此时 Bool 是’no’，这是因为 Duck 没有类型为 string 的 occupation 属性，类型 Duck 不满足类型 Human 的类型约束。因此，A extends B，是指类型 A 可以分配给类型 B，而不是说类型 A 是类型 B 的子集，理解 extends 在类型三元表达式里的用法非常重要。</p><p>继续看示例</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type A1 &#x3D; &quot;x&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; stringtype A2 &#x3D; &quot;x&quot; | &quot;y&quot; extends &quot;x&quot; ? string : number; &#x2F;&#x2F; numbertype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; ?</code></pre><p>A1 和 A2 是 extends 条件判断的普通用法，和上面的判断方法一样。</p><p>P 是带参数 T 的泛型类型，其表达式和 A1，A2 的形式完全相同，A3 是泛型类型 P 传入参数’x’ | ‘y’得到的类型，如果将’x’ | ‘y’带入泛型类的表达式，可以看到和 A2 类型的形式是完全一样的，那是不是说明，A3 和 A2 的类型就是完全一样的呢？</p><p>有兴趣可以自己试一试，这里就直接给结论了</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre><p>是不是很反直觉？这个反直觉结果的原因就是所谓的分配条件类型（Distributive Conditional Types）</p><p>When conditional types act on a generic type, they become distributive when given a union type<br><code>当条件类型作用于泛型类型时，它们变成分配条件类型（Distributive Conditional Types）</code></p><p>这句话翻译过来也还是看不懂，大白话</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>对于使用 extends 关键字的条件类型（即上面的三元表达式类型），<strong>如果 extends 前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</strong></p></blockquote><p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br><code>如果将联合类型传入 ToArray，则条件类型将会应用到联合类型的每一个成员。</code></p><p>还是用上面的例子说明</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A3 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; A3 的类型是 string | number</code></pre><p>该例中，extends 的前参为 T，T 是一个泛型参数。在 A3 的定义中，给 T 传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入 P<T></p><pre class="line-numbers language-none"><code class="language-none">P&lt;&#39;x&#39; | &#39;y&#39;&gt; &#x3D;&gt; P&lt;&#39;x&#39;&gt; | P&lt;&#39;y&#39;&gt;&#39;x&#39;代入得到&#39;x&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; string&#39;y&#39;代入得到&#39;y&#39; extends &#39;x&#39; ? string : number &#x3D;&gt; number然后将每一项代入得到的结果联合起来，得到 string | number</code></pre><p>总之，满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型</p><p>特殊的 never</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; never 是所有类型的子类型type A1 &#x3D; never extends &quot;x&quot; ? string : number; &#x2F;&#x2F; stringtype P&lt;T&gt; &#x3D; T extends &quot;x&quot; ? string : number;type A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; never</code></pre><p>上面的示例中，A2 和 A1 的结果竟然不一样，看起来 never 并不是一个联合类型，所以直接代入条件类型的定义即可，获取的结果应该和 A1 一直才对啊？</p><p>实际上，这里还是条件分配类型在起作用。never 被认为是空的联合类型，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以 P<T>的表达式其实根本就没有执行，所以 A2 的定义也就类似于永远没有返回的函数一样，是 never 类型的。</p><p>防止条件判断中的分配</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type P&lt;T&gt; &#x3D; [T] extends [&quot;x&quot;] ? string : number;type A1 &#x3D; P&lt;&quot;x&quot; | &quot;y&quot;&gt;; &#x2F;&#x2F; numbertype A2 &#x3D; P&lt;never&gt;; &#x2F;&#x2F; string</code></pre><p>在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数 T 的类型将被当做一个整体，不再分配。</p><hr/><h2 id="原理-注意"><a href="#原理-注意" class="headerlink" title="原理(注意)"></a>原理(注意)</h2><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>需前置学习 extends 关键字</p></div><ul><li>源码很简单，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 never，否则返回 T</li><li>never 是一个特殊的类型，在这里可以表示为空的联合类型，在于与其他类型的联合后，结果为其他类型。</li><li>没有遍历，怎么也能实现呢? <code>这里还涉及到extends条件类型的特殊情况，extends的前参T如果是一个泛型参数。对于使用extends关键字的条件类型（即上面的三元表达式类型），如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，两个类型会成为分配条件类型（Distributive Conditional Types）。分配条件类型是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;</code></pre><h2 id="Extract-lt-Type-Union-gt"><a href="#Extract-lt-Type-Union-gt" class="headerlink" title="Extract&lt;Type, Union&gt;"></a>Extract&lt;Type, Union&gt;</h2><p>Released:2.8</p><p>Constructs a type by extracting from Type all union members that are assignable to Union.<br><code>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampletype T0 &#x3D; Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;;&#x2F;&#x2F; type T0 &#x3D; &quot;a&quot;;type T1 &#x3D; Extract&lt;string | number | (() &#x3D;&gt; void), Function&gt;;&#x2F;&#x2F; type T1 &#x3D; () &#x3D;&gt; void;</code></pre><h2 id="原理-注意-1"><a href="#原理-注意-1" class="headerlink" title="原理(注意)"></a>原理(注意)</h2><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><p>需前置学习 extends 关键字</p></p></div><p>原理：与 Exclude 相反，判断联合类型 T 是否可以赋值给联合类型 U，是则返回 T，否则返回 never。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never;</code></pre><h2 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable<Type></h2><p>Released:2.8</p><p>Constructs a type by excluding null and undefined from Type.<br><code>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampletype T0 &#x3D; NonNullable&lt;string | number | undefined&gt;;&#x2F;&#x2F; type T0 &#x3D; string | number;type T1 &#x3D; NonNullable&lt;string[] | null | undefined&gt;;&#x2F;&#x2F; type T1 &#x3D; string[];</code></pre><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>判断 T 是否可以赋值给 null 或者 undefined 类型，是则返回 never，否则返回 T，如果这段看不明白的可以再看下 Exclude 那段关于 extends 的补充说明。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type NonNullable&lt;T&gt; &#x3D; T extends null | undefined ? never : T;</code></pre><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters<Type></h2><p>Released:3.1</p><p>Constructs a tuple type from the types used in the parameters of a function type Type.<br><code>用于根据所有Type中函数类型的参数构造一个元祖类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampledeclare function f1(arg: &#123; a: number; b: string &#125;): void;type T0 &#x3D; Parameters&lt;() &#x3D;&gt; string&gt;;&#x2F;&#x2F; type T0 &#x3D; []type T1 &#x3D; Parameters&lt;(s: string) &#x3D;&gt; void&gt;;&#x2F;&#x2F; type T1 &#x3D; [s: string]type T2 &#x3D; Parameters&lt;&lt;T&gt;(arg: T) &#x3D;&gt; T&gt;;&#x2F;&#x2F; type T2 &#x3D; [arg: unknown]type T3 &#x3D; Parameters&lt;typeof f1&gt;;&#x2F;&#x2F; type T3 &#x3D; [arg: &#123;&#x2F;&#x2F;   a: number;&#x2F;&#x2F;   b: string;&#x2F;&#x2F; &#125;]type T4 &#x3D; Parameters&lt;any&gt;;&#x2F;&#x2F; type T4 &#x3D; unknown[]type T5 &#x3D; Parameters&lt;never&gt;;&#x2F;&#x2F; type T5 &#x3D; nevertype T6 &#x3D; Parameters&lt;string&gt;;&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; type T6 &#x3D; nevertype T7 &#x3D; Parameters&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.type T7 &#x3D; never;</code></pre><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li><code>Parameters</code> 首先约束参数 <code>T </code>必须是个函数类型</li><li>判断 <code>T</code> 是否是函数类型，如果是则使用 <code>infer P</code> 暂时存一下函数的参数类型，直接用 P 即可得到这个类型并返回，否则就返回 <code>never</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Parameters&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (  ...args: infer P) &#x3D;&gt; any  ? P  : never;</code></pre><p>这里用到了<code>infer</code>，<code>infer P</code>标记一个泛型，表示这个泛型是一个待推断的类型，并且可以直接使用。</p><h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters<Type></h2><p><code>构造参数类型</code><br>Released:3.1</p><p>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).<br><code>构造一个从构造函数类型Type中提取的元组或数组类型。如果Type不是函数，则生成never类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampletype T0 &#x3D; ConstructorParameters&lt;ErrorConstructor&gt;;&#x2F;&#x2F; type T0 &#x3D; [message?: string]type T1 &#x3D; ConstructorParameters&lt;FunctionConstructor&gt;;&#x2F;&#x2F; type T1 &#x3D; string[]type T2 &#x3D; ConstructorParameters&lt;RegExpConstructor&gt;;&#x2F;&#x2F; type T2 &#x3D; [pattern: string | RegExp, flags?: string]type T3 &#x3D; ConstructorParameters&lt;any&gt;;&#x2F;&#x2F; type T3 &#x3D; unknown[]type T4 &#x3D; ConstructorParameters&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.&#x2F;&#x2F; type T4 &#x3D; never</code></pre><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<Type></h2><p>Released:2.8</p><p>Constructs a type consisting of the return type of function Type.<br><code>用于构造一个含有Type函数的返回值的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampledeclare function f1(): &#123; a: number; b: string &#125;;type T0 &#x3D; ReturnType&lt;() &#x3D;&gt; string&gt;;&#x2F;&#x2F; type T0 &#x3D; stringtype T1 &#x3D; ReturnType&lt;(s: string) &#x3D;&gt; void&gt;;&#x2F;&#x2F; type T1 &#x3D; voidtype T2 &#x3D; ReturnType&lt;&lt;T&gt;() &#x3D;&gt; T&gt;;&#x2F;&#x2F; type T2 &#x3D; unknowntype T3 &#x3D; ReturnType&lt;&lt;T extends U, U extends number[]&gt;() &#x3D;&gt; T&gt;;&#x2F;&#x2F; type T3 &#x3D; number[]type T4 &#x3D; ReturnType&lt;typeof f1&gt;;&#x2F;&#x2F; type T4 &#x3D; &#123;&#x2F;&#x2F; a: number;&#x2F;&#x2F; b: string;&#x2F;&#x2F; &#125;type T5 &#x3D; ReturnType&lt;any&gt;;&#x2F;&#x2F; type T5 &#x3D; anytype T6 &#x3D; ReturnType&lt;never&gt;;&#x2F;&#x2F; type T6 &#x3D; nevertype T7 &#x3D; ReturnType&lt;string&gt;;&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; type T7 &#x3D; anytype T8 &#x3D; ReturnType&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;(...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;(...args: any): any&#39;.&#x2F;&#x2F; type T8 &#x3D; any</code></pre><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>与 Parameters 类似</p><p>ReturnType 首先约束参数 T 必须是个函数类型<br>判断 T 是否是函数类型，如果是则使用 infer R 暂时存一下函数的返回值类型，后面的语句直接用 R 即可得到这个类型并返回，否则就返回 any</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (  ...args: any) &#x3D;&gt; infer R  ? R  : any;</code></pre><h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType<Type></h2><p>Released:2.8</p><p>Constructs a type consisting of the instance type of a constructor function in Type.<br><code>返回构造函数类型T的实例类型</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampleclass C &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;type T0 &#x3D; InstanceType&lt;typeof C&gt;;&#x2F;&#x2F; type T0 &#x3D; Ctype T1 &#x3D; InstanceType&lt;any&gt;;&#x2F;&#x2F; type T1 &#x3D; anytype T2 &#x3D; InstanceType&lt;never&gt;;&#x2F;&#x2F; type T2 &#x3D; nevertype T3 &#x3D; InstanceType&lt;string&gt;;&#x2F;&#x2F; Type &#39;string&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; type T3 &#x3D; anytype T4 &#x3D; InstanceType&lt;Function&gt;;&#x2F;&#x2F; Type &#39;Function&#39; does not satisfy the constraint &#39;abstract new (...args: any) &#x3D;&gt; any&#39;.&#x2F;&#x2F; Type &#39;Function&#39; provides no match for the signature &#39;new (...args: any): any&#39;.&#x2F;&#x2F; type T4 &#x3D; any</code></pre><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p><code>type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; = T extends abstract new (...args: any) =&gt; infer R ? R : any</code><br>与ResultType 类似<br><code>type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;</code></p><h2 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType<Type></h2><p>Released:3.3</p><p>Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.<br><code>用于提取一个函数类型Type的this (opens new window)参数类型，返回unknown (opens new window)如果这个函数类型没有this参数。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Examplefunction toHex(this: Number) &#123;  return this.toString(16);&#125;function numberToString(n: ThisParameterType&lt;typeof toHex&gt;) &#123;  return toHex.apply(n);&#125;</code></pre><h2 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter<Type></h2><p>Released:3.3</p><p>Removes the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.<br><code>用于移除一个函数类型Type的this (opens new window)参数类型。如果Type没有明确的声明this 类型，那么这个返回的结果就是Type，不然的话，就返回一个新的函数类型，基于Type，但不再有this参数。范型会被抹去，只有最后重载的签名被传播进了返回的新的函数类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Examplefunction toHex(this: Number) &#123;  return this.toString(16);&#125;const fiveToHex: OmitThisParameter&lt;typeof toHex&gt; &#x3D; toHex.bind(5);console.log(fiveToHex());</code></pre><h2 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType<Type></h2><p>Released:2.3</p><p>This utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.<br><code>这个类型不返回一个转换过的类型，它被用作标记一个上下文的this类型。注意下如果想使用这个工具类型，noImplicitThis (opens new window)的flag必须启用。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Exampletype ObjectDescriptor&lt;D, M&gt; &#x3D; &#123;  data?: D;  methods?: M &amp; ThisType&lt;D &amp; M&gt;; &#x2F;&#x2F; Type of &#39;this&#39; in methods is D &amp; M&#125;;function makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M &#123;  let data: object &#x3D; desc.data || &#123;&#125;;  let methods: object &#x3D; desc.methods || &#123;&#125;;  return &#123; ...data, ...methods &#125; as D &amp; M;&#125;let obj &#x3D; makeObject(&#123;  data: &#123; x: 0, y: 0 &#125;,  methods: &#123;    moveBy(dx: number, dy: number) &#123;      this.x +&#x3D; dx; &#x2F;&#x2F; Strongly typed this      this.y +&#x3D; dy; &#x2F;&#x2F; Strongly typed this    &#125;,  &#125;,&#125;);obj.x &#x3D; 10;obj.y &#x3D; 20;obj.moveBy(5, 5);</code></pre><p>In the example above, the methods object in the argument to makeObject has a contextual type that includes ThisType&lt;D &amp; M&gt; and therefore the type of this in methods within the methods object is { x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }. Notice how the type of the methods property simultaneously is an inference target and a source for the this type in methods.<br><code>在上面的示例中，makeObject的参数中的methods对象包含了一个上下文类型，该类型包含了ThisType&lt;D &amp; M&gt;，因此methods对象中的this类型是&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;。请注意，methods属性的类型同时是一个推断目标和一个methods对象中的this类型的源。</code><br>The ThisType<T> marker interface is simply an empty interface declared in lib.d.ts. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.<br><code>ThisType&lt;T&gt;标记接口是在lib.d.ts中声明的空接口。它只是在对象字面量的上下文类型中被识别而已，该接口的行为与空接口一样。</code></p><h2 id="Intrinsic-String-Manipulation-Types"><a href="#Intrinsic-String-Manipulation-Types" class="headerlink" title="Intrinsic String Manipulation Types"></a>Intrinsic String Manipulation Types</h2><p><code>内部字符串操作类型</code><br>Uppercase<StringType><br>Lowercase<StringType><br>Capitalize<StringType><br>Uncapitalize<StringType></p><p>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can find those in the Template Literal Types documentation.<br><code>为了帮助模板字符串操作，TypeScript包含一组可以在字符串操作中使用的类型。你可以在模板字符串类型文档中找到它们。</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">typescript handbook utility-types</a><br><a href="https://ts.yayujs.com/reference/UtilityTypes.html#intrinsic-string-manipulation-types">工具类型</a><br><a href="https://blog.csdn.net/qq_34998786/article/details/120300361">Typescript 中的 extends 关键字</a>Exclude 与 Extract 前置学习项<br><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses">Typescript Classes extends-clauses</a><br><a href="https://blog.csdn.net/qq_32438227/article/details/125058423">彻底搞懂 typescript 工具类型及其原理</a> 该文有错误内容，要注意哦<br><a href="https://juejin.cn/post/6844904066485583885">TypeScript 的 extends 条件类型</a></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.Typescript手册 模块</title>
      <link href="//post/2022-06-08ts-modules.html"/>
      <url>//post/2022-06-08ts-modules.html</url>
      
        <content type="html"><![CDATA[<p>JavaScript has a long history of different ways to handle modularizing code. TypeScript having been around since 2012, has implemented support for a lot of these formats, but over time the community and the JavaScript specification has converged on a format called ES Modules (or ES6 modules). You might know it as the import&#x2F;export syntax.<br><code>JavaScript 有很长的历史，不同的方式来处理代码的模块化。TypeScript 从 2012 年开始，就支持了大量的模块化格式，但是，在过去的时间，社区和 JavaScript 规范一致地聚合了一个模块化格式，叫做 ES Modules（或 ES6 模块）。你可能会知道它叫做 import/export 语法。</code></p><p>ES Modules was added to the JavaScript spec in 2015, and by 2020 had broad support in most web browsers and JavaScript runtimes.<br><code>ES Modules 在 2015 年添加到 JavaScript 规范，2020 年已经有广泛的支持在大部分的 web 浏览器和 JavaScript 运行时。</code><br>For focus, the handbook will cover both ES Modules and its popular pre-cursor CommonJS module.exports &#x3D; syntax, and you can find information about the other module patterns in the reference section under Modules.<br><code>为了获得焦点，本手册将介绍 ES Modules 和其常用的先行模块 CommonJS module.exports = 同义词，并且你可以在 Modules 下的参考节中找到其他模块模式的信息。</code></p><h2 id="How-JavaScript-Modules-are-Defined"><a href="#How-JavaScript-Modules-are-Defined" class="headerlink" title="How JavaScript Modules are Defined"></a>How JavaScript Modules are Defined</h2><p>In TypeScript, just as in ECMAScript 2015, any file containing a top-level import or export is considered a module.<br><code>在 TypeScript 中，只要文件包含一个顶层的 import 或 export 就被视为一个模块。</code><br>Conversely, a file without any top-level import or export declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).<br><code>反之，一个没有顶层的 import 或 export 声明的文件就被视为一个脚本，其内容可以在全局作用域中使用（并且也可以作为模块使用）。</code><br>Modules are executed within their own scope, not in the global scope. This means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the export forms. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the import forms.<br><code>模块是在自己的作用域中执行的，不是在全局作用域中执行的。这意味着在模块中声明的变量，函数，类，接口等等，只有在显式的使用 export 声明的时候才能在模块外被访问。反之，要从其他模块中消费一个变量，函数，类，接口等等，必须使用 import 声明来导入。</code></p><h2 id="Non-modules"><a href="#Non-modules" class="headerlink" title="Non-modules"></a>Non-modules</h2><p><code>非模块</code><br>Before we start, it’s important to understand what TypeScript considers a module. The JavaScript specification declares that any JavaScript files without an export or top-level await should be considered a script and not a module.<br><code>在开始之前，我们需要明白 TypeScript 认为什么是模块。JavaScript 规范定义了任何没有 export 或 top-level await 的 JavaScript 文件都被视为脚本而不是模块。</code><br>Inside a script file variables and types are declared to be in the shared global scope, and it’s assumed that you’ll either use the outFile compiler option to join multiple input files into one output file, or use multiple <script> tags in your HTML to load these files (in the correct order!).<br><code>在脚本文件中，变量和类型被声明为共享的全局作用域，并且我们假设你会使用 outFile 编译选项将多个输入文件合并成一个输出文件，或者使用多个 &lt;script&gt; 标签在你的 HTML 中加载这些文件（按照正确的顺序）。</code><br>If you have a file that doesn’t currently have any imports or exports, but you want to be treated as a module, add the line:<br><code>如果你有一个文件，它目前没有任何 import 或 export 声明，但是你想被视为一个模块，那么添加这一行：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export &#123;&#125;;</code></pre><p>which will change the file to be a module exporting nothing. This syntax works regardless of your module target.<br><code>这种语法对于你的模块目标无论如何都是可行的。</code></p><h2 id="Modules-in-TypeScript"><a href="#Modules-in-TypeScript" class="headerlink" title="Modules in TypeScript"></a>Modules in TypeScript</h2><p><code>TypeScript 中的模块</code><br>Additional Reading:<br><code>附加阅读：</code><br>Impatient JS (Modules)<br><code>不知道模块的 TypeScript</code><br>MDN: JavaScript Modules<br><code>MDN：JavaScript 模块</code><br>There are three main things to consider when writing module-based code in TypeScript:<br><code>在 TypeScript 中写模块基础的代码时，要考虑三个主要问题：</code><br>Syntax: What syntax do I want to use to import and export things?<br><code>语法：我想要使用什么语法来导入和导出东西？</code><br>Module Resolution: What is the relationship between module names (or paths) and files on disk?<br><code>模块解析：模块名（或路径）和磁盘上的文件之间的关系是什么？</code><br>Module Output Target: What should my emitted JavaScript module look like?<br><code>模块输出目标：我的输出的 JavaScript 模块应该怎样看？</code></p><h2 id="ES-Module-Syntax"><a href="#ES-Module-Syntax" class="headerlink" title="ES Module Syntax"></a>ES Module Syntax</h2><p><code>ES 模块语法</code><br>A file can declare a main export via export default:<br><code>一个文件可以通过 export default 声明一个主要的导出：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: hello.tsexport default function helloWorld() &#123;  console.log(&quot;Hello, world!&quot;);&#125;</code></pre><p>This is then imported via:<br><code>这是通过以下方式导入的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import helloWorld from &quot;.&#x2F;hello.js&quot;;helloWorld();</code></pre><p>In addition to the default export, you can have more than one export of variables and functions via the export by omitting default:<br><code>除了默认导出，你还可以有多个导出的变量和函数，通过将 default 去掉：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: maths.tsexport var pi &#x3D; 3.14;export let squareTwo &#x3D; 1.41;export const phi &#x3D; 1.61;export class RandomNumberGenerator &#123;&#125;export function absolute(num: number) &#123;if (num &lt; 0) return num \* -1;  return num;&#125;</code></pre><p>These can be used in another file via the import syntax:<br><code>这些可以在另一个文件中通过导入语法使用：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; pi, phi, absolute &#125; from &quot;.&#x2F;maths.js&quot;;console.log(pi);const absPhi &#x3D; absolute(phi);&#x2F;&#x2F; const absPhi: number;</code></pre><h2 id="Additional-Import-Syntax"><a href="#Additional-Import-Syntax" class="headerlink" title="Additional Import Syntax"></a>Additional Import Syntax</h2><p><code>附加导入语法</code><br>An import can be renamed using a format like import {old as new}:<br><code>一个导入可以通过这样的格式：import &#123;old as new&#125;：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; pi as π &#125; from &quot;.&#x2F;maths.js&quot;;console.log(π);&#x2F;&#x2F; (alias) var π: number&#x2F;&#x2F; import π</code></pre><p>You can mix and match the above syntax into a single import:<br><code>你可以混合这些语法到一个单独的导入：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: maths.tsexport const pi &#x3D; 3.14;export default class RandomNumberGenerator &#123;&#125;&#x2F;&#x2F; @filename: app.tsimport RandomNumberGenerator, &#123; pi as π &#125; from &quot;.&#x2F;maths.js&quot;;RandomNumberGenerator;&#x2F;&#x2F; (alias) class RandomNumberGenerator&#x2F;&#x2F; import RandomNumberGeneratorconsole.log(π);&#x2F;&#x2F; (alias) const π: 3.14&#x2F;&#x2F; import π</code></pre><p>You can take all of the exported objects and put them into a single namespace using * as name:<br><code>你可以将所有导出的对象放到一个单独的命名空间，使用 \* as name：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: app.tsimport \* as math from &quot;.&#x2F;maths.js&quot;;console.log(math.pi);const positivePhi &#x3D; math.absolute(math.phi);&#x2F;&#x2F; const positivePhi: number</code></pre><p>You can import a file and not include any variables into your current module via import "./file":<br><code>你可以通过 import &quot;./file&quot; 导入一个文件，并且不包含任何变量到当前模块：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: app.tsimport &quot;.&#x2F;maths.js&quot;;console.log(&quot;3.14&quot;);</code></pre><p>In this case, the import does nothing. However, all of the code in maths.ts was evaluated, which could trigger side-effects which affect other objects.<br><code>在这种情况下，导入并没有什么事情。但是，maths.ts 中的所有代码都会被评估，这可能会触发其他对象的副作用。</code></p><h2 id="TypeScript-Specific-ES-Module-Syntax"><a href="#TypeScript-Specific-ES-Module-Syntax" class="headerlink" title="TypeScript Specific ES Module Syntax"></a>TypeScript Specific ES Module Syntax</h2><p><code>TypeScript 特定的 ES 模块语法</code><br>Types can be exported and imported using the same syntax as JavaScript values:<br><code>类型可以使用相同的语法来导出和导入 JavaScript 值：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: animal.tsexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;export interface Dog &#123;  breeds: string[];  yearOfBirth: number;&#125;&#x2F;&#x2F; @filename: app.tsimport &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;type Animals &#x3D; Cat | Dog;</code></pre><p>TypeScript has extended the import syntax with two concepts for declaring an import of a type:<br><code>TypeScript 已经扩展了导入类型的语法，它有两个概念来声明导入类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import type&#x2F;&#x2F; Which is an import statement which can only import types:&#x2F;&#x2F; 只能导入类型的导入语句：&#x2F;&#x2F; @filename: animal.tsexport type Cat &#x3D; &#123; breed: string; yearOfBirth: number &#125;;&#x2F;&#x2F; &#39;createCatName&#39; cannot be used as a value because it was imported using &#39;import type&#39;.&#x2F;&#x2F; &#39;createCatName&#39; 不能被用作值，因为它被导入使用了 &#39;import type&#39;。export type Dog &#x3D; &#123; breeds: string[]; yearOfBirth: number &#125;;export const createCatName &#x3D; () &#x3D;&gt; &quot;fluffy&quot;;&#x2F;&#x2F; @filename: valid.tsimport type &#123; Cat, Dog &#125; from &quot;.&#x2F;animal.js&quot;;export type Animals &#x3D; Cat | Dog;&#x2F;&#x2F; @filename: app.tsimport type &#123; createCatName &#125; from &quot;.&#x2F;animal.js&quot;;const name &#x3D; createCatName();</code></pre><p>Inline type imports<br><code>内联类型导入</code></p><p>TypeScript 4.5 also allows for individual imports to be prefixed with type to indicate that the imported reference is a type:<br><code>TypeScript 4.5 可以使用 type 前缀来声明导入的引用是一个类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @filename: app.tsimport &#123; createCatName, type Cat, type Dog &#125; from &quot;.&#x2F;animal.js&quot;;export type Animals &#x3D; Cat | Dog;const name &#x3D; createCatName();</code></pre><p>Together these allow a non-TypeScript transpiler like Babel, swc or esbuild to know what imports can be safely removed.<br><code>这些同时允许一个非 TypeScript 编译器，如 Babel、swc 或 esbuild 知道哪些导入可以安全地移除。</code></p><h2 id="ES-Module-Syntax-with-CommonJS-Behavior"><a href="#ES-Module-Syntax-with-CommonJS-Behavior" class="headerlink" title="ES Module Syntax with CommonJS Behavior"></a>ES Module Syntax with CommonJS Behavior</h2><p><code>ES 模块语法与 CommonJS 行为</code><br>TypeScript has ES Module syntax which directly correlates to a CommonJS and AMD require. Imports using ES Module are for most cases the same as the require from those environments, but this syntax ensures you have a 1 to 1 match in your TypeScript file with the CommonJS output:<br><code>TypeScript 有 ES 模块语法，它相对于 CommonJS 和 AMD require。使用 ES Module 的导入是为了大多数情况下与这些环境的 require 一致，但这种语法确保了你的 TypeScript 文件与 CommonJS 输出有一个 1 到 1 的匹配。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import fs &#x3D; require(&quot;fs&quot;);const code &#x3D; fs.readFileSync(&quot;hello.ts&quot;, &quot;utf8&quot;);</code></pre><p>You can learn more about this syntax in the modules reference page.<br><code>你可以在模块参考页面了解更多关于这种语法。</code></p><h2 id="CommonJS-Syntax"><a href="#CommonJS-Syntax" class="headerlink" title="CommonJS Syntax"></a>CommonJS Syntax</h2><p><code>CommonJS 语法</code></p><p>CommonJS is the format which most modules on npm are delivered in. Even if you are writing using the ES Modules syntax above, having a brief understanding of how CommonJS syntax works will help you debug easier.<br><code>CommonJS 是 npm 上大多数模块的格式。即使你正在使用上面的 ES 模块语法，也会有一个简单的了解 CommonJS 语法的方式帮助你调试更容易。</code></p><h2 id="Exporting"><a href="#Exporting" class="headerlink" title="Exporting"></a>Exporting</h2><p><code>导出</code></p><p>Identifiers are exported via setting the exports property on a global called module.<br><code>标识符通过设置 module.exports 属性来导出。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function absolute(num: number) &#123;    if (num &lt; 0) return num \* -1;    return num;&#125;module.exports &#x3D; &#123;  pi: 3.14,  squareTwo: 1.41,  phi: 1.61,  absolute,&#125;;</code></pre><p>Then these files can be imported via a require statement:<br><code>然后，这些文件可以通过 require 语句来导入：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const maths &#x3D; require(&quot;maths&quot;);maths.pi;&#x2F;&#x2F; any;</code></pre><p>Or you can simplify a bit using the destructuring feature in JavaScript:<br><code>或者，你可以使用 JavaScript 的解构特性来简化一些：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const &#123; squareTwo &#125; &#x3D; require(&quot;maths&quot;);squareTwo;&#x2F;&#x2F; const squareTwo: any;</code></pre><h2 id="CommonJS-and-ES-Modules-interop"><a href="#CommonJS-and-ES-Modules-interop" class="headerlink" title="CommonJS and ES Modules interop"></a>CommonJS and ES Modules interop</h2><p><code>CommonJS 和 ES 模块的互操作</code></p><p>There is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop.<br><code>在 CommonJS 和 ES 模块之间存在不匹配的特性，关于默认导入和模块命名空间对象导入的区别。TypeScript 有一个编译器标志来减少 CommonJS 和 ES 模块之间的摩擦。</code></p><h2 id="TypeScript’s-Module-Resolution-Options"><a href="#TypeScript’s-Module-Resolution-Options" class="headerlink" title="TypeScript’s Module Resolution Options"></a>TypeScript’s Module Resolution Options</h2><p><code>TypeScript 的模块解析选项</code></p><p>Module resolution is the process of taking a string from the import or require statement, and determining what file that string refers to.<br><code>模块解析是从 import 或 require 语句中获取字符串，并确定该字符串所引用的文件。</code></p><p>TypeScript includes two resolution strategies: Classic and Node. Classic, the default when the compiler option module is not commonjs, is included for backwards compatibility. The Node strategy replicates how Node.js works in CommonJS mode, with additional checks for .ts and .d.ts.<br><code>TypeScript 包含两种解析策略：经典和 Node。经典，默认情况下，当编译器选项 module 不是 commonjs 时，包含了向后兼容性。Node 策略重复了 Node.js 在 CommonJS 模式下工作的方式，并且添加了 .ts 和 .d.ts 的检查。</code><br>There are many TSConfig flags which influence the module strategy within TypeScript: moduleResolution, baseUrl, paths, rootDirs.<br><code>在 TypeScript 中，有很多 TSConfig 标志影响模块策略：moduleResolution、baseUrl、paths、rootDirs。</code><br>For the full details on how these strategies work, you can consult the Module Resolution.<br><code>关于如何工作的详细信息，你可以参考模块解析。</code></p><h2 id="TypeScript’s-Module-Output-Options"><a href="#TypeScript’s-Module-Output-Options" class="headerlink" title="TypeScript’s Module Output Options"></a>TypeScript’s Module Output Options</h2><p><code>TypeScript 的模块输出选项</code><br>There are two options which affect the emitted JavaScript output:<br><code>有两个影响输出的 JavaScript 的选项：</code></p><ul><li>target which determines which JS features are downleveled (converted to run in older JavaScript runtimes) and which are left intact<br><code>target 是指定哪些 JS 特性被下游（转换为在旧的 JavaScript 运行时运行），哪些被保留。</code></li><li>module which determines what code is used for modules to interact with each other<br><code>module 是指定哪些代码用于模块交互。</code></li></ul><p>Which target you use is determined by the features available in the JavaScript runtime you expect to run the TypeScript code in. That could be: the oldest web browser you support, the lowest version of Node.js you expect to run on or could come from unique constraints from your runtime - like Electron for example.<br><code>哪个目标你使用是由你期望在 JavaScript 运行时运行 TypeScript 代码的功能决定的。这可能是：最旧的 web 浏览器，最低版本的 Node.js，或者来自你运行时的唯一约束 - 例如，Electron。</code><br>All communication between modules happens via a module loader, the compiler option module determines which one is used. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it.<br><code>模块之间的通信都是通过模块加载器来完成的，编译器选项 module 是指定哪个被使用。在运行时，模块加载器负责定位并执行所有模块的依赖之前执行它。</code><br>For example, here is a TypeScript file using ES Modules syntax, showcasing a few different options for module:<br><code>例如，这里是一个使用 ES Modules 语法的 TypeScript 文件，展示了一些模块的选项：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;export const twoPi &#x3D; valueOfPi _ 2;</code></pre><h2 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a>ES2020</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; valueOfPi &#125; from &quot;.&#x2F;constants.js&quot;;export const twoPi &#x3D; valueOfPi _ 2;</code></pre><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;use strict&quot;;Object.defineProperty(exports, &quot;\_\_esModule&quot;, &#123; value: true &#125;);exports.twoPi &#x3D; void 0;const constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);exports.twoPi &#x3D; constants_js_1.valueOfPi \* 2;</code></pre><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">(function (factory) &#123;  if (typeof module &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof module.exports &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;    var v &#x3D; factory(require, exports);    if (v !&#x3D;&#x3D; undefined) module.exports &#x3D; v;  &#125;  else if (typeof define &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; define.amd) &#123;    define([&quot;require&quot;, &quot;exports&quot;, &quot;.&#x2F;constants.js&quot;], factory);  &#125;&#125;)(function (require, exports) &#123;  &quot;use strict&quot;;  Object.defineProperty(exports, &quot;\_\_esModule&quot;, &#123; value: true &#125;);  exports.twoPi &#x3D; void 0;  const constants_js_1 &#x3D; require(&quot;.&#x2F;constants.js&quot;);  exports.twoPi &#x3D; constants_js_1.valueOfPi \* 2;&#125;);</code></pre><p>Note that ES2020 is effectively the same as the original index.ts.<br><code>ES2020 是一样的于原始 index.ts。</code><br>You can see all of the available options and what their emitted JavaScript code looks like in the TSConfig Reference for module.<br><code>你可以看到所有可用的选项和他们的输出 JavaScript 代码的样子在 module 的 TSConfig 参考中。</code></p><h2 id="TypeScript-namespaces"><a href="#TypeScript-namespaces" class="headerlink" title="TypeScript namespaces"></a>TypeScript namespaces</h2><p><code>TypeScript 命名空间</code><br>TypeScript has its own module format called namespaces which pre-dates the ES Modules standard. This syntax has a lot of useful features for creating complex definition files, and still sees active use in DefinitelyTyped. While not deprecated, the majority of the features in namespaces exist in ES Modules and we recommend you use that to align with JavaScript’s direction. You can learn more about namespaces in the namespaces reference page.<br><code>TypeScript 有自己的模块格式命名空间，它是先期的 ES Modules 标准。这种语法具有很多有用的功能创建复杂的定义文件，仍然在 DefinitelyTyped 中有活跃使用。尽管不被弃用，大多数的功能在命名空间中存在于 ES Modules，我们建议你使用它与 JavaScript 的方向对齐。你可以在命名空间参考页面上了解更多关于命名空间。</code></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.Typescript手册 类</title>
      <link href="//post/2022-06-08ts-classes.html"/>
      <url>//post/2022-06-08ts-classes.html</url>
      
        <content type="html"><![CDATA[<p>Background Reading:<br><code>背景阅读</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Classes (MDN)</a></p><p>TypeScript offers full support for the class keyword introduced in ES2015.<br><code>typescript 支持 ES2015 的 class 关键字。</code></p><p>As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.<br><code> 像其他 JavaScript 语言特性一样，TypeScript 添加了类型注解和其他语法，以便您可以表达类和其他类型之间的关系。</code></p><h2 id="Class-Members"><a href="#Class-Members" class="headerlink" title="Class Members"></a>Class Members</h2><p><code>类成员</code><br>Here’s the most basic class - an empty one:<br><code>这是最基本的类 - 空的一个：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;&#125;</code></pre><p>This class isn’t very useful yet, so let’s start adding some members.<br><code>这个类还不是很有用，所以我们开始添加一些成员。</code></p><h2 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h2><p><code>字段</code><br>A field declaration creates a public writeable property on a class:<br><code>字段声明创建一个公共可写属性在类上：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x: number;  y: number;&#125;const pt &#x3D; new Point();pt.x &#x3D; 0;pt.y &#x3D; 0;</code></pre><p>As with other locations, the type annotation is optional, but will be an implicit any if not specified.<br><code>与其他地方一样，类型注解是可选的，如果没有指定，将会是任意类型。</code><br>Fields can also have initializers; these will run automatically when the class is instantiated:<br><code>字段也可以有初始值，这会在类被实例化时自动运行：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;const pt &#x3D; new Point();&#x2F;&#x2F; Prints 0, 0console.log(&#96;$&#123;pt.x&#125;, $&#123;pt.y&#125;&#96;);</code></pre><p>Just like with const, let, and var, the initializer of a class property will be used to infer its type:<br><code>和 const，let，var 类型推断的初始值。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const pt &#x3D; new Point();pt.x &#x3D; &quot;0&quot;;&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre><h2 id="–strictPropertyInitialization"><a href="#–strictPropertyInitialization" class="headerlink" title="–strictPropertyInitialization"></a>–strictPropertyInitialization</h2><p>The strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor.<br><code>strictPropertyInitialization 设置控制类字段是否需要在构造函数中初始化。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class BadGreeter &#123;  name: string;  &#x2F;&#x2F; Property &#39;name&#39; has no initializer and is not definitely assigned in the constructor.&#125;class GoodGreeter &#123;  name: string;  constructor() &#123;    this.name &#x3D; &quot;hello&quot;;  &#125;&#125;</code></pre><p>Note that the field needs to be initialized in the constructor itself. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.<br><code>注意，字段需要在构造函数本身中初始化。TypeScript 不会分析调用构造函数的方法来检测初始化，因为继承的子类可能覆盖这些方法并且失败初始化成员。</code><br>If you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !:<br><code>如果您愿意通过其他方式来确定初始化一个字段（例如，可能是外部库填充您的类的一部分），您可以使用确定赋值断言运算符：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class OKGreeter &#123;  &#x2F;&#x2F; Not initialized, but no error  name!: string;&#125;</code></pre><h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><p>Fields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor.<br><code>字段可以使用 readonly 前缀。这将阻止在构造函数之外赋值给字段。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Greeter &#123;  readonly name: string &#x3D; &quot;world&quot;;  constructor(otherName?: string) &#123;    if (otherName !&#x3D;&#x3D; undefined) &#123;      this.name &#x3D; otherName;    &#125;  &#125;  err() &#123;    this.name &#x3D; &quot;not ok&quot;;    &#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.  &#125;&#125;const g &#x3D; new Greeter();g.name &#x3D; &quot;also not ok&quot;;&#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.</code></pre><h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p><code>构造函数</code><br>Background Reading:<br><code>背景阅读：</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">Constructor (MDN)</a></p><p>Class constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:<br><code>类构造函数和函数很相似。您可以添加参数，类型注解，默认值和重载。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x: number;  y: number;  &#x2F;&#x2F; Normal signature with defaults  constructor(x &#x3D; 0, y &#x3D; 0) &#123;    this.x &#x3D; x;    this.y &#x3D; y;  &#125;&#125;</code></pre><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  &#x2F;&#x2F; Overloads  constructor(x: number, y: string);  constructor(s: string);  constructor(xs: any, y?: any) &#123;    &#x2F;&#x2F; TBD  &#125;&#125;</code></pre><p>There are just a few differences between class constructor signatures and function signatures:<br><code>类构造函数和函数签名有一些不同：</code></p><ul><li>Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later<br><code>- 构造函数不能有类型参数，这些属于外部类声明，我们将会学习其他内容</code></li><li>Constructors can’t have return type annotations - the class instance type is always what’s returned<br><code>- 构造函数不能有返回类型注解，返回的类实例类型始终是返回的</code></li></ul><h2 id="Super-Calls"><a href="#Super-Calls" class="headerlink" title="Super Calls"></a>Super Calls</h2><p><code>超类调用</code><br>Just as in JavaScript, if you have a base class, you’ll need to call super(); in your constructor body before using any this. members:<br><code>在 JavaScript 中，如果您有基类，您需要在构造函数体中调用 super(); 在使用任何 this. 成员之前：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;k &#x3D; 4;&#125;class Derived extends Base &#123;constructor() &#123;&#x2F;&#x2F; Prints a wrong value in ES5; throws exception in ES6console.log(this.k);&#39;super&#39; must be called before accessing &#39;this&#39; in the constructor of a derived class.super();&#125;&#125;</code></pre><p>Forgetting to call super is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.<br><code>在 JavaScript 中，忘记调用 super() 可能是一个很简单的错误，但 TypeScript 将告诉您当必要时。</code></p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><code>方法</code><br>Background Reading:<br><code>背景阅读：</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/method">Method (MDN)</a></p><p>A function property on a class is called a method. Methods can use all the same type annotations as functions and constructors:<br><code>类中的函数属性被称为方法。方法可以使用和函数和构造函数一样的类型注解：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Point &#123;  x &#x3D; 10;  y &#x3D; 10;  scale(n: number): void &#123;    this.x *&#x3D; n;    this.y *&#x3D; n;  &#125;&#125;</code></pre><p>Other than the standard type annotations, TypeScript doesn’t add anything else new to methods.<br><code>除了标准类型注解之外，TypeScript 不会添加任何其他东西到方法。</code><br>Note that inside a method body, it is still mandatory to access fields and other methods via this.. An unqualified name in a method body will always refer to something in the enclosing scope:<br><code>在方法体中，在方法体内部，您仍然必须通过 this 访问字段和其他方法。在方法体内部，未命名的名称将始终指向包含它的作用域内的东西：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let x: number &#x3D; 0;class C &#123;x: string &#x3D; &quot;hello&quot;;  m() &#123;    &#x2F;&#x2F; This is trying to modify &#39;x&#39; from line 1, not the class property    &#x2F;&#x2F; 这是尝试从行 1 修改 &#39;x&#39;，而不是类属性    x &#x3D; &quot;world&quot;;    Type &#39;string&#39; is not assignable to type &#39;number&#39;.  &#125;&#125;</code></pre><h2 id="Getters-x2F-Setters"><a href="#Getters-x2F-Setters" class="headerlink" title="Getters &#x2F; Setters"></a>Getters &#x2F; Setters</h2><p><code>获取器/设置器</code><br>Classes can also have accessors:<br><code>类也可以有访问器：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class C &#123;  _length &#x3D; 0;  get length() &#123;    return this._length;  &#125;  set length(value) &#123;    this._length &#x3D; value;  &#125;&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Note that a field-backed get&#x2F;set pair with no extra logic is very rarely useful in JavaScript. It’s fine to expose public fields if you don’t need to add additional logic during the get&#x2F;set operations.<br><code>&gt;注意，没有额外逻辑的字段-获取/设置-对偶在 JavaScript 中很少是有用的。如果您不需要在获取/设置操作期间添加额外逻辑，则可以暴露公共字段。</code></p></blockquote><p>TypeScript has some special inference rules for accessors:<br><code>TypeScript 有一些特殊的推断规则为访问器：</code></p><ul><li>If get exists but no set, the property is automatically readonly<br><code>- 如果 get 存在但没有 set，属性是自动只读的</code></li><li>If the type of the setter parameter is not specified, it is inferred from the return type of the getter<br><code>- 如果设置器参数的类型没有指定，它会从 getter 的返回类型推断</code></li><li>Getters and setters must have the same Member Visibility<br><code>- 获取器和设置器必须具有相同的成员可见性</code><br>Since TypeScript 4.3, it is possible to have accessors with different types for getting and setting.<br><code>从 TypeScript 4.3 开始，可以有不同类型的访问器获取和设置。</code></li></ul><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Thing &#123;  _size &#x3D; 0;  get size(): number &#123;    return this._size;  &#125;  set size(value: string | number | boolean) &#123;    let num &#x3D; Number(value);    &#x2F;&#x2F; Don&#39;t allow NaN, Infinity, etc    if (!Number.isFinite(num)) &#123;      this._size &#x3D; 0;      return;    &#125;    this._size &#x3D; num;  &#125;&#125;</code></pre><h2 id="Index-Signatures"><a href="#Index-Signatures" class="headerlink" title="Index Signatures"></a>Index Signatures</h2><p><code>索引签名</code><br>Classes can declare index signatures; these work the same as Index Signatures for other object types:<br><code>类可以声明索引签名；这类似于其他对象类型的索引签名：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class MyClass &#123;  [s: string]: boolean | ((s: string) &#x3D;&gt; boolean);  check(s: string) &#123;    return this[s] as boolean;  &#125;&#125;</code></pre><p>Because the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.<br><code>因为索引签名类型也需要捕获方法的类型，这使得并不容易有效的使用这些类型。通常的来说，在其他地方存储索引数据而不是在类实例本身，会更好一些。</code></p><h2 id="Class-Heritage"><a href="#Class-Heritage" class="headerlink" title="Class Heritage"></a>Class Heritage</h2><p><code>类继承</code><br>Like other languages with object-oriented features, classes in JavaScript can inherit from base classes.<br><code>在 JavaScript 中，类可以从基类继承。</code></p><h2 id="implements-Clauses"><a href="#implements-Clauses" class="headerlink" title="implements Clauses"></a>implements Clauses</h2><p><code>implements 语句</code><br>You can use an implements clause to check that a class satisfies a particular interface. An error will be issued if a class fails to correctly implement it:<br><code>你可以使用 implements 语句检查一个类是否满足一个特定的 interface。如果一个类没有正确的实现(implement)它，TypeScript 会报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Pingable &#123;  ping(): void;&#125;class Sonar implements Pingable &#123;  ping() &#123;    console.log(&quot;ping!&quot;);  &#125;&#125;class Ball implements Pingable &#123;  &#x2F;&#x2F; Class &#39;Ball&#39; incorrectly implements interface &#39;Pingable&#39;.  &#x2F;&#x2F; 类 &#39;Ball&#39; 错误地实现了接口 &#39;Pingable&#39;。  &#x2F;&#x2F; Property &#39;ping&#39; is missing in type &#39;Ball&#39; but required in type &#39;Pingable&#39;.  &#x2F;&#x2F; 在类型 &#39;Ball&#39; 中缺少属性 &#39;ping&#39;，但是在类型 &#39;Pingable&#39; 中是必需的。  pong() &#123;    console.log(&quot;pong!&quot;);  &#125;&#125;</code></pre><p>Classes may also implement multiple interfaces, e.g. class C implements A, B {.<br><code>类也可以实现多个接口，比如 class C implements A, B &#123;</code></p><p><strong>Cautions</strong></p><p><code>注意事项</code></p><p><strong>大概意思：这是类型，不是 java 中的接口，不能当 js 类去用,与 js 的类不是一个概念</strong></p><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>It’s important to understand that an implements clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods at all. A common source of error is to assume that an implements clause will change the class type - it doesn’t!<br><code>implements 语句仅仅检查类是否按照接口类型实现，但它并不会改变类的类型或者方法的类型。一个常见的错误就是以为 implements 语句会改变类的类型,——然而实际上它并不会：</code></p></div><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Checkable &#123;  check(name: string): boolean;&#125;class NameChecker implements Checkable &#123;  check(s) &#123;    &#x2F;&#x2F; Parameter &#39;s&#39; implicitly has an &#39;any&#39; type.    &#x2F;&#x2F; Notice no error here    return s.toLowercse() &#x3D;&#x3D;&#x3D; &quot;ok&quot;;    &#x2F;&#x2F; any;  &#125;&#125;</code></pre><p>In this example, we perhaps expected that s’s type would be influenced by the name: string parameter of check. It is not - implements clauses don’t change how the class body is checked or its type inferred.<br><code>在这个例子中，我们可能会以为 s 的类型会被 check 的 name: string 参数影响。实际上并没有，implements 语句并不会影响类的内部是如何检查或者类型推断的。</code><br>Similarly, implementing an interface with an optional property doesn’t create that property:<br><code>类似的，实现一个有可选属性的接口，并不会创建这个属性：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface A &#123;  x: number;  y?: number;&#125;class C implements A &#123;  x &#x3D; 0;&#125;const c &#x3D; new C();c.y &#x3D; 10;&#x2F;&#x2F; Property &#39;y&#39; does not exist on type &#39;C&#39;.</code></pre><h2 id="extends-Clauses"><a href="#extends-Clauses" class="headerlink" title="extends Clauses"></a>extends Clauses</h2><p><code>extends 语句</code></p><p>Background Reading: <a href="https://www.typescriptlang.org/docs/handbook/classes.html#class-inheritance">Class Inheritance</a></p><p><code>背景阅读：[类继承](https://www.typescriptlang.org/docs/handbook/classes.html#class-inheritance)</code></p><p>Classes may extend from a base class. A derived class has all the properties and methods of its base class, and also define additional members.<br><code>类可以从基类继承。一个派生类具有基类的所有属性和方法，并且还定义了一些额外的成员。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Animal &#123;  move() &#123;    console.log(&quot;Moving along!&quot;);  &#125;&#125;class Dog extends Animal &#123;  woof(times: number) &#123;    for (let i &#x3D; 0; i &lt; times; i++) &#123;      console.log(&quot;woof!&quot;);    &#125;  &#125;&#125;const d &#x3D; new Dog();&#x2F;&#x2F; Base class methodd.move();&#x2F;&#x2F; Derived class methodd.woof(3);</code></pre><h3 id="Overriding-Methods"><a href="#Overriding-Methods" class="headerlink" title="Overriding Methods"></a>Overriding Methods</h3><p><code>覆写方法</code></p><p>Background Reading: <a href="https://www.typescriptlang.org/docs/handbook/classes.html#overriding-methods">Overriding Methods</a></p><p>A derived class can also override a base class field or property. You can use the super. syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.<br><code>派生类可以覆写基类的属性或方法。可以使用 super. 语句访问基类的方法。注意，因为 JavaScript 的类是简单的查找对象，所以没有基类的“super 字段”。</code><br>TypeScript enforces that a derived class is always a subtype of its base class.<br><code>TypeScript 强制所有派生类都是基类的子类。</code><br>For example, here’s a legal way to override a method:<br><code>这里是一种合法的方式覆写方法：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  greet() &#123;    console.log(&quot;Hello, world!&quot;);  &#125;&#125;class Derived extends Base &#123;  greet(name?: string) &#123;    if (name &#x3D;&#x3D;&#x3D; undefined) &#123;      super.greet();    &#125; else &#123;      console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);    &#125;  &#125;&#125;const d &#x3D; new Derived();d.greet();d.greet(&quot;reader&quot;);</code></pre><p>It’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:<br><code>派生类需要遵循着它的基类的实现。而且通过一个基类引用指向一个派生类实例，这是非常常见并合法的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; Alias the derived instance through a base class reference&#x2F;&#x2F; 基类引用来访问派生类的实例const b: Base &#x3D; d;&#x2F;&#x2F; No problem&#x2F;&#x2F; 没有问题b.greet();</code></pre><p>What if Derived didn’t follow Base’s contract?<br><code>但是如果 Derived 不遵循 Base 的约定实现呢？</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  greet() &#123;    console.log(&quot;Hello, world!&quot;);  &#125;&#125;class Derived extends Base &#123;  &#x2F;&#x2F; Make this parameter required  greet(name: string) &#123;    &#x2F;&#x2F; Property &#39;greet&#39; in type &#39;Derived&#39; is not assignable to the same property in base type &#39;Base&#39;.    &#x2F;&#x2F; Type &#39;(name: string) &#x3D;&gt; void&#39; is not assignable to type &#39;() &#x3D;&gt; void&#39;.    console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);  &#125;&#125;</code></pre><p>If we compiled this code despite the error, this sample would then crash:<br><code>如果我们编译这段代码，却没有报错，那么这个例子就会崩溃：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const b: Base &#x3D; new Derived();&#x2F;&#x2F; Crashes because &quot;name&quot; will be undefinedb.greet();</code></pre><h3 id="Type-only-Field-Declarations"><a href="#Type-only-Field-Declarations" class="headerlink" title="Type-only Field Declarations"></a>Type-only Field Declarations</h3><p><code>只有字段申明的类型</code><br>When target &gt;&#x3D; ES2022 or useDefineForClassFields is true, class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write declare to indicate to TypeScript that there should be no runtime effect for this field declaration.<br><code>当目标版本 &gt;= ES2022 或者 useDefineForClassFields 为 true 时，类字段在父类构造函数完成后初始化，并且会覆盖父类的设置。这种情况下，如果你只想重新定义一个更加准确的类型，你可以使用 declare 来指示给 TypeScript。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Animal &#123;  dateOfBirth: any;&#125;interface Dog extends Animal &#123;  breed: any;&#125;class AnimalHouse &#123;  resident: Animal;  constructor(animal: Animal) &#123;    this.resident &#x3D; animal;  &#125;&#125;class DogHouse extends AnimalHouse &#123;  &#x2F;&#x2F; Does not emit JavaScript code,  &#x2F;&#x2F; 不能生成 JavaScript 代码  &#x2F;&#x2F; only ensures the types are correct  &#x2F;&#x2F; 只是确保类型正确  declare resident: Dog;  constructor(dog: Dog) &#123;    super(dog);  &#125;&#125;</code></pre><p><strong>输出</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; .d.tsinterface Animal &#123;  dateOfBirth: any;&#125;interface Dog extends Animal &#123;  breed: any;&#125;declare class AnimalHouse &#123;  resident: Animal;  constructor(animal: Animal);&#125;declare class DogHouse extends AnimalHouse &#123;  resident: Dog;  constructor(dog: Dog);&#125;</code></pre><h3 id="Initialization-Order"><a href="#Initialization-Order" class="headerlink" title="Initialization Order"></a>Initialization Order</h3><p><code>初始化顺序</code><br>The order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:<br><code>这段代码的初始化顺序可能会有些不同。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Base &#123;  name &#x3D; &quot;base&quot;;  constructor() &#123;    console.log(&quot;My name is &quot; + this.name);  &#125;&#125;class Derived extends Base &#123;  name &#x3D; &quot;derived&quot;;&#125;&#x2F;&#x2F; Prints &quot;base&quot;, not &quot;derived&quot;const d &#x3D; new Derived();</code></pre><h3 id="What-happened-here"><a href="#What-happened-here" class="headerlink" title="What happened here?"></a>What happened here?</h3><p><code>这里发生了什么？</code> 先执行基类构造，this.name 值是“base”<br>The order of class initialization, as defined by JavaScript, is:<br><code>JavaScript 的初始化顺序：</code></p><ul><li>The base class fields are initialized<br><code>基类字段初始化</code></li><li>The base class constructor runs<br><code>基类构造函数运行</code></li><li>The derived class fields are initialized<br><code>派生类字段初始化</code></li><li>The derived class constructor runs<br><code>派生类构造函数运行</code><br>This means that the base class constructor saw its own value for name during its own constructor, because the derived class field initializations hadn’t run yet.</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;  name &#x3D; &quot;base&quot;;  constructor() &#123;    console.log(&quot;My name is &quot; + this.name);  &#125;&#125;class Derived extends Base &#123;  name &#x3D; &quot;derived&quot;;&#125;&#x2F;&#x2F; Prints &quot;base&quot;, not &quot;derived&quot;const d &#x3D; new Derived();console.log(d.name); &#x2F;&#x2F; 加个日志看看</code></pre><p>点击 run 后，返回</p><pre class="line-numbers language-none"><code class="language-none">[LOG]: &quot;My name is base&quot;[LOG]: &quot;derived&quot;</code></pre><h3 id="Inheriting-Built-in-Types"><a href="#Inheriting-Built-in-Types" class="headerlink" title="Inheriting Built-in Types"></a>Inheriting Built-in Types</h3><p><code>继承内置类型</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Note: If you don’t plan to inherit from built-in types like Array, Error, Map, etc. or your compilation target is explicitly set to ES6&#x2F;ES2015 or above, you may skip this section<br><code>注意：如果你不打算继承内置的类型比如 Array、Error、Map 等或者你的编译目标是 ES6/ES2015 或者更新的版本，你可以跳过这个章节。</code></p></blockquote><p>In ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(…). It is necessary for generated constructor code to capture any potential return value of super(…) and replace it with this.<br><code>在 ES2015 中，当调用 super(...) 的时候，如果构造函数返回了一个对象，会隐式替换 this 的值。所以捕获 super() 可能的返回值并用 this 替换它是非常有必要的。</code><br>As a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6’s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.<br><code>这就导致，像 Error、Array 等子类，也许不会再如你期望的那样运行。这是因为 Error、Array 等类似内置对象的构造函数，会使用 ECMAScript 6 的 new.target 调整原型链。然而，在 ECMAScript 5 中，当调用一个构造函数的时候，并没有方法可以确保 new.target 的值。 其他的降级编译器默认也会有同样的限制。</code><br>For a subclass like the following:<br><code>下面的子类：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MsgError extends Error &#123;  constructor(m: string) &#123;    super(m);  &#125;  sayHello() &#123;    return &quot;hello &quot; + this.message;  &#125;&#125;</code></pre><p>you may find that:<br><code>你也许可以发现：</code><br>methods may be undefined on objects returned by constructing these subclasses, so calling sayHello will result in an error.<br><code>对象的方法可能是 undefined ，所以调用 sayHello 会导致错误</code><br>instanceof will be broken between instances of the subclass and their instances, so (new MsgError()) instanceof MsgError will return false.<br><code>instanceof 失效， (new MsgError()) instanceof MsgError 会返回 false。</code><br>As a recommendation, you can manually adjust the prototype immediately after any super(…) calls.<br><code>我们推荐，手动的在 super(...) 调用后调整原型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MsgError extends Error &#123;  constructor(m: string) &#123;    super(m);    &#x2F;&#x2F; Set the prototype explicitly.    Object.setPrototypeOf(this, MsgError.prototype);  &#125;  sayHello() &#123;    return &quot;hello &quot; + this.message;  &#125;&#125;</code></pre><p>However, any subclass of MsgError will have to manually set the prototype as well. For runtimes that don’t support Object.setPrototypeOf, you may instead be able to use <code>__proto__</code>.<br><code>不过，任何 MsgError 的子类也不得不手动设置原型。如果运行时不支持 Object.setPrototypeOf，你也许可以使用 __proto__ </code></p><p>Unfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed.<br><code>不幸的是，这些方案并不会能在 IE 10 或者之前的版本正常运行。解决的一个方法是手动拷贝原型中的方法到实例中（就比如 MsgError.prototype 到 this），但是它自己的原型链依然没有被修复</code></p><h2 id="Member-Visibility"><a href="#Member-Visibility" class="headerlink" title="Member Visibility"></a>Member Visibility</h2><p><code>成员可见性</code><br>You can use TypeScript to control whether certain methods or properties are visible to code outside the class.<br><code>你可以使用 TypeScript 控制某个方法或者属性是否对类以外的代码可见。</code></p><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>The default visibility of class members is public. A public member can be accessed anywhere:<br><code>因为 public 是默认的可见性修饰符，所以你不需要写它，除非处于格式或者可读性的原因。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Greeter &#123;  public greet() &#123;    console.log(&quot;hi!&quot;);  &#125;&#125;const g &#x3D; new Greeter();g.greet();</code></pre><p>Because public is already the default visibility modifier, you don’t ever need to write it on a class member, but might choose to do so for style&#x2F;readability reasons.<br><code>因为 public 是默认的可见性修饰符，所以你不需要写它，除非处于格式或者可读性的原因。</code></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>protected members are only visible to subclasses of the class they’re declared in.<br><code>protected 成员仅仅对子类可见</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Greeter &#123;  public greet() &#123;    console.log(&quot;Hello, &quot; + this.getName());  &#125;  protected getName() &#123;    return &quot;hi&quot;;  &#125;&#125;class SpecialGreeter extends Greeter &#123;  public howdy() &#123;    &#x2F;&#x2F; OK to access protected member here    console.log(&quot;Howdy, &quot; + this.getName());  &#125;&#125;const g &#x3D; new SpecialGreeter();g.greet(); &#x2F;&#x2F; OKg.getName();&#x2F;&#x2F; Property &#39;getName&#39; is protected and only accessible within class &#39;Greeter&#39; and its subclasses.</code></pre><h3 id="Exposure-of-protected-members"><a href="#Exposure-of-protected-members" class="headerlink" title="Exposure of protected members"></a>Exposure of protected members</h3><p><code>受保护成员的公开</code></p><p>Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public:<br><code>派生类需要遵循基类的实现，但是依然可以选择公开拥有更多能力的基类子类型，这就包括让一个 protected 成员变成 public：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;  protected m &#x3D; 10;&#125;class Derived extends Base &#123;  &#x2F;&#x2F; No modifier, so default is &#39;public&#39;  m &#x3D; 15;&#125;const d &#x3D; new Derived();console.log(d.m); &#x2F;&#x2F; OK</code></pre><p>Note that Derived was already able to freely read and write m, so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the protected modifier if this exposure isn’t intentional.<br><code>这里需要注意的是，如果公开不是故意的，在这个派生类中，我们需要小心的拷贝 protected 修饰符。</code></p><h3 id="Cross-hierarchy-protected-access"><a href="#Cross-hierarchy-protected-access" class="headerlink" title="Cross-hierarchy protected access"></a>Cross-hierarchy protected access</h3><p><code>交叉等级受保护成员访问</code></p><p>Different OOP languages disagree about whether it’s legal to access a protected member through a base class reference:</p><p><code>不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;  protected x: number &#x3D; 1;&#125;class Derived1 extends Base &#123;  protected x: number &#x3D; 5;&#125;class Derived2 extends Base &#123;  f1(other: Derived2) &#123;    other.x &#x3D; 10;  &#125;  f2(other: Base) &#123;    other.x &#x3D; 10;    &#x2F;&#x2F; Property &#39;x&#39; is protected and only accessible through an instance of class &#39;Derived2&#39;. This is an instance of class &#39;Base&#39;.    &#x2F;&#x2F; 属性 &#39;x&#39; 受保护并且只能通过类 &#39;Derived2&#39; 的实例访问。这是一个类 &#39;Base&#39; 的实例。  &#125;&#125;</code></pre><p>Java, for example, considers this to be legal. On the other hand, C# and C++ chose that this code should be illegal.<br><code>在 Java 中，这是合法的，而 C# 和 C++ 认为这段代码是不合法的。</code><br>TypeScript sides with C# and C++ here, because accessing x in Derived2 should only be legal from Derived2’s subclasses, and Derived1 isn’t one of them. Moreover, if accessing x through a Derived1 reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.<br><code>TypeScript 站在 C# 和 C++ 这边。因为 Derived2 的 x 应该只有从 Derived2 的子类访问才是合法的，而 Derived1 并不是它们中的一个。此外，如果通过 Derived1 访问 x 是不合法的，通过一个基类引用访问也应该是不合法的。</code><br>See also Why Can’t I Access A Protected Member From A Derived Class? which explains more of C#‘s reasoning.<br><code>看这篇《Why Can’t I Access A Protected Member From A Derived Class?》 (opens new window)，解释了更多 C# 这样做的原因。</code></p><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>private is like protected, but doesn’t allow access to the member even from subclasses:<br><code>private 有点像 protected ，但是不允许访问成员，即便是子类。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;  private x &#x3D; 0;&#125;const b &#x3D; new Base();&#x2F;&#x2F; Can&#39;t access from outside the class&#x2F;&#x2F; 不能从外部访问console.log(b.x);&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.&#x2F;&#x2F; 属性 &#39;x&#39; 是私有的，只能在类 &#39;Base&#39; 中访问。</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Derived extends Base &#123;  showX() &#123;    &#x2F;&#x2F; Can&#39;t access in subclasses    console.log(this.x);    &#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.    &#x2F;&#x2F; 属性 &#39;x&#39; 是私有的，只能在类 &#39;Base&#39; 中访问。  &#125;&#125;</code></pre><p>Because private members aren’t visible to derived classes, a derived class can’t increase its visibility:<br><code>因为 private 成员对派生类并不可见，所以一个派生类也不能增加它的可见性：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;  private x &#x3D; 0;&#125;class Derived extends Base &#123;  &#x2F;&#x2F; Class &#39;Derived&#39; incorrectly extends base class &#39;Base&#39;.  &#x2F;&#x2F; 类 &#39;Derived&#39; 错误地继承了基类 &#39;Base&#39;。  &#x2F;&#x2F; Property &#39;x&#39; is private in type &#39;Base&#39; but not in type &#39;Derived&#39;.  &#x2F;&#x2F; 属性 &#39;x&#39; 在类 &#39;Base&#39; 中，但不在类 &#39;Derived&#39; 中。  x &#x3D; 1;&#125;</code></pre><h3 id="Cross-instance-private-access"><a href="#Cross-instance-private-access" class="headerlink" title="Cross-instance private access"></a>Cross-instance private access</h3><p><code>交叉等级受保护成员访问</code><br>Different OOP languages disagree about whether different instances of the same class may access each others’ private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.<br><code>不同的 OOP 语言在通过一个基类引用是否可以合法的获取一个 protected 成员是有争议的。在 Java, C#, C++, Swift, and PHP 中，这是合法的，而 Ruby 认为这段代码是不合法的。</code><br>TypeScript does allow cross-instance private access:<br><code>允许交叉实例私有访问</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class A &#123;  private x &#x3D; 10;  public sameAs(other: A) &#123;    &#x2F;&#x2F; No error    return other.x &#x3D;&#x3D;&#x3D; this.x;  &#125;&#125;</code></pre><h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats"></a>Caveats</h3><p><code>警告</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Like other aspects of TypeScript’s type system, private and protected are only enforced during type checking.<br><code>类型检查中，private 和 protected 只是类型检查的一部分。</code></p></blockquote><p>This means that JavaScript runtime constructs like in or simple property lookup can still access a private or protected member:<br><code>这意味着在 JavaScript 运行时，像 in 或者简单的属性查找，依然可以获取 private 或者 protected 成员。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MySafe &#123;  private secretKey &#x3D; 12345;&#125;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; In a JavaScript file...const s &#x3D; new MySafe();&#x2F;&#x2F; Will print 12345console.log(s.secretKey);</code></pre><p>private also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy.<br><code>private 也允许使用方括号来访问，这使得 private-declared 字段可以轻松地访问，但是这些字段是软私有的，并不强制私密。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MySafe &#123;private secretKey &#x3D; 12345;&#125;const s &#x3D; new MySafe();&#x2F;&#x2F; Not allowed during type checkingconsole.log(s.secretKey);Property &#39;secretKey&#39; is private and only accessible within class &#39;MySafe&#39;.&#x2F;&#x2F; OKconsole.log(s[&quot;secretKey&quot;]);</code></pre><p>Unlike TypeScripts’s private, JavaScript’s private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.<br><code>不像 TypeScript 的 private，JavaScript 的私有字段 (opens new window)（#）即便是编译后依然保留私有性，并且不会提供像上面这种方括号获取的方法，这让它们变得强私有（hard private）。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Dog &#123;  #barkAmount &#x3D; 0;  personality &#x3D; &quot;happy&quot;;  constructor() &#123;&#125;&#125;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;use strict&quot;;class Dog &#123;  #barkAmount &#x3D; 0;  personality &#x3D; &quot;happy&quot;;  constructor() &#123;&#125;&#125;</code></pre><p>When compiling to ES2021 or less, TypeScript will use WeakMaps in place of #.<br><code>在编译到 ES2021 或更低版本时，TypeScript 会使用 WeakMaps 替代 #。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;use strict&quot;;var _Dog_barkAmount;class Dog &#123;  constructor() &#123;    _Dog_barkAmount.set(this, 0);    this.personality &#x3D; &quot;happy&quot;;  &#125;&#125;_Dog_barkAmount &#x3D; new WeakMap();</code></pre><p>If you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.<br><code>如果你需要防止恶意攻击，保护类中的值，你应该使用强私有的机制比如闭包，WeakMaps ，或者私有字段。但是注意，这也会在运行时影响性能。</code></p><h2 id="Static-Members"><a href="#Static-Members" class="headerlink" title="Static Members"></a>Static Members</h2><p><code>静态成员</code></p><p>Background Reading: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">Static Members (MDN)</a></p><p>Classes may have static members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:<br><code>类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;  static x &#x3D; 0;  static printX() &#123;    console.log(MyClass.x);  &#125;&#125;console.log(MyClass.x);MyClass.printX();</code></pre><p>Static members can also use the same public, protected, and private visibility modifiers:<br><code>类可以有静态成员，静态成员跟类实例没有关系，可以通过类本身访问到：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;  private static x &#x3D; 0;&#125;console.log(MyClass.x);&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;MyClass&#39;.</code></pre><h3 id="Static-members-are-also-inherited"><a href="#Static-members-are-also-inherited" class="headerlink" title="Static members are also inherited:"></a>Static members are also inherited:</h3><p><code>静态成员也可以被继承：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;  static getGreeting() &#123;    return &quot;Hello world&quot;;  &#125;&#125;class Derived extends Base &#123;  myGreeting &#x3D; Derived.getGreeting();&#125;</code></pre><h3 id="Special-Static-Names"><a href="#Special-Static-Names" class="headerlink" title="Special Static Names"></a>Special Static Names</h3><p><code>特殊静态类</code><br>It’s generally not safe&#x2F;possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names can’t be used. Function properties like name, length, and call aren’t valid to define as static members:<br><code>类本身是函数，而覆写 Function 原型上的属性通常认为是不安全的，因此不能使用一些固定的静态名称，函数属性像 name、length、call 不能被用来定义 static 成员：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class S &#123;  static name &#x3D; &quot;S!&quot;;  &#x2F;&#x2F; Static property &#39;name&#39; conflicts with built-in property &#39;Function.name&#39; of constructor function &#39;S&#39;.&#125;</code></pre><h3 id="Why-No-Static-Classes"><a href="#Why-No-Static-Classes" class="headerlink" title="Why No Static Classes?"></a>Why No Static Classes?</h3><p><code>为什么没有静态类？</code></p><p>TypeScript (and JavaScript) don’t have a construct called static class the same way as, for example, C# does.<br><code>TypeScript（和 JavaScript） 并没有名为静态类（static class）的结构，但是像 C# 和 Java 有。</code><br>Those constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript&#x2F;TypeScript.<br><code>所谓静态类，指的是作为类的静态成员存在于某个类的内部的类。比如这种：</code><br>For example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:<br><code>静态类之所以存在是因为这些语言强迫所有的数据和函数都要在一个类内部，但这个限制在 TypeScript 中并不存在，所以也没有静态类的需要。一个只有一个单独实例的类，在 JavaScript/TypeScript 中，完全可以使用普通的对象替代。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Unnecessary &quot;static&quot; classclass MyStaticClass &#123;  static doSomething() &#123;&#125;&#125;&#x2F;&#x2F; Preferred (alternative 1)function doSomething() &#123;&#125;&#x2F;&#x2F; Preferred (alternative 2)const MyHelperObject &#x3D; &#123;  dosomething() &#123;&#125;,&#125;;</code></pre><h2 id="static-Blocks-in-Classes"><a href="#static-Blocks-in-Classes" class="headerlink" title="static Blocks in Classes"></a>static Blocks in Classes</h2><p><code>类静态块</code><br>Static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.<br><code>静态块允许你写一系列有自己作用域的语句，也可以获取类里的私有字段。这意味着我们可以安心的写初始化代码：正常书写语句，无变量泄漏，还可以完全获取类中的属性和方法。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Foo &#123;  static #count &#x3D; 0;  get count() &#123;    return Foo.#count;  &#125;  static &#123;    try &#123;      const lastInstances &#x3D; loadLastInstances();      Foo.#count +&#x3D; lastInstances.length;    &#125; catch &#123;&#125;  &#125;&#125;</code></pre><h3 id="Generic-Classes"><a href="#Generic-Classes" class="headerlink" title="Generic Classes"></a>Generic Classes</h3><p><code>范型类</code></p><p>Classes, much like interfaces, can be generic. When a generic class is instantiated with new, its type parameters are inferred the same way as in a function call:<br><code>类跟接口一样，也可以写泛型。当使用 new 实例化一个泛型类，它的类型参数的推断跟函数调用是同样的方式：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box&lt;Type&gt; &#123;  contents: Type;  constructor(value: Type) &#123;    this.contents &#x3D; value;  &#125;&#125;const b &#x3D; new Box(&quot;hello!&quot;);const b: Box&lt;string&gt;;</code></pre><p>Classes can use generic constraints and defaults the same way as interfaces.<br><code>类跟接口一样也可以使用泛型约束以及默认值。</code></p><h3 id="Type-Parameters-in-Static-Members"><a href="#Type-Parameters-in-Static-Members" class="headerlink" title="Type Parameters in Static Members"></a>Type Parameters in Static Members</h3><p><code>静态成员中的类型参数</code><br>This code isn’t legal, and it may not be obvious why:<br><code>这段代码不合法，并且可能不明白为什么：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box&lt;Type&gt; &#123;static defaultValue: Type;Static members cannot reference class type parameters.&#125;</code></pre><p>Remember that types are always fully erased! At runtime, there’s only one Box.defaultValue property slot. This means that setting Box<string>.defaultValue (if that were possible) would also change Box<number>.defaultValue - not good. The static members of a generic class can never refer to the class’s type parameters.<br><code>记住类型会被完全抹除，运行时，只有一个 Box.defaultValue 属性槽。这也意味着如果设置 Box&lt;string&gt;.defaultValue 是可以的话，这也会改变 Box&lt;number&gt;.defaultValue，而这样是不好的。</code></p><h3 id="this-at-Runtime-in-Classes"><a href="#this-at-Runtime-in-Classes" class="headerlink" title="this at Runtime in Classes"></a>this at Runtime in Classes</h3><p>Background Reading:<br><code>背景阅读：</code><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">this keyword (MDN)</a><br>It’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.<br><code>TypeScript 并不会更改 JavaScript 运行时的行为，并且 JavaScript 有时会出现一些奇怪的运行时行为。</code><br>JavaScript’s handling of this is indeed unusual:<br><code>就比如 JavaScript 处理 this 就很奇怪：</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class MyClass &#123;  name &#x3D; &quot;MyClass&quot;;  getName() &#123;    return this.name;  &#125;&#125;const c &#x3D; new MyClass();const obj &#x3D; &#123;  name: &quot;obj&quot;,  getName: c.getName,&#125;;&#x2F;&#x2F; Prints &quot;obj&quot;, not &quot;MyClass&quot;console.log(obj.getName());</code></pre><p>Long story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance.<br><code>长篇大论，默认情况下，函数内部的 this 值取决于函数被调用的方式。在这个例子中，因为函数被 obj 引用调用，它的 this 值是 obj，而不是类实例。</code><br>This is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.<br><code>这很少是你想要的！TypeScript 提供了一些方法来解决这种错误。</code></p><h3 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h3><p>Background Reading:<br><code>背景阅读：</code><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions (MDN)</a></p><p>If you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition:<br><code>如果你有一个函数，经常在被调用的时候丢失 this 上下文，使用一个箭头函数或许更好些。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;  name &#x3D; &quot;MyClass&quot;;  getName &#x3D; () &#x3D;&gt; &#123;    return this.name;  &#125;;&#125;const c &#x3D; new MyClass();const g &#x3D; c.getName;&#x2F;&#x2F; Prints &quot;MyClass&quot; instead of crashingconsole.log(g());</code></pre><p>This has some trade-offs:<br><code>这里有几点需要注意下：</code></p><ul><li>The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript<br><code>- 这个 this 值在运行时是一定的，即使没有 TypeScript 的检查</code></li><li>This will use more memory, because each class instance will have its own copy of each function defined this way<br><code>- 这会使用更多的内存，因为每个类实例都会有自己的拷贝</code></li><li>You can’t use super.getName in a derived class, because there’s no entry in the prototype chain to fetch the base class method from<br><code>- 你不能在子类中使用 super.getName，因为没有基类原型链来获取基类方法</code></li></ul><h3 id="this-parameters"><a href="#this-parameters" class="headerlink" title="this parameters"></a>this parameters</h3><p>In a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation:<br><code>在方法或函数定义中，一个初始参数名为 this 的特殊意义在 TypeScript 中。这些参数在编译期间会被抹除。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; TypeScript input with &#39;this&#39; parameterfunction fn(this: SomeType, x: number) &#123;  &#x2F;* ... *&#x2F;&#125;</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; JavaScript outputfunction fn(x) &#123;  &#x2F;* ... *&#x2F;&#125;</code></pre><p>TypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly:<br><code>TypeScript 会检查一个有 this 参数的函数在调用时是否有一个正确的上下文。不像上个例子使用箭头函数，我们可以给方法定义添加一个 this 参数，静态强制方法被正确调用：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;  name &#x3D; &quot;MyClass&quot;;  getName(this: MyClass) &#123;    return this.name;  &#125;&#125;const c &#x3D; new MyClass();&#x2F;&#x2F; OKc.getName();&#x2F;&#x2F; Error, would crashconst g &#x3D; c.getName;console.log(g());&#x2F;&#x2F; The &#39;this&#39; context of type &#39;void&#39; is not assignable to method&#39;s &#39;this&#39; of type &#39;MyClass&#39;.</code></pre><p>This method makes the opposite trade-offs of the arrow function approach:<br><code>这个方法也有一些注意点，正好跟箭头函数相反：</code></p><ul><li>JavaScript callers might still use the class method incorrectly without realizing it<br><code>JavaScript 调用者依然可能在没有意识到它的时候错误使用类方法</code></li><li>Only one function per class definition gets allocated, rather than one per class instance<br><code>每个类一个函数，而不是每一个类实例一个函数</code></li><li>Base method definitions can still be called via super.<br><code>基类方法定义依然可以通过 super 调用</code></li></ul><h3 id="this-Types"><a href="#this-Types" class="headerlink" title="this Types"></a>this Types</h3><p>In classes, a special type called this refers dynamically to the type of the current class. Let’s see how this is useful:<br><code>在类中，一个特殊的类型叫做 this，它可以动态指向当前类的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box &#123;  contents: string &#x3D; &quot;&quot;;  set(value: string) &#123;    &#x2F;&#x2F; (method) Box.set(value: string): this    this.contents &#x3D; value;    return this;  &#125;&#125;</code></pre><p>Here, TypeScript inferred the return type of set to be this, rather than Box. Now let’s make a subclass of Box:<br><code>这里，TypeScript 推断 set 的返回类型为 this，而不是 Box。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class ClearableBox extends Box &#123;  clear() &#123;    this.contents &#x3D; &quot;&quot;;  &#125;&#125;const a &#x3D; new ClearableBox();const b &#x3D; a.set(&quot;hello&quot;);&#x2F;&#x2F; const b: ClearableBox</code></pre><p>You can also use this in a parameter type annotation:<br><code>你也可以在参数类型注解中使用 this：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box &#123;  content: string &#x3D; &quot;&quot;;  sameAs(other: this) &#123;    return other.content &#x3D;&#x3D;&#x3D; this.content;  &#125;&#125;</code></pre><p>This is different from writing other: Box — if you have a derived class, its sameAs method will now only accept other instances of that same derived class:<br><code>这与写其他：Box — 如果你有一个派生类，它的 sameAs 方法将只接受来自同一派生类的其他实例：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box &#123;  content: string &#x3D; &quot;&quot;;  sameAs(other: this) &#123;    return other.content &#x3D;&#x3D;&#x3D; this.content;  &#125;&#125;class DerivedBox extends Box &#123;  otherContent: string &#x3D; &quot;?&quot;;&#125;const base &#x3D; new Box();const derived &#x3D; new DerivedBox();derived.sameAs(base);&#x2F;&#x2F; Argument of type &#39;Box&#39; is not assignable to parameter of type &#39;DerivedBox&#39;.&#x2F;&#x2F; Property &#39;otherContent&#39; is missing in type &#39;Box&#39; but required in type &#39;DerivedBox&#39;.</code></pre><h3 id="this-based-type-guards"><a href="#this-based-type-guards" class="headerlink" title="this -based type guards"></a>this -based type guards</h3><p>You can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type.<br><code>你可以在类和接口中的方法的返回位置使用 this。当混入一个类型缩小（如 if 语句）的时候，目标对象的类型将被缩小到指定的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class FileSystemObject &#123;  isFile(): this is FileRep &#123;    return this instanceof FileRep;  &#125;  isDirectory(): this is Directory &#123;    return this instanceof Directory;  &#125;  isNetworked(): this is Networked &amp; this &#123;    return this.networked;  &#125;  constructor(public path: string, private networked: boolean) &#123;&#125;&#125;class FileRep extends FileSystemObject &#123;  constructor(path: string, public content: string) &#123;    super(path, false);  &#125;&#125;class Directory extends FileSystemObject &#123;  children: FileSystemObject[];&#125;interface Networked &#123;  host: string;&#125;const fso: FileSystemObject &#x3D; new FileRep(&quot;foo&#x2F;bar.txt&quot;, &quot;foo&quot;);if (fso.isFile()) &#123;  fso.content;  &#x2F;&#x2F; const fso: FileRep;&#125; else if (fso.isDirectory()) &#123;  fso.children;  &#x2F;&#x2F; const fso: Directory;&#125; else if (fso.isNetworked()) &#123;  fso.host;  &#x2F;&#x2F; const fso: Networked &amp; FileSystemObject;&#125;</code></pre><p>A common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an undefined from the value held inside box when hasValue has been verified to be true:<br><code>一个常见的基于 this 的类型保护的使用例子，会对一个特定的字段进行懒校验（lazy validation）。举个例子，在这个例子中，当 hasValue 被验证为 true 时，会从类型中移除 undefined：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box&lt;T&gt; &#123;value?: T;hasValue(): this is &#123; value: T &#125; &#123;return this.value !&#x3D;&#x3D; undefined;&#125;&#125;const box &#x3D; new Box();box.value &#x3D; &quot;Gameboy&quot;;box.value;(property) Box&lt;unknown&gt;.value?: unknownif (box.hasValue()) &#123;box.value;(property) value: unknown&#125;</code></pre><h2 id="Parameter-Properties"><a href="#Parameter-Properties" class="headerlink" title="Parameter Properties"></a>Parameter Properties</h2><p><code>参数属性</code><br>TypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s):<br><code>TypeScript 提供了特殊的语法，可以把一个构造函数参数转成一个同名同值的类属性。这些就被称为参数属性（parameter properties）。你可以通过在构造函数参数前添加一个可见性修饰符 public private protected 或者 readonly 来创建参数属性，最后这些类属性字段也会得到这些修饰符：</code></p><p><strong>之后我们 look 一下 flutter,太像</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Params &#123;  constructor(    public readonly x: number,    protected y: number,    private z: number  ) &#123;    &#x2F;&#x2F; No body necessary  &#125;&#125;const a &#x3D; new Params(1, 2, 3);console.log(a.x);&#x2F;&#x2F; (property) Params.x: numberconsole.log(a.z);&#x2F;&#x2F; Property &#39;z&#39; is private and only accessible within class &#39;Params&#39;.</code></pre><h2 id="Class-Expressions"><a href="#Class-Expressions" class="headerlink" title="Class Expressions"></a>Class Expressions</h2><p><code>类表达式</code></p><p>Background Reading:<br><code>背景阅读：</code><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class">Class expressions (MDN)</a></p><p>Class expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:<br><code>类表达式跟类声明非常类似，唯一不同的是类表达式不需要一个名字，尽管我们可以通过绑定的标识符进行引用：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const someClass &#x3D; class&lt;Type&gt; &#123;  content: Type;  constructor(value: Type) &#123;    this.content &#x3D; value;  &#125;&#125;;const m &#x3D; new someClass(&quot;Hello, world&quot;);&#x2F;&#x2F; const m: someClass&lt;string&gt;;</code></pre><h3 id="abstract-Classes-and-Members"><a href="#abstract-Classes-and-Members" class="headerlink" title="abstract Classes and Members"></a>abstract Classes and Members</h3><p><code>抽象类和成员</code><br>Classes, methods, and fields in TypeScript may be abstract.<br><code>TypeScript 中，类、方法、字段都可以是抽象的（abstract）。</code><br>An abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.<br><code>抽象方法或者抽象字段是不提供实现的。这些成员必须存在在一个抽象类中，这个抽象类也不能直接被实例化。</code><br>The role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete.<br><code>抽象类的作用是作为子类的基类，让子类实现所有的抽象成员。当一个类没有任何抽象成员，他就会被认为是具体的（concrete）。</code><br>Let’s look at an example:<br><code>让我们看个例子：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">abstract class Base &#123;  abstract getName(): string;  printName() &#123;    console.log(&quot;Hello, &quot; + this.getName());  &#125;&#125;const b &#x3D; new Base();&#x2F;&#x2F; Cannot create an instance of an abstract class.</code></pre><p>We can’t instantiate Base with new because it’s abstract. Instead, we need to make a derived class and implement the abstract members:<br><code>我们不能使用 new 实例 Base 因为它是抽象类。我们需要写一个派生类，并且实现抽象成员。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Derived extends Base &#123;  getName() &#123;    return &quot;world&quot;;  &#125;&#125;const d &#x3D; new Derived();d.printName();</code></pre><p>Notice that if we forget to implement the base class’s abstract members, we’ll get an error:<br><code>注意，如果我们忘记实现基类的抽象成员，我们会得到一个报错：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Derived extends Base &#123;  &#x2F;&#x2F; Non-abstract class &#39;Derived&#39; does not implement inherited abstract member &#39;getName&#39; from class &#39;Base&#39;.  &#x2F;&#x2F; forgot to do anything&#125;</code></pre><h2 id="Abstract-Construct-Signatures"><a href="#Abstract-Construct-Signatures" class="headerlink" title="Abstract Construct Signatures"></a>Abstract Construct Signatures</h2><p><code>抽象构造签名</code></p><p>Sometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.<br><code>有的时候，你希望接受传入可以继承一些抽象类产生一个类的实例的类构造函数。</code><br>For example, you might want to write this code:<br><code>举个例子，你也许会写这样的代码：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(ctor: typeof Base) &#123;  const instance &#x3D; new ctor();  &#x2F;&#x2F; Cannot create an instance of an abstract class.  instance.printName();&#125;</code></pre><p>TypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of greet, it’s perfectly legal to write this code, which would end up constructing an abstract class:<br><code>TypeScript 会报错，告诉你正在尝试实例化一个抽象类。毕竟，根据 greet 的定义，这段代码应该是合法的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Bad!greet(Base);</code></pre><p>Instead, you want to write a function that accepts something with a construct signature:<br><code>但如果你写一个函数接受传入一个构造签名：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(ctor: new () &#x3D;&gt; Base) &#123;  const instance &#x3D; new ctor();  instance.printName();&#125;greet(Derived);greet(Base);&#x2F;&#x2F; Argument of type &#39;typeof Base&#39; is not assignable to parameter of type &#39;new () &#x3D;&gt; Base&#39;.&#x2F;&#x2F; 参数类型 &#39;typeof Base&#39; 不能赋值给参数类型 &#39;new () &#x3D;&gt; Base&#39;。&#x2F;&#x2F; Cannot assign an abstract constructor type to a non-abstract constructor type.&#x2F;&#x2F; 不能将一个抽象构造类型赋值给一个非抽象构造类型。</code></pre><p>Now TypeScript correctly tells you about which class constructor functions can be invoked - Derived can because it’s concrete, but Base cannot.<br><code>现在 TypeScript 会正确的告诉你，哪一个类构造函数可以被调用，Derived 可以，因为它是具体的，而 Base 是不能的。</code></p><h2 id="Relationships-Between-Classes"><a href="#Relationships-Between-Classes" class="headerlink" title="Relationships Between Classes"></a>Relationships Between Classes</h2><p><code>类之间的关系</code><br>In most cases, classes in TypeScript are compared structurally, the same as other types.<br><code>大部分时候，TypeScript 的类跟其他类型一样，会被结构性比较。</code><br>For example, these two classes can be used in place of each other because they’re identical:<br><code>举个例子，这两个类可以用于替代彼此，因为它们结构是相等的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point1 &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;class Point2 &#123;  x &#x3D; 0;  y &#x3D; 0;&#125;&#x2F;&#x2F; OKconst p: Point1 &#x3D; new Point2();</code></pre><p>Similarly, subtype relationships between classes exist even if there’s no explicit inheritance:<br><code>类似的还有，类的子类型之间可以建立关系，即使没有明显的继承：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Person &#123;  name: string;  age: number;&#125;class Employee &#123;  name: string;  age: number;  salary: number;&#125;&#x2F;&#x2F; OKconst p: Person &#x3D; new Employee();</code></pre><p>This sounds straightforward, but there are a few cases that seem stranger than others.<br><code>这听起来有些简单，但还有一些例子可以看出奇怪的地方。</code></p><p>Empty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:</p><p><code>空类没有任何成员。在一个结构化类型系统中，没有成员的类型通常是任何其他类型的父类型。所以如果你写一个空类（只是举例，你可不要这样做），任何东西都可以用来替换它：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Empty &#123;&#125;function fn(x: Empty) &#123;  &#x2F;&#x2F; can&#39;t do anything with &#39;x&#39;, so I won&#39;t&#125;&#x2F;&#x2F; All OK!fn(window);fn(&#123;&#125;);fn(fn);</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#class-members">typescript官网 类</a><br><a href="https://ts.yayujs.com/handbook/Class.html#%E7%B1%BB-classes">类（Classes）</a></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.Typescript手册 类型操作</title>
      <link href="//post/2022-06-07ts-type-manipulation.html"/>
      <url>//post/2022-06-07ts-type-manipulation.html</url>
      
        <content type="html"><![CDATA[<h2 id="ts-类型如何调试"><a href="#ts-类型如何调试" class="headerlink" title="ts 类型如何调试"></a>ts 类型如何调试</h2><ul><li>不是代码逻辑如何调试，没想到</li></ul><h2 id="ts-自定义类型如何打印"><a href="#ts-自定义类型如何打印" class="headerlink" title="ts 自定义类型如何打印"></a>ts 自定义类型如何打印</h2><ul><li>不是 js 的结果如何打印，没想到</li></ul><h2 id="Creating-Types-from-Types"><a href="#Creating-Types-from-Types" class="headerlink" title="Creating Types from Types"></a>Creating Types from Types</h2><p>从已有类型中创建类型</p><p>TypeScript 的类型系统非常强大，因为它允许表达类型的另一种表达方式。<br>最简单的方式是泛型，我们实际上有一大堆的类型操作符可用。还可以表达类型的另一种表达方式，就是把已有的值作为类型。<br>通过合并多种类型操作符，我们可以表达复杂的操作和值，这里我们将介绍以另一个类型或值为基础如何表达一个新类型。</p><p><code>简单来说：使用 范型 或 6种表达式 来创建新类型</code></p><ul><li><p>范型 - 类型需要参数</p></li><li><p>Keyof Type Operator - 用 keyof 操作去创建新类型</p></li><li><p>Typeof Type Operator - 用 typeof 操作去创建新类型</p></li><li><p>Indexed Access Types - 使用 Type[‘a’]语法去访问一个类型的一部分</p></li><li><p>Conditional Types - 类型行为像 if 语句一样</p></li><li><p>Mapped Types - 通过映射已有类型的每个属性来创建新类型</p></li><li><p>Template Literal Types - 通过模板字符串来改变属性的映射类型</p></li></ul><h2 id="Keyof-Type-Operator"><a href="#Keyof-Type-Operator" class="headerlink" title="Keyof Type Operator"></a>Keyof Type Operator</h2><ul><li>这个操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type P1 &#x3D; keyof any; &#x2F;&#x2F; 提示：type P1 &#x3D; string | number | symbol</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Point &#x3D; &#123; x: number; y: number &#125;;type P &#x3D; keyof Point; &#x2F;&#x2F; 提示：type P &#x3D; keyof Point，这个提示等于没提示</code></pre><ul><li>如果这个类型有字符串或者数字索引，keyof 就会返回这个类型：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Arrayish &#x3D; &#123; [n: number]: unknown &#125;;type A &#x3D; keyof Arrayish; &#x2F;&#x2F;提示：type A &#x3D; numbertype Mapish &#x3D; &#123; [k: string]: boolean &#125;;type M &#x3D; keyof Mapish; &#x2F;&#x2F; 提示：type M &#x3D; string | number&#x2F;&#x2F; --------------------------------------------------------------&#x2F;&#x2F; 对于Arrayish&#x2F;&#x2F; 实例1:okvar a: Arrayish &#x3D; &#123;  1: &quot;string&quot;,  2: false,&#125;;&#x2F;&#x2F; 实例2: okvar a1: Arrayish &#x3D; [1, 2, 3, 4];&#x2F;&#x2F; 对于 Mapishvar b: Mapish &#x3D; &#123;  name: true,  age: false,&#125;;</code></pre><p>注意，这个例子中，M 是 string | number — 这是因为 JavaScript 对象键是总是被强制为字符串，所以 obj[0] 总是和 obj[“0”] 相同。</p><p>keyof 类型操作符可以获取一个对象的所有 key，返回一个字符串或者数字的联合类型，接下来的类型 P 是这个类型的类型：</p><h2 id="Typeof-type-operator"><a href="#Typeof-type-operator" class="headerlink" title="Typeof type operator"></a>Typeof type operator</h2><p>JavaScript 也有一个 typeof 操作符，可以用在表达式中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; Prints &quot;string&quot;console.log(typeof &quot;Hello world&quot;);</code></pre><p>TypeScript 增加了一个 typeof 操作符，可以用在类型上：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let s &#x3D; &quot;hello&quot;;let n: typeof s; &#x2F;&#x2F; 提示：let n: string</code></pre><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><p>对于基本类型，typeof 操作符没有意义，但是与其他类型操作符结合使用，可以用 typeof 操作符来实现一些模式。例如，我们开始用 ReturnType<T> 来表示函数的返回类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Predicate &#x3D; (x: unknown) &#x3D;&gt; boolean;type K &#x3D; ReturnType&lt;Predicate&gt;; &#x2F;&#x2F; 提示 type K &#x3D; boolean</code></pre><p>如果我们尝试使用 ReturnType 在函数名上，我们会看到一个指示性的错误：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function f() &#123;  return &#123; x: 10, y: 3 &#125;;&#125;type P &#x3D; ReturnType&lt;f&gt;;&#x2F;&#x2F; 提示：&#39;f&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof f&#39;?&#x2F;&#x2F; 提示：&#39;f&#39; 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof f&#39; 来代替 &#39;f&#39;？</code></pre><p>记住，值和类型不是一回事。要引用值 f 所拥有的类型，我们使用 typeof：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function f() &#123;  return &#123; x: 10, y: 3 &#125;;&#125;type P &#x3D; ReturnType&lt;typeof f&gt;;&#x2F;** * 提示 * type P &#x3D; &#123;    x: number;    y: number;&#125;**&#x2F;</code></pre><p><strong>限制</strong></p><p>typescript 通常限制了 typeof 的表达式的类型。<br>特殊的，typeof 的表达式<code>只能用于标识符（即变量名）其属性</code>。这个限制是为了避免写一些你认为是执行的代码，但实际上并不是的：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Meant to use &#x3D; ReturnType&lt;typeof msgbox&gt;let shouldContinue: typeof msgbox(&quot;Are you sure you want to continue?&quot;);&#x2F;&#x2F; &#39;,&#39; expected.</code></pre><h2 id="Indexed-Access-Types"><a href="#Indexed-Access-Types" class="headerlink" title="Indexed Access Types"></a>Indexed Access Types</h2><p>我们可以使用索引访问类型来查找一个类型的特定属性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Person &#x3D; &#123; age: number; name: string; alive: boolean &#125;;type Age &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示：type Age &#x3D; number</code></pre><p>这个索引类型本身是一个类型，所以我们可以使用联合，keyof 或者其他类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type I1 &#x3D; Person[&quot;age&quot; | &quot;name&quot;]; &#x2F;&#x2F; 提示：type I1 &#x3D; string | numbertype I2 &#x3D; Person[keyof Person]; &#x2F;&#x2F; 提示：type I2 &#x3D; string | number | booleantype AliveOrName &#x3D; &quot;alive&quot; | &quot;name&quot;;type I3 &#x3D; Person[AliveOrName]; &#x2F;&#x2F; 提示：type I3 &#x3D; string | boolean</code></pre><p>你会看到一个错误，如果你尝试索引一个不存在的属性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type I1 &#x3D; Person[&quot;alve&quot;];Property &#39;alve&#39; does not exist on type &#39;Person&#39;.</code></pre><p>另一个例子是使用 number 来获取数组的元素类型。我们可以使用 typeof 来方便地捕获数组字面量的元素类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const MyArray &#x3D; [  &#123; name: &quot;Alice&quot;, age: 15 &#125;,  &#123; name: &quot;Bob&quot;, age: 23 &#125;,  &#123; name: &quot;Eve&quot;, age: 38 &#125;,];type Person &#x3D; typeof MyArray[number];&#x2F;&#x2F; 提示：type Person &#x3D; &#123; name: string; age: number; &#125;type Age &#x3D; typeof MyArray[number][&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age &#x3D; number;&#x2F;&#x2F; Ortype Age2 &#x3D; Person[&quot;age&quot;]; &#x2F;&#x2F; 提示 type Age2 &#x3D; number;</code></pre><p>你只能使用类型来索引，意味着你不能使用 const 来创建一个变量引用：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const key &#x3D; &quot;age&quot;;type Age &#x3D; Person[key];&#x2F;&#x2F; Type &#39;key&#39; cannot be used as an index type.&#x2F;&#x2F; 这个错误是因为 key 是一个字面量，而不是一个变量。&#x2F;&#x2F; &#39;key&#39; refers to a value, but is being used as a type here. Did you mean &#39;typeof key&#39;?&#x2F;&#x2F; 这个错误是因为 key 涉及到一个值，但是在这里被使用作为类型。你是否想使用 &#39;typeof key&#39; 来代替 &#39;key&#39;？</code></pre><p>然而，你可以使用一个类型别名来替换相同的风格的重构：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type key &#x3D; &quot;age&quot;;type Age &#x3D; Person[key];</code></pre><h2 id="Conditional-Types"><a href="#Conditional-Types" class="headerlink" title="Conditional Types"></a>Conditional Types</h2><p>At the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs.<br>在最常见的程序中，我们需要根据输入来做决策。 JavaScript 程序是不同的，但是给定了这个事实，那些决策是根据输入的类型来做的。条件类型帮助描述输入和输出类型之间的关系。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Animal &#123;  live(): void;&#125;interface Dog extends Animal &#123;  woof(): void;&#125;type Example1 &#x3D; Dog extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example1 &#x3D; numbertype Example2 &#x3D; RegExp extends Animal ? number : string; &#x2F;&#x2F; 提示：type Example2 &#x3D; string</code></pre><p>条件类型的表达式像 JavaScript 中的条件表达式一样：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">SomeType extends OtherType ? TrueType : FalseType;</code></pre><p><strong>此段内容，原文保留</strong><br>When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).</p><p>当 extends 左边的类型可以赋值给右边的类型时，你会得到第一个分支的类型（“true”分支）；否则你会得到第二个分支的类型（“false”分支）。</p><p>From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string! But the power of conditional types comes from using them with generics.<br>从上面的例子中可以看到条件类型可能不会立即看起来很有用，我们可以告诉自己 Dog 是否继承了 Animal，然后选择 number 或 string！但是条件类型的力量来自于使用它们与泛型。</p><p>For example, let’s take the following createLabel function:<br>例如，我们可以把下面的 createLabel 函数拿来说说：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface IdLabel &#123;  id: number &#x2F;* some fields *&#x2F;;&#125;interface NameLabel &#123;  name: string &#x2F;* other fields *&#x2F;;&#125;function createLabel(id: number): IdLabel;function createLabel(name: string): NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel;function createLabel(nameOrId: string | number): IdLabel | NameLabel &#123;  throw &quot;unimplemented&quot;;&#125;</code></pre><p>These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:<br>这些 createLabel 的重载描述了一个单一的 JavaScript 函数，它根据输入的类型来做决策。请注意一些事情：</p><p>If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.<br>We have to create three overloads: one for each case when we’re sure of the type (one for string and one for number), and one for the most general case (taking a string | number). For every new type createLabel can handle, the number of overloads grows exponentially.<br>如果一个库需要在其 API 中重复使用相同的选择，这就变得非常麻烦。我们需要创建三个重载：一个当我们知道类型时，一个当我们知道类型时，一个当我们不知道类型时。对于每个新的类型 createLabel 可以处理，重载的数量就会指数增长。<br>Instead, we can encode that logic in a conditional type:<br>反之，我们可以使用条件类型来表示逻辑：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type NameOrId&lt;T extends number | string&gt; &#x3D; T extends number  ? IdLabel  : NameLabel;</code></pre><p>We can then use that conditional type to simplify our overloads down to a single function with no overloads.<br>我们可以使用这个条件类型来简化我们的重载，只有一个函数。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function createLabel&lt;T extends number | string&gt;(idOrName: T): NameOrId&lt;T&gt; &#123;  throw &quot;unimplemented&quot;;&#125;let a &#x3D; createLabel(&quot;typescript&quot;);&#x2F;&#x2F; 提示：let a: NameLabel;let b &#x3D; createLabel(2.8);&#x2F;&#x2F; 提示：let b: IdLabel;let c &#x3D; createLabel(Math.random() ? &quot;hello&quot; : 42);&#x2F;&#x2F; 提示：let c: NameLabel | IdLabel;</code></pre><ul><li>Conditional Type Constraints</li></ul><p>条件类型约束</p><p>Often, the checks in a conditional type will provide us with some new information. Just like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.<br>通常，在条件类型中的检查会提供我们一些新的信息。像类型检查一样，通过类型约束可以给我们更具体的类型，条件类型的 true 分支将通过我们检查的类型来约束泛型。<br>For example, let’s take the following:<br>例如，我们可以把下面的函数拿来说说：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type MessageOf&lt;T&gt; &#x3D; T[&quot;message&quot;];&#x2F;&#x2F; Type &#39;&quot;message&quot;&#39; cannot be used to index type &#39;T&#39;.</code></pre><p>In this example, TypeScript errors because T isn’t known to have a property called message. We could constrain T, and TypeScript would no longer complain:</p><p>在这个例子中，TypeScript 错误，因为 T 没有一个属性叫 message。我们可以约束 T，TypeScript 不会再报错了：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type MessageOf&lt;T extends &#123; message: unknown &#125;&gt; &#x3D; T[&quot;message&quot;];interface Email &#123;  message: string;&#125;type EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string</code></pre><p>However, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available? We can do this by moving the constraint out and introducing a conditional type:<br>然而，如果我们想要 MessageOf 取任意类型，并且默认为没有 message 属性的情况，我们可以这样做：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type MessageOf&lt;T&gt; &#x3D; T extends &#123; message: unknown &#125; ? T[&quot;message&quot;] : never;interface Email &#123;  message: string;&#125;interface Dog &#123;  bark(): void;&#125;type EmailMessageContents &#x3D; MessageOf&lt;Email&gt;;&#x2F;&#x2F; 提示：type EmailMessageContents &#x3D; string;type DogMessageContents &#x3D; MessageOf&lt;Dog&gt;;&#x2F;&#x2F; 提示：type DogMessageContents &#x3D; never;</code></pre><p>Within the true branch, TypeScript knows that T will have a message property.<br>在 true 分支中，TypeScript 知道 T 有一个 message 属性。</p><p>As another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:<br>作为另一个示例，我们还可以编写一个名为 Flatten 的类型，该类型将数组类型展平为其元素类型，但在其他情况下不使用它们：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Flatten&lt;T&gt; &#x3D; T extends any[] ? T[number] : T;&#x2F;&#x2F; Extracts out the element type. 提取元素类型。type Str &#x3D; Flatten&lt;string[]&gt;;type Str &#x3D; string;&#x2F;&#x2F; Leaves the type alone. 保留该类型。type Num &#x3D; Flatten&lt;number&gt;;type Num &#x3D; number;</code></pre><p>When Flatten is given an array type, it uses an indexed access with number to fetch out string[]’s element type. Otherwise, it just returns the type it was given.<br>当 Flatten 给定一个数组类型，它使用 number 下标得到 string[]元素类型，否则，仅返回所给类型</p><p>Inferring Within Conditional Types<br>在条件类型内推断</p><p>We just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.</p><p>我们只是发现自己使用条件类型来应用约束，然后提取出类型。这最终是一种常见的操作，条件类型使其更容易实现。</p><p>Conditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword. For example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:</p><p>条件类型为我们提供了一种使用 infer 关键字从 true 分支中比较的类型推断的方法。例如，我们可以在 Flatten 中推断元素类型，而不是使用索引访问类型“手动”提取它：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Flatten&lt;Type&gt; &#x3D; Type extends Array&lt;infer Item&gt; ? Item : Type;</code></pre><p>Here, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of T within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.</p><p>在这里，我们使用 infer 关键字声明性地引入一个名为 Item 的新泛型类型变量，而不是指定如何在 true 分支中检索 T 的元素类型。这使我们不必思考如何挖掘和探索我们感兴趣的类型的结构。</p><p>We can write some useful helper type aliases using the infer keyword. For example, for simple cases, we can extract the return type out from function types:</p><p>我们可以使用 infer 关键字编写一些有用的助手类型别名。例如，对于简单的情况，我们可以从函数类型中提取返回类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type GetReturnType&lt;Type&gt; &#x3D; Type extends (...args: never[]) &#x3D;&gt; infer Return  ? Return  : never;type Num &#x3D; GetReturnType&lt;() &#x3D;&gt; number&gt;;&#x2F;&#x2F; 提示： type Num &#x3D; numbertype Str &#x3D; GetReturnType&lt;(x: string) &#x3D;&gt; string&gt;;&#x2F;&#x2F; 提示：type Str &#x3D; stringtype Bools &#x3D; GetReturnType&lt;(a: boolean, b: boolean) &#x3D;&gt; boolean[]&gt;;&#x2F;&#x2F; 提示： type Bools &#x3D; boolean[]</code></pre><p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.<br>当从具有多个调用签名的类型（例如重载函数的类型）进行推断时，将从最后一个签名进行推断（这可能是最允许的一网打尽的情况）。无法基于参数类型列表执行重载解析。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare function stringOrNum(x: string): number;declare function stringOrNum(x: number): string;declare function stringOrNum(x: string | number): string | number;type T1 &#x3D; ReturnType&lt;typeof stringOrNum&gt;;&#x2F;&#x2F; 提示：type T1 &#x3D; string | number;</code></pre><h2 id="Distributive-Conditional-Types"><a href="#Distributive-Conditional-Types" class="headerlink" title="Distributive Conditional Types"></a>Distributive Conditional Types</h2><p>分布条件类型</p><p>When conditional types act on a generic type, they become distributive when given a union type. For example, take the following:<br>当条件类型作用于泛型类型时，当给定一个联合类型时，它们将成为分布式的。例如，以以下内容为例：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;</code></pre><p>If we plug a union type into ToArray, then the conditional type will be applied to each member of that union.<br>如果我们将一个联合类型插入 ToArray，那么条件类型将应用于该联合的每个成员。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type ToArray&lt;Type&gt; &#x3D; Type extends any ? Type[] : never;type StrArrOrNumArr &#x3D; ToArray&lt;string | number&gt;;&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; string[] | number[];</code></pre><p>What happens here is that StrArrOrNumArr distributes on:<br>这里发生了什么？</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">string | number;</code></pre><p>and maps over each member type of the union, to what is effectively:<br>并映射到联合类型每个成员类型</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">ToArray&lt;string&gt; | ToArray&lt;number&gt;;</code></pre><p>which leaves us with:<br>这给我们留下了：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">string[] | number[];</code></pre><p>Typically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets.<br>通常情况下，分布式是所需的行为。要避免这种行为，你可以在每边 extends 关键字之前使用方括号。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type ToArrayNonDist&lt;Type&gt; &#x3D; [Type] extends [any] ? Type[] : never;&#x2F;&#x2F; &#39;StrArrOrNumArr&#39; is no longer a union.type StrArrOrNumArr &#x3D; ToArrayNonDist&lt;string | number&gt;;&#x2F;&#x2F; 提示：type StrArrOrNumArr &#x3D; (string | number)[];</code></pre><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><h2 id="模板字面量类型（Template-Literal-Types）"><a href="#模板字面量类型（Template-Literal-Types）" class="headerlink" title="模板字面量类型（Template Literal Types）"></a>模板字面量类型（Template Literal Types）</h2><p>模板字面量类型以字符串字面量类型为基础，可以通过联合类型扩展成多个字符串。</p><p>它们跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。当使用模板字面量类型时，它会替换模板中的变量，返回一个新的字符串字面量：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type World &#x3D; &quot;world&quot;;type Greeting &#x3D; &#96;hello $&#123;World&#125;&#96;;&#x2F;&#x2F; type Greeting &#x3D; &quot;hello world&quot;</code></pre><ul><li>当模板中的变量是一个联合类型时，每一个可能的字符串字面量都会被表示：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type EmailLocaleIDs &#x3D; &quot;welcome_email&quot; | &quot;email_heading&quot;;type FooterLocaleIDs &#x3D; &quot;footer_title&quot; | &quot;footer_sendoff&quot;;type AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;&#x2F;&#x2F; type AllLocaleIDs &#x3D; &quot;welcome*email_id&quot; | &quot;email_heading_id&quot; | &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;</code></pre><ul><li>如果模板字面量里的多个变量都是联合类型，结果会交叉相乘，比如下面的例子就有 2 * 2 _ 3 一共 12 种结果：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type AllLocaleIDs &#x3D; &#96;$&#123;EmailLocaleIDs | FooterLocaleIDs&#125;_id&#96;;type Lang &#x3D; &quot;en&quot; | &quot;ja&quot; | &quot;pt&quot;;type LocaleMessageIDs &#x3D; &#96;$&#123;Lang&#125;_$&#123;AllLocaleIDs&#125;&#96;;&#x2F;&#x2F; type LocaleMessageIDs &#x3D; &quot;en_welcome_email_id&quot; | &quot;en_email_heading_id&quot; | &quot;en_footer_title_id&quot; | &quot;en_footer_sendoff_id&quot; | &quot;ja_welcome_email_id&quot; | &quot;ja_email_heading_id&quot; | &quot;ja_footer_title_id&quot; | &quot;ja_footer_sendoff_id&quot; | &quot;pt_welcome_email_id&quot; | &quot;pt_email_heading_id&quot; | &quot;pt_footer_title_id&quot; | &quot;pt_footer_sendoff_id&quot;</code></pre><ul><li>如果真的是非常长的字符串联合类型，推荐提前生成，这种还是适用于短一些的情况。</li></ul><h2 id="类型中的字符串联合类型（String-Unions-in-Types）"><a href="#类型中的字符串联合类型（String-Unions-in-Types）" class="headerlink" title="类型中的字符串联合类型（String Unions in Types）"></a>类型中的字符串联合类型（String Unions in Types）</h2><p>模板字面量最有用的地方在于你可以基于一个类型内部的信息，定义一个新的字符串，让我们举个例子：</p><p>有这样一个函数 makeWatchedObject， 它会给传入的对象添加了一个 on 方法。在 JavaScript 中，它的调用看起来是这样：makeWatchedObject(baseObject)，我们假设这个传入对象为：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const passedObject &#x3D; &#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;;</code></pre><p>这个 on 方法会被添加到这个传入对象上，该方法接受两个参数，eventName （ string 类型） 和 callBack （function 类型）：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 伪代码const result &#x3D; makeWatchedObject(baseObject);result.on(eventName, callBack);</code></pre><p>我们希望 eventName 是这种形式：attributeInThePassedObject + “Changed” ，举个例子，</p><ul><li>passedObject 有一个属性 firstName，对应产生的 eventName 为 firstNameChanged，</li><li>同理，lastName 对应的是 lastNameChanged，</li><li>age 对应的是 ageChanged。</li></ul><p>当这个 callBack 函数被调用的时候：</p><ul><li>应该被传入与 attributeInThePassedObject 相同类型的值。比如 passedObject 中，<ul><li>firstName 的值的类型为 string , 对应 firstNameChanged 事件的回调函数，则接受传入一个 string 类型的值。</li><li>age 的值的类型为 number，对应 ageChanged 事件的回调函数，则接受传入一个 number 类型的值。</li></ul></li><li>返回值类型为 void 类型。<br>on() 方法的签名最一开始是这样的：on(eventName: string, callBack: (newValue: any) &#x3D;&gt; void)。 使用这样的签名，我们是不能实现上面所说的这些约束的，这个时候就可以使用模板字面量：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const person &#x3D; makeWatchedObject(&#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;);&#x2F;&#x2F; makeWatchedObject has added &#96;on&#96; to the anonymous Objectperson.on(&quot;firstNameChanged&quot;, (newValue) &#x3D;&gt; &#123;  console.log(&#96;firstName was changed to $&#123;newValue&#125;!&#96;);&#125;);</code></pre><p>注意这个例子里，on 方法添加的事件名为 “firstNameChanged”， 而不仅仅是 “firstName”，而回调函数传入的值 newValue ，我们希望约束为 string 类型。我们先实现第一点。</p><p>在这个例子里，我们希望传入的事件名的类型，是对象属性名的联合，只是每个联合成员都还在最后拼接一个 Changed 字符，在 JavaScript 中，我们可以做这样一个计算：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">Object.keys(passedObject).map(x &#x3D;&gt; $&#123;x&#125;Changed)</code></pre><p>模板字面量提供了一个相似的字符串操作：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;string &amp; keyof Type&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;&#x2F;&#x2F;&#x2F; Create a &quot;watched object&quot; with an &#39;on&#39; method&#x2F;&#x2F;&#x2F; so that you can watch for changes to properties.declare function makeWatchedObject&lt;Type&gt;(  obj: Type): Type &amp; PropEventSource&lt;Type&gt;;</code></pre><p>注意，我们在这里例子中，模板字面量里我们写的是 string &amp; keyof Type，我们可不可以只写成 keyof Type 呢？如果我们这样写，会报错：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;keyof Type&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;&#x2F;&#x2F; Type &#39;keyof Type&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.&#x2F;&#x2F; Type &#39;string | number | symbol&#39; is not assignable to type &#39;string | number | bigint | boolean | null | undefined&#39;.&#x2F;&#x2F; ...</code></pre><p>从报错信息中，我们也可以看出报错原因，在 《TypeScript 系列之 Keyof 操作符》里，我们知道</p><ul><li>keyof 操作符会返回 string | number | symbol 类型，</li><li>但是模板字面量的变量要求的类型却是 string | number | bigint | boolean | null | undefined，</li></ul><p>比较一下，多了一个 symbol 类型，所以其实我们也可以这样写：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;Exclude&lt;keyof Type, symbol&gt;&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;</code></pre><p>再或者这样写：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on(    eventName: &#96;$&#123;Extract&lt;keyof Type, string&gt;&#125;Changed&#96;,    callback: (newValue: any) &#x3D;&gt; void  ): void;&#125;;</code></pre><p>使用这种方式，在我们使用错误的事件名时，TypeScript 会给出报错：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const person &#x3D; makeWatchedObject(&#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;);person.on(&quot;firstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);&#x2F;&#x2F; Prevent easy human error (using the key instead of the event name)person.on(&quot;firstName&quot;, () &#x3D;&gt; &#123;&#125;);&#x2F;&#x2F; Argument of type &#39;&quot;firstName&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.&#x2F;&#x2F; It&#39;s typo-resistantperson.on(&quot;frstNameChanged&quot;, () &#x3D;&gt; &#123;&#125;);&#x2F;&#x2F; Argument of type &#39;&quot;frstNameChanged&quot;&#39; is not assignable to parameter of type &#39;&quot;firstNameChanged&quot; | &quot;lastNameChanged&quot; | &quot;ageChanged&quot;&#39;.</code></pre><h2 id="模板字面量的推断（Inference-with-Template-Literals）"><a href="#模板字面量的推断（Inference-with-Template-Literals）" class="headerlink" title="模板字面量的推断（Inference with Template Literals）"></a>模板字面量的推断（Inference with Template Literals）</h2><p>现在我们来实现第二点，回调函数传入的值的类型与对应的属性值的类型相同。<br>我们现在只是简单的对 callBack 的参数使用 any 类型。实现这个约束的关键在于借助泛型函数：</p><p>捕获泛型函数第一个参数的字面量，生成一个字面量类型</p><ul><li>该字面量类型可以被对象属性构成的联合约束</li><li>对象属性的类型可以通过索引访问获取</li><li>应用此类型，确保回调函数的参数类型与对象属性的类型是同一个类型</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type PropEventSource&lt;Type&gt; &#x3D; &#123;  on&lt;Key extends string &amp; keyof Type&gt;(    eventName: &#96;$&#123;Key&#125;Changed&#96;,    callback: (newValue: Type[Key]) &#x3D;&gt; void  ): void;&#125;;declare function makeWatchedObject&lt;Type&gt;(  obj: Type): Type &amp; PropEventSource&lt;Type&gt;;const person &#x3D; makeWatchedObject(&#123;  firstName: &quot;Saoirse&quot;,  lastName: &quot;Ronan&quot;,  age: 26,&#125;);person.on(&quot;firstNameChanged&quot;, (newName) &#x3D;&gt; &#123;  &#x2F;&#x2F; (parameter) newName: string  console.log(&#96;new name is $&#123;newName.toUpperCase()&#125;&#96;);&#125;);person.on(&quot;ageChanged&quot;, (newAge) &#x3D;&gt; &#123;  &#x2F;&#x2F; (parameter) newAge: number  if (newAge &lt; 0) &#123;    console.warn(&quot;warning! negative age&quot;);  &#125;&#125;);</code></pre><p>这里我们把 on 改成了一个泛型函数。</p><p>当一个用户调用的时候传入 “firstNameChanged”，TypeScript 会尝试着推断 Key 正确的类型。它会匹配 key 和 “Changed” 前的字符串 ，然后推断出字符串 “firstName” ，然后再获取原始对象的 firstName 属性的类型，在这个例子中，就是 string 类型。</p><h2 id="内置字符操作类型（Intrinsic-String-Manipulation-Types）"><a href="#内置字符操作类型（Intrinsic-String-Manipulation-Types）" class="headerlink" title="内置字符操作类型（Intrinsic String Manipulation Types）"></a>内置字符操作类型（Intrinsic String Manipulation Types）</h2><p>TypeScript 的一些类型可以用于字符操作，这些类型处于性能的考虑被内置在编译器中，你不能在 .d.ts 文件里找到它们。</p><h2 id="Uppercase"><a href="#Uppercase" class="headerlink" title="Uppercase"></a>Uppercase</h2><p>把每个字符转为大写形式：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Greeting &#x3D; &quot;Hello, world&quot;;type ShoutyGreeting &#x3D; Uppercase&lt;Greeting&gt;;&#x2F;&#x2F; type ShoutyGreeting &#x3D; &quot;HELLO, WORLD&quot;type ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;ID-$&#123;Uppercase&lt;Str&gt;&#125;&#96;;type MainID &#x3D; ASCIICacheKey&lt;&quot;my_app&quot;&gt;;&#x2F;&#x2F; type MainID &#x3D; &quot;ID-MY_APP&quot;</code></pre><h2 id="Lowercase"><a href="#Lowercase" class="headerlink" title="Lowercase"></a>Lowercase</h2><p>把每个字符转为小写形式：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Greeting &#x3D; &quot;Hello, world&quot;;type QuietGreeting &#x3D; Lowercase&lt;Greeting&gt;;&#x2F;&#x2F; type QuietGreeting &#x3D; &quot;hello, world&quot;type ASCIICacheKey&lt;Str extends string&gt; &#x3D; &#96;id-$&#123;Lowercase&lt;Str&gt;&#125;&#96;;type MainID &#x3D; ASCIICacheKey&lt;&quot;MY_APP&quot;&gt;;&#x2F;&#x2F; type MainID &#x3D; &quot;id-my_app&quot;</code></pre><h2 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h2><ul><li>把字符串的第一个字符转为大写形式：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type LowercaseGreeting &#x3D; &quot;hello, world&quot;;type Greeting &#x3D; Capitalize&lt;LowercaseGreeting&gt;;&#x2F;&#x2F; type Greeting &#x3D; &quot;Hello, world&quot;</code></pre><h2 id="Uncapitalize"><a href="#Uncapitalize" class="headerlink" title="Uncapitalize"></a>Uncapitalize</h2><ul><li>把字符串的第一个字符转换为小写形式：</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type UppercaseGreeting &#x3D; &quot;HELLO WORLD&quot;;type UncomfortableGreeting &#x3D; Uncapitalize&lt;UppercaseGreeting&gt;;&#x2F;&#x2F; type UncomfortableGreeting &#x3D; &quot;hELLO WORLD&quot;</code></pre><ul><li>字符操作类型的技术细节<br>从 TypeScript 4.1 起，这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别 (locale aware)。</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function applyStringMapping(symbol: Symbol, str: string) &#123;  switch (intrinsicTypeKinds.get(symbol.escapedName as string)) &#123;    case IntrinsicTypeKind.Uppercase:      return str.toUpperCase();    case IntrinsicTypeKind.Lowercase:      return str.toLowerCase();    case IntrinsicTypeKind.Capitalize:      return str.charAt(0).toUpperCase() + str.slice(1);    case IntrinsicTypeKind.Uncapitalize:      return str.charAt(0).toLowerCase() + str.slice(1);  &#125;  return str;&#125;</code></pre><p>作者：冴羽<br>链接：<a href="https://www.imooc.com/article/322215">https://www.imooc.com/article/322215</a><br>来源：慕课网<br>本文原创发布于慕课网 ，转载请注明出处，谢谢合作</p><h2 id="在想一个问题"><a href="#在想一个问题" class="headerlink" title="在想一个问题"></a>在想一个问题</h2><p>为什么别人可以把文档翻译的那么准确，让读者一看就明白</p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.Typescript手册 对象类型</title>
      <link href="//post/2022-06-08ts-object-types.html"/>
      <url>//post/2022-06-08ts-object-types.html</url>
      
        <content type="html"><![CDATA[<p>In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.<br><code>在 JavaScript 中，我们通过对象来组织和传递数据。在 TypeScript 中，我们通过对象类型来表示这些对象。</code><br>As we’ve seen, they can be anonymous:<br><code>我们可以看到，它们可以是匿名的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greet(person: &#123; name: string; age: number &#125;) &#123;  return &quot;Hello &quot; + person.name;&#125;</code></pre><p>or they can be named by using either an interface<br><code>或者，它们可以使用接口来命名</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;  name: string;  age: number;&#125;function greet(person: Person) &#123;  return &quot;Hello &quot; + person.name;&#125;</code></pre><p>or a type alias.<br><code>或者，它们可以使用类型别名</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Person &#x3D; &#123;  name: string;  age: number;&#125;;function greet(person: Person) &#123;  return &quot;Hello &quot; + person.name;&#125;</code></pre><p>In all three examples above, we’ve written functions that take objects that contain the property name (which must be a string) and age (which must be a number).<br><code>在上面三个例子中，我们已经写了一个函数，它接受包含属性 name（必须是字符串）和 age（必须是数字）的对象。</code></p><h2 id="Property-Modifiers"><a href="#Property-Modifiers" class="headerlink" title="Property Modifiers"></a>Property Modifiers</h2><p><code>属性修饰符</code><br>Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.<br><code>对象类型中的每个属性都可以指定一些东西：类型、是否是可选的，以及是否可以写入。</code></p><h2 id="Optional-Properties"><a href="#Optional-Properties" class="headerlink" title="Optional Properties"></a>Optional Properties</h2><p><code>可选属性</code><br>Much of the time, we’ll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names.<br><code>大多数时候，我们会发现我们在对对象进行操作的时候，可能会有属性被设置。在这些情况下，我们可以通过在属性名的末尾添加问号来标记这些属性为可选的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface PaintOptions &#123;  shape: Shape;  xPos?: number;  yPos?: number;&#125;function paintShape(opts: PaintOptions) &#123;  &#x2F;&#x2F; ...&#125;const shape &#x3D; getShape();paintShape(&#123; shape &#125;);paintShape(&#123; shape, xPos: 100 &#125;);paintShape(&#123; shape, yPos: 100 &#125;);paintShape(&#123; shape, xPos: 100, yPos: 100 &#125;);</code></pre><p>In this example, both xPos and yPos are considered optional. We can choose to provide either of them, so every call above to paintShape is valid. All optionality really says is that if the property is set, it better have a specific type.<br><code>在这个例子中，xPos和yPos都被认为是可选的。我们可以选择提供其中一个，因此每次调用paintShape都是有效的。所有的可选性都说是，如果属性被设置，它应该有一个特定的类型。</code><br>We can also read from those properties - but when we do under strictNullChecks, TypeScript will tell us they’re potentially undefined.<br><code>我们也可以读取这些属性，但是在严格的 null 检查下，TypeScript 将会告诉我们这些属性可能是 undefined。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function paintShape(opts: PaintOptions) &#123;  let xPos &#x3D; opts.xPos;  &#x2F;&#x2F; (property) PaintOptions.xPos?: number | undefined  let yPos &#x3D; opts.yPos;  &#x2F;&#x2F; (property) PaintOptions.yPos?: number | undefined  &#x2F;&#x2F; ...&#125;</code></pre><p>In JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value undefined. We can just handle undefined specially.<br><code>在 JavaScript 中，即使属性没有被设置，我们仍然可以访问它，它只是给我们一个值 undefined。我们可以特别处理 undefined。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function paintShape(opts: PaintOptions) &#123;  let xPos &#x3D; opts.xPos &#x3D;&#x3D;&#x3D; undefined ? 0 : opts.xPos;  &#x2F;&#x2F; let xPos: number;  let yPos &#x3D; opts.yPos &#x3D;&#x3D;&#x3D; undefined ? 0 : opts.yPos;  &#x2F;&#x2F; let yPos: number;  &#x2F;&#x2F; ...&#125;</code></pre><p>Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.<br><code>注意，这种设置默认值的方式很常见，因此 JavaScript 有一种语法来支持它。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function paintShape(&#123; shape, xPos &#x3D; 0, yPos &#x3D; 0 &#125;: PaintOptions) &#123;  console.log(&quot;x coordinate at&quot;, xPos);  &#x2F;&#x2F; (parameter) xPos: number  console.log(&quot;y coordinate at&quot;, yPos);  &#x2F;&#x2F; (parameter) yPos: number  &#x2F;&#x2F; ...&#125;</code></pre><p>Here we used a destructuring pattern for paintShape’s parameter, and provided default values for xPos and yPos. Now xPos and yPos are both definitely present within the body of paintShape, but optional for any callers to paintShape.<br><code>在这里，我们使用了 paintShape 的参数的析构模式，并为 xPos 和 yPos 提供了默认值。现在 xPos 和 yPos 在 paintShape 的主体中都是必须的，但是任何调用者调用 paintShape 的值都是可选的。</code><br>Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.<br><code>注意，目前没有办法在析构模式中放置类型标注。因为这个语法已经在 JavaScript 中表示了不同的意思。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function draw(&#123; shape: Shape, xPos: number &#x3D; 100 &#x2F;_..._&#x2F; &#125;) &#123;render(shape);&#x2F;&#x2F; Cannot find name &#39;shape&#39;. Did you mean &#39;Shape&#39;?render(xPos);&#x2F;&#x2F; Cannot find name &#39;xPos&#39;.&#125;</code></pre><p>In an object destructuring pattern, shape: Shape means “grab the property shape and redefine it locally as a variable named Shape. Likewise xPos: number creates a variable named number whose value is based on the parameter’s xPos.<br><code>在一个对象析构模式中，shape: Shape 表示“抓取属性 shape 并重新定义它作为名为 Shape 的变量。同样的，xPos: number 创建了一个名为 number 的变量，其值是基于参数的 xPos。</code><br>Using mapping modifiers, you can remove optional attributes.<br><code>使用映射修饰符，你可以移除可选属性。</code></p><h2 id="Readonly-Properties"><a href="#Readonly-Properties" class="headerlink" title="Readonly Properties"></a>Readonly Properties</h2><p><code>只读属性</code><br>Properties can also be marked as readonly for TypeScript. While it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking.<br><code>只读属性</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface SomeType &#123;  readonly prop: string;&#125;function doSomething(obj: SomeType) &#123;  &#x2F;&#x2F; We can read from &#39;obj.prop&#39;.  console.log(&#96;prop has the value &#39;$&#123;obj.prop&#125;&#39;.&#96;);  &#x2F;&#x2F; But we can&#39;t re-assign it.  obj.prop &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; Cannot assign to &#39;prop&#39; because it is a read-only property.&#125;</code></pre><p>Using the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.<br><code>使用 readonly 修饰符并不意味着一个值是完全不可变的，也就是说，它的内部内容不能被改变。它只是说，属性本身不能被重写。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Home &#123;  readonly resident: &#123; name: string; age: number &#125;;&#125;function visitForBirthday(home: Home) &#123;  &#x2F;&#x2F; We can read and update properties from &#39;home.resident&#39;.  &#x2F;&#x2F; 我们可以从 &#39;home.resident&#39; 中读取和更新属性。  console.log(&#96;Happy birthday $&#123;home.resident.name&#125;!&#96;);  home.resident.age++;&#125;function evict(home: Home) &#123;  &#x2F;&#x2F; But we can&#39;t write to the &#39;resident&#39; property itself on a &#39;Home&#39;.  &#x2F;&#x2F; 但是，我们不能在 &#39;Home&#39; 上写入 &#39;resident&#39; 属性。  home.resident &#x3D; &#123;    &#x2F;&#x2F; Cannot assign to &#39;resident&#39; because it is a read-only property.    name: &quot;Victor the Evictor&quot;,    age: 42,  &#125;;&#125;</code></pre><p>It’s important to manage expectations of what readonly implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing.</p><p><strong>注意</strong></p><p><code>TypeScript 在检查两个类型是否兼容的时候，并不会考虑两个类型里的属性是否是 readonly，这就意味着，readonly 的值是可以通过别名修改的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Person &#123;  name: string;  age: number;&#125;interface ReadonlyPerson &#123;  readonly name: string;  readonly age: number;&#125;let writablePerson: Person &#x3D; &#123;  name: &quot;Person McPersonface&quot;,  age: 42,&#125;;&#x2F;&#x2F; workslet readonlyPerson: ReadonlyPerson &#x3D; writablePerson;console.log(readonlyPerson.age); &#x2F;&#x2F; prints &#39;42&#39;writablePerson.age++;console.log(readonlyPerson.age); &#x2F;&#x2F; prints &#39;43&#39;</code></pre><p>Using mapping modifiers, you can remove readonly attributes.</p><h2 id="Index-Signatures"><a href="#Index-Signatures" class="headerlink" title="Index Signatures"></a>Index Signatures</h2><p><code>索引签名</code><br>Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.<br><code>有时候，你不知道一个类型的所有属性的名字，但是你知道值的形状。</code></p><p>In those cases you can use an index signature to describe the types of possible values, for example:<br><code>在这些情况下，你可以使用索引签名来描述可能的值的类型，例如：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface StringArray &#123;  [index: number]: string;&#125;const myArray: StringArray &#x3D; getStringArray();const secondItem &#x3D; myArray[1];const secondItem: string;</code></pre><p>Above, we have a StringArray interface which has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string.<br><code>上面，我们有一个 StringArray 接口，它有一个索引签名。这个索引签名说明，当一个 StringArray 被索引为一个数字时，它会返回一个字符串。</code><br>An index signature property type must be either ‘string’ or ‘number’.<br><code>索引签名属性类型必须是‘string’或‘number’。</code><br>It is possible to support both types of indexers…<br><code>可以支持两种类型的索引器...</code></p><p>While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj[“property”]. In the following example, name’s type does not match the string index’s type, and the type checker gives an error:<br><code>尽管字符串索引用来描述字典模式（dictionary pattern）非常的有效，但也会强制要求所有的属性要匹配索引签名的返回类型。这是因为一个声明类似于 obj.property 的字符串索引，跟 obj[&quot;property&quot;]是一样的。在下面的例子中，name 的类型并不匹配字符串索引的类型，所以类型检查器会给出报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface NumberDictionary &#123;  [index: string]: number;  length: number; &#x2F;&#x2F; ok  name: string;  &#x2F;&#x2F; Property &#39;name&#39; of type &#39;string&#39; is not assignable to &#39;string&#39; index type &#39;number&#39;.&#125;</code></pre><p>However, properties of different types are acceptable if the index signature is a union of the property types:<br><code>但是，不同类型的属性是可以接受的，如果索引签名是属性类型的联合：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface NumberOrStringDictionary &#123;  [index: string]: number | string;  length: number; &#x2F;&#x2F; ok, length is a number  name: string; &#x2F;&#x2F; ok, name is a string&#125;</code></pre><p>Finally, you can make index signatures readonly in order to prevent assignment to their indices:<br><code>最后，你可以使索引签名变成只读，以防止索引赋值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface ReadonlyStringArray &#123;  readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray &#x3D; getReadOnlyStringArray();myArray[2] &#x3D; &quot;Mallory&quot;;&#x2F;&#x2F; Index signature in type &#39;ReadonlyStringArray&#39; only permits reading.</code></pre><p>You can’t set myArray[2] because the index signature is readonly.<br><code>你不能设置 myArray[2]，因为索引签名是只读的。</code></p><h2 id="Extending-Types"><a href="#Extending-Types" class="headerlink" title="Extending Types"></a>Extending Types</h2><p><code>扩展类型</code><br>It’s pretty common to have types that might be more specific versions of other types. For example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S.<br><code>我们可能有一个基本的地址类型，它描述了在美国发送信件和包裹的必要字段。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface BasicAddress &#123;  name?: string;  street: string;  city: string;  country: string;  postalCode: string;&#125;</code></pre><p>In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an AddressWithUnit.<br><code>在某些情况下，这样就足够了，但是地址有时候会有单元号码，如果地址的建筑有多个单元。我们可以描述一个 AddressWithUnit。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface AddressWithUnit &#123;  name?: string;  unit: string;  street: string;  city: string;  country: string;  postalCode: string;&#125;</code></pre><p>This does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive. Instead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit.<br><code>这样做就可以了，但是有一个缺点，就是我们必须重复所有的字段来自 BasicAddress，当我们的改动只是增加性的时候。我们可以扩展原来的 BasicAddress 类型，并且只需要增加 AddressWithUnit 的唯一字段。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface BasicAddress &#123;  name?: string;  street: string;  city: string;  country: string;  postalCode: string;&#125;interface AddressWithUnit extends BasicAddress &#123;  unit: string;&#125;</code></pre><p>The extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, AddressWithUnit didn’t need to repeat the street property, and because street originates from BasicAddress, a reader will know that those two types are related in some way.<br><code>在一个接口上使用 extends 关键字，我们可以从其他命名类型复制成员，并且添加我们想要的新成员。这可以用来缩短我们写的类型声明的热身，以及为同一属性的多个声明提供相关性的信号。例如，AddressWithUnit 不需要重复 street 属性，因为 street 来自 BasicAddress，读者知道这两个类型是相关的。</code><br>interfaces can also extend from multiple types.<br><code>接口也可以扩展多个类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Colorful &#123;  color: string;&#125;interface Circle &#123;  radius: number;&#125;interface ColorfulCircle extends Colorful, Circle &#123;&#125;const cc: ColorfulCircle &#x3D; &#123;  color: &quot;red&quot;,  radius: 42,&#125;;</code></pre><h2 id="Intersection-Types"><a href="#Intersection-Types" class="headerlink" title="Intersection Types"></a>Intersection Types</h2><p><code>交叉类型</code><br>interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.<br><code>接口允许我们从其他类型扩展新类型。TypeScript 提供了一种合并现有对象类型的交叉类型。</code><br>An intersection type is defined using the &amp; operator.<br><code>交叉类型用 &amp; 运算符定义。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Colorful &#123;  color: string;&#125;interface Circle &#123;  radius: number;&#125;type ColorfulCircle &#x3D; Colorful &amp; Circle;</code></pre><p>Here, we’ve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle.<br><code>这里，我们将 Colorful 和 Circle 进行交叉，以生成一个新类型，它包含了 Colorful 和 Circle 的所有成员。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function draw(circle: Colorful &amp; Circle) &#123;  console.log(&#96;Color was $&#123;circle.color&#125;&#96;);  console.log(&#96;Radius was $&#123;circle.radius&#125;&#96;);&#125;&#x2F;&#x2F; okaydraw(&#123; color: &quot;blue&quot;, radius: 42 &#125;);&#x2F;&#x2F; oopsdraw(&#123; color: &quot;red&quot;, raidus: 42 &#125;);&#x2F;&#x2F; Argument of type &#39;&#123; color: string; raidus: number; &#125;&#39; is not assignable to parameter of type &#39;Colorful &amp; Circle&#39;.&#x2F;&#x2F; Object literal may only specify known properties, but &#39;raidus&#39; does not exist in type &#39;Colorful &amp; Circle&#39;. Did you mean to write &#39;radius&#39;?</code></pre><h2 id="Interfaces-vs-Intersections"><a href="#Interfaces-vs-Intersections" class="headerlink" title="Interfaces vs. Intersections"></a>Interfaces vs. Intersections</h2><p><code>接口与交叉类型</code><br>We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.<br><code>我们只看到了两种方式来合并类型，但是实际上是有着微妙的区别。接口使用 extends 关键字扩展其他类型，而交叉类型使用类型别名定义。接口与交叉类型之间的主要区别是如何处理冲突，这个区别通常是在选择一个接口或者类型别名的时候，接口或者类型别名是否更好。</code></p><p>这两种方式在合并类型上看起来很相似，但实际上还是有很大的不同。最原则性的不同就是在于冲突怎么处理，这也是你决定选择那种方式的主要原因。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Colorful &#123;  color: string;&#125;interface ColorfulSub extends Colorful &#123;  color: number;&#125;&#x2F;&#x2F; Interface &#39;ColorfulSub&#39; incorrectly extends interface &#39;Colorful&#39;.&#x2F;&#x2F; Types of property &#39;color&#39; are incompatible.&#x2F;&#x2F; Type &#39;number&#39; is not assignable to type &#39;string&#39;.</code></pre><p>使用继承的方式，如果重写类型会导致编译错误，但交叉类型不会：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Colorful &#123;  color: string;&#125;type ColorfulSub &#x3D; Colorful &amp; &#123;  color: number;&#125;;</code></pre><p>虽然不会报错，那 color 属性的类型是什么呢，答案是 never，取得是 string 和 number 的交集。</p><h2 id="Generic-Object-Types"><a href="#Generic-Object-Types" class="headerlink" title="Generic Object Types"></a>Generic Object Types</h2><p><code>泛型对象类型</code><br>Let’s imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever.<br><code>想想一个可以包含任何值的盒子类型，例如字符串、数字、狮子等。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box &#123;  contents: any;&#125;</code></pre><p>Right now, the contents property is typed as any, which works, but can lead to accidents down the line.<br><code>现在，contents 属性是任意类型，这就可以工作，但是有可能会在未来出现意外。</code><br>We could instead use unknown, but that would mean that in cases where we already know the type of contents, we’d need to do precautionary checks, or use error-prone type assertions.<br><code>我们可以使用 unknown，但是这会导致在我们已经知道 contents 的类型的情况下，我们需要做一些预防性检查，或者使用错误性的类型断言。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box &#123;  contents: unknown;&#125;let x: Box &#x3D; &#123;  contents: &quot;hello world&quot;,&#125;;&#x2F;&#x2F; we could check &#39;x.contents&#39;if (typeof x.contents &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;  console.log(x.contents.toLowerCase());&#125;&#x2F;&#x2F; or we could use a type assertionconsole.log((x.contents as string).toLowerCase());</code></pre><p>One type safe approach would be to instead scaffold out different Box types for every type of contents.<br><code>一种安全的解决方案就是把不同的盒子类型用于不同的类型的内容。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface NumberBox &#123;  contents: number;&#125;interface StringBox &#123;  contents: string;&#125;interface BooleanBox &#123;  contents: boolean;&#125;</code></pre><p>But that means we’ll have to create different functions, or overloads of functions, to operate on these types.<br><code>但是，这会导致我们需要创建不同的函数，或者重载函数，来操作这些类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: &#123; contents: any &#125;, newContents: any) &#123;  box.contents &#x3D; newContents;&#125;</code></pre><p>That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.<br><code>这就是一大堆的烧饼，同时，我们可能需要在未来添加新的类型和重载。这是困难的，因为我们的盒子类型和重载都是一样的。</code><br>Instead, we can make a generic Box type which declares a type parameter.<br><code>而不是，我们可以把盒子类型变成泛型类型，它声明了一个类型参数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;  contents: Type;&#125;</code></pre><p>You might read this as “A Box of Type is something whose contents have type Type”. Later on, when we refer to Box, we have to give a type argument in place of Type.<br><code>你可以读这个为“一个类型为 Type 的盒子”。之后，当我们引用 Box 时，我们需要给它一个类型参数。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">let box: Box&lt;string&gt;;</code></pre><p>Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type. When TypeScript sees Box<string>, it will replace every instance of Type in Box<Type> with string, and end up working with something like { contents: string }. In other words, Box<string> and our earlier StringBox work identically.<br><code>想想 Box&lt;string&gt; 和 StringBox 类型，它们都是一样的。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;contents: Type;&#125;interface StringBox &#123;contents: string;&#125;let boxA: Box&lt;string&gt; &#x3D; &#123; contents: &quot;hello&quot; &#125;;boxA.contents;(property) Box&lt;string&gt;.contents: stringlet boxB: StringBox &#x3D; &#123; contents: &quot;world&quot; &#125;;boxB.contents;(property) StringBox.contents: string</code></pre><p>Box is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new Box type at all (though we certainly could if we wanted to).<br><code>Box 可以重用，因为 Type 可以被替换成任何类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;  contents: Type;&#125;interface Apple &#123;  &#x2F;&#x2F; ....&#125;&#x2F;&#x2F; Same as &#39;&#123; contents: Apple &#125;&#39;.type AppleBox &#x3D; Box&lt;Apple&gt;;</code></pre><p>This also means that we can avoid overloads entirely by instead using generic functions.</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function setContents&lt;Type&gt;(box: Box&lt;Type&gt;, newContents: Type) &#123;  box.contents &#x3D; newContents;&#125;</code></pre><p>It is worth noting that type aliases can also be generic. We could have defined our new Box<Type> interface, which was:<br><code>我们可以定义一个新的盒子类型，它是：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Box&lt;Type&gt; &#123;  contents: Type;&#125;</code></pre><p>by using a type alias instead:<br><code>使用类型别名来代替：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type Box&lt;Type&gt; &#x3D; &#123;  contents: Type;&#125;;</code></pre><p>Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.<br><code>类型别名，跟接口不同，它可以描述除了对象类型之外的其他类型，我们也可以用它来写其他类型的辅助类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type OrNull&lt;Type&gt; &#x3D; Type | null;type OneOrMany&lt;Type&gt; &#x3D; Type | Type[];&#x2F;&#x2F; 这组结果一样type OneOrManyOrNull&lt;Type&gt; &#x3D; OrNull&lt;OneOrMany&lt;Type&gt;&gt;;type OneOrManyOrNull&lt;Type&gt; &#x3D; OneOrMany&lt;Type&gt; | null;&#x2F;&#x2F; 这组结果一样type OneOrManyOrNullStrings &#x3D; OneOrManyOrNull&lt;string&gt;;type OneOrManyOrNullStrings &#x3D; OneOrMany&lt;string&gt; | null;</code></pre><p>We’ll circle back to type aliases in just a little bit.<br><code>我们会在稍后回到类型别名。</code></p><h2 id="The-Array-Type"><a href="#The-Array-Type" class="headerlink" title="The Array Type"></a>The Array Type</h2><p><code>数组类型</code><br>Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.<br><code>泛型对象类型通常是一种可以独立于其包含元素的类型的容器类型。这样，它们可以在不同的数据类型之间重用。</code><br>It turns out we’ve been working with a type just like that throughout this handbook: the Array type. Whenever we write out types like number[] or string[], that’s really just a shorthand for Array<number> and Array<string>.<br><code>我们在这本手册中已经使用过一样的类型：数组类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doSomething(value: Array&lt;string&gt;) &#123;  &#x2F;&#x2F; ...&#125;let myArray: string[] &#x3D; [&quot;hello&quot;, &quot;world&quot;];&#x2F;&#x2F; either of these work!doSomething(myArray);doSomething(new Array(&quot;hello&quot;, &quot;world&quot;));</code></pre><p>Much like the Box type above, Array itself is a generic type.<br><code>数组本身是一个泛型类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface Array&lt;Type&gt; &#123;  &#x2F;**   * Gets or sets the length of the array.   *&#x2F;  length: number;  &#x2F;**   * Removes the last element from an array and returns it.   *&#x2F;  pop(): Type | undefined;  &#x2F;**   * Appends new elements to an array, and returns the new length of the array.   *&#x2F;  push(...items: Type[]): number;  &#x2F;&#x2F; ...&#125;</code></pre><p>Modern JavaScript also provides other data structures which are generic, like Map&lt;K, V&gt;, Set<T>, and Promise<T>. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types.<br><code>现代 JavaScript 也提供了其他的数据结构，比如 Map&lt;K, V&gt;, Set&lt;T&gt;, Promise&lt;T&gt;。</code></p><h2 id="The-ReadonlyArray-Type"><a href="#The-ReadonlyArray-Type" class="headerlink" title="The ReadonlyArray Type"></a>The ReadonlyArray Type</h2><p><code>只读数组类型</code></p><p>The ReadonlyArray is a special type that describes arrays that shouldn’t be changed.<br><code>只读数组是一个描述不能被修改的数组的特殊类型。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function doStuff(values: ReadonlyArray&lt;string&gt;) &#123;  &#x2F;&#x2F; We can read from &#39;values&#39;...  const copy &#x3D; values.slice();  console.log(&#96;The first value is $&#123;values[0]&#125;&#96;);  &#x2F;&#x2F; ...but we can&#39;t mutate &#39;values&#39;.  values.push(&quot;hello!&quot;);  &#x2F;&#x2F; Property &#39;push&#39; does not exist on type &#39;readonly string[]&#39;.&#125;</code></pre><p>Much like the readonly modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents.<br><code>ReadonlyArray 主要是用来做意图声明。当我们看到一个函数返回 ReadonlyArray，就是在告诉我们不能去更改其中的内容，当我们看到一个函数支持传入 ReadonlyArray ，这是在告诉我们我们可以放心的传入数组到函数中，而不用担心会改变数组的内容。</code><br>Unlike Array, there isn’t a ReadonlyArray constructor that we can use.<br><code>不像 Array，ReadonlyArray 并不是一个我们可以用的构造器函数。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">new ReadonlyArray(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;);&#39;ReadonlyArray&#39; only refers to a type, but is being used as a value here.</code></pre><p>Instead, we can assign regular Arrays to ReadonlyArrays.<br><code>然而，我们可以直接把一个常规数组赋值给 ReadonlyArray。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const roArray: ReadonlyArray&lt;string&gt; &#x3D; [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</code></pre><p>Just as TypeScript provides a shorthand syntax for Array<Type> with Type[], it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[].<br><code>TypeScript 也针对 ReadonlyArray&lt;Type&gt; 提供了更简短的写法 readonly Type[]。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doStuff(values: readonly string[]) &#123;  &#x2F;&#x2F; We can read from &#39;values&#39;...  const copy &#x3D; values.slice();  console.log(&#96;The first value is $&#123;values[0]&#125;&#96;);  &#x2F;&#x2F; ...but we can&#39;t mutate &#39;values&#39;.  values.push(&quot;hello!&quot;);  &#x2F;&#x2F; Property &#39;push&#39; does not exist on type &#39;readonly string[]&#39;.&#125;</code></pre><p>One last thing to note is that unlike the readonly property modifier, assignability isn’t bidirectional between regular Arrays and ReadonlyArrays.<br><code>最后有一点要注意，就是 Arrays 和 ReadonlyArray 并不能双向的赋值：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x: readonly string[] &#x3D; [];let y: string[] &#x3D; [];x &#x3D; y; &#x2F;&#x2F; oky &#x3D; x;&#x2F;&#x2F; The type &#39;readonly string[]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;string[]&#39;.</code></pre><h2 id="Tuple-Types"><a href="#Tuple-Types" class="headerlink" title="Tuple Types"></a>Tuple Types</h2><p>A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.<br><code>元组类型是另外一种 Array 类型，当你明确知道数组包含多少个元素，并且每个位置元素的类型都明确知道的时候，就适合使用元组类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type StringNumberPair &#x3D; [string, number];</code></pre><p>Here, StringNumberPair is a tuple type of string and number. Like ReadonlyArray, it has no representation at runtime, but is significant to TypeScript. To the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number.<br><code>在这个例子中，StringNumberPair 就是 string 和 number 的元组类型。</code></p><p><code>跟 ReadonlyArray 一样，它并不会在运行时产生影响，但是对 TypeScript 很有意义。因为对于类型系统，StringNumberPair 描述了一个数组，索引 0 的值的类型是 string，索引 1 的值的类型是 number。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(pair: [string, number]) &#123;  const a &#x3D; pair[0];  const a: string;  const b &#x3D; pair[1];  const b: number;  &#x2F;&#x2F; ...&#125;doSomething([&quot;hello&quot;, 42]);</code></pre><p>If we try to index past the number of elements, we’ll get an error.<br><code>如果要获取元素数量之外的元素，TypeScript 会提示错误：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(pair: [string, number]) &#123;  &#x2F;&#x2F; ...  const c &#x3D; pair[2];  &#x2F;&#x2F; Tuple type &#39;[string, number]&#39; of length &#39;2&#39; has no element at index &#39;2&#39;.&#125;</code></pre><p>We can also destructure tuples using JavaScript’s array destructuring.<br><code>我们也可以使用 JavaScript 的数组解构语法解构元组：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(stringHash: [string, number]) &#123;  const [inputString, hash] &#x3D; stringHash;  console.log(inputString);  &#x2F;&#x2F; const inputString: string;  console.log(hash);  &#x2F;&#x2F; const hash: number;&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements 0 and 1 to whatever we wanted.<br><code>元组类型在重度依赖约定的 API 中很有用，因为它会让每个元素的意义都很明显。当我们解构的时候，元组给了我们命名变量的自由度。在上面的例子中，我们可以命名元素 0 和 1 为我们想要的名字。</code><br>However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API.<br><code>然而，也不是每个用户都这样认为，所以有的时候，使用一个带有描述属性名字的对象也许是个更好的方式。</code><br>Other than those length checks, simple tuple types like these are equivalent to types which are versions of Arrays that declare properties for specific indexes, and that declare length with a numeric literal type.<br><code>除了长度检查，简单的元组类型跟声明了 length 属性和具体的索引属性的 Array 是一样的。</code></p></blockquote><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface StringNumberPair &#123;  &#x2F;&#x2F; specialized properties  length: 2;  0: string;  1: number;  &#x2F;&#x2F; Other &#39;Array&lt;string | number&gt;&#39; members...  slice(start?: number, end?: number): Array&lt;string | number&gt;;&#125;</code></pre><p>Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an element’s type). Optional tuple elements can only come at the end, and also affect the type of length.<br><code>在元组类型中，你也可以写一个可选属性，但可选元素必须在最后面，而且也会影响类型的 length 。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Either2dOr3d &#x3D; [number, number, number?];function setCoordinate(coord: Either2dOr3d) &#123;  const [x, y, z] &#x3D; coord;  const z: number | undefined;  console.log(&#96;Provided coordinates had $&#123;coord.length&#125; dimensions&#96;);  &#x2F;&#x2F; (property) length: 2 | 3&#125;</code></pre><p>Tuples can also have rest elements, which have to be an array&#x2F;tuple type.<br><code>Tuples 也可以使用剩余元素语法，但必须是 array/tuple 类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type StringNumberBooleans &#x3D; [string, number, ...boolean[]];type StringBooleansNumber &#x3D; [string, ...boolean[], number];type BooleansStringNumber &#x3D; [...boolean[], string, number];</code></pre><ul><li><code>StringNumberBooleans</code> describes a tuple whose first two elements are string and number respectively, but which may have any number of booleans following.<br><code>描述一个元组，前两个是字符串和数值，后面是boolean</code></li><li><code>StringBooleansNumber</code> describes a tuple whose first element is string and then any number of booleans and ending with a number.<br><code>描述一个元组，第一个是字符串，最后一个是数值，中间有任意多个boolean类型</code></li><li><code>BooleansStringNumber</code> describes a tuple whose starting elements are any number of booleans and ending with a string then a number.<br><code>描述一个元组，最后两个是string、number</code><br>A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.<br><code>有剩余元素的元组并不会设置 length，因为它只知道在不同位置上的已知元素信息：</code></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const a: StringNumberBooleans &#x3D; [&quot;hello&quot;, 1];const b: StringNumberBooleans &#x3D; [&quot;beautiful&quot;, 2, true];const c: StringNumberBooleans &#x3D; [&quot;world&quot;, 3, true, false, true, false, true];</code></pre><p>Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:<br><code>可选元素和剩余元素的存在，使得 TypeScript 可以在参数列表里使用元组，就像这样：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function readButtonInput(...args: [string, number, ...boolean[]]) &#123;  const [name, version, ...input] &#x3D; args;  &#x2F;&#x2F; ...&#125;</code></pre><p>is basically equivalent to:<br><code>基本等同于：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function readButtonInput(name: string, version: number, ...input: boolean[]) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.</p><h2 id="readonly-Tuple-Types"><a href="#readonly-Tuple-Types" class="headerlink" title="readonly Tuple Types"></a>readonly Tuple Types</h2><p><code>只读元组类型</code><br>One final note about tuple types - tuples types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax.<br><code>元组类型也是可以设置 readonly 的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(pair: readonly [string, number]) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>As you might expect, writing to any property of a readonly tuple isn’t allowed in TypeScript.<br><code>这样 TypeScript 就不会允许写入readonly 元组的任何属性：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(pair: readonly [string, number]) &#123;  pair[0] &#x3D; &quot;hello!&quot;;  &#x2F;&#x2F; Cannot assign to &#39;0&#39; because it is a read-only property.&#125;</code></pre><p>Tuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default. This is also important given that array literals with const assertions will be inferred with readonly tuple types.<br><code>在大部分的代码中，元组只是被创建，使用完后也不会被修改，所以尽可能的将元组设置为 readonly 是一个好习惯。如果我们给一个数组字面量 const 断言，也会被推断为 readonly 元组类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let point &#x3D; [3, 4] as const;function distanceFromOrigin([x, y]: [number, number]) &#123;  return Math.sqrt(x ** 2 + y ** 2);&#125;distanceFromOrigin(point);&#x2F;&#x2F; Argument of type &#39;readonly [3, 4]&#39; is not assignable to parameter of type &#39;[number, number]&#39;.&#x2F;&#x2F; The type &#39;readonly [3, 4]&#39; is &#39;readonly&#39; and cannot be assigned to the mutable type &#39;[number, number]&#39;.</code></pre><p>Here, distanceFromOrigin never modifies its elements, but expects a mutable tuple. Since point’s type was inferred as readonly [3, 4], it won’t be compatible with [number, number] since that type can’t guarantee point’s elements won’t be mutated.<br><code>尽管 distanceFromOrigin 并没有更改传入的元素，但函数希望传入一个可变元组。因为 point 的类型被推断为 readonly [3, 4]，它跟 [number number] 并不兼容，所以 TypeScript 给了一个报错。</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5.Typescript手册 函数</title>
      <link href="//post/2022-06-08ts-more-on-functions.html"/>
      <url>//post/2022-06-08ts-more-on-functions.html</url>
      
        <content type="html"><![CDATA[<p>Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class. They’re also values, and just like other values, TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions.</p><h2 id="Function-Type-Expressions"><a href="#Function-Type-Expressions" class="headerlink" title="Function Type Expressions"></a>Function Type Expressions</h2><p><code>函数类型表达式</code><br>The simplest way to describe a function is with a function type expression. These types are syntactically similar to arrow functions:<br><code>最简单描述一个函数的方式是使用函数类型表达式（function type expression）。**它的写法有点类似于箭头函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function greeter(fn: (a: string) &#x3D;&gt; void) &#123;  fn(&quot;Hello, World&quot;);&#125;function printToConsole(s: string) &#123;  console.log(s);&#125;greeter(printToConsole);</code></pre><p>The syntax (a: string) &#x3D;&gt; void means “a function with one parameter, named a, of type string, that doesn’t have a return value”. Just like with function declarations, if a parameter type isn’t specified, it’s implicitly any.<br><code>这个函数类型表达式的语法（a: string）=&gt; void，意思是“一个参数，名为a，类型为string，没有返回值”。</code><br>Note that the parameter name is required. The function type (string) &#x3D;&gt; void means “a function with a parameter named string of type any“!<br><code>注意，参数名是必需的。函数类型（string）=&gt; void意思是“一个参数名为string，类型为any”！</code><br>Of course, we can use a type alias to name a function type:<br><code>类型别名，可以命名一个函数类型：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type GreetFunction &#x3D; (a: string) &#x3D;&gt; void;function greeter(fn: GreetFunction) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><h2 id="Call-Signatures"><a href="#Call-Signatures" class="headerlink" title="Call Signatures"></a>Call Signatures</h2><p><code>调用签名</code></p><p>In JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type:<br><code>在JavaScript中，函数可以有属性，但是函数类型表达式语法不允许声明属性。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type DescribableFunction &#x3D; &#123;  description: string;  (someArg: number): boolean;&#125;;function doSomething(fn: DescribableFunction) &#123;  console.log(fn.description + &quot; returned &quot; + fn(6));&#125;</code></pre><p>Note that the syntax is slightly different compared to a function type expression - use : between the parameter list and the return type rather than &#x3D;&gt;.<br><code>注意，语法与函数类型表达式不同，使用:在参数列表和返回类型之间。</code></p><h2 id="Construct-Signatures"><a href="#Construct-Signatures" class="headerlink" title="Construct Signatures"></a>Construct Signatures</h2><p><code>构造签名</code><br>JavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature:<br><code>JavaScript函数也可以使用new操作符。TypeScript将它们称为构造函数，因为它们通常会创建一个新的对象。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">type SomeConstructor &#x3D; &#123;  new (s: string): SomeObject;&#125;;function fn(ctor: SomeConstructor) &#123;  return new ctor(&quot;hello&quot;);&#125;</code></pre><p>Some objects, like JavaScript’s Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily:<br><code>一些对象，如JavaScript的Date对象，可以使用或不使用new。你可以在同一类型中同时使用调用和构造签名：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">interface CallOrConstruct &#123;  new (s: string): Date;  (n?: number): number;&#125;</code></pre><h2 id="Generic-Functions"><a href="#Generic-Functions" class="headerlink" title="Generic Functions"></a>Generic Functions</h2><p><code>泛型函数</code><br>It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way. Let’s consider for a moment a function that returns the first element of an array:<br><code>我们经常需要写这种函数，即函数的输出类型依赖函数的输入类型，或者两个输入的类型以某种形式相互关联。让我们考虑这样一个函数，它返回数组的第一个元素：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstElement(arr: any[]) &#123;  return arr[0];&#125;</code></pre><p>This function does its job, but unfortunately has the return type any. It’d be better if the function returned the type of the array element.<br><code>注意此时函数返回值的类型是 any，如果能返回第一个元素的具体类型就更好了。</code><br>In TypeScript, generics are used when we want to describe a correspondence between two values. We do this by declaring a type parameter in the function signature:<br><code>在TypeScript中，我们可以使用泛型来描述两个值之间的关系。我们这样做的目的是为了描述函数的输入和输出之间的关系。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstElement&lt;Type&gt;(arr: Type[]): Type | undefined &#123;  return arr[0];&#125;</code></pre><p>By adding a type parameter Type to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value). Now when we call it, a more specific type comes out:<br><code>在此函数中添加一个类型参数Type，并在两处使用它，我们创建了一个函数的输入和输出之间的关系。</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; s is of type &#39;string&#39;const s &#x3D; firstElement([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);&#x2F;&#x2F; n is of type &#39;number&#39;const n &#x3D; firstElement([1, 2, 3]);&#x2F;&#x2F; u is of type undefinedconst u &#x3D; firstElement([]);</code></pre><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p><code>接口</code><br>Note that we didn’t have to specify Type in this sample. The type was inferred - chosen automatically - by TypeScript.<br><code>注意，我们在这个例子中没有指定类型。TypeScript自动推断出来了。</code><br>We can use multiple type parameters as well. For example, a standalone version of map would look like this:<br><code>我们可以使用多个类型参数。例如，一个单独版本的map函数会如下所示：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function map&lt;Input, Output&gt;(  arr: Input[],  func: (arg: Input) &#x3D;&gt; Output): Output[] &#123;  return arr.map(func);&#125;&#x2F;&#x2F; Parameter &#39;n&#39; is of type &#39;string&#39;&#x2F;&#x2F; &#39;parsed&#39; is of type &#39;number[]&#39;const parsed &#x3D; map([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], (n) &#x3D;&gt; parseInt(n));</code></pre><p>Note that in this example, TypeScript could infer both the type of the Input type parameter (from the given string array), as well as the Output type parameter based on the return value of the function expression (number).<br><code>在这个例子中，TypeScript可以推断出Input类型参数的类型（从给定的字符串数组），以及Output类型参数的类型，基于函数表达式的返回值（number）。</code></p><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p><code>约束</code><br>We’ve written some generic functions that can work on any kind of value. Sometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept.<br><code>我们写了一些可以操作任意类型的函数。有时候，我们可以只操作一个特定的类型集合。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型。</code><br>Let’s write a function that returns the longer of two values. To do this, we need a length property that’s a number. We constrain the type parameter to that type by writing an extends clause:<br><code>我们写一个函数，返回两个值的长度。我们需要一个length属性，它是一个数字。我们通过写一个extends子句来限制类型参数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function longest&lt;Type extends &#123; length: number &#125;&gt;(a: Type, b: Type) &#123;  if (a.length &gt;&#x3D; b.length) &#123;    return a;  &#125; else &#123;    return b;  &#125;&#125;&#x2F;&#x2F; longerArray is of type &#39;number[]&#39;const longerArray &#x3D; longest([1, 2], [1, 2, 3]);&#x2F;&#x2F; longerString is of type &#39;alice&#39; | &#39;bob&#39;const longerString &#x3D; longest(&quot;alice&quot;, &quot;bob&quot;);&#x2F;&#x2F; Error! Numbers don&#39;t have a &#39;length&#39; propertyconst notOK &#x3D; longest(10, 100);&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;&#123; length: number; &#125;&#39;.</code></pre><p>There are a few interesting things to note in this example. We allowed TypeScript to infer the return type of longest. Return type inference also works on generic functions.<br><code>在这个例子中，我们允许TypeScript推断longest的返回类型。返回类型推断也可以在泛型函数中使用。</code><br>Because we constrained Type to { length: number }, we were allowed to access the .length property of the a and b parameters. Without the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.<br><code>因为我们限制了类型参数为&#123; length: number &#125;，所以我们可以访问a和b参数的.length属性。没有类型约束，我们不能访问这些属性，因为值可能是其他类型而没有length属性。</code><br>The types of longerArray and longerString were inferred based on the arguments. Remember, generics are all about relating two or more values with the same type!<br><code>longerArray和longerString的类型是根据参数的类型推断出来的。记住，泛型是关于两个或多个值具有相同类型的问题！</code><br>Finally, just as we’d like, the call to longest(10, 100) is rejected because the number type doesn’t have a .length property.<br><code>最后，我们想要，调用longest(10, 100)会被拒绝，因为数字类型没有.length属性。</code></p><h2 id="Working-with-Constrained-Values"><a href="#Working-with-Constrained-Values" class="headerlink" title="Working with Constrained Values"></a>Working with Constrained Values</h2><p><code>工作中的约束值</code><br>Here’s a common error when working with generic constraints:<br><code>这里是工作中常见的错误：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function minimumLength&lt;Type extends &#123; length: number &#125;&gt;(  obj: Type,  minimum: number): Type &#123;  if (obj.length &gt;&#x3D; minimum) &#123;    return obj;  &#125; else &#123;    return &#123; length: minimum &#125;;    &#x2F;&#x2F; Type &#39;&#123; length: number; &#125;&#39; is not assignable to type &#39;Type&#39;.    &#x2F;&#x2F; &#39;&#123; length: number; &#125;&#39; is assignable to the constraint of type &#39;Type&#39;, but &#39;Type&#39; could be instantiated with a different subtype of constraint &#39;&#123; length: number; &#125;&#39;.  &#125;&#125;</code></pre><p>It might look like this function is OK - Type is constrained to { length: number }, and the function either returns Type or a value matching that constraint. The problem is that the function promises to return the same kind of object as was passed in, not just some object matching the constraint. If this code were legal, you could write code that definitely wouldn’t work:<br><code>这个函数看起来是可以的，因为Type是约束为&#123; length: number &#125;，函数可以返回Type或者匹配这个约束的值。问题是，函数承诺返回传入的同样类型的对象，而不是匹配约束的对象。如果这段代码是合法的，你可以写一段代码，它永远不会运行：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; &#39;arr&#39; gets value &#123; length: 6 &#125;const arr &#x3D; minimumLength([1, 2, 3], 6);&#x2F;&#x2F; and crashes here because arrays have&#x2F;&#x2F; a &#39;slice&#39; method, but not the returned object!console.log(arr.slice(0));</code></pre><h2 id="Specifying-Type-Arguments"><a href="#Specifying-Type-Arguments" class="headerlink" title="Specifying Type Arguments"></a>Specifying Type Arguments</h2><p><code>明确指定类型参数</code><br>TypeScript can usually infer the intended type arguments in a generic call, but not always. For example, let’s say you wrote a function to combine two arrays:<br><code>Typescript通常可以在泛型调用中推断出意图的类型参数，但不是所有的情况。例如，如果你写了一个函数，用来合并两个数组：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function combine&lt;Type&gt;(arr1: Type[], arr2: Type[]): Type[] &#123;  return arr1.concat(arr2);&#125;</code></pre><p>Normally it would be an error to call this function with mismatched arrays:<br><code>通常情况下，如果调用这个函数传入不匹配的数组，就会报错：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const arr &#x3D; combine([1, 2, 3], [&quot;hello&quot;]);&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.</code></pre><p>If you intended to do this, however, you could manually specify Type:<br><code>如果你想这样做，你可以手动指定Type：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const arr &#x3D; combine&lt;string | number&gt;([1, 2, 3], [&quot;hello&quot;]);</code></pre><h2 id="Guidelines-for-Writing-Good-Generic-Functions"><a href="#Guidelines-for-Writing-Good-Generic-Functions" class="headerlink" title="Guidelines for Writing Good Generic Functions"></a>Guidelines for Writing Good Generic Functions</h2><p><code>写好泛型函数的指南</code><br>Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.<br><code>写好泛型函数是很有趣的，也可以很容易地使用类型参数。有太多类型参数或者使用约束，而且这些约束不需要的话，推断就会更加不成功，使用者会困惑。</code></p><h2 id="Push-Type-Parameters-Down"><a href="#Push-Type-Parameters-Down" class="headerlink" title="Push Type Parameters Down"></a>Push Type Parameters Down</h2><p><code>推下类型参数</code><br>Here are two ways of writing a function that appear similar:<br><code>这里有两种方式写一个函数，看起来像是一样的：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function firstElement1&lt;Type&gt;(arr: Type[]) &#123;  return arr[0];&#125;function firstElement2&lt;Type extends any[]&gt;(arr: Type) &#123;  return arr[0];&#125;&#x2F;&#x2F; a: number (good)const a &#x3D; firstElement1([1, 2, 3]);&#x2F;&#x2F; b: any (bad)const b &#x3D; firstElement2([1, 2, 3]);</code></pre><p>These might seem identical at first glance, but firstElement1 is a much better way to write this function. Its inferred return type is Type, but firstElement2’s inferred return type is any because TypeScript has to resolve the arr[0] expression using the constraint type, rather than “waiting” to resolve the element during a call.<br><code>这两个函数看起来像是一样的，但是firstElement1更好的写法。它的推断返回类型是Type，但firstElement2的推断返回类型是any，因为TypeScript要在调用时使用约束类型，而不是等待元素被解析。</code><br>Rule: When possible, use the type parameter itself rather than constraining it<br><code>当可能的话，尽量使用类型参数本身而不约束它</code><br>Use Fewer Type Parameters<br><code>使用更少的类型参数</code><br>Here’s another pair of similar functions:<br><code>这里有一对相似的函数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function filter1&lt;Type&gt;(arr: Type[], func: (arg: Type) &#x3D;&gt; boolean): Type[] &#123;  return arr.filter(func);&#125;function filter2&lt;Type, Func extends (arg: Type) &#x3D;&gt; boolean&gt;(  arr: Type[],  func: Func): Type[] &#123;  return arr.filter(func);&#125;</code></pre><p>We’ve created a type parameter Func that doesn’t relate two values. That’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason. Func doesn’t do anything but make the function harder to read and reason about!<br><code>我们创建了一个类型参数Func，它不关联两个值。这是一个红线，因为它意味着调用者希望指定类型参数时，必须手动指定一个额外的类型参数。Func不做任何事情，只是让这个函数更难读，理解。</code><br>Rule: Always use as few type parameters as possible<br><code>总是使用最少的类型参数</code></p><h2 id="Type-Parameters-Should-Appear-Twice"><a href="#Type-Parameters-Should-Appear-Twice" class="headerlink" title="Type Parameters Should Appear Twice"></a>Type Parameters Should Appear Twice</h2><p><code>类型参数应该出现两次</code><br>Sometimes we forget that a function might not need to be generic:<br><code>有时候我们忘记了一个函数可能不需要泛型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet&lt;Str extends string&gt;(s: Str) &#123;  console.log(&quot;Hello, &quot; + s);&#125;greet(&quot;world&quot;);</code></pre><p>We could just as easily have written a simpler version:<br><code>我们可以简单的写一个更简单的版本：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(s: string) &#123;  console.log(&quot;Hello, &quot; + s);&#125;</code></pre><p>Remember, type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it’s not relating anything.<br><code>记住，类型参数是用来关联多个值的类型的。如果一个类型参数只被一次使用在函数签名中，它不关联任何东西。</code><br>Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it<br><code>如果一个类型参数只出现在一个位置，强烈建议如果你实际上需要它的话，</code></p><h2 id="Optional-Parameters"><a href="#Optional-Parameters" class="headerlink" title="Optional Parameters"></a>Optional Parameters</h2><p><code>可选参数</code><br>Functions in JavaScript often take a variable number of arguments. For example, the toFixed method of number takes an optional digit count:<br><code>在 JavaScript 中，函数通常会接受一个可变数量的参数。例如，number 的 toFixed 方法接受一个可选的位数：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f(n: number) &#123;  console.log(n.toFixed()); &#x2F;&#x2F; 0 arguments  console.log(n.toFixed(3)); &#x2F;&#x2F; 1 argument&#125;</code></pre><p>We can model this in TypeScript by marking the parameter as optional with ?:<br><code>我们可以在 TypeScript 中使用 ?: 来标记可选参数</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f(x?: number) &#123;  &#x2F;&#x2F; ...&#125;f(); &#x2F;&#x2F; OKf(10); &#x2F;&#x2F; OK</code></pre><p>Although the parameter is specified as type number, the x parameter will actually have the type number | undefined because unspecified parameters in JavaScript get the value undefined.<br><code>在 JavaScript 中，未指定参数的值会被设置为 undefined。</code><br>You can also provide a parameter default:<br><code>你也可以提供一个参数默认值：</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function f(x &#x3D; 10) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>Now in the body of f, x will have type number because any undefined argument will be replaced with 10. Note that when a parameter is optional, callers can always pass undefined, as this simply simulates a “missing” argument:<br><code>在 f 中的 body 中，x 将有 number 类型，因为任何未定义的参数都会被替换为 10。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare function f(x?: number): void;&#x2F;&#x2F; cut&#x2F;&#x2F; All OKf();f(10);f(undefined);</code></pre><h2 id="Optional-Parameters-in-Callbacks"><a href="#Optional-Parameters-in-Callbacks" class="headerlink" title="Optional Parameters in Callbacks"></a>Optional Parameters in Callbacks</h2><p><code>回调函数中的可选参数</code><br>Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:<br><code>一旦你学会了可选参数和函数类型表达式，写函数调用回调函数时很容易出错：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function myForEach(arr: any[], callback: (arg: any, index?: number) &#x3D;&gt; void) &#123;  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;    callback(arr[i], i);  &#125;&#125;</code></pre><p>What people usually intend when writing index? as an optional parameter is that they want both of these calls to be legal:<br><code>人们常常希望写 index 作为可选参数，这意味着它们都是合法的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">myForEach([1, 2, 3], (a) &#x3D;&gt; console.log(a));myForEach([1, 2, 3], (a, i) &#x3D;&gt; console.log(a, i));</code></pre><p>What this actually means is that callback might get invoked with one argument. In other words, the function definition says that the implementation might look like this:<br><code>这实际上意味着回调函数可能会被调用一个参数。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function myForEach(arr: any[], callback: (arg: any, index?: number) &#x3D;&gt; void) &#123;  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;    &#x2F;&#x2F; I don&#39;t feel like providing the index today    callback(arr[i]);  &#125;&#125;</code></pre><p>In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:<br><code>在 TypeScript 中，会发出这些不可能的错误：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">myForEach([1, 2, 3], (a, i) &#x3D;&gt; &#123;  console.log(i.toFixed());  &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.&#125;);</code></pre><p>In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored. TypeScript behaves the same way. Functions with fewer parameters (of the same types) can always take the place of functions with more parameters.<br><code>在 JavaScript 中，如果调用函数的参数多于参数，那么这些多余的参数将被忽略。TypeScript 也会像这样。函数可以接受多个参数，但是参数的类型必须是相同的。</code><br>When writing a function type for a callback, never write an optional parameter unless you intend to call the function without passing that argument<br><code>写一个回调函数类型时，如果你不想传递这个参数，就不要写可选参数。</code></p><h2 id="Function-Overloads"><a href="#Function-Overloads" class="headerlink" title="Function Overloads"></a>Function Overloads</h2><p><code>函数重载</code><br>Some JavaScript functions can be called in a variety of argument counts and types. For example, you might write a function to produce a Date that takes either a timestamp (one argument) or a month&#x2F;day&#x2F;year specification (three arguments).<br><code>在 JavaScript 中，可以调用一个函数，参数的数量和类型都不一样。例如，你可以写一个函数，用来生成一个 Date 对象，可以接受一个时间戳（一个参数）或一个月/日/年 的指定（三个参数）。</code><br>In TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function:<br><code>在 TypeScript 中，我们可以写一个函数，它可以被调用不同的参数和类型，通过写出多个函数类型（通常是两个或多个），然后写出函数的 body：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function makeDate(timestamp: number): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number, y?: number): Date &#123;  if (d !&#x3D;&#x3D; undefined &amp;&amp; y !&#x3D;&#x3D; undefined) &#123;    return new Date(y, mOrTimestamp, d);  &#125; else &#123;    return new Date(mOrTimestamp);  &#125;&#125;const d1 &#x3D; makeDate(12345678);const d2 &#x3D; makeDate(5, 5, 5);const d3 &#x3D; makeDate(1, 3);&#x2F;&#x2F; No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</code></pre><p>In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments. These first two signatures are called the overload signatures.<br><code>在这个例子中，我们写了两个函数类型：一个只接受一个参数，一个只接受三个参数。这两个第一个类型是函数类型。</code><br>Then, we wrote a function implementation with a compatible signature. Functions have an implementation signature, but this signature can’t be called directly. Even though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!<br><code>然后，我们写了一个函数实现，这个函数类型不能直接调用。即使我们写了一个参数后，再写了一个可选参数，也不能调用两个参数。虽然我们写了两个参数，但是不能调用两个参数。</code></p><h2 id="Overload-Signatures-and-the-Implementation-Signature"><a href="#Overload-Signatures-and-the-Implementation-Signature" class="headerlink" title="Overload Signatures and the Implementation Signature"></a>Overload Signatures and the Implementation Signature</h2><p><code>重载签名和实现签名</code><br>This is a common source of confusion. Often people will write code like this and not understand why there is an error:<br><code>这是一个常见的混乱源。很多人写了这样的代码，但是不知道为什么会有错误。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function fn(x: string): void;function fn() &#123;  &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; Expected to be able to call with zero argumentsfn();&#x2F;&#x2F; Expected 1 arguments, but got 0.</code></pre><p>Again, the signature used to write the function body can’t be “seen” from the outside.<br><code>再次，写出函数的 body 的签名不能被外部看到。</code><br>The signature of the implementation is not visible from the outside. When writing an overloaded function, you should always have two or more signatures above the implementation of the function.<br><code>在写一个重载函数时，你应该总是写两个或多个签名，在函数的实现之上。你应该总是写两个或多个签名，在函数的实现之上。</code><br>The implementation signature must also be compatible with the overload signatures. For example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:<br><code>实现签名必须与重载签名一致。例如，这些函数有错误，因为实现签名不正确。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function fn(x: boolean): void;&#x2F;&#x2F; Argument type isn&#39;t rightfunction fn(x: string): void;&#x2F;&#x2F; This overload signature is not compatible with its implementation signature.function fn(x: boolean) &#123;&#125;function fn(x: string): string;&#x2F;&#x2F; Return type isn&#39;t rightfunction fn(x: number): boolean;&#x2F;&#x2F; This overload signature is not compatible with its implementation signature.function fn(x: string | number) &#123;  return &quot;oops&quot;;&#125;</code></pre><h2 id="Writing-Good-Overloads"><a href="#Writing-Good-Overloads" class="headerlink" title="Writing Good Overloads"></a>Writing Good Overloads</h2><p><code>写好重载</code><br>Like generics, there are a few guidelines you should follow when using function overloads. Following these principles will make your function easier to call, easier to understand, and easier to implement.<br><code>就像泛型一样，也有一些建议提供给你。遵循这些原则，可以让你的函数更方便调用、理解。</code><br>Let’s consider a function that returns the length of a string or an array:<br><code>我们来考虑一个函数，它返回一个字符串或数组的长度：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function len(s: string): number;function len(arr: any[]): number;function len(x: any) &#123;  return x.length;&#125;</code></pre><p>This function is fine; we can invoke it with strings or arrays. However, we can’t invoke it with a value that might be a string or an array, because TypeScript can only resolve a function call to a single overload:<br><code>这个函数代码功能实现了，也没有什么报错，但我们不能传入一个可能是字符串或者是数组的值，因为 TypeScript 只能一次用一个函数重载处理一次函数调用。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">len(&quot;&quot;); &#x2F;&#x2F; OKlen([0]); &#x2F;&#x2F; OKlen(Math.random() &gt; 0.5 ? &quot;hello&quot; : [0]);&#x2F;&#x2F; No overload matches this call.&#x2F;&#x2F; 没有匹配的重载函数。&#x2F;&#x2F; Overload 1 of 2, &#39;(s: string): number&#39;, gave the following error.&#x2F;&#x2F; 重载 1 和 2 之间的函数调用报错。&#x2F;&#x2F; Argument of type &#39;number[] | &quot;hello&quot;&#39; is not assignable to parameter of type &#39;string&#39;.&#x2F;&#x2F;  参数类型 &#39;number[] | &quot;hello&quot;&#39; 不能赋值给参数类型 &#39;string&#39;。&#x2F;&#x2F; Type &#39;number[]&#39; is not assignable to type &#39;string&#39;.&#x2F;&#x2F; 类型 &#39;number[]&#39; 不能赋值给类型 &#39;string&#39;。&#x2F;&#x2F; Overload 2 of 2, &#39;(arr: any[]): number&#39;, gave the following error.&#x2F;&#x2F; 重载 2 和 2 之间的函数调用报错。&#x2F;&#x2F; Argument of type &#39;number[] | &quot;hello&quot;&#39; is not assignable to parameter of type &#39;any[]&#39;.&#x2F;&#x2F; 参数类型 &#39;number[] | &quot;hello&quot;&#39; 不能赋值给参数类型 &#39;any[]&#39;。&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;any[]&#39;.&#x2F;&#x2F; 类型 &#39;string&#39; 不能赋值给类型 &#39;any[]&#39;。</code></pre><p>Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:<br><code>因为两个重载函数的参数数量和返回值类型都一样，我们可以写一个不重载的函数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function len(x: any[] | string) &#123;  return x.length;&#125;</code></pre><p>This is much better! Callers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.<br><code>这更好了！调用者可以传入任意类型的值，并且我们不需要再去找一个正确的实现签名。</code><br>Always prefer parameters with union types instead of overloads when possible<br><code>如果可以的话，尽量使用联合类型而不是重载函数。</code></p><h2 id="Declaring-this-in-a-Function"><a href="#Declaring-this-in-a-Function" class="headerlink" title="Declaring this in a Function"></a>Declaring this in a Function</h2><p><code>在函数中声明 this</code><br>TypeScript will infer what the this should be in a function via code flow analysis, for example in the following:<br><code>TypeScript 会根据代码流分析来决定函数中 this 的值。例如，在下面的代码中：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const user &#x3D; &#123;  id: 123,  admin: false,  becomeAdmin: function () &#123;    this.admin &#x3D; true;  &#125;,&#125;;</code></pre><p>TypeScript understands that the function user.becomeAdmin has a corresponding this which is the outer object user. this, heh, can be enough for a lot of cases, but there are a lot of cases where you need more control over what object this represents. The JavaScript specification states that you cannot have a parameter called this, and so TypeScript uses that syntax space to let you declare the type for this in the function body.<br><code>TypeScript 知道函数 user.becomeAdmin 有一个对应的 this，这个 this 可以足够大部分的情况，但有很多情况需要更多的控制权。 JavaScript 规范禁止使用 this 参数，因此 TypeScript 使用这种语法空间来声明函数体中 this 的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface DB &#123;  filterUsers(filter: (this: User) &#x3D;&gt; boolean): User[];&#125;const db &#x3D; getDB();const admins &#x3D; db.filterUsers(function (this: User) &#123;  return this.admin;&#125;);</code></pre><p>This pattern is common with callback-style APIs, where another object typically controls when your function is called. Note that you need to use function and not arrow functions to get this behavior:<br><code>这种模式通常出现在回调函数风格的 API 中，其中另一个对象通常控制函数调用的时机。请注意，你需要使用 function 而不是 arrow function 来获取这种行为。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface DB &#123;  filterUsers(filter: (this: User) &#x3D;&gt; boolean): User[];&#125;const db &#x3D; getDB();const admins &#x3D; db.filterUsers(() &#x3D;&gt; this.admin);&#x2F;&#x2F; The containing arrow function captures the global value of &#39;this&#39;.&#x2F;&#x2F; 这个包含的箭头函数捕获了全局值 &#39;this&#39;。&#x2F;&#x2F; Element implicitly has an &#39;any&#39; type because type &#39;typeof globalThis&#39; has no index signature.&#x2F;&#x2F; 元素隐式有一个 &#39;any&#39; 类型，因为类型 &#39;typeof globalThis&#39; 没有索引签名。</code></pre><h2 id="Other-Types-to-Know-About"><a href="#Other-Types-to-Know-About" class="headerlink" title="Other Types to Know About"></a>Other Types to Know About</h2><p><code>其他需要知道的类型</code><br>There are some additional types you’ll want to recognize that appear often when working with function types. Like all types, you can use them everywhere, but these are especially relevant in the context of functions.<br><code>这里介绍一些也会经常出现的类型。像其他的类型一样，你也可以在任何地方使用它们，但它们经常与函数搭配使用。</code><br><strong>void</strong></p><p>void represents the return value of functions which don’t return a value. It’s the inferred type any time a function doesn’t have any return statements, or doesn’t return any explicit value from those return statements:<br><code>void 类型表示函数没有返回值的情况。它在函数没有返回值的情况下被推断为 any 类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; The inferred return type is voidfunction noop() &#123;  return;&#125;</code></pre><p>In JavaScript, a function that doesn’t return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. There are further details at the end of this chapter.<br><code>在 JavaScript 中，函数没有返回值的情况下，函数会自动返回 undefined。但是在 TypeScript 中，void 和 undefined 的类型不一样。有更多详情在本章末尾。</code><br>void is not the same as undefined.<br><code>void 类型不是 undefined 类型。</code></p><p><strong>object</strong></p><p>The special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. It’s very likely you will never use Object.<br><code>这个特殊的类型 object 可以表示任何不是原始类型（primitive）的值 (string、number、bigint、boolean、symbol、null、undefined)。object 不同于空对象类型 &#123; &#125;，也不同于全局类型 Object。很有可能你也用不到 Object</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>object is not Object. Always use object!<br><code>object 不同于 Object ，总是用 object!</code></p></blockquote><p>Note that in JavaScript, function values are objects: They have properties, have Object.prototype in their prototype chain, are instanceof Object, you can call Object.keys on them, and so on. For this reason, function types are considered to be objects in TypeScript.<br><code>注意在 JavaScript 中，函数就是对象，他们可以有属性，在他们的原型链上有 Object.prototype，并且 instanceof Object。你可以对函数使用 Object.keys 等等。由于这些原因，在 TypeScript 中，函数也被认为是 object。</code></p><p><strong>unknown</strong></p><p>The unknown type represents any value. This is similar to the any type, but is safer because it’s not legal to do anything with an unknown value:<br><code>unknown 类型可以表示任何值。有点类似于 any，但是更安全，因为对 unknown 类型的值做任何事情都是不合法的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function f1(a: any) &#123;  a.b(); &#x2F;&#x2F; OK&#125;function f2(a: unknown) &#123;  a.b();  &#x2F;&#x2F; Object is of type &#39;unknown&#39;.&#125;</code></pre><p>This is useful when describing function types because you can describe functions that accept any value without having any values in your function body.<br><code>有的时候用来描述函数类型，还是蛮有用的。你可以描述一个函数可以接受传入任何值，但是在函数体内又不用到 any 类型的值。</code><br>Conversely, you can describe a function that returns a value of unknown type:<br><code>相反，你可以描述一个函数返回一个不知道什么类型的值，比如：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function safeParse(s: string): unknown &#123;  return JSON.parse(s);&#125;&#x2F;&#x2F; Need to be careful with &#39;obj&#39;!const obj &#x3D; safeParse(someRandomString);</code></pre><p><strong>never</strong></p><p>Some functions never return a value:<br><code>一些函数从来不返回值：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function fail(msg: string): never &#123;  throw new Error(msg);&#125;</code></pre><p>The never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program.<br><code>never 类型表示一个值不会再被观察到 (observed)。作为一个返回类型时，它表示这个函数会丢一个异常，或者会结束程序的执行。</code><br>never also appears when TypeScript determines there’s nothing left in a union.<br><code>当 TypeScript 确定在联合类型中已经没有可能是其中的类型的时候，never 类型也会出现：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function fn(x: string | number) &#123;  if (typeof x &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    &#x2F;&#x2F; do something  &#125; else if (typeof x &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    &#x2F;&#x2F; do something else  &#125; else &#123;    x; &#x2F;&#x2F; has type &#39;never&#39;!  &#125;&#125;</code></pre><p><strong>Function</strong></p><p>The global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any:<br><code>Function 类型描述了所有函数值的属性，比如 bind、call、apply 等等。这个类型也有一个特殊的属性，可以被调用，这些调用会返回任何类型的值：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(f: Function) &#123;  return f(1, 2, 3);&#125;</code></pre><p>This is an untyped function call and is generally best avoided because of the unsafe any return type.<br><code>这是一个无类型函数调用 (untyped function call)，这种调用最好被避免，因为它返回的是一个不安全的 any类型。</code><br>If you need to accept an arbitrary function but don’t intend to call it, the type () &#x3D;&gt; void is generally safer.<br><code>如果你准备接受一个黑盒的函数，但是又不打算调用它，() =&gt; void 会更安全一些。</code></p><h2 id="Rest-Parameters-and-Arguments"><a href="#Rest-Parameters-and-Arguments" class="headerlink" title="Rest Parameters and Arguments"></a>Rest Parameters and Arguments</h2><p><code>剩余参数</code><br><strong>Background Reading:</strong></p><ul><li>Rest Parameters</li><li>Spread Syntax</li></ul><h2 id="Rest-Parameters"><a href="#Rest-Parameters" class="headerlink" title="Rest Parameters"></a>Rest Parameters</h2><p><code>剩余参数</code><br>In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an unbounded number of arguments using rest parameters.<br><code>除了用可选参数、重载能让函数接收不同数量的函数参数，我们也可以通过使用剩余参数语法（rest parameters），定义一个可以传入数量不受限制的函数参数的函数：</code><br>A rest parameter appears after all other parameters, and uses the … syntax:<br><code>剩余参数必须放在所有参数的最后面，并使用 ... 语法：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function multiply(n: number, ...m: number[]) &#123;  return m.map((x) &#x3D;&gt; n \* x);&#125;&#x2F;&#x2F; &#39;a&#39; gets value [10, 20, 30, 40]const a &#x3D; multiply(10, 1, 2, 3, 4);</code></pre><p>In TypeScript, the type annotation on these parameters is implicitly any[] instead of any, and any type annotation given must be of the form Array<T>or T[], or a tuple type (which we’ll learn about later).<br><code>在 TypeScript 中，剩余参数的类型会被隐式设置为 any[] 而不是 any，如果你要设置具体的类型，必须是 Array&lt;T&gt; 或者 T[]的形式，再或者就是元组类型（tuple type）。</code></p><h2 id="Rest-Arguments"><a href="#Rest-Arguments" class="headerlink" title="Rest Arguments"></a>Rest Arguments</h2><p><code>剩余参数</code><br>Conversely, we can provide a variable number of arguments from an array using the spread syntax. For example, the push method of arrays takes any number of arguments:<br><code>我们可以借助一个使用 ... 语法的数组，为函数提供不定数量的实参。举个例子，数组的 push 方法就可以接受任何数量的实参：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const arr1 &#x3D; [1, 2, 3];const arr2 &#x3D; [4, 5, 6];arr1.push(...arr2);</code></pre><p>Note that in general, TypeScript does not assume that arrays are immutable. This can lead to some surprising behavior:<br><code>注意一般情况下，TypeScript 并不会假定数组是不变的(immutable)，这会导致一些意外的行为：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Inferred type is number[] -- &quot;an array with zero or more numbers&quot;,&#x2F;&#x2F; not specifically two numbersconst args &#x3D; [8, 5];const angle &#x3D; Math.atan2(...args);&#x2F;&#x2F; A spread argument must either have a tuple type or be passed to a rest parameter.</code></pre><p>The best fix for this situation depends a bit on your code, but in general a const context is the most straightforward solution:<br><code>这种情况的最佳解决方案可能是一个更简单的方案：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Inferred as 2-length tupleconst args &#x3D; [8, 5] as const;&#x2F;&#x2F; OKconst angle &#x3D; Math.atan2(...args);</code></pre><p>Using rest arguments may require turning on downlevelIteration when targeting older runtimes.<br><code>使用剩余参数可能需要在更旧的运行时配合 downlevelIteration 参数。</code></p><h2 id="Parameter-Destructuring"><a href="#Parameter-Destructuring" class="headerlink" title="Parameter Destructuring"></a>Parameter Destructuring</h2><p><code>你可以使用参数解构方便的将作为参数提供的对象解构为函数体内一个或者多个局部变量，在 JavaScript 中，是这样的：</code></p><p><strong>Background Reading:</strong></p><ul><li>Destructuring Assignment</li></ul><p>You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body. In JavaScript, it looks like this:<br><code>你可以使用参数解构来轻松地将一个作为参数提供的对象解构为函数体内一个或者多个局部变量。在 JavaScript 中，它的样子是这样的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function sum(&#123; a, b, c &#125;) &#123;  console.log(a + b + c);&#125;sum(&#123; a: 10, b: 3, c: 9 &#125;);&#x2F;&#x2F; The type annotation for the object goes after the destructuring syntax:function sum(&#123; a, b, c &#125;: &#123; a: number; b: number; c: number &#125;) &#123;  console.log(a + b + c);&#125;</code></pre><p>This can look a bit verbose, but you can use a named type here as well:<br><code>这可能会太长，但你可以使用一个命名类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Same as prior exampletype ABC &#x3D; &#123; a: number; b: number; c: number &#125;;function sum(&#123; a, b, c &#125;: ABC) &#123;  console.log(a + b + c);&#125;</code></pre><h2 id="Assignability-of-Functions"><a href="#Assignability-of-Functions" class="headerlink" title="Assignability of Functions"></a>Assignability of Functions</h2><p><code>函数的可赋值性</code><br>Return type void<br><code>返回void</code><br>The void return type for functions can produce some unusual, but expected behavior.<br><code>函数的返回类型为void时，可能会产生一些有意想不到的行为。</code><br>Contextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type vf &#x3D; () &#x3D;&gt; void), when implemented, can return any other value, but it will be ignored.<br><code>在一个返回类型为void的函数中，不会强制函数不返回什么东西。另一种说法是一个上下文函数类型，它的返回类型为void，当实现的时候，可以返回任何值，但是它将被忽略。</code><br>Thus, the following implementations of the type () &#x3D;&gt; void are valid:<br><code>因此，下面的实现是有效的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type voidFunc &#x3D; () &#x3D;&gt; void;const f1: voidFunc &#x3D; () &#x3D;&gt; &#123;  return true;&#125;;const f2: voidFunc &#x3D; () &#x3D;&gt; true;const f3: voidFunc &#x3D; function () &#123;  return true;&#125;;</code></pre><p>And when the return value of one of these functions is assigned to another variable, it will retain the type of void:<br><code>当一个函数的返回值被赋值给另一个变量时，它将保持返回类型为void的类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const v1 &#x3D; f1();const v2 &#x3D; f2();const v3 &#x3D; f3();</code></pre><p>This behavior exists so that the following code is valid even though Array.prototype.push returns a number and the Array.prototype.forEach method expects a function with a return type of void.<br><code>这种行为存在，这样就可以保证下面的代码是有效的，即使 Array.prototype.push 返回一个数字，Array.prototype.forEach 方法也期望一个返回类型为void的函数。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const src &#x3D; [1, 2, 3];const dst &#x3D; [0];src.forEach((el) &#x3D;&gt; dst.push(el));</code></pre><p>There is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything.<br><code>当一个字面量函数定义有一个返回类型为void的函数，那么函数必须不返回任何东西。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function f2(): void &#123;  &#x2F;&#x2F; @ts-expect-error  return true;&#125;const f3 &#x3D; function (): void &#123;  &#x2F;&#x2F; @ts-expect-error , Type &#39;boolean&#39; is not assignable to type &#39;void&#39;.  return true;&#125;;</code></pre><p>For more on void please refer to these other documentation entries:<br><code>更多关于void的文档请参见这些其他文档条目：</code><br><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#void">v1 handbook</a><br><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#void">v2 handbook</a><br>FAQ - “Why are functions returning non-void assignable to function returning void?”<br><code>为什么函数返回非void类型可以赋值给函数返回void类型？</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html">TypeScript 手册 functions</a><br><a href="https://ts.yayujs.com/handbook/MoreOnFunctions.html#%E5%87%BD%E6%95%B0-more-on-functions">函数（More On Functions）</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4.Typescript手册 收缩类型</title>
      <link href="//post/2022-06-08ts-norrowing.html"/>
      <url>//post/2022-06-08ts-norrowing.html</url>
      
        <content type="html"><![CDATA[<h2 id="Narrowing"><a href="#Narrowing" class="headerlink" title="Narrowing"></a>Narrowing</h2><p><code>缩小范围</code></p><p>Imagine we have a function called padLeft.<br><code>试想我们有这样一个函数，函数名为 padLeft：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string): string &#123;  throw new Error(&quot;Not implemented yet!&quot;);&#125;</code></pre><p>If padding is a number, it will treat that as the number of spaces we want to prepend to input. If padding is a string, it should just prepend padding to input. Let’s try to implement the logic for when padLeft is passed a number for padding.</p><p><code>如果 padding 是数字，它将会将 padding 视为我们要添加的空格数量，如果 padding 是字符串，它将会添加 padding 到 input 的前面。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;  return &quot; &quot;.repeat(padding) + input;  &#x2F;&#x2F; Argument of type &#39;string | number&#39; is not assignable to parameter of type &#39;number&#39;.  &#x2F;&#x2F; 参数类型 &#39;string | number&#39; 不能赋值给参数类型 &#39;number&#39;。  &#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.  &#x2F;&#x2F; 类型 &#39;string&#39; 不能赋值给类型 &#39;number&#39;。&#125;</code></pre><p>Uh-oh, we’re getting an error on padding.<br><code>哇，我们得到一个错误，padding。</code><br>TypeScript is warning us that adding a number | string to a number might not give us what we want, and it’s right. In other words, we haven’t explicitly checked if padding is a number first, nor are we handling the case where it’s a string, so let’s do exactly that.<br><code>这是 TypeScript 在警告我们，如果把一个 number 类型 (即例子里的数字 1 )和一个 number | string 类型相加，也许并不会达到我们想要的结果。换句话说，我们应该先检查下 padding 是否是一个 number，或者处理下当 padding 是 string 的情况，那我们可以这样做：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;  &#125;  return padding + input;&#125;</code></pre><p>If this mostly looks like uninteresting JavaScript code, that’s sort of the point. Apart from the annotations we put in place, this TypeScript code looks like JavaScript. The idea is that TypeScript’s type system aims to make it as easy as possible to write typical JavaScript code without bending over backwards to get type safety.<br><code>如果这个代码看起来没有什么意思，那就是 TypeScript 的类型系统希望我们能写出一些比较普通的 JavaScript 代码，而不是折腾至最后才知道类型安全。</code><br>While it might not look like much, there’s actually a lot going under the covers here. Much like how TypeScript analyzes runtime values using static types, it overlays type analysis on JavaScript’s runtime control flow constructs like if&#x2F;else, conditional ternaries, loops, truthiness checks, etc., which can all affect those types.<br><code>这里的实现比较简单，但是它真的是一个类型检查器，它会在 JavaScript 中的 if/else、条件表达式、循环、真假值检查等控制流中进行类型检查。</code><br>Within our if check, TypeScript sees typeof padding &#x3D;&#x3D;&#x3D; “number” and understands that as a special form of code called a type guard. TypeScript follows possible paths of execution that our programs can take to analyze the most specific possible type of a value at a given position. It looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing. In many editors we can observe these types as they change, and we’ll even do so in our examples.<br><code>在我们的 if 检查中，TypeScript 会看到 typeof padding === &quot;number&quot;，并且会解释这个表达式为一个特殊的代码，这个代码被称为类型检查。TypeScript 会根据我们的程序的执行流，来检查一个值的最具体的类型。这些特殊的检查（称为类型检查）和赋值，会影响到类型的精确性。在编辑器中，我们可以看到这些类型的变化，我们也会在我们的例子中看到。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;    &#x2F;&#x2F; (parameter) padding: number  &#125;  return padding + input;  &#x2F;&#x2F; (parameter) padding: string&#125;</code></pre><p>There are a couple of different constructs TypeScript understands for narrowing.<br><code>TypeScript 会理解一些更加精确的构造。</code></p><h2 id="typeof-type-guards"><a href="#typeof-type-guards" class="headerlink" title="typeof type guards"></a>typeof type guards</h2><p><code>类型保护</code></p><p>As we’ve seen, JavaScript supports a typeof operator which can give very basic information about the type of values we have at runtime. TypeScript expects this to return a certain set of strings:<br><code>JavaScript 支持一个 typeof 操作符，它可以给我们的值返回一些基本的信息。TypeScript 期望这些信息是一个特定的集合：</code></p><p>“string”<br>“number”<br>“bigint”<br>“boolean”<br>“symbol”<br>“undefined”<br>“object”<br>“function”</p><p>Like we saw with padLeft, this operator comes up pretty often in a number of JavaScript libraries, and TypeScript can understand it to narrow types in different branches.<br><code>和 padLeft 一样，这个操作符在 JavaScript 库中很常见，TypeScript 可以理解它来缩小不同的分支的类型。</code><br>In TypeScript, checking against the value returned by typeof is a type guard. Because TypeScript encodes how typeof operates on different values, it knows about some of its quirks in JavaScript. For example, notice that in the list above, typeof doesn’t return the string null. Check out the following example:<br><code>在 TypeScript 中，检查 typeof 返回的值就是一种类型保护。TypeScript 知道 typeof 不同值的结果，它也能识别 JavaScript 中一些怪异的地方，就比如在上面的列表中，typeof 并没有返回字符串 null，看下面这个例子：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;  if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;    for (const s of strs) &#123;      &#x2F;&#x2F; Object is possibly &#39;null&#39;.      console.log(s);    &#125;  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    console.log(strs);  &#125; else &#123;    &#x2F;&#x2F; do nothing  &#125;&#125;</code></pre><p>In the printAll function, we try to check if strs is an object to see if it’s an array type (now might be a good time to reinforce that arrays are object types in JavaScript). But it turns out that in JavaScript, typeof null is actually “object”! This is one of those unfortunate accidents of history.<br><code>在这个 printAll 函数中，我们尝试判断 strs 是否是一个对象，原本的目的是判断它是否是一个数组类型，但是在 JavaScript 中，typeof null 也会返回 object。而这是 JavaScript 一个不幸的历史事故。</code><br>Users with enough experience might not be surprised, but not everyone has run into this in JavaScript; luckily, TypeScript lets us know that strs was only narrowed down to string[] | null instead of just string[].<br><code>熟练的用户自然不会感到惊讶，但也并不是所有人都如此熟练。不过幸运的是，TypeScript 会让我们知道 strs 被收窄为 strings[] | null ，而不仅仅是 string[]。</code><br>This might be a good segue into what we’ll call “truthiness” checking.<br><code>这可能是一个好的转折点。</code></p><h2 id="Truthiness-narrowing"><a href="#Truthiness-narrowing" class="headerlink" title="Truthiness narrowing"></a>Truthiness narrowing</h2><p><code>真实性缩减</code></p><p>Truthiness might not be a word you’ll find in the dictionary, but it’s very much something you’ll hear about in JavaScript.<br><code>真实性可能不是在字典里面找到的，但是你会听到 JavaScript 中的真实性。</code><br>In JavaScript, we can use any expression in conditionals, &amp;&amp;s, ||s, if statements, Boolean negations (!), and more. As an example, if statements don’t expect their condition to always have the type boolean.<br><code>这是因为 JavaScript 会做隐式类型转换，像 0 、NaN、&quot;&quot;、0n、null undefined 这些值都会被转为 false，其他的值则会被转为 true。当然你也可以使用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getUsersOnlineMessage(numUsersOnline: number) &#123;  if (numUsersOnline) &#123;    return &#96;There are $&#123;numUsersOnline&#125; online now!&#96;;  &#125;  return &quot;Nobody&#39;s here. :(&quot;;&#125;</code></pre><p>In JavaScript, constructs like if first “coerce” their conditions to booleans to make sense of them, and then choose their branches depending on whether the result is true or false. Values like<br><code>0、NaN、&quot;&quot;、0n、null undefined 这些值都会被转为 false，其他的值则会被转为 true。当然你也可以使用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!：</code></p><ul><li>0</li><li>NaN</li><li>“” (the empty string)</li><li>0n (the bigint version of zero)</li><li>null</li><li>undefined</li></ul><p>all coerce to false, and other values get coerced true. You can always coerce values to booleans by running them through the Boolean function, or by using the shorter double-Boolean negation. (The latter has the advantage that TypeScript infers a narrow literal boolean type true, while inferring the first as type boolean.)<br>所有 这些值都会被转为 false，其他的值则会被转为 true。你可以通过调用 Boolean 函数强制转为 boolean 值，或者使用更加简短的!!。(这种情况下，TypeScript 会推断一个简单的布尔值类型 true，而不是类型 boolean。)</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; both of these result in &#39;true&#39;Boolean(&quot;hello&quot;); &#x2F;&#x2F; type: boolean, value: true!!&quot;world&quot;; &#x2F;&#x2F; type: true,    value: true</code></pre><p>It’s fairly popular to leverage this behavior, especially for guarding against values like null or undefined. As an example, let’s &#96;&#96;&#96;using it for our printAll function.<code>这种使用方式非常流行，尤其适用于防范 null 和 undefiend 这种值的时候。举个例子，我们可以在 printAll 函数中这样使用：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;  if (strs &amp;&amp; typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;    for (const s of strs) &#123;      console.log(s);    &#125;  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    console.log(strs);  &#125;&#125;</code></pre><p>You’ll notice that we’ve gotten rid of the error above by checking if strs is truthy. This at least prevents us from dreaded errors when we run our code like:<br><code>这里我们获得了一个错误，因为我们检查了 strs 是否为真。这至少防止了我们在运行代码时出现的错误。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; TypeError: null is not iterable</code></pre><p>Keep in mind though that truthiness checking on primitives can often be error prone. As an example, consider a different attempt at writing printAll<br><code>但还是要注意，在基本类型上的真值检查很容易导致错误，比如，如果我们这样写 printAll 函数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;  &#x2F;&#x2F; !!!!!!!!!!!!!!!!  &#x2F;&#x2F; DON&#39;T DO THIS!  &#x2F;&#x2F; KEEP READING  &#x2F;&#x2F; !!!!!!!!!!!!!!!!  if (strs) &#123;    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;      for (const s of strs) &#123;        console.log(s);      &#125;    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;      console.log(strs);    &#125;  &#125;&#125;</code></pre><p>We wrapped the entire body of the function in a truthy check, but this has a subtle downside: we may no longer be handling the empty string case correctly.<br><code>我们将整个函数包裹在真值检查中，但这有一个潜在的问题：我们可能不再正确处理空字符串的情况。</code><br>TypeScript doesn’t hurt us here at all, but this is behavior worth noting if you’re less familiar with JavaScript. TypeScript can often help you catch bugs early on, but if you choose to do nothing with a value, there’s only so much that it can do without being overly prescriptive. If you want, you can make sure you handle situations like these with a linter.<br><code>TypeScript 不会给我们任何麻烦，但如果你不了解 JavaScript，这可能是一个很有用的技巧。TypeScript 可以帮助你提前发现错误，但如果你选择不做任何事情，那么只能是有限的。如果你想，你可以使用一个 linter 来确保你在这种情况下正确处理。</code><br>One last word on narrowing by truthiness is that Boolean negations with ! filter out from negated branches.<br><code>另外一个通过真值检查收窄类型的方式是通过!操作符。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function multiplyAll(values: number[] | undefined, factor: number): number[] | undefined &#123;  if (!values) &#123;    return values;  &#125; else &#123;    return values.map((x) &#x3D;&gt; x \* factor);  &#125;&#125;</code></pre><h2 id="Equality-narrowing"><a href="#Equality-narrowing" class="headerlink" title="Equality narrowing"></a>Equality narrowing</h2><p><code>等值缩减</code></p><p>TypeScript also uses switch statements and equality checks like &#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;, and !&#x3D; to narrow types. For example:<br><code>TypeScript 也使用了 switch 语句和等值检查，比如 ===、!==、==、!=。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function example(x: string | number, y: string | boolean) &#123;  if (x &#x3D;&#x3D;&#x3D; y) &#123;    &#x2F;&#x2F; We can now call any &#39;string&#39; method on &#39;x&#39; or &#39;y&#39;.    x.toUpperCase();    &#x2F;&#x2F; (method) String.toUpperCase(): string    y.toLowerCase();    &#x2F;&#x2F; (method) String.toLowerCase(): string  &#125; else &#123;    console.log(x);    &#x2F;&#x2F; (parameter) x: string | number    console.log(y);    &#x2F;&#x2F; (parameter) y: string | boolean  &#125;&#125;</code></pre><p>When we checked that x and y are both equal in the above example, TypeScript knew their types also had to be equal. Since string is the only common type that both x and y could take on, TypeScript knows that x and y must be a string in the first branch.<br><code>在上面的例子中，我们检查了 x 和 y 是否相等。TypeScript 知道 x 和 y 的类型也必须相等。因为 string 是所有 x 和 y 可能取得的类型的共同类型，所以 TypeScript 知道 x 和 y 必须是 string 的第一个分支。</code><br>Checking against specific literal values (as opposed to variables) works also. In our section about truthiness narrowing, we wrote a printAll function which was error-prone because it accidentally didn’t handle empty strings properly. Instead we could have done a specific check to block out nulls, and TypeScript still correctly removes null from the type of strs.<br><code>检查特定的字面值（而不是变量）也可以工作。在我们提到的真值收窄中，我们写了一个 printAll 函数，它错误地处理了空字符串，而不是通过检查 null 来做。可以通过检查 null 来阻止 null，TypeScript 仍然能正确地从 strs 的类型中去除 null。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;  if (strs !&#x3D;&#x3D; null) &#123;    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;      for (const s of strs) &#123;        &#x2F;&#x2F; (parameter) strs: string[]        console.log(s);      &#125;    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;      console.log(strs);      &#x2F;&#x2F; (parameter) strs: string    &#125;  &#125;&#125;</code></pre><p>JavaScript’s looser equality checks with &#x3D;&#x3D; and !&#x3D; also get narrowed correctly. If you’re unfamiliar, checking whether something &#x3D;&#x3D; null actually not only checks whether it is specifically the value null - it also checks whether it’s potentially undefined. The same applies to &#x3D;&#x3D; undefined: it checks whether a value is either null or undefined.<br><code>JavaScript 的更粗糙的等值检查，比如 == 和 !=，也能正确收窄类型。如果你不了解，检查 something == null 是否不仅检查了 something 是否是特定的值 null，还检查了它是否可能是未定义的。同样的道理，检查 something == undefined 是否不仅检查了 something 是否是特定的值 undefined，还检查了它是否可能是未定义的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Container &#123;  value: number | null | undefined;&#125;function multiplyValue(container: Container, factor: number) &#123;  &#x2F;&#x2F; Remove both &#39;null&#39; and &#39;undefined&#39; from the type.  if (container.value !&#x3D; null) &#123;    console.log(container.value);    &#x2F;&#x2F; (property) Container.value: number    &#x2F;&#x2F; Now we can safely multiply &#39;container.value&#39;.    container.value *&#x3D; factor;  &#125;&#125;</code></pre><h2 id="The-in-operator-narrowing"><a href="#The-in-operator-narrowing" class="headerlink" title="The in operator narrowing"></a>The in operator narrowing</h2><p><code>in操作符缩减</code></p><p>JavaScript has an operator for determining if an object has a property with a name: the in operator. TypeScript takes this into account as a way to narrow down potential types.<br><code>JavaScript 有一个操作符用来确定对象是否有一个属性名：in 操作符。TypeScript 使用这种方式来收窄可能的类型。</code><br>For example, with the code: “value” in x. where “value” is a string literal and x is a union type. The “true” branch narrows x’s types which have either an optional or required property value, and the “false” branch narrows to types which have an optional or missing property value.<br><code>例如，在 x 中，“value” 是一个字面量字符串，x 是一个联合类型。“true” 分支收窄 x 的类型，其中有一个可选或必须的属性值，而“false” 分支收窄到有一个可选或缺少的属性值。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;type Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;function move(animal: Fish | Bird) &#123;  if (&quot;swim&quot; in animal) &#123;    return animal.swim();  &#125;  return animal.fly();&#125;</code></pre><p>To reiterate optional properties will exist in both sides for narrowing, for example a human could both swim and fly (with the right equipment) and thus should show up in both sides of the in check:<br><code>为了收窄可选属性，人类可以同时飞行和游泳（有正确的装备），因此应该在 in 检查的两侧显示。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;type Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;type Human &#x3D; &#123; swim?: () &#x3D;&gt; void; fly?: () &#x3D;&gt; void &#125;;function move(animal: Fish | Bird | Human) &#123;  if (&quot;swim&quot; in animal) &#123;    animal;    &#x2F;&#x2F; (parameter) animal: Fish | Human  &#125; else &#123;    animal;    &#x2F;&#x2F; (parameter) animal: Bird | Human  &#125;&#125;</code></pre><h2 id="instanceof-narrowing"><a href="#instanceof-narrowing" class="headerlink" title="instanceof narrowing"></a>instanceof narrowing</h2><p><code>instanceof缩减</code></p><p>JavaScript has an operator for checking whether or not a value is an “instance” of another value. More specifically, in JavaScript x instanceof Foo checks whether the prototype chain of x contains Foo.prototype. While we won’t dive deep here, and you’ll see more of this when we get into classes, they can still be useful for most values that can be constructed with new. As you might have guessed, instanceof is also a type guard, and TypeScript narrows in branches guarded by instanceofs.<br><code>JavaScript 有一个操作符用来检查一个值是否是另一个值的实例：in 操作符。更详细的说，在 JavaScript x instanceof Foo 检查 x 的原型链是否包含 Foo.prototype。但我们这里不会深入，当我们接触到类时，它们仍然可以用于构造函数。你可能会猜到，instanceof 是一个类型检查，而 TypeScript 收窄在 instanceof 检查的分支。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function logValue(x: Date | string) &#123;  if (x instanceof Date) &#123;    console.log(x.toUTCString());    &#x2F;&#x2F; (parameter) x: Date  &#125; else &#123;    console.log(x.toUpperCase());    &#x2F;&#x2F; (parameter) x: string  &#125;&#125;</code></pre><h2 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a>Assignments</h2><p><code>赋值</code></p><p>As we mentioned earlier, when we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.<br><code>我们前面提到过，当我们给任何变量赋值时，TypeScript 会检查赋值右侧并收窄左侧适当的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;let x: string | number;x &#x3D; 1;console.log(x);let x: number;x &#x3D; &quot;goodbye!&quot;;console.log(x);let x: string;</code></pre><p>Notice that each of these assignments is valid. Even though the observed type of x changed to number after our first assignment, we were still able to assign a string to x. This is because the declared type of x - the type that x started with - is string | number, and assignability is always checked against the declared type.<br><code>注意，每一个赋值都是有效的。即使 x 的发现类型改变为 number 之后，我们仍然能够给 x 赋值一个字符串。这是因为 x 的声明类型是 string | number，而赋值时是检查赋值类型是否可以赋值给它。</code><br>If we’d assigned a boolean to x, we’d have seen an error since that wasn’t part of the declared type.</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;let x: string | number;x &#x3D; 1;console.log(x);let x: number;x &#x3D; true;&#x2F;&#x2F; Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.console.log(x);let x: string | number;</code></pre><h2 id="Control-flow-analysis"><a href="#Control-flow-analysis" class="headerlink" title="Control flow analysis"></a>Control flow analysis</h2><p><code>控制流分析</code></p><p>Up until this point, we’ve gone through some basic examples of how TypeScript narrows within specific branches. But there’s a bit more going on than just walking up from every variable and looking for type guards in ifs, whiles, conditionals, etc. For example<br><code>在这个点之前，我们已经探索了一些基本的例子，如何收窄在特定分支中。但这里有一些比较复杂的事情，比如从每个变量上来看，如果有一个 if 语句，while 语句，条件表达式等，都可以看到收窄。例如</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;  &#125;  return padding + input;&#125;</code></pre><p>padLeft returns from within its first if block. TypeScript was able to analyze this code and see that the rest of the body (return padding + input;) is unreachable in the case where padding is a number. As a result, it was able to remove number from the type of padding (narrowing from string | number to string) for the rest of the function.<br><code>padLeft 返回在它的第一个 if 块中。TypeScript 可以分析这段代码，并且发现 rest of the body (return padding + input;) 是不可达的，在 padding 是一个 number 的情况下。因此，它可以移除 padding 的声明类型（收窄从 string | number 到 string），从而移除了 padding 的类型。</code><br>This analysis of code based on reachability is called control flow analysis, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments. When a variable is analyzed, control flow can split off and re-merge over and over again, and that variable can be observed to have a different type at each point.<br><code>这段代码基于可达性的分析是控制流分析，TypeScript 使用这个分析来收窄类型，当遇到类型检查和赋值时。当一个变量被分析时，控制流可以分裂和重新合并，并且这个变量在每个点都会有不同的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function example() &#123;  let x: string | number | boolean;  x &#x3D; Math.random() &lt; 0.5;  console.log(x);  let x: boolean;  if (Math.random() &lt; 0.5) &#123;    x &#x3D; &quot;hello&quot;;    console.log(x);    let x: string;  &#125; else &#123;    x &#x3D; 100;    console.log(x);    let x: number;  &#125;  return x;  let x: string | number;&#125;</code></pre><h2 id="Using-type-predicates"><a href="#Using-type-predicates" class="headerlink" title="Using type predicates"></a>Using type predicates</h2><p><code>使用类型断言</code></p><p>We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.<br><code>我们已经使用了现有的 JavaScript 工具来处理收窄，但有时候你想更加直接控制类型在你的代码中的变化。</code><br>To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:<br><code>定义一个用户定义的类型断言，我们只需要定义一个返回类型为类型断言的函数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function isFish(pet: Fish | Bird): pet is Fish &#123;  return (pet as Fish).swim !&#x3D;&#x3D; undefined;&#125;</code></pre><p>pet is Fish is our type predicate in this example. A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.<br><code>pet is Fish 是我们的类型断言。一个断言的格式是 parameterName is Type，其中 parameterName 必须是当前函数签名中的一个参数名。</code><br>Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.<br><code>任何时候，isFish 被调用，TypeScript 将会收窄这个变量的类型，如果原始类型是兼容的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Both calls to &#39;swim&#39; and &#39;fly&#39; are now okay.let pet &#x3D; getSmallPet();if (isFish(pet)) &#123;  pet.swim();&#125; else &#123;  pet.fly();&#125;</code></pre><p>Notice that TypeScript not only knows that pet is a Fish in the if branch; it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.<br><code>TypeScript 知道 pet 是一个 Fish 在 if 分支；它也知道在 else 分支，你没有一个 Fish，所以你必须有一个 Bird。</code><br>You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:<br><code>你可以使用 isFish 来过滤 Fish | Bird 数组，并获得一个 Fish 数组。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];const underWater1: Fish[] &#x3D; zoo.filter(isFish);&#x2F;&#x2F; or, equivalentlyconst underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];&#x2F;&#x2F; The predicate may need repeating for more complex examplesconst underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;  return isFish(pet);&#125;);</code></pre><p>In addition, classes can use this is Type to narrow their type.We’ve worked with existing JavaScript constructs to handle narrowing so far, however sometimes you want more direct control over how types change throughout your code.<br><code>类可以使用 is Type 来收窄类型。我们已经使用了现有的 JavaScript 工具来处理收窄，但有时候你想更加直接控制类型在你的代码中的变化。</code><br>To define a user-defined type guard, we simply need to define a function whose return type is a type predicate:<br><code>定义一个用户定义的类型断言，我们只需要定义一个返回类型为类型断言的函数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function isFish(pet: Fish | Bird): pet is Fish &#123;  return (pet as Fish).swim !&#x3D;&#x3D; undefined;&#125;</code></pre><p>pet is Fish is our type predicate in this example. A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.<br><code>pet is Fish 是我们的类型断言。一个断言的格式是 parameterName is Type，其中 parameterName 必须是当前函数签名中的一个参数名。</code><br>Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.<br><code>任何时候，isFish 被调用，TypeScript 将会收窄这个变量的类型，如果原始类型是兼容的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Both calls to &#39;swim&#39; and &#39;fly&#39; are now okay.let pet &#x3D; getSmallPet();if (isFish(pet)) &#123;  pet.swim();&#125; else &#123;  pet.fly();&#125;</code></pre><p>Notice that TypeScript not only knows that pet is a Fish in the if branch; it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.<br><code>TypeScript 知道 pet 是一个 Fish 在 if 分支；它也知道在 else 分支，你没有一个 Fish，所以你必须有一个 Bird。</code><br>You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:<br><code>你可以使用 isFish 来过滤 Fish | Bird 数组，并获得一个 Fish 数组。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];const underWater1: Fish[] &#x3D; zoo.filter(isFish);&#x2F;&#x2F; or, equivalentlyconst underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];&#x2F;&#x2F; The predicate may need repeating for more complex examplesconst underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;  return isFish(pet);&#125;);</code></pre><p>In addition, classes can use this is Type to narrow their type.<br><code>除此之外，类中可以使用this is Type来缩减类型。</code></p><h2 id="Discriminated-unions"><a href="#Discriminated-unions" class="headerlink" title="Discriminated unions"></a>Discriminated unions</h2><p><code>分区联合</code></p><p>Most of the examples we’ve looked at so far have focused around narrowing single variables with simple types like string, boolean, and number. While this is common, most of the time in JavaScript we’ll be dealing with slightly more complex structures.<br>For some motivation, let’s imagine we’re trying to encode shapes like circles and squares.<br>Circles keep track of their radiuses and squares keep track of their side lengths. We’ll use a field called kind to tell which shape we’re dealing with. Here’s a first attempt at defining Shape.<br><code>让我们试想有这样一个处理 Shape （比如 Circles、Squares ）的函数，Circles 会记录它的半径属性，Squares 会记录它的边长属性，我们使用一个 kind 字段来区分判断处理的是 Circles 还是 Squares，这是初始的 Shape 定义：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Shape &#123;  kind: &quot;circle&quot; | &quot;square&quot;;  radius?: number;  sideLength?: number;&#125;</code></pre><p>Notice we’re using a union of string literal types: “circle” and “square” to tell us whether we should treat the shape as a circle or square respectively. By using “circle” | “square” instead of string, we can avoid misspelling issues.<br><code>我们使用一个字符串字面量类型的联合：&quot;circle&quot; 和 &quot;square&quot;，来告诉我们是处理一个圆形还是一个正方形。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function handleShape(shape: Shape) &#123;  &#x2F;&#x2F; oops!  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;rect&quot;) &#123;    &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;circle&quot; | &quot;square&quot;&#39; and &#39;&quot;rect&quot;&#39; have no overlap.    &#x2F;&#x2F; 此条件将总是返回 &#39;false&#39;，因为类型 &#39;&quot;circle&quot; | &quot;square&quot;&#39; 和 &#39;&quot;rect&quot;&#39; 没有重叠。    &#x2F;&#x2F; ...  &#125;&#125;</code></pre><p>We can write a getArea function that applies the right logic based on if it’s dealing with a circle or square. We’ll first try dealing with circles.<br><code>我们可以写一个 getArea 函数，用来处理圆形。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;  return Math.PI * shape.radius ** 2;  &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.&#125;</code></pre><p>Under strictNullChecks that gives us an error - which is appropriate since radius might not be defined. But what if we perform the appropriate checks on the kind property?<br><code>在严格的 null 检查下，我们会得到一个错误 - 因为 radius 可能不存在。但是如果我们对 kind 属性进行正确的检查，就不会出现错误。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI * shape.radius ** 2;    &#x2F;&#x2F; Object is possibly &#39;undefined&#39;.  &#125;&#125;</code></pre><p>Hmm, TypeScript still doesn’t know what to do here. We’ve hit a point where we know more about our values than the type checker does. We could try to use a non-null assertion (a ! after shape.radius) to say that radius is definitely present.<br><code>哇，TypeScript 还不知道怎么办。我们已经碰到了一个点，我们知道更多的信息了，比类型检查器更多。我们可以尝试使用一个非空断言（shape.radius 后面加一个 !）来告诉 TypeScript radius 是一定存在的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI * shape.radius! ** 2;  &#125;&#125;</code></pre><p>But this doesn’t feel ideal. We had to shout a bit at the type-checker with those non-null assertions (!) to convince it that shape.radius was defined, but those assertions are error-prone if we start to move code around. Additionally, outside of strictNullChecks we’re able to accidentally access any of those fields anyway (since optional properties are just assumed to always be present when reading them). We can definitely do better.<br><code>但这不太好。我们必须向类型检查器发出一些非空断言（!）来告诉它 shape.radius 存在，但这些断言是错误的，如果我们开始移动代码。同时，在非严格的 null 检查下，我们还是可以随意访问这些字段（因为可选属性是被假定为总是存在的，当读取它们时）。我们可以很好地做。</code><br>The problem with this encoding of Shape is that the type-checker doesn’t have any way to know whether or not radius or sideLength are present based on the kind property. We need to communicate what we know to the type checker. With that in mind, let’s take another swing at defining Shape.<br><code>这个 Shape 的编码有点问题，因为类型检查器没有任何方式可以告诉我们 radius 或 sideLength 存在。我们需要向类型检查器通报我们知道的信息。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Circle &#123;  kind: &quot;circle&quot;;  radius: number;&#125;interface Square &#123;  kind: &quot;square&quot;;  sideLength: number;&#125;type Shape &#x3D; Circle | Square;</code></pre><p>Here, we’ve properly separated Shape out into two types with different values for the kind property, but radius and sideLength are declared as required properties in their respective types.<br><code>这里，我们已经将 Shape 分成了两种类型，其中 kind 属性的值不同，radius 和 sideLength 在它们的类型中声明为必须的属性。</code><br>Let’s see what happens here when we try to access the radius of a Shape.<br><code>我们看看这里如何访问 Shape 的 radius。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;  return Math.PI * shape.radius ** 2;  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Shape&#39;.  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Square&#39;.&#125;</code></pre><p>Like with our first definition of Shape, this is still an error. When radius was optional, we got an error (with strictNullChecks enabled) because TypeScript couldn’t tell whether the property was present. Now that Shape is a union, TypeScript is telling us that shape might be a Square, and Squares don’t have radius defined on them! Both interpretations are correct, but only the union encoding of Shape will cause an error regardless of how strictNullChecks is configured.<br><code>与我们第一次定义 Shape 的例子相同，这还是一个错误。当 radius 是可选的时，我们得到一个错误（与 strictNullChecks 启用时），因为 TypeScript 不能告诉我们这个属性是否存在。</code><br>But what if we tried checking the kind property again?<br><code>如果我们再次检查 kind 属性？</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI * shape.radius ** 2;    &#x2F;&#x2F; (parameter) shape: Circle  &#125;&#125;</code></pre><p>That got rid of the error! When every type in a union contains a common property with literal types, TypeScript considers that to be a discriminated union, and can narrow out the members of the union.<br><code>这消除了错误！当一个联合里的每个类型都包含常量类型的共同属性，TypeScript 认为这是一个分区联合，可以缩小联合的成员。</code><br>In this case, kind was that common property (which is what’s considered a discriminant property of Shape). Checking whether the kind property was “circle” got rid of every type in Shape that didn’t have a kind property with the type “circle”. That narrowed shape down to the type Circle.<br><code>在这种情况下，kind 属性是那个被认为是 Shape 的分区属性（这是被认为是 Shape 的分区属性）。检查 kind 属性是否是 &quot;circle&quot; 可以消除掉没有 kind 属性的类型。这缩小了 shape 到 Circle 类型。</code><br>The same checking works with switch statements as well. Now we can try to write our complete getArea without any pesky ! non-null assertions.<br><code>在这里，我们可以尝试写我们的完整 getArea 没有任何非空断言！</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    &#x2F;&#x2F; (parameter) shape: Circle    case &quot;square&quot;:      return shape.sideLength ** 2;    &#x2F;&#x2F; (parameter) shape: Square  &#125;&#125;</code></pre><p>The important thing here was the encoding of Shape. Communicating the right information to TypeScript - that Circle and Square were really two separate types with specific kind fields - was crucial. Doing that let us write type-safe TypeScript code that looks no different than the JavaScript we would’ve written otherwise. From there, the type system was able to do the “right” thing and figure out the types in each branch of our switch statement.<br><code>这里有重要的事情，需要通过编码 Shape 来告诉 TypeScript，Circle 和 Square 是真正的两个类型，具有特定的 kind 属性。这样就可以写出类型安全的 TypeScript 代码，看起来和 JavaScript 一样。</code><br>As an aside, try playing around with the above example and remove some of the return keywords. You’ll see that type-checking can help avoid bugs when accidentally falling through different clauses in a switch statement.<br><code>作为一个例子，试着玩一下上面的例子，并删除一些 return 关键字。你会发现，类型检查可以帮助避免在意外的情况下跳过不同的分支。</code><br>Discriminated unions are useful for more than just talking about circles and squares. They’re good for representing any sort of messaging scheme in JavaScript, like when sending messages over the network (client&#x2F;server communication), or encoding mutations in a state management framework.<br><code>分区联合是用来表示任何类型的消息协议，比如在网络上发送消息（客户端/服务器通信），或者编码状态管理框架的变化。</code></p><h2 id="The-never-type"><a href="#The-never-type" class="headerlink" title="The never type"></a>The never type</h2><p><code>never类型</code></p><p>When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist.<br><code>在缩小联合的时候，你可以将联合的可能性降低到没有任何可能性的状态。在这种情况下，TypeScript 会使用 never 类型来表示不应该存在的状态。</code></p><h2 id="Exhaustiveness-checking"><a href="#Exhaustiveness-checking" class="headerlink" title="Exhaustiveness checking"></a>Exhaustiveness checking</h2><p><code>推断性检查</code></p><p>The never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement.<br><code>never类型可以赋值给所有类型，但是不可以赋值给 never（除了 never 本身）。这意味着你可以使用缩小，并且可以在 switch 语句中使用推断性检查。</code><br>For example, adding a default to our getArea function which tries to assign the shape to never will raise when every possible case has not been handled.<br><code>添加一个默认到 getArea 函数中，这样就会抛出异常，因为没有处理所有可能性。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Shape &#x3D; Circle | Square;function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    case &quot;square&quot;:      return shape.sideLength ** 2;    default:      const _exhaustiveCheck: never &#x3D; shape;      return _exhaustiveCheck;  &#125;&#125;</code></pre><p>Adding a new member to the Shape union, will cause a TypeScript error:<br><code>添加一个新的成员到 Shape 联合，会导致一个 TypeScript 错误：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Triangle &#123;  kind: &quot;triangle&quot;;  sideLength: number;&#125;type Shape &#x3D; Circle | Square | Triangle;function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    case &quot;square&quot;:      return shape.sideLength ** 2;    default:      const _exhaustiveCheck: never &#x3D; shape;      &#x2F;&#x2F; Type &#39;Triangle&#39; is not assignable to type &#39;never&#39;.      &#x2F;&#x2F; 类型 &#39;Triangle&#39; 不能赋值给类型 &#39;never&#39;。      return _exhaustiveCheck;  &#125;&#125;</code></pre><p>因为 TypeScript 的收窄特性，执行到 default 的时候，类型被收窄为 Triangle，但因为任何类型都不能赋值给 never 类型，这就会产生一个编译错误。通过这种方式，你就可以确保 getArea 函数总是穷尽了所有 shape 的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Typescript 常见类型</title>
      <link href="//post/2022-06-08ts-Everyday%20Types.html"/>
      <url>//post/2022-06-08ts-Everyday%20Types.html</url>
      
        <content type="html"><![CDATA[<h2 id="Everyday-Types"><a href="#Everyday-Types" class="headerlink" title="Everyday Types"></a>Everyday Types</h2><p><code>常见类型</code><br>In this chapter, we’ll cover some of the most common types of values you’ll find in JavaScript code, and explain the corresponding ways to describe those types in TypeScript. This isn’t an exhaustive list, and future chapters will describe more ways to name and use other types.<br><code>在这一章中，我们将探讨一些 JavaScript 代码中的常见类型，并在 TypeScript 中说明这些类型的相应方式。这并不是一个完整的列表，而且未来的章节将说明更多的方法来命名和使用其他类型。</code><br>Types can also appear in many more places than just type annotations. As we learn about the types themselves, we’ll also learn about the places where we can refer to these types to form new constructs.<br><code>类型也可以出现在类型注释之外。我们学习类型本身时，我们也会学习到哪些地方可以引用这些类型来形成新的构造。</code><br>We’ll start by reviewing the most basic and common types you might encounter when writing JavaScript or TypeScript code. These will later form the core building blocks of more complex types.<br><code>我们将开始介绍最基本的 JavaScript 或 TypeScript 代码中可能遇到的常见类型。这些类型将作为更复杂的类型的基础建筑块。</code></p><h2 id="The-primitives-string-number-and-boolean"><a href="#The-primitives-string-number-and-boolean" class="headerlink" title="The primitives: string,number, and boolean"></a>The primitives: string,number, and boolean</h2><p>JavaScript has three very commonly used primitives: string, number, and boolean. Each has a corresponding type in TypeScript. As you might expect, these are the same names you’d see if you used the JavaScript typeof operator on a value of those types:<br><code>JavaScript 有三个非常常见的原始类型：字符串，数字和布尔值。这三个类型在 TypeScript 中对应。如果你可以接受，这三个类型的名字都是相同的：</code></p><ul><li>string represents string values like “Hello, world”<br><code>string 表示字符串，比如 &quot;Hello, world&quot;</code></li><li>number is for numbers like 42. JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply number<br><code>number 是数字，比如 42。JavaScript 不支持整数，所以没有相应的 int 或 float - 所有都是 number</code></li><li>boolean is for the two values true and false<br><code>boolean 是布尔值，比如 true 和 false</code></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p><p>The type names String, Number, and Boolean (starting with capital letters) are legal, but refer to some special built-in types that will very rarely appear in your code. Always use string, number, or boolean for types.<br><code>类型名 String ，Number 和 Boolean （首字母大写）也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用 string ，number 或者 boolean 。</code></p></div><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><code>数组</code><br>To specify the type of an array like [1, 2, 3], you can use the syntax number[]; this syntax works for any type (e.g. string[] is an array of strings, and so on). You may also see this written as Array<number>, which means the same thing. We’ll learn more about the syntax T<U> when we cover generics.<br><code>指定数组的类型，可以使用 number[] 的语法，这种语法可以用于任何类型（比如 string[] 是一个字符串数组，而 so on）。你也可以看到这种写法 Array&lt;number&gt;，它表示相同的意思。我们将在接下来的章节中学习更多关于语法 T&lt;U&gt; 的详细信息。</code><br>:::warning<br>Note that [number] is a different thing; refer to the section on Tuples.<br><code>[number] 不是同一个东西，请参见关于元组的章节。</code><br>:::</p><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.<br><code>TypeScript 也有一个特殊的类型 any，可以用于指定你不想要某个值导致类型检查错误的情况。</code><br>When a value is of type any, you can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal:<br><code>当值是 any 类型时，你可以访问它的任何属性（这将导致它的类型为 any ），调用它，将它赋值给（或从）任何类型的值，或者其他任何合法的语法：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let obj: any &#x3D; &#123; x: 0 &#125;;&#x2F;&#x2F; None of the following lines of code will throw compiler errors.&#x2F;&#x2F; 以下代码行都不会引发编译器错误。&#x2F;&#x2F; Using &#96;any&#96; disables all further type checking, and it is assumed&#x2F;&#x2F; 使用“any”将禁用所有进一步的类型检查，并且假定&#x2F;&#x2F; you know the environment better than TypeScript.&#x2F;&#x2F; 你知道环境优于TypeScript。obj.foo();obj();obj.bar &#x3D; 100;obj &#x3D; &quot;hello&quot;;const n: number &#x3D; obj;</code></pre><p>The any type is useful when you don’t want to write out a long type just to convince TypeScript that a particular line of code is okay.<br><code>any 类型是用于指定你不想要写出一个长的类型来说明 TypeScript 对某一行代码是合法的。</code></p><h2 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h2><p>When you don’t specify a type, and TypeScript can’t infer it from context, the compiler will typically default to any.<br><code>当你不指定类型，并且 TypeScript 不能从上下文中推断出来时，编译器默认使用 any。</code><br>You usually want to avoid this, though, because any isn’t type-checked. Use the compiler flag noImplicitAny to flag any implicit any as an error.<br><code>你通常想避免这种情况，但是 any 不会被类型检查。使用编译器标记 noImplicitAny 来标记 any 为错误。</code></p><h2 id="Type-Annotations-on-Variables"><a href="#Type-Annotations-on-Variables" class="headerlink" title="Type Annotations on Variables"></a>Type Annotations on Variables</h2><p><code>变量上的类型注解</code></p><p>When you declare a variable using const, var, or let, you can optionally add a type annotation to explicitly specify the type of the variable:<br><code>使用 const ，var 或 let 声明变量时，可以添加一个类型注解来显式指定变量的类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let myName: string &#x3D; &quot;Alice&quot;;</code></pre><p>TypeScript doesn’t use “types on the left”-style declarations like int x &#x3D; 0; Type annotations will always go after the thing being typed.<br><code>TypeScript 不使用“左边的类型”的声明方式，如 int x = 0; 类型注解将总是在被类型的东西后面。</code><br>In most cases, though, this isn’t needed. Wherever possible, TypeScript tries to automatically infer the types in your code. For example, the type of a variable is inferred based on the type of its initializer:<br><code>在大多数情况下，不需要这样做。在每个变量的初始值的类型可以被自动推断出来。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; No type annotation needed -- &#39;myName&#39; inferred as type &#39;string&#39;&#x2F;&#x2F; 没有类型注解需要 -- &#39;myName&#39; 类型被推断为 &#39;string&#39;let myName &#x3D; &quot;Alice&quot;;</code></pre><p>For the most part you don’t need to explicitly learn the rules of inference. If you’re starting out, try using fewer type annotations than you think - you might be surprised how few you need for TypeScript to fully understand what’s going on.<br><code>大多数情况下，你不需要显式地指定类型注解。如果你是新手，尝试使用比你认为更少的类型注解，你可能会意外地发现 TypeScript 可以完全理解你的代码。</code></p><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><code>函数</code></p><p>Functions are the primary means of passing data around in JavaScript. TypeScript allows you to specify the types of both the input and output values of functions.<br><code>函数是 JavaScript 中传递数据的主要方式。TypeScript 允许你指定函数的输入和输出值的类型。</code></p><h2 id="Parameter-Type-Annotations"><a href="#Parameter-Type-Annotations" class="headerlink" title="Parameter Type Annotations"></a>Parameter Type Annotations</h2><p><code>参数上的类型注解</code></p><p>When you declare a function, you can add type annotations after each parameter to declare what types of parameters the function accepts. Parameter type annotations go after the parameter name:<br><code>声明函数时，可以在每个参数后面添加类型注解来声明函数接受哪些类型的参数。参数类型注解在参数名后面：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Parameter type annotationfunction greet(name: string) &#123;  console.log(&quot;Hello, &quot; + name.toUpperCase() + &quot;!!&quot;);&#125;</code></pre><p>When a parameter has a type annotation, arguments to that function will be checked:<br><code>当参数有类型注解时，函数的参数会被检查：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Would be a runtime error if executed!&#x2F;&#x2F; 如果执行，就会产生一个运行时错误！greet(42);&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.&#x2F;&#x2F; 参数类型 &#39;number&#39; 不能赋值给参数类型 &#39;string&#39;。</code></pre><p>Even if you don’t have type annotations on your parameters, TypeScript will still check that you passed the right number of arguments.<br><code>即使你没有类型注解，TypeScript 也会检查你传入的参数是否正确。</code></p><h2 id="Return-Type-Annotations"><a href="#Return-Type-Annotations" class="headerlink" title="Return Type Annotations"></a>Return Type Annotations</h2><p><code>返回值上的类型注解</code></p><p>You can also add return type annotations. Return type annotations appear after the parameter list:<br><code>你也可以添加返回值类型注解。返回值类型注解出现在参数列表后面：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getFavoriteNumber(): number &#123;  return 26;&#125;</code></pre><p>Much like variable type annotations, you usually don’t need a return type annotation because TypeScript will infer the function’s return type based on its return statements. The type annotation in the above example doesn’t change anything. Some codebases will explicitly specify a return type for documentation purposes, to prevent accidental changes, or just for personal preference.<br><code>和变量类型注解一样，你通常不需要返回值类型注解，因为 TypeScript 将基于返回语句的类型推断出来。上面的示例示例不会改变任何东西。一些代码库将显式指定一个返回值类型，以防止意外的改变，或者只是为了个人偏好。</code></p><h2 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h2><p><code>匿名函数</code></p><p>Anonymous functions are a little bit different from function declarations. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types.<br><code>匿名函数和函数声明一样。当函数出现在 TypeScript 可以确定它会如何被调用时，函数的参数会被自动指定类型。</code><br>Here’s an example:<br><code>这里有一个示例：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; No type annotations here, but TypeScript can spot the bug&#x2F;&#x2F; 没有类型注解，但 TypeScript 可以检测到错误const names &#x3D; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;];&#x2F;&#x2F; Contextual typing for function&#x2F;&#x2F; 函数上下文类型names.forEach(function (s) &#123;  console.log(s.toUppercase());  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?  &#x2F;&#x2F; 属性 &#39;toUppercase&#39; 不存在于类型 &#39;string&#39; 中。你可能想用 &#39;toUpperCase&#39; 吗？&#125;);&#x2F;&#x2F; Contextual typing also applies to arrow functions&#x2F;&#x2F; 箭头函数上下文类型names.forEach((s) &#x3D;&gt; &#123;  console.log(s.toUppercase());  &#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?  &#x2F;&#x2F; 属性 &#39;toUppercase&#39; 不存在于类型 &#39;string&#39; 中。你可能想用 &#39;toUpperCase&#39; 吗？&#125;);</code></pre><p>Even though the parameter s didn’t have a type annotation, TypeScript used the types of the forEach function, along with the inferred type of the array, to determine the type s will have.<br><code>即使参数 s 没有类型注解，TypeScript 会使用 forEach 函数的类型，以及推断的数组类型，来确定 s 的类型。</code><br>This process is called contextual typing because the context that the function occurred within informs what type it should have.<br><code>这个过程是上下文类型的，因为函数发生在哪里的上下文，就会确定它应该有哪种类型。</code><br>Similar to the inference rules, you don’t need to explicitly learn how this happens, but understanding that it does happen can help you notice when type annotations aren’t needed. Later, we’ll see more examples of how the context that a value occurs in can affect its type.<br><code>与推断规则相似，你不需要显式学习这种过程，但是了解这种过程可以帮助你发现，当值不需要类型注解时，它会发生什么。之后，我们会看到更多的例子，如何值的上下文可以影响它的类型。</code></p><h2 id="Object-Types"><a href="#Object-Types" class="headerlink" title="Object Types"></a>Object Types</h2><p><code>对象类型</code></p><p>Apart from primitives, the most common sort of type you’ll encounter is an object type. This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.<br><code>除了原始类型，最常见的类型是对象类型。这指的是任何 JavaScript 值，它的属性都是很多的！为了定义对象类型，我们只需要列出它的属性和它们的类型。</code><br>For example, here’s a function that takes a point-like object:<br><code>这里有一个接受点类型对象的函数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; The parameter&#39;s type annotation is an object typefunction printCoord(pt: &#123; x: number; y: number &#125;) &#123;  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);&#125;printCoord(&#123; x: 3, y: 7 &#125;);</code></pre><p>Here, we annotated the parameter with a type with two properties - x and y - which are both of type number. You can use , or ; to separate the properties, and the last separator is optional either way.<br><code>这里，我们使用了一个有两个属性的类型，x 和 y，它们都是 number 类型。你可以使用 , 或 ; 分隔属性，最后的分隔符可以是任意的。</code><br>The type part of each property is also optional. If you don’t specify a type, it will be assumed to be any.<br><code>每个属性的类型部分都是可选的。如果你没有指定类型，它会被认为是 any 类型。</code></p><h2 id="Optional-Properties"><a href="#Optional-Properties" class="headerlink" title="Optional Properties"></a>Optional Properties</h2><p><code>可选属性</code></p><p>Object types can also specify that some or all of their properties are optional. To do this, add a ? after the property name:<br><code>对象类型可以指定一些或全部的属性是可选的。要做到这一点，只需要在属性名后面加上 ? 就可以了。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printName(obj: &#123; first: string; last?: string &#125;) &#123;  &#x2F;&#x2F; ...&#125;&#x2F;&#x2F; Both OKprintName(&#123; first: &quot;Bob&quot; &#125;);printName(&#123; first: &quot;Alice&quot;, last: &quot;Alisson&quot; &#125;);</code></pre><p>In JavaScript, if you access a property that doesn’t exist, you’ll get the value undefined rather than a runtime error. Because of this, when you read from an optional property, you’ll have to check for undefined before using it.</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printName(obj: &#123; first: string; last?: string &#125;) &#123;  &#x2F;&#x2F; Error - might crash if &#39;obj.last&#39; wasn&#39;t provided!  console.log(obj.last.toUpperCase());Object is possibly &#39;undefined&#39;.  if (obj.last !&#x3D;&#x3D; undefined) &#123;    &#x2F;&#x2F; OK    console.log(obj.last.toUpperCase());  &#125;  &#x2F;&#x2F; A safe alternative using modern JavaScript syntax:  console.log(obj.last?.toUpperCase());&#125;</code></pre><h2 id="Union-Types"><a href="#Union-Types" class="headerlink" title="Union Types"></a>Union Types</h2><p><code>联合类型</code></p><p>TypeScript’s type system allows you to build new types out of existing ones using a large variety of operators. Now that we know how to write a few types, it’s time to start combining them in interesting ways.</p><h2 id="Defining-a-Union-Type"><a href="#Defining-a-Union-Type" class="headerlink" title="Defining a Union Type"></a>Defining a Union Type</h2><p><code>定义一个联合类型</code></p><p>The first way to combine types you might see is a union type. A union type is a type formed from two or more other types, representing values that may be any one of those types. We refer to each of these types as the union’s members.</p><p>Let’s write a function that can operate on strings or numbers:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printId(id: number | string) &#123;  console.log(&quot;Your ID is: &quot; + id);&#125;&#x2F;&#x2F; OKprintId(101);&#x2F;&#x2F; OKprintId(&quot;202&quot;);&#x2F;&#x2F; ErrorprintId(&#123; myID: 22342 &#125;);&#x2F;&#x2F; Argument of type &#39;&#123; myID: number; &#125;&#39; is not assignable to parameter of type &#39;string | number&#39;.</code></pre><h2 id="Working-with-Union-Types"><a href="#Working-with-Union-Types" class="headerlink" title="Working with Union Types"></a>Working with Union Types</h2><p><code>使用联合类型</code></p><p>It’s easy to provide a value matching a union type - simply provide a type matching any of the union’s members. If you have a value of a union type, how do you work with it?</p><p>TypeScript will only allow an operation if it is valid for every member of the union. For example, if you have the union string | number, you can’t use methods that are only available on string:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printId(id: number | string) &#123;  console.log(id.toUpperCase());Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.  Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.&#125;</code></pre><p>The solution is to narrow the union with code, the same as you would in JavaScript without type annotations. Narrowing occurs when TypeScript can deduce a more specific type for a value based on the structure of the code.</p><p>For example, TypeScript knows that only a string value will have a typeof value “string”:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printId(id: number | string) &#123;  if (typeof id &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    &#x2F;&#x2F; In this branch, id is of type &#39;string&#39;    console.log(id.toUpperCase());  &#125; else &#123;    &#x2F;&#x2F; Here, id is of type &#39;number&#39;    console.log(id);  &#125;&#125;</code></pre><p>Another example is to use a function like Array.isArray:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function welcomePeople(x: string[] | string) &#123;  if (Array.isArray(x)) &#123;    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string[]&#39;    console.log(&quot;Hello, &quot; + x.join(&quot; and &quot;));  &#125; else &#123;    &#x2F;&#x2F; Here: &#39;x&#39; is &#39;string&#39;    console.log(&quot;Welcome lone traveler &quot; + x);  &#125;&#125;</code></pre><p>Notice that in the else branch, we don’t need to do anything special - if x wasn’t a string[], then it must have been a string.</p><p>Sometimes you’ll have a union where all the members have something in common. For example, both arrays and strings have a slice method. If every member in a union has a property in common, you can use that property without narrowing:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Return type is inferred as number[] | stringfunction getFirstThree(x: number[] | string) &#123;  return x.slice(0, 3);&#125;</code></pre><p>It might be confusing that a union of types appears to have the intersection of those types’ properties. This is not an accident - the name union comes from type theory. The union number | string is composed by taking the union of the values from each type. Notice that given two sets with corresponding facts about each set, only the intersection of those facts applies to the union of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat.</p><h2 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h2><p><code>类型别名</code></p><p>We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.</p><p>A type alias is exactly that - a name for any type. The syntax for a type alias is:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Point &#x3D; &#123;  x: number;  y: number;&#125;;&#x2F;&#x2F; Exactly the same as the earlier examplefunction printCoord(pt: Point) &#123;  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);&#125;printCoord(&#123; x: 100, y: 100 &#125;);</code></pre><p>You can actually use a type alias to give a name to any type at all, not just an object type. For example, a type alias can name a union type:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type ID &#x3D; number | string;</code></pre><p>Note that aliases are only aliases - you cannot use type aliases to create different&#x2F;distinct “versions” of the same type. When you use the alias, it’s exactly as if you had written the aliased type. In other words, this code might look illegal, but is OK according to TypeScript because both types are aliases for the same type:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type UserInputSanitizedString &#x3D; string;function sanitizeInput(str: string): UserInputSanitizedString &#123;  return sanitize(str);&#125;&#x2F;&#x2F; Create a sanitized inputlet userInput &#x3D; sanitizeInput(getInput());&#x2F;&#x2F; Can still be re-assigned with a string thoughuserInput &#x3D; &quot;new input&quot;;</code></pre><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><p><code>接口</code></p><p>An interface declaration is another way to name an object type:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Point &#123;  x: number;  y: number;&#125;function printCoord(pt: Point) &#123;  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);&#125;printCoord(&#123; x: 100, y: 100 &#125;);</code></pre><p>Just like when we used a type alias above, the example works just as if we had used an anonymous object type. TypeScript is only concerned with the structure of the value we passed to printCoord - it only cares that it has the expected properties. Being concerned only with the structure and capabilities of types is why we call TypeScript a structurally typed type system.</p><h2 id="Differences-Between-Type-Aliases-and-Interfaces"><a href="#Differences-Between-Type-Aliases-and-Interfaces" class="headerlink" title="Differences Between Type Aliases and Interfaces"></a>Differences Between Type Aliases and Interfaces</h2><p><code>类型别名和接口的区别</code></p><p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p><p><strong>Interface</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Extending an interfaceinterface Animal &#123;  name: string;&#125;interface Bear extends Animal &#123;  honey: boolean;&#125;const bear &#x3D; getBear();bear.name;bear.honey;</code></pre><p><strong>Type</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Extending a type via intersectionstype Animal &#x3D; &#123;  name: string;&#125;;type Bear &#x3D; Animal &amp; &#123;  honey: boolean;&#125;;const bear &#x3D; getBear();bear.name;bear.honey;</code></pre><p>Adding new fields to an existing interface</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Window &#123;  title: string;&#125;interface Window &#123;  ts: TypeScriptAPI;&#125;const src &#x3D; &#39;const a &#x3D; &quot;Hello World&quot;&#39;;window.ts.transpileModule(src, &#123;&#125;);</code></pre><p>A type cannot be changed after being created</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Window &#x3D; &#123;  title: string;&#125;;type Window &#x3D; &#123;  ts: TypeScriptAPI;&#125;;&#x2F;&#x2F; Error: Duplicate identifier &#39;Window&#39;.</code></pre><p>You’ll learn more about these concepts in later chapters, so don’t worry if you don’t understand all of these right away.</p><ul><li>Prior to TypeScript version 4.2, type alias names may appear in error messages, sometimes in place of the equivalent anonymous type (which may or may not be desirable). Interfaces will always be named in error messages.</li><li>Type aliases may not participate in declaration merging, but interfaces can.</li><li>Interfaces may only be used to declare the shapes of objects, not rename primitives.</li><li>Interface names will always appear in their original form in error messages, but only when they are used by name.</li></ul><p>For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type.</p><h2 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h2><p><code>类型断言</code></p><p>Sometimes you will have information about the type of a value that TypeScript can’t know about.</p><p>For example, if you’re using document.getElementById, TypeScript only knows that this will return some kind of HTMLElement, but you might know that your page will always have an HTMLCanvasElement with a given ID.</p><p>In this situation, you can use a type assertion to specify a more specific type:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const myCanvas &#x3D; document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;</code></pre><p>Like a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.</p><p>You can also use the angle-bracket syntax (except if the code is in a .tsx file), which is equivalent:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const myCanvas &#x3D; &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);</code></pre><p>Reminder: Because type assertions are removed at compile-time, there is no runtime checking associated with a type assertion. There won’t be an exception or null generated if the type assertion is wrong.</p><p>TypeScript only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents “impossible” coercions like:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const x &#x3D; &quot;hello&quot; as number;&#x2F;&#x2F; Conversion of type &#39;string&#39; to type &#39;number&#39; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#39;unknown&#39; first.</code></pre><p>Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown, which we’ll introduce later), then to the desired type:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const a &#x3D; expr as any as T;</code></pre><h2 id="Literal-Types"><a href="#Literal-Types" class="headerlink" title="Literal Types"></a>Literal Types</h2><p><code>字面量类型</code></p><p>In addition to the general types string and number, we can refer to specific strings and numbers in type positions.</p><p>One way to think about this is to consider how JavaScript comes with different ways to declare a variable. Both var and let allow for changing what is held inside the variable, and const does not. This is reflected in how TypeScript creates types for literals.</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let changingString &#x3D; &quot;Hello World&quot;;changingString &#x3D; &quot;Olá Mundo&quot;;&#x2F;&#x2F; Because &#96;changingString&#96; can represent any possible string, that&#x2F;&#x2F; is how TypeScript describes it in the type systemchangingString;let changingString: string;const constantString &#x3D; &quot;Hello World&quot;;&#x2F;&#x2F; Because &#96;constantString&#96; can only represent 1 possible string, it&#x2F;&#x2F; has a literal type representationconstantString;const constantString: &quot;Hello World&quot;;</code></pre><p>By themselves, literal types aren’t very valuable:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x: &quot;hello&quot; &#x3D; &quot;hello&quot;;&#x2F;&#x2F; OKx &#x3D; &quot;hello&quot;;&#x2F;&#x2F; ...x &#x3D; &quot;howdy&quot;;&#x2F;&#x2F; Type &#39;&quot;howdy&quot;&#39; is not assignable to type &#39;&quot;hello&quot;&#39;.</code></pre><p>It’s not much use to have a variable that can only have one value!</p><p>But by combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;  &#x2F;&#x2F; ...&#125;printText(&quot;Hello, world&quot;, &quot;left&quot;);printText(&quot;G&#39;day, mate&quot;, &quot;centre&quot;);Argument of type &#39;&quot;centre&quot;&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot;&#39;.</code></pre><p>Numeric literal types work the same way:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function compare(a: string, b: string): -1 | 0 | 1 &#123;  return a &#x3D;&#x3D;&#x3D; b ? 0 : a &gt; b ? 1 : -1;&#125;</code></pre><p>Of course, you can combine these with non-literal types:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Options &#123;  width: number;&#125;function configure(x: Options | &quot;auto&quot;) &#123;  &#x2F;&#x2F; ...&#125;configure(&#123; width: 100 &#125;);configure(&quot;auto&quot;);configure(&quot;automatic&quot;);Argument of type &#39;&quot;automatic&quot;&#39; is not assignable to parameter of type &#39;Options | &quot;auto&quot;&#39;.</code></pre><p>There’s one more kind of literal type: boolean literals. There are only two boolean literal types, and as you might guess, they are the types true and false. The type boolean itself is actually just an alias for the union true | false.</p><h2 id="Literal-Inference"><a href="#Literal-Inference" class="headerlink" title="Literal Inference"></a>Literal Inference</h2><p><code>字面量推断</code><br>When you initialize a variable with an object, TypeScript assumes that the properties of that object might change values later. For example, if you wrote code like this:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const obj &#x3D; &#123; counter: 0 &#125;;if (someCondition) &#123;  obj.counter &#x3D; 1;&#125;</code></pre><p>TypeScript doesn’t assume the assignment of 1 to a field which previously had 0 is an error. Another way of saying this is that obj.counter must have the type number, not 0, because types are used to determine both reading and writing behavior.</p><p>The same applies to strings:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125;;handleRequest(req.url, req.method);Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;GET&quot; | &quot;POST&quot;&#39;.</code></pre><p>In the above example req.method is inferred to be string, not “GET”. Because code can be evaluated between the creation of req and the call of handleRequest which could assign a new string like “GUESS” to req.method, TypeScript considers this code to have an error.</p><p>There are two ways to work around this.</p><p>You can change the inference by adding a type assertion in either location:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Change 1:const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; &#125;;&#x2F;&#x2F; Change 2handleRequest(req.url, req.method as &quot;GET&quot;);</code></pre><p>Change 1 means “I intend for req.method to always have the literal type “GET””, preventing the possible assignment of “GUESS” to that field after. Change 2 means “I know for other reasons that req.method has the value “GET”“.</p><p>You can use as const to convert the entire object to be type literals:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125; as const;handleRequest(req.url, req.method);</code></pre><p>The as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number.</p><h2 id="null-and-undefined"><a href="#null-and-undefined" class="headerlink" title="null and undefined"></a>null and undefined</h2><p><code>null和undefined</code></p><p>JavaScript has two primitive values used to signal absent or uninitialized value: null and undefined.</p><p>TypeScript has two corresponding types by the same names. How these types behave depends on whether you have the strictNullChecks option on.</p><h2 id="strictNullChecks-off"><a href="#strictNullChecks-off" class="headerlink" title="strictNullChecks off"></a>strictNullChecks off</h2><p><code>strictNullChecks关闭</code></p><p>With strictNullChecks off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; we always recommend people turn strictNullChecks on if it’s practical to do so in their codebase.</p><h2 id="strictNullChecks-on"><a href="#strictNullChecks-on" class="headerlink" title="strictNullChecks on"></a>strictNullChecks on</h2><p><code>strictNullChecks开启</code></p><p>With strictNullChecks on, when a value is null or undefined, you will need to test for those values before using methods or properties on that value. Just like checking for undefined before using an optional property, we can use narrowing to check for values that might be null:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(x: string | null) &#123;  if (x &#x3D;&#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; do nothing  &#125; else &#123;    console.log(&quot;Hello, &quot; + x.toUpperCase());  &#125;&#125;</code></pre><h2 id="Non-null-Assertion-Operator-Postfix"><a href="#Non-null-Assertion-Operator-Postfix" class="headerlink" title="Non-null Assertion Operator (Postfix !)"></a>Non-null Assertion Operator (Postfix !)</h2><p><code>非空断言运算符</code></p><p>TypeScript also has a special syntax for removing null and undefined from a type without doing any explicit checking. Writing ! after any expression is effectively a type assertion that the value isn’t null or undefined:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function liveDangerously(x?: number | null) &#123;  &#x2F;&#x2F; No error  console.log(x!.toFixed());&#125;</code></pre><p>Just like other type assertions, this doesn’t change the runtime behavior of your code, so it’s important to only use ! when you know that the value can’t be null or undefined.</p><h2 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h2><p><code>枚举</code></p><p>Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the Enum reference page.</p><h2 id="Less-Common-Primitives"><a href="#Less-Common-Primitives" class="headerlink" title="Less Common Primitives"></a>Less Common Primitives</h2><p><code>更少常见的原始类型</code><br>It’s worth mentioning the rest of the primitives in JavaScript which are represented in the type system. Though we will not go into depth here.</p><p>bigint<br>From ES2020 onwards, there is a primitive in JavaScript used for very large integers, BigInt:</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Creating a bigint via the BigInt functionconst oneHundred: bigint &#x3D; BigInt(100);&#x2F;&#x2F; Creating a BigInt via the literal syntaxconst anotherHundred: bigint &#x3D; 100n;</code></pre><p>You can learn more about BigInt in the TypeScript 3.2 release notes.</p><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>There is a primitive in JavaScript used to create a globally unique reference via the function Symbol():</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const firstName &#x3D; Symbol(&quot;name&quot;);const secondName &#x3D; Symbol(&quot;name&quot;);if (firstName &#x3D;&#x3D;&#x3D; secondName) &#123;This condition will always return &#39;false&#39; since the types &#39;typeof firstName&#39; and &#39;typeof secondName&#39; have no overlap.  &#x2F;&#x2F; Can&#39;t ever happen&#125;</code></pre><p>You can learn more about them in Symbols reference page.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean">Typescript 常见类型</a></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Typescript 基础</title>
      <link href="//post/2022-06-07ts-basics.html"/>
      <url>//post/2022-06-07ts-basics.html</url>
      
        <content type="html"><![CDATA[<h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><p>Welcome to the first page of the handbook. If this is your first experience with TypeScript - you may want to start at one of the ‘Getting Started’ guides<br><code>欢迎来到 TypeScript 手册的第一页。如果您是第一次使用 TypeScript - 您可能想要开始一个&#39;Getting Started&#39;指南</code></p><p>Each and every value in JavaScript has a set of behaviors you can observe from running different operations. That sounds abstract, but as a quick example, consider some operations we might run on a variable named message.<br><code>每个和所有的值在 JavaScript 中都有一组行为可以观察从运行不同的操作。这会感觉很抽象，但是作为一个快速的例子，考虑一些我们可能运行的操作的变量名称 message。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Accessing the property &#39;toLowerCase&#39;&#x2F;&#x2F; on &#39;message&#39; and then calling itmessage.toLowerCase();&#x2F;&#x2F; Calling &#39;message&#39;message();</code></pre><p>If we break this down, the first runnable line of code accesses a property called toLowerCase and then calls it. The second one tries to call message directly.<br><code>如果 我们将这个分解，第一个可运行的行代码访问一个属性叫做 toLowerCase 并且调用它。第二个尝试直接调用 message。</code><br>But assuming we don’t know the value of message - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code. The behavior of each operation depends entirely on what value we had in the first place.<br><code>但是假设我们不知道 message 的值 - 并且这是很常见的 - 我们不可以可靠地说什么结果我们会得到运行这些代码。每个操作的行为取决于我们本身的值。</code></p><ul><li>Is message callable? <code>message 是可调用的吗？</code></li><li>Does it have a property called toLowerCase on it? <code>message 有一个属性叫做 toLowerCase 吗？</code></li><li>If it does, is toLowerCase even callable? <code>如果是，是否 toLowerCase 可调用？</code></li><li>If both of these values are callable, what do they return? <code>如果这两个值都是可调用的，它们会返回什么？</code></li></ul><p>The answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.<br><code>这些问题的答案通常是我们在写 JavaScript 时保留在我们的脑中，并且我们必须希望我们拿到所有的细节正确。</code><br>Let’s say message was defined in the following way.<br><code>让我们假设 message 被定义为以下的方式。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const message &#x3D; &quot;Hello World!&quot;;</code></pre><p>As you can probably guess, if we try to run message.toLowerCase(), we’ll get the same string only in lower-case.<br><code>如果我们试着运行 message.toLowerCase()，我们会得到一个只有小写字母的字符串。</code><br>What about that second line of code? If you’re familiar with JavaScript, you’ll know this fails with an exception:<br><code>如果您熟悉 JavaScript，您会知道这个失败了一个异常：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; TypeError: message is not a function</code></pre><p>It’d be great if we could avoid mistakes like this.<br><code>我们应该能避免这样的错误。</code><br>When we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the type of the value - what sorts of behaviors and capabilities it has. That’s part of what that TypeError is alluding to - it’s saying that the string “Hello World!” cannot be called as a function.<br><code>当我们运行我们的代码，我们的 JavaScript 运行时通过分析值的类型来决定如何做。这是它引用的 TypeError 的一部分 - 它说明 &quot;Hello World!&quot; 不能被调用作为函数。</code><br>For some values, such as the primitives string and number, we can identify their type at runtime using the typeof operator. But for other things like functions, there’s no corresponding runtime mechanism to identify their types. For example, consider this function:<br><code>对于某些值，如字符串和数字，我们可以在运行时通过 typeof 操作符来识别它的类型。但是对于其他的东西，没有相应的运行时机制来识别它们的类型。例如，让我们来看这个函数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function fn(x) &#123;  return x.flip();&#125;</code></pre><p>We can observe by reading the code that this function will only work if given an object with a callable flip property, but JavaScript doesn’t surface this information in a way that we can check while the code is running. The only way in pure JavaScript to tell what fn does with a particular value is to call it and see what happens. This kind of behavior makes it hard to predict what code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.<br><code>我们可以通过阅读代码, 看到这个函数只有在给定一个可调用 flip 属性的对象时才能工作，但 JavaScript 没有一种方式可以在运行代码时来识别 fn 的行为。只有在调用它时才能知道 fn 的行为，这种行为难以预测，这意味着在写代码时难以知道你的代码会做什么。</code><br>Seen in this way, a type is the concept of describing which values can be passed to fn and which will crash. JavaScript only truly provides dynamic typing - running the code to see what happens.<br><code>在这种方式中，一个类型是描述哪些值可以传给 fn，哪些会崩溃的概念。JavaScript 只是提供了动态类型定义 - 运行代码来看看会发生什么。</code><br>The alternative is to use a static type system to make predictions about what code is expected before it runs.<br><code>另一种方式是使用静态类型系统来预测在运行代码之前会发生什么。</code></p><h2 id="Static-type-checking"><a href="#Static-type-checking" class="headerlink" title="Static type-checking"></a>Static type-checking</h2><p><code>静态类型检查</code><br>Think back to that TypeError we got earlier from trying to call a string as a function. Most people don’t like to get any sorts of errors when running their code - those are considered bugs! And when we write new code, we try our best to avoid introducing new bugs.<br><code>想起那个 TypeError 我们以前从尝试调用一个字符串作为函数时得到的。大多数人不喜欢在运行他们的代码时得到任何类型的错误，这些错误被称为 bug！而当我们写新代码时，我们尽可能地避免引入新的 bug。</code><br>If we add just a bit of code, save our file, re-run the code, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case. We might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown! Or if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.<br><code>如果我们添加些点代码，保存我们的文件，重新运行代码，并立即看到错误，我们可能会快速地发现问题；但这并不总是如此。我们可能没有测试特性的充分程度，所以我们可能没有真正发生可能会抛出的错误！或者如果我们能够看到错误，我们可能已经做了大量的重构和添加了很多不同的代码，我们被迫要探索它们。</code><br>Ideally, we could have a tool that helps us find these bugs before our code runs. That’s what a static type-checker like TypeScript does. Static types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails.<br><code>最好的方式是我们可以在我们的代码运行之前，有一个工具帮我们找到这些 bug。这是 TypeScript 的静态类型检查器做的。静态类型系统描述了我们的值在运行我们的程序时的形状和行为。一个类型检查器像 TypeScript 使用这些信息，告诉我们当可能会出现问题时。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const message &#x3D; &quot;hello!&quot;;message();&#x2F;&#x2F; This expression is not callable.&#x2F;&#x2F;   Type &#39;String&#39; has no call signatures.</code></pre><p>Running that last sample with TypeScript will give us an error message before we run the code in the first place.<br><code>运行这个最后一个示例，TypeScript 将在第一个代码之前报错。</code></p><h2 id="Non-exception-Failures"><a href="#Non-exception-Failures" class="headerlink" title="Non-exception Failures"></a>Non-exception Failures</h2><p><code>非异常失败</code><br>So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime tells us that it thinks something is nonsensical. Those cases come up because the ECMAScript specification has explicit instructions on how the language should behave when it runs into something unexpected.<br><code>直到现在，我们都讨论了一些关于运行时错误的事情，比如说，当 JavaScript 运行时认为某些东西是无效的。这些情况出现的原因是 ECMAScript 规范明确指出了在运行时如何应该行为。</code><br>For example, the specification says that trying to call something that isn’t callable should throw an error. Maybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too. Instead, JavaScript gives us different behavior and returns the value undefined:<br><code>比如说，规范指出了尝试调用不可调用的东西应该抛出一个错误。可能会认为这是“明显的行为”，但你可以想象一下，访问一个对象上不存在的属性应该抛出一个错误。而 JavaScript 给我们不同的行为，返回值 undefined：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const user &#x3D; &#123;  name: &quot;Daniel&quot;,  age: 26,&#125;;user.location; &#x2F;&#x2F; returns undefined</code></pre><p>Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. In TypeScript, the following code produces an error about location not being defined:<br><code>最终，一个静态类型系统必须要在它的系统中，告诉我们应该把哪些代码标记为错误的代码，即使它是“有效的 JavaScript”，也不会立即抛出错误。在 TypeScript 中，下面的代码会报错：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const user &#x3D; &#123;  name: &quot;Daniel&quot;,  age: 26,&#125;;user.location;&#x2F;&#x2F; Property &#39;location&#39; does not exist on type &#39;&#123; name: string; age: number; &#125;&#39;.</code></pre><p>While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs. And TypeScript catches a lot of legitimate bugs.<br><code>在某些情况下，这意味着一个交换，在你能表达的范围内，在你的程序中，你可以把一些有效的 JavaScript 抛出错误。而 TypeScript 捕获很多有效的错误。</code><br>For example: typos,<br><code>比如说，拼写错误，</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const announcement &#x3D; &quot;Hello World!&quot;;&#x2F;&#x2F; How quickly can you spot the typos?announcement.toLocaleLowercase();announcement.toLocalLowerCase();&#x2F;&#x2F; We probably meant to write this...announcement.toLocaleLowerCase();</code></pre><p>uncalled functions,<br><code>未调用的函数，</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function flipCoin() &#123;  &#x2F;&#x2F; Meant to be Math.random()  return Math.random &lt; 0.5;  &#x2F;&#x2F; Operator &#39;&lt;&#39; cannot be applied to types &#39;() &#x3D;&gt; number&#39; and &#39;number&#39;.&#125;</code></pre><p>or basic logic errors.<br><code>或基本的逻辑错误。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const value &#x3D; Math.random() &lt; 0.5 ? &quot;a&quot; : &quot;b&quot;;if (value !&#x3D;&#x3D; &quot;a&quot;) &#123;  &#x2F;&#x2F; ...&#125; else if (value &#x3D;&#x3D;&#x3D; &quot;b&quot;) &#123;  &#x2F;&#x2F; This condition will always return &#39;false&#39; since the types &#39;&quot;a&quot;&#39; and &#39;&quot;b&quot;&#39; have no overlap.  &#x2F;&#x2F; Oops, unreachable&#125;</code></pre><h2 id="Types-for-Tooling"><a href="#Types-for-Tooling" class="headerlink" title="Types for Tooling"></a>Types for Tooling</h2><p><code>类型为工具</code><br>TypeScript can catch bugs when we make mistakes in our code. That’s great, but TypeScript can also prevent us from making those mistakes in the first place.<br><code>TypeScript 可以捕获我们在我们的代码中做错误的错误。这很好，但 TypeScript 可以防止我们做错误。</code><br>The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use.<br><code>类型检查器有信息来检查变量和其他属性是否正确。一旦有这些信息，它也可以开始提建议你应该使用哪些属性。</code><br>That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor. That’s part of what people often refer to when they talk about tooling in TypeScript.<br><code>这意味着 TypeScript 可以用于编辑代码，并且核心类型检查器可以提供错误消息和代码补全。这是人们通常在说讨论工具时所提到的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import express from &quot;express&quot;;const app &#x3D; express();app.get(&quot;&#x2F;&quot;, function (req, res) &#123;  res.sen    &#x2F;&#x2F; send    &#x2F;&#x2F; sendDate    &#x2F;&#x2F; sendfile    &#x2F;&#x2F; sendFile    &#x2F;&#x2F; sendStatus&#125;);app.</code></pre><p>TypeScript takes tooling seriously, and that goes beyond completions and errors as you type. An editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable. All of this is built on top of the type-checker and is fully cross-platform, so it’s likely that your favorite editor has TypeScript support available.<br><code>TypeScript 也深深地认识到工具，并且这也包括了完成和错误的补全，你在输入时可以自动修复错误，重新组织代码，以及寻找变量的定义，或寻找所有引用的变量。这全部是基于类型检查器的，并且是完全的跨平台，所以你可能喜欢的编辑器有 TypeScript 的支持。</code></p><h2 id="tsc-the-TypeScript-compiler"><a href="#tsc-the-TypeScript-compiler" class="headerlink" title="tsc, the TypeScript compiler"></a>tsc, the TypeScript compiler</h2><p><code>tsc</code>，TypeScript 编译器<br>We’ve been talking about type-checking, but we haven’t yet used our type-checker. Let’s get acquainted with our new friend tsc, the TypeScript compiler. First we’ll need to grab it via npm.<br><code>我们已经讲述了类型检查，但我们还没有使用我们的类型检查器。我们需要通过 npm 来获取 tsc，TypeScript 编译器。</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g typescript</code></pre><p>This installs the TypeScript Compiler tsc globally. You can use npx or similar tools if you’d prefer to run tsc from a local node_modules package instead.<br><code>这将安装 TypeScript 编译器 tsc 在全局。如果你想从本地的 node_modules 包里运行 tsc，可以使用 npx 或类似的工具。</code><br>Now let’s move to an empty folder and try writing our first TypeScript program: hello.ts:<br><code>现在我们移动到一个空文件夹，并尝试写我们的第一个 TypeScript 程序：hello.ts：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Greets the world.console.log(&quot;Hello world!&quot;);</code></pre><p>Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript. And now let’s type-check it by running the command tsc which was installed for us by the typescript package.<br><code>通过运行 tsc 命令，我们可以检查我们的程序。</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tsc hello.ts</code></pre><p>Tada!<br><code>拍拍拍！</code><br>Wait, “tada” what exactly? We ran tsc and nothing happened! Well, there were no type errors, so we didn’t get any output in our console since there was nothing to report.<br><code>等等，“拍拍拍”，什么意思？我们运行 tsc，没有任何事情发生！</code><br>But check again - we got some file output instead. If we look in our current directory, we’ll see a hello.js file next to hello.ts. That’s the output from our hello.ts file after tsc compiles or transforms it into a plain JavaScript file. And if we check the contents, we’ll see what TypeScript spits out after it processes a .ts file:<br><code>但再检查一次，我们会看到一个 hello.js 文件，它在 hello.ts 后面。这是 tsc 编译或转换成一个纯 JavaScript 文件的 hello.ts 的输出。如果我们检查内容，我们会看到 TypeScript 在处理 .ts 文件后打印出来的内容：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; Greets the world.console.log(&quot;Hello world!&quot;);</code></pre><p>In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote. The compiler tries to emit clean readable code that looks like something a person would write. While that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.<br><code>在这种情况下，TypeScript 尝试输出一个清洁的可读代码，看起来像一个人写的代码。这并不总是如此简单，TypeScript 缩进一致，注意代码的不同行，并尝试保持注释在同一行。</code><br>What about if we did introduce a type-checking error? Let’s rewrite hello.ts:<br><code>如果我们把 hello.ts 中的 console.log 改成 console.logs，我们会发现什么？我们再次重写 hello.ts：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; This is an industrial-grade general-purpose greeter function:function greet(person, date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date&#125;!&#96;);&#125;greet(&quot;Brendan&quot;);</code></pre><p>If we run tsc hello.ts again, notice that we get an error on the command line!<br><code>如果我们运行 tsc hello.ts 再次，我们会发现在命令行上出现一个错误！</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">Expected 2 arguments, but got 1.</code></pre><p>TypeScript is telling us we forgot to pass an argument to the greet function, and rightfully so. So far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code. Thanks TypeScript!<br><code>TypeScript 提醒我们没有传递参数给 greet 函数，并且正确地。直到现在，我们只写了标准 JavaScript，然而类型检查仍然可以找到我们的代码的问题。感谢 TypeScript！</code></p><h2 id="Emitting-with-Errors"><a href="#Emitting-with-Errors" class="headerlink" title="Emitting with Errors"></a>Emitting with Errors</h2><p><code>发射错误</code><br>One thing you might not have noticed from the last example was that our hello.js file changed again. If we open that file up then we’ll see that the contents still basically look the same as our input file. That might be a bit surprising given the fact that tsc reported an error about our code, but this is based on one of TypeScript’s core values: much of the time, you will know better than TypeScript.<br><code>一个你可能没有注意到的事情是，我们的 hello.js 文件变了一次。如果我们打开这个文件，我们会看到它的内容仍然基本和我们的输入文件一样。这可能是一个很糟的情况，因为 tsc 报告了我们的代码的错误，但这是基于 TypeScript 的核心值：很多时候，你会更了解更多的事情。</code><br>To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable. Most of the time that’s okay, but there are scenarios where those checks get in the way. For example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors. Eventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working! Why should converting it over to TypeScript stop you from running it?<br><code>重复上一段内容，类型检查代码限制了你可以运行的程序，因此有一个交换，如果你的类型检查器找到了可接受的东西，那么你可以运行它。但是，有时候，这些检查会拖慢你的程序。例如，假设你是一个 JavaScript 的移植者，并且你把类型检查错误插入到你的代码中。最终，你会把它们清理掉，但是原来的 JavaScript 代码已经已经正常运行了！为什么你会把它移植到 TypeScript 中，然后停止运行它？</code><br>So TypeScript doesn’t get in your way. Of course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly. In that case, you can use the noEmitOnError compiler option. Try changing your hello.ts file and running tsc with that flag:<br><code>因此，TypeScript 不会拖慢你。但是，随着时间的推移，你可能会想要更加安全，并且使 TypeScript 变得更严格。在这种情况下，你可以使用 noEmitOnError 编译器选项。试着把 hello.ts 文件中的代码改一下，然后运行 tsc 并且使用这个选项：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">tsc --noEmitOnError hello.ts</code></pre><p>You’ll notice that hello.js never gets updated.<br><code>hello.js 不会被更新。</code></p><h2 id="Explicit-Types"><a href="#Explicit-Types" class="headerlink" title="Explicit Types"></a>Explicit Types</h2><p><code>显式类型</code><br>Up until now, we haven’t told TypeScript what person or date are. Let’s edit the code to tell TypeScript that person is a string, and that date should be a Date object. We’ll also use the toDateString() method on date.<br><code>直到现在，我们都没有告诉 TypeScript 什么是人或日期。我们现在编辑代码，让 TypeScript 知道 person 是一个字符串，而 date 应该是一个 Date 对象。我们也使用 date 的 toDateString() 方法。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(person: string, date: Date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;</code></pre><p>What we did was add type annotations on person and date to describe what types of values greet can be called with. You can read that signature as ”greet takes a person of type string, and a date of type Date“.<br><code>我们做了一个类型标注，让 TypeScript 知道 greet 可以被调用的时候，person 的类型是 string，而 date 的类型是 Date。</code><br>With this, TypeScript can tell us about other cases where greet might have been called incorrectly. For example…<br><code>这样，TypeScript 可以告诉我们其他情况下 greet 可能会被调用错误。例如…</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(person: string, date: Date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;greet(&quot;Maddison&quot;, Date());&#x2F;&#x2F; Argument of type &#39;string&#39; is not assignable to parameter of type &#39;Date&#39;.</code></pre><p>Huh? TypeScript reported an error on our second argument, but why?<br><code>哎？TypeScript 在第二个参数上报错了，但是为什么？</code><br>Perhaps surprisingly, calling Date() in JavaScript returns a string. On the other hand, constructing a Date with new Date() actually gives us what we were expecting.<br><code>可能就是因为 JavaScript 中的 Date() 返回一个字符串，而 new Date() 则会返回我们期望的结果。</code><br>Anyway, we can quickly fix up the error:<br><code>然后，我们可以快速修复错误：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(person: string, date: Date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;greet(&quot;Maddison&quot;, new Date());</code></pre><p>Keep in mind, we don’t always have to write explicit type annotations. In many cases, TypeScript can even just infer (or “figure out”) the types for us even if we omit them.<br><code>记住，我们不是总是要写明类型标注。在大多数情况下，TypeScript 也可以自动推断（或者说认为）类型，即使我们没有写明类型标注。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let msg &#x3D; &quot;hello there!&quot;;let msg: string;</code></pre><p>Even though we didn’t tell TypeScript that msg had the type string it was able to figure that out. That’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.<br><code>即使我们没有告诉 TypeScript msg 的类型是 string，它也能够自动推断出来。这是一个特性，并且当类型系统自动推断出相同类型的时候，不要写明类型标注。</code><br>:::tip</p><p>the message bubble inside the code sample above. That is what your editor would show if you had hovered over the word.<br><code>在上面的代码段中，你的编辑器会显示一个消息泡。如果你鼠标悬停在这个单词上，那么你的编辑器会显示这个消息泡。</code><br>:::</p><h2 id="Erased-Types"><a href="#Erased-Types" class="headerlink" title="Erased Types"></a>Erased Types</h2><p><code>擦除类型</code><br>Let’s take a look at what happens when we compile the above function greet with tsc to output JavaScript:<br><code>我们看看如果我们用 tsc 编译上面的函数 greet，它会输出 JavaScript 代码：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;use strict&quot;;function greet(person, date) &#123;  console.log(    &quot;Hello &quot;.concat(person, &quot;, today is &quot;).concat(date.toDateString(), &quot;!&quot;)  );&#125;greet(&quot;Maddison&quot;, new Date());</code></pre><p>Notice two things here:<br><code>注意这里有两件事情：</code><br>Our person and date parameters no longer have type annotations.<br><code>我们的 person 和 date 参数没有类型标注。</code><br>Our “template string” - that string that used backticks (the <code>character) - was converted to plain strings with concatenations (+).</code>我们的模板字符串（使用 字符）已经被转换成了纯字符串，并且使用了 + 字符串连接。<code>More on that second point later, but let’s now focus on that first point. Type annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.</code>TypeScript 不是 JavaScript（或者说 ECMAScript）的一部分，所以不会有浏览器或其他运行时可以直接运行 TypeScript 的情况。因此 TypeScript 需要一个编译器，以便我们可以去掉或转换 TypeScript 的任何特定代码，以便我们可以运行它。大多数 TypeScript 特定代码都会被去掉，反之，这里的类型标注也会被去掉。&#96;</p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p>Remember: Type annotations never change the runtime behavior of your program.<br><code>记住：类型标注不会改变你的程序的运行时行为。</code></div><h2 id="Downleveling"><a href="#Downleveling" class="headerlink" title="Downleveling"></a>Downleveling</h2><p><code>降级</code><br>One other difference from the above was that our template string was rewritten from<br><code>我们的模板字符串是从</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;;</code></pre><p>to</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;Hello &quot; + person + &quot;, today is &quot; + date.toDateString() + &quot;!&quot;;</code></pre><p>Why did this happen?<br><code>为什么这样发生了？</code><br>Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - don’t ask). TypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called downleveling.<br><code>模板字符串是 ECMAScript 2015 的一个特性（或者说 ECMAScript 6，ES2015，ES6 等）。TypeScript 有能力将从更新的 ECMAScript 移到更旧的 ECMAScript，比如 ECMAScript 3 或 ECMAScript 5（或者说 ES3 和 ES5）。这种移动的过程称为降级。</code><br>By default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with –target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. So running tsc –target es2015 hello.ts gives us the following output:<br><code>默认情况下，TypeScript 目标 ES3，一个非常老的 ECMAScript 版本。我们可以选择一个更新的版本，使用 target 选项。运行 tsc --target es2015 hello.ts 就会得到以下的输出：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(person, date) &#123;  console.log(&#96;Hello $&#123;person&#125;, today is $&#123;date.toDateString()&#125;!&#96;);&#125;greet(&quot;Maddison&quot;, new Date());</code></pre><p>While the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.<br><code>默认目标是 ES3，大多数当前浏览器都支持 ES2015。大多数开发人员可以安全地指定 ES2015 或以上作为目标，除非需要与某些古老的浏览器兼容。</code></p><h2 id="Strictness"><a href="#Strictness" class="headerlink" title="Strictness"></a>Strictness</h2><p><code>严格</code><br>Different users come to TypeScript looking for different things in a type-checker. Some people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling. This is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially null&#x2F;undefined values. Much like how tsc emits in the face of errors, these defaults are put in place to stay out of your way. If you’re migrating existing JavaScript, that might be a desirable first step.<br><code>不同的用户到 TypeScript 上来看，有不同的意图。有人想要一个更宽松的选择，这可以帮助验证某些部分的程序，并且仍然有很好的工具。这是 TypeScript 默认的行为，其中类型是可选的，推断会接受更宽松的类型，并且没有检查可能 null/undefined 的值。和 tsc 在出现错误的时候一样，这些默认值被放在了你的脚跟上（兜底：这些默认选项并不会阻碍你的开发）。如果你正在迁移已有的 JavaScript，那么这可能是一个最佳的第一步。</code><br>In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.<br><code>不同的用户喜欢立刻验证程序，而不是等到最后。这是 TypeScript 的语言提供了严格性设置，这些设置可以改变静态类型检查的行为。这些设置可以改变静态类型检查的行为，而不是一个开关。这些设置越高，TypeScript 越会检查更多的信息。这可能需要一点额外的工作，但一般来说，这能提供更好的工具，并且能更好地支持你的代码。当可能的时候，一个新的代码应该总是开启这些严格性检查。</code><br>TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated. The strict flag in the CLI, or “strict”: true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks.<br><code>TypeScript 有多个严格性标志，可以开启或关闭，所有的示例都将使用所有的标志，除非特别说明。CLI 中的 strict 开关，或 tsconfig.json 中的 strict: true 开启了所有的标志，但是我们可以单独关闭它们。两个最大的，你应该知道的是 noImplicitAny 和 strictNullChecks。</code></p><h2 id="noImplicitAny"><a href="#noImplicitAny" class="headerlink" title="noImplicitAny"></a>noImplicitAny</h2><p><code>无隐式any</code><br>Recall that in some places, TypeScript doesn’t try to infer types for us and instead falls back to the most lenient type: any. This isn’t the worst thing that can happen - after all, falling back to any is just the plain JavaScript experience anyway.<br><code>在某些地方，TypeScript 不会为我们自动推断类型，而是使用最宽松的类型：any。这并不是最差的情况，因为仍然是 JavaScript 的经验。</code><br>However, using any often defeats the purpose of using TypeScript in the first place. The more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code. Turning on the noImplicitAny flag will issue an error on any variables whose type is implicitly inferred as any.<br><code>使用 any 很容易让你的程序变得更加不可靠。因为更加类型化的程序，你会发现更多的错误，并且更加容易地调试。开启 noImplicitAny 标志会在任何自动推断类型为 any 的变量上发出错误。</code></p><h2 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h2><p><code>严格null</code><br>By default, values like null and undefined are assignable to any other type. This can make writing some code easier, but forgetting to handle null and undefined is the cause of countless bugs in the world - some consider it<code> a billion dollar mistake!</code> The <code>strictNullChecks</code> flag makes handling null and undefined more explicit, and spares us from worrying about whether we forgot to handle null and undefined.<br><code>默认情况下，null 和 undefined 可以赋值给任何类型。这可以让写一些代码更容易，但是忘记处理 null 和 undefined 就会导致世界上的很多错误，有人认为这是一百亿美元错误！ strictNullChecks 可以让处理 null 和 undefined 更加明确，并且让我们不用担心是否忘记处理 null 和 undefined。</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html#static-type-checking">Typescript The Basics</a></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Typescript起步</title>
      <link href="//post/2022-06-08ts-start.html"/>
      <url>//post/2022-06-08ts-start.html</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此文及后续的几篇是对<a href="https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html">Typescript官方原文</a>的翻译，方便阅读</p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>typescript 起步，分别针对 4 类不同的程序开发者进行引导， <strong>对号入座</strong></p><ul><li>新手程序猿，没有接触过任何开发语言</li><li>JS 开发者</li><li>Java&#x2F;C#开发 [跳过]</li><li>函数式编程人员</li><li>5 分钟内了解 Typescript</li></ul><h2 id="新手程序猿"><a href="#新手程序猿" class="headerlink" title="新手程序猿"></a>新手程序猿</h2><p>Congratulations on choosing TypeScript as one of your first languages — you’re already making good decisions!<br><code>祝贺您选择了 TypeScript 作为您的第一种语言，您已经做出了优秀的决策！</code><br>You’ve probably already heard that TypeScript is a “flavor” or “variant” of JavaScript. The relationship between TypeScript (TS) and JavaScript (JS) is rather unique among modern programming languages, so learning more about this relationship will help you understand how TypeScript adds to JavaScript.<br><code>你大概已经听说过，TypeScript 是 JavaScript 的一个变体。TypeScript 和 JavaScript 的关系是在现代编程语言中非常独特的，所以学习更多关于这个关系的知识将帮助你了解 TypeScript 和 JavaScript 的区别。</code></p><h3 id="What-is-JavaScript-A-Brief-History"><a href="#What-is-JavaScript-A-Brief-History" class="headerlink" title="What is JavaScript? A Brief History"></a>What is JavaScript? A Brief History</h3><p><code>什么是 JavaScript？简单的历史</code></p><p>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page — writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.<br><code>JavaScript 是一种简单的脚本语言，用于浏览器。在创建时，它预期会被用于嵌入在网页中的短片代码 — 写入超过十几行代码会有点不便。</code><br>Web browser developers responded to this increased JS usage by optimizing their execution engines (dynamic compilation) and extending what could be done with it (adding APIs), which in turn made web developers use it even more. On modern websites, your browser is frequently running applications that span hundreds of thousands of lines of code. This is long and gradual growth of “the web”, starting as a simple network of static pages, and evolving into a platform for rich applications of all kinds.<br><code>Web 浏览器开发者对这个增加了 JS 使用的响应，优化了他们的执行引擎（动态编译）和扩展了他们可以做的事情（添加 APIs），这使得 Web 开发者使用它来做更多的事情。在现代网站上，您的浏览器通常运行着一些应用程序，其中包括千万行代码的应用程序。这是一个非常长的“网”的发展，从一个简单的静态页面开始，并进入一个丰富的应用程序的平台。</code><br>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The “run anywhere” nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use only JavaScript to program their entire stack!<br><code>不仅如此，JS 变得越来越受欢迎，并且可以在浏览器之外使用，比如使用 node.js 来实现 JS 服务器。JS 的“运行在任何地方”性质使得它一个极受欢迎的选择。有许多开发者今天只使用 JavaScript 来编程他们的整个堆栈！</code><br>To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own quirks — oddities and surprises, and JavaScript’s humble beginning makes it have many of these. Some examples:<br><code>概括，我们有一种语言，被设计为快速使用，然后扩展到一个具有千万行代码的应用程序的工具。每种语言都有自己的特性，有的有点不同，有的有点惊人，而 JavaScript 的轻重感使得它有许多这些。有些例子：</code></p><p>JavaScript’s equality operator (&#x3D;&#x3D;) coerces its arguments, leading to unexpected behavior:<br><code>JavaScript 的相等操作符（==）会强制转换它的参数，导致意外的行为：</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">if (&quot;&quot; &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; It is! But why??&#125;if (1 &lt; x &lt; 3) &#123;  &#x2F;&#x2F; True for *any* value of x!&#125;</code></pre><p>JavaScript also allows accessing properties which aren’t present:<br><code>JavaScript 也允许访问不存在的属性：</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const obj &#x3D; &#123; width: 10, height: 15 &#125;;&#x2F;&#x2F; Why is this NaN? Spelling is hard!const area &#x3D; obj.width * obj.heigth;</code></pre><p>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation — before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.<br><code>大多数编程语言会抛出错误，当这些错误发生时，它们会抛出错误，而不是在编译时。当写小型程序时，这些惊人的惊喜是可接受的；当写大型应用程序时，这些惊喜是一个严重的问题。</code></p><ul><li>TypeScript: A Static Type Checker</li></ul><p>We said earlier that some languages wouldn’t allow those buggy programs to run at all. Detecting errors in code without running it is referred to as static checking. Determining what’s an error and what’s not based on the kinds of values being operated on is known as static type checking.<br><code>我们说过，某些语言不允许运行那些错误的程序。检测代码中的错误，而不运行它, 是静态检查。确定哪些是错误的，哪些是正确的，是基于值的类型的静态检查。</code><br>TypeScript checks a program for errors before execution, and does so based on the kinds of values, it’s a static type checker. For example, the last example above has an error because of the type of obj. Here’s the error TypeScript found:<br><code>TypeScript 检测程序前，并且基于值的类型，它是一个静态类型检查器。例如，上面的最后一个例子有一个错误，因为 obj 的类型是 NaN。这里 TypeScript 发现了错误：</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const obj &#x3D; &#123; width: 10, height: 15 &#125;;const area &#x3D; obj.width * obj.heigth;&#x2F;&#x2F; Property &#39;heigth&#39; does not exist on type &#39;&#123; width: number; height: number; &#125;&#39;. Did you mean &#39;height&#39;?</code></pre><h3 id="A-Typed-Superset-of-JavaScript"><a href="#A-Typed-Superset-of-JavaScript" class="headerlink" title="A Typed Superset of JavaScript"></a>A Typed Superset of JavaScript</h3><p><code>一个类型定义的超集 JavaScript</code></p><p>How does TypeScript relate to JavaScript, though?<br><code>TypeScript 的类型定义是什么，和 JavaScript 的类型定义有什么关系？</code></p><h3 id="Syntax-语法"><a href="#Syntax-语法" class="headerlink" title="Syntax 语法"></a>Syntax 语法</h3><p>TypeScript is a language that is a superset of JavaScript: JS syntax is therefore legal TS. Syntax refers to the way we write text to form a program. For example, this code has a syntax error because it’s missing a ):<br><code>Typescript 是 JavaScript 的一个子集：JS 语言的语法是合法的 TS。语法是指我们写程序的方式。例如，这段代码有一个语法错误，因为没有一个）。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let a &#x3D; (4&#39;)&#39; expected.</code></pre><p>TypeScript doesn’t consider any JavaScript code to be an error because of its syntax. This means you can take any working JavaScript code and put it in a TypeScript file without worrying about exactly how it is written.<br><code>TypeScript 不会认为任何 JavaScript 代码是错误的，因为它的语法。这意味着你可以把任何工作的 JavaScript 代码放在 TypeScript 文件中，而不用担心它的语法。</code></p><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>类型</p><p>However, TypeScript is a typed superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about obj.heigth was not a syntax error: it is an error of using some kind of value (a type) in an incorrect way.</p><p><code>然而，TypeScript 是一个类型的超集，意味着它添加了一些规则，如何使用不同类型的值。前面的错误，obj.heigth 是不是一个语法错误？它是一个错误的使用某种类型的值（一个类型）的方式。</code></p><p>As another example, this is JavaScript code that you can run in your browser, and it will log a value:</p><p><code>另一个例子，这是你可以在浏览器中运行的 JavaScript 代码，它会记录一个值：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">console.log(4 &#x2F; []);&#x2F;&#x2F; The right-hand side of an arithmetic operation must be of type &#39;any&#39;, &#39;number&#39;, &#39;bigint&#39; or an enum type.</code></pre><p>It’s possible you really did intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript’s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we’ll learn about settings you can use to configure how strictly TypeScript checks your code.)</p><p><code>之前一个数除以一个数组，可能仅仅是想看下会出现什么，尽管他是一个错误程序。Typescript 的类型检查器是设计的，让正确的程序通过，并且尽可能少的错误。(后面，我们会学习如何配置 TypeScript 检查你的代码。)</code></p><p>If you move some code from a JavaScript file to a TypeScript file, you might see type errors depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we’ll demonstrate how to add various TypeScript syntax to eliminate such errors.</p><p><code>如果你从一个 JavaScript 文件移动到一个 TypeScript 文件，你可能会看到一些类型错误，取决于你的代码如何写。这些可能是代码的正确性，或者 TypeScript 过于保守。本指南中，我们会演示如何添加各种 TypeScript 语法，以便消除这些错误。</code></p><h3 id="Runtime-Behavior"><a href="#Runtime-Behavior" class="headerlink" title="Runtime Behavior"></a>Runtime Behavior</h3><p><code>运行时行为</code><br>TypeScript is also a programming language that preserves the runtime behavior of JavaScript. For example, dividing by zero in JavaScript produces Infinity instead of throwing a runtime exception. As a principle, TypeScript never changes the runtime behavior of JavaScript code.<br>TypeScript 也是一个编程语言，它保留 JavaScript 的运行时行为。例如，在 JavaScript 中除以零会产生无穷，而不是抛出一个运行时异常。作为一个原则，TypeScript 不会改变 JavaScript 代码的运行时行为。<br>This means that if you move code from JavaScript to TypeScript, it is guaranteed to run the same way, even if TypeScript thinks that the code has type errors.<br><code>这意味着如果你从 JavaScript 移动到 TypeScript，它就保证会运行一样的，即使 TypeScript 认为代码有类型错误。</code><br>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.<br><code>保持和 JavaScript 的运行时一致的行为是 TypeScript 的基础承诺，因为它意味着你可以很容易地从 JavaScript 到 TypeScript 过渡，而不用担心潜在的差异，可能会影响你的程序的正常运行。</code></p><h3 id="Erased-Types"><a href="#Erased-Types" class="headerlink" title="Erased Types"></a>Erased Types</h3><p><code>擦除类型</code><br>Roughly speaking, once TypeScript’s compiler is done with checking your code, it erases the types to produce the resulting “compiled” code. This means that once your code is compiled, the resulting plain JS code has no type information.<br><code>换句话说，一旦 TypeScript 编译器完成了检查你的代码，它会擦除类型，生成结果的“编译”代码。这意味着，一旦你的代码编译完成，结果的普通 JS 代码将没有类型信息。</code><br>This also means that TypeScript never changes the behavior of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.<br><code>这意味着，在编译时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。底线是，在运行时，你可能会看到类型错误，但是类型系统本身没有什么影响你的程序的运行。</code><br>Finally, TypeScript doesn’t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there’s no additional TypeScript-specific framework to learn.<br><code>最后，TypeScript 不提供任何额外的运行时库。你的程序将使用和 JavaScript 程序一样的标准库（或外部库），所以没有额外的 TypeScript-特定的框架来学习。</code></p><h3 id="Learning-JavaScript-and-TypeScript"><a href="#Learning-JavaScript-and-TypeScript" class="headerlink" title="Learning JavaScript and TypeScript"></a>Learning JavaScript and TypeScript</h3><p><code>学习 JavaScript 和 TypeScript</code><br>We frequently see the question “Should I learn JavaScript or TypeScript?“.<br><code>我们经常会看到这个问题：“我应该学习 JavaScript 还是 TypeScript？”</code><br>The answer is that you can’t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.<br><code>答案是，你不能学习 TypeScript，除非你学习 JavaScript！TypeScript 和 JavaScript 共享语法和运行时行为，所以你学习 JavaScript 的任何内容都是帮助你学习 TypeScript 的同时。</code><br>There are many, many resources available for programmers to learn JavaScript; you should not ignore these resources if you’re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged javascript than typescript, but all of the javascript questions also apply to TypeScript.<br><code>有很多，很多资源可供程序员学习 JavaScript；如果你写 TypeScript，你不应该忽略这些资源。例如，有 20 倍的 StackOverflow 问题标记了 javascript，而 typescript 问题也适用于 javascript。</code><br>If you find yourself searching for something like “how to sort a list in TypeScript”, remember: TypeScript is JavaScript’s runtime with a compile-time type checker. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that’s great too, but don’t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.<br><code>如果你发现自己在搜索“如何排序一个列表”，记住：TypeScript 是 JavaScript 的运行时，同时还有一个编译时类型检查器。你在 TypeScript 中排序一个列表的方式和在 JavaScript 中一样。如果你找到一个使用 TypeScript 的资源，那也是很好的，但不要限制自己在每天的问题中想要使用 TypeScript-特定的答案来实现运行时任务。</code></p><h3 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h3><p><code>下一步</code><br>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:<br><code>这是一个简单的概述，从这里你可以：</code><br>Learn some of the JavaScript fundamentals, we recommend either:<br><code>学习 JavaScript 基本原理，我们建议：</code><br>Microsoft’s JavaScript Resources or<br>JavaScript guide at the Mozilla Web Docs<br>Continue to TypeScript for JavaScript Programmers<br><code>继续学习 TypeScript 为 JavaScript 程序员</code><br>Read the full Handbook from start to finish (30m)<br><code>阅读全部手册从头到尾（30 分钟）</code>大佬就是大佬 30 分钟能搞定，我估计要搞 3 天，手册这地方内容还是很多的<br>Explore the Playground examples<br><code>探索 Playground 示例</code></p><h2 id="JS-开发者"><a href="#JS-开发者" class="headerlink" title="JS 开发者"></a>JS 开发者</h2><p>TypeScript stands in an unusual relationship to JavaScript. TypeScript offers all of JavaScript’s features, and an additional layer on top of these: TypeScript’s type system.<br><code>TypeScript 与 JavaScript 的关系是不正常的。TypeScript 提供了 JavaScript 的所有功能，并且在这些功能的基础上添加了一层：TypeScript 的类型系统。</code><br>For example, JavaScript provides language primitives like string and number, but it doesn’t check that you’ve consistently assigned these. TypeScript does.<br><code>例如，JavaScript 提供了字符串和数字，但它不检查你是否按照一致的方式分配这些。TypeScript 也提供了。</code><br>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.<br><code>这意味着你的已有的工作中的 JavaScript 代码也是 TypeScript 代码。TypeScript 的主要好处是它可以高亮你的代码中的意外行为，降低 bug 的可能性。</code><br>This tutorial provides a brief overview of TypeScript, focusing on its type system.<br><code>这个教程主要介绍 TypeScript 的类型系统。</code></p><h3 id="Types-by-Inference"><a href="#Types-by-Inference" class="headerlink" title="Types by Inference"></a>Types by Inference</h3><p><code>类型推论</code></p><p>TypeScript knows the JavaScript language and will generate types for you in many cases. For example in creating a variable and assigning it to a particular value, TypeScript will use the value as its type.<br><code>TypeScript 知道 JavaScript 语言，并且会为你生成类型。例如，创建一个变量并为它赋值，TypeScript 就会使用值作为它的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let helloWorld &#x3D; &quot;Hello World&quot;;&#x2F;&#x2F; let helloWorld: string</code></pre><p>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that helloWorld is a string in the above example.<br><code>通过了解 JavaScript 工作方式，TypeScript 可以建立一个接受 JavaScript 代码，但有类型的类型系统。这个类型系统没有需要在你的代码中添加额外的字符来明确类型。这就是 TypeScript 知道 helloWorld 是一个字符串的原因。</code></p><p>You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.<br><code>你可能在 Visual Studio Code 中写了 JavaScript，并且有自动补全。Visual Studio Code 使用 TypeScript 作为后台来更加方便地工作。（原来如此）</code></p><h3 id="Defining-Types"><a href="#Defining-Types" class="headerlink" title="Defining Types"></a>Defining Types</h3><p><code>定义类型</code><br>You can use a wide variety of design patterns in JavaScript. However, some design patterns make it difficult for types to be inferred automatically (for example, patterns that use dynamic programming). To cover these cases, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.<br><code>你可以使用 JavaScript 的许多设计模式。_然而，有些设计模式使得类型无法被自动推断（例如，使用动态规划的模式_。为了解决这些情况，TypeScript 支持一个 JavaScript 的扩展，它提供了给你告诉 TypeScript 的类型应该是什么的地方。</code><br>For example, to create an object with an inferred type which includes name: string and id: number, you can write:<br><code>例如，创建一个具有推断类型的对象，它包含 name: string 和 id: number，你可以这样写：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const user &#x3D; &#123;  name: &quot;Hayes&quot;,  id: 0,&#125;;</code></pre><p>You can explicitly describe this object’s shape using an interface declaration:<br><code>你可以使用接口声明来明确地描述这个对象的形状：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface User &#123;  name: string;  id: number;&#125;</code></pre><p>You can then declare that a JavaScript object conforms to the shape of your new interface by using syntax like : TypeName after a variable declaration:<br><code>你可以使用类型名称来告诉 JavaScript 你的变量是属于哪个类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const user: User &#x3D; &#123;  name: &quot;Hayes&quot;,  id: 0,&#125;;</code></pre><p>If you provide an object that doesn’t match the interface you have provided, TypeScript will warn you:<br><code>如果你提供的对象不符合你提供的接口，TypeScript 就会警告你：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface User &#123;  name: string;  id: number;&#125;const user: User &#x3D; &#123;  username: &quot;Hayes&quot;,  &#x2F;&#x2F; Type &#39;&#123; username: string; id: number; &#125;&#39; is not assignable to type &#39;User&#39;.  &#x2F;&#x2F; Object literal may only specify known properties, and &#39;username&#39; does not exist in type &#39;User&#39;.  id: 0,&#125;;</code></pre><p>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:<br><code>因为 JavaScript 支持类和对象-面向对象编程，所以 TypeScript 也支持。你可以使用接口声明类：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface User &#123;  name: string;  id: number;&#125;class UserAccount &#123;  name: string;  id: number;  constructor(name: string, id: number) &#123;    this.name &#x3D; name;    this.id &#x3D; id;  &#125;&#125;const user: User &#x3D; new UserAccount(&quot;Murphy&quot;, 1);</code></pre><p>You can use interfaces to annotate parameters and return values to functions:<br><code>你可以使用接口来标注函数的参数和返回值：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getAdminUser(): User &#123;  &#x2F;&#x2F;...&#125;function deleteUser(user: User) &#123;  &#x2F;&#x2F; ...&#125;</code></pre><p>There is already a small set of primitive types available in JavaScript: boolean, bigint, null, number, string, symbol, and undefined, which you can use in an interface. TypeScript extends this list with a few more, such as any (allow anything), unknown (ensure someone using this type declares what the type is), never (it’s not possible that this type could happen), and void (a function which returns undefined or has no return value).<br><code>已经有一些简单的原始类型可用于 JavaScript：boolean, bigint, null, number, string, symbol, 和 undefined，你可以在接口中使用它们。TypeScript 将这些类型扩展了一些，如 any（允许任何东西），unknown（确保使用者使用这个类型时声明了它的类型），never（不可能发生的类型），和 void（函数返回 undefined 或没有返回值）。</code></p><p>You’ll see that there are two syntaxes for building types: Interfaces and Types. You should prefer interface. Use type when you need specific features.<br><code>你会看到有两种编写类型的语法：接口和类型。当你需要特定的功能时，你应该使用接口。使用类型时，你需要特定的功能。</code></p><h3 id="Composing-Types"><a href="#Composing-Types" class="headerlink" title="Composing Types"></a>Composing Types</h3><p><code>组合类型</code><br>With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.<br><code>通过使用联合类型，或者通过使用泛型来组合复杂的类型。</code></p><h3 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h3><p><code>联合类型</code><br>With a union, you can declare that a type could be one of many types. For example, you can describe a boolean type as being either true or false:<br><code>通过使用联合类型，你可以声明一个类型是可能是 true 或 false 的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type MyBool &#x3D; true | false;</code></pre><p>Note: If you hover over MyBool above, you’ll see that it is classed as boolean. That’s a property of the Structural Type System. More on this below.<br><code>请注意，如果你将鼠标移到 MyBool 上，你会看到它是一个 boolean 类型。这是结构类型系统的一个属性。更多内容在下面。</code><br>A popular use-case for union types is to describe the set of string or number literals that a value is allowed to be:<br><code>联合类型的一个常见用例是描述一个值可以是一个字符串或数字的集合：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type WindowStates &#x3D; &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;type LockStates &#x3D; &quot;locked&quot; | &quot;unlocked&quot;;type PositiveOddNumbersUnderTen &#x3D; 1 | 3 | 5 | 7 | 9;</code></pre><p>Unions provide a way to handle different types too. For example, you may have a function that takes an array or a string:<br><code>联合类型可以用来处理不同类型的参数。例如，你可以有一个函数可以接受一个数组或字符串类型的参数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getLength(obj: string | string[]) &#123;  return obj.length;&#125;</code></pre><p>To learn the type of a variable, use typeof:<br><code>使用 typeof 来查看一个变量的类型：</code></p><h3 id="Type-Predicate"><a href="#Type-Predicate" class="headerlink" title="Type Predicate"></a>Type Predicate</h3><p><code>类型断言</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">string typeof s &#x3D;&#x3D;&#x3D; &quot;string&quot;number typeof n &#x3D;&#x3D;&#x3D; &quot;number&quot;boolean typeof b &#x3D;&#x3D;&#x3D; &quot;boolean&quot;undefined typeof undefined &#x3D;&#x3D;&#x3D; &quot;undefined&quot;function typeof f &#x3D;&#x3D;&#x3D; &quot;function&quot;array Array.isArray(a)</code></pre><p>For example, you can make a function return different values depending on whether it is passed a string or an array:<br><code>例如，你可以用来返回不同的值，根据传入的参数是字符串还是数组：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function wrapInArray(obj: string | string[]) &#123;  if (typeof obj &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    return [obj];    (parameter) obj: string  &#125;  return obj;&#125;</code></pre><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p><code>泛型</code></p><p>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.<br><code>泛型可以提供类型变量。例如，数组。数组没有泛型可以包含任何东西。数组有泛型可以描述数组中包含的值。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type StringArray &#x3D; Array&lt;string&gt;;type NumberArray &#x3D; Array&lt;number&gt;;type ObjectWithNameArray &#x3D; Array&lt;&#123; name: string &#125;&gt;;You can declare your own types that use generics:</code></pre><p><code>你可以声明自己的类型，使用泛型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Backpack&lt;Type&gt; &#123;  add: (obj: Type) &#x3D;&gt; void;  get: () &#x3D;&gt; Type;&#125;&#x2F;&#x2F; This line is a shortcut to tell TypeScript there is a&#x2F;&#x2F; constant called &#96;backpack&#96;, and to not worry about where it came from.declare const backpack: Backpack&lt;string&gt;;&#x2F;&#x2F; object is a string, because we declared it above as the variable part of Backpack.const object &#x3D; backpack.get();&#x2F;&#x2F; Since the backpack variable is a string, you can&#39;t pass a number to the add function.backpack.add(23);Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.</code></pre><h3 id="Structural-Type-System"><a href="#Structural-Type-System" class="headerlink" title="Structural Type System"></a>Structural Type System</h3><p><code>结构类型系统</code></p><p>One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”.<br><code>结构类型系统的一个核心原则是，类型检查只关注值的形状。这称为“鸭子类型”或“结构类型”。</code><br>In a structural type system, if two objects have the same shape, they are considered to be of the same type.<br><code>在结构类型系统中，如果两个对象具有相同的形状，则被视为相同的类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Point &#123;  x: number;  y: number;&#125;function logPoint(p: Point) &#123;  console.log(&#96;$&#123;p.x&#125;, $&#123;p.y&#125;&#96;);&#125;&#x2F;&#x2F; logs &quot;12, 26&quot;const point &#x3D; &#123; x: 12, y: 26 &#125;;logPoint(point);</code></pre><p>The point variable is never declared to be a Point type. However, TypeScript compares the shape of point to the shape of Point in the type-check. They have the same shape, so the code passes.<br><code>point 变量没有被声明为 Point 类型。但是，TypeScript 对比 point 和 Point 的形状，它们具有相同的形状，所以代码通过。</code><br>The shape-matching only requires a subset of the object’s fields to match.<br><code>结构类型系统只需要对象的一部分字段匹配。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const point3 &#x3D; &#123; x: 12, y: 26, z: 89 &#125;;logPoint(point3); &#x2F;&#x2F; logs &quot;12, 26&quot;const rect &#x3D; &#123; x: 33, y: 3, width: 30, height: 80 &#125;;logPoint(rect); &#x2F;&#x2F; logs &quot;33, 3&quot;const color &#x3D; &#123; hex: &quot;#187ABF&quot; &#125;;logPoint(color);&#x2F;&#x2F; Argument of type &#39;&#123; hex: string; &#125;&#39; is not assignable to parameter of type &#39;Point&#39;.&#x2F;&#x2F; Type &#39;&#123; hex: string; &#125;&#39; is missing the following properties from type &#39;Point&#39;: x, y</code></pre><p>There is no difference between how classes and objects conform to shapes:<br><code>类和对象都遵循结构类型系统。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class VirtualPoint &#123;  x: number;  y: number;  constructor(x: number, y: number) &#123;    this.x &#x3D; x;    this.y &#x3D; y;  &#125;&#125;const newVPoint &#x3D; new VirtualPoint(13, 56);logPoint(newVPoint); &#x2F;&#x2F; logs &quot;13, 56&quot;</code></pre><p>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.<br><code>如果对象或类有所有必要的属性，TypeScript将认为它们匹配，无论实现细节。</code></p><h3 id="Next-Steps-1"><a href="#Next-Steps-1" class="headerlink" title="Next Steps"></a>Next Steps</h3><p><code>下一步</code><br>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:<br><code>从这里开始，你可以：</code><br>Read the full Handbook from start to finish (30m)<br><code>阅读完整手册（30分钟）</code><br>Explore the Playground examples<br><code>探索 Playground 示例</code></p><h2 id="Java-x2F-C-开发"><a href="#Java-x2F-C-开发" class="headerlink" title="Java&#x2F;C#开发"></a>Java&#x2F;C#开发</h2><p>虽然 Java&#x2F;C#也接触过，但这不是我本次的重点，之后会补上</p><h2 id="函数式编程人员"><a href="#函数式编程人员" class="headerlink" title="函数式编程人员"></a>函数式编程人员</h2><p>TypeScript began its life as an attempt to bring traditional object-oriented types to JavaScript so that the programmers at Microsoft could bring traditional object-oriented programs to the web. As it has developed, TypeScript’s type system has evolved to model code written by native JavaScripters. The resulting system is powerful, interesting and messy.<br><code>TypeScript 开始于一个尝试，将传统对象-对象类型的编程语言转换为 JavaScript，这样的编程人员可以将传统的对象-对象编程程序转换为 Web 端的程序。</code><br>This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell’s type system. It also describes unique features of TypeScript’s type system that arise from its modelling of JavaScript code.<br><code>这个介绍是为了工作 Haskell 或 ML 程序员而设计的，它描述了 TypeScript 的类型系统与 Haskell 的类型系统之间的不同。</code><br>This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.<br><code>这个介绍不会讲到对象-对象编程。实际上，在 TypeScript 中的对象-对象编程程序与其他流行语言的对象-对象编程程序相似。</code></p><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><p><code>先决条件</code><br>In this introduction, I assume you know the following:<br><code>在这个介绍中，我假设你知道了以下内容：</code><br>How to program in JavaScript, the good parts.<br><code>如何编写 JavaScript 程序，好的部分。</code><br>Type syntax of a C-descended language.<br><code>C-descended 语言的类型语法。</code><br>If you need to learn the good parts of JavaScript, read JavaScript: The Good Parts. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. R4RS Scheme is a good example.<br><code>如果你需要学习 JavaScript，请阅读 JavaScript：The Good Parts。如果你知道如何编写基于值词法的词法作用域语言，并且拥有大量可变性和不多的其他特性，你可以跳过这本书。R4RS Scheme 是一个好例子。</code><br>The C++ Programming Language is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: x: string instead of string x.<br><code>C++ 编程语言是一个好的地方学习 C-style 类型语法。</code></p><h3 id="Concepts-not-in-Haskell"><a href="#Concepts-not-in-Haskell" class="headerlink" title="Concepts not in Haskell"></a>Concepts not in Haskell</h3><p><code>在 Haskell 中不存在的概念</code></p><h3 id="Built-in-types"><a href="#Built-in-types" class="headerlink" title="Built-in types"></a>Built-in types</h3><p><code>内置类型</code><br>JavaScript defines 8 built-in types:<br><code>JavaScript 定义了 8 个内置类型：</code> <strong>这里是包装类型</strong><br>Type Explanation<br><code>类型说明</code><br>Number a double-precision IEEE 754 floating point.<br><code>数字，双精度 IEEE 754 浮点数。</code><br>String an immutable UTF-16 string.<br><code>字符串，不可变的 UTF-16 字符串。</code><br>BigInt integers in the arbitrary precision format.<br><code>大整数，任意精度格式。</code><br>Boolean true and false.<br><code>布尔值，true 和 false。</code><br>Symbol a unique value usually used as a key.<br><code>符号，通常用作键。</code><br>Null equivalent to the unit type.<br><code>空，等同于单元类型。</code><br>Undefined also equivalent to the unit type.<br><code>未定义，也等同于单元类型。</code><br>Object similar to records.<br><code>对象，类似于记录。</code><br>See the MDN page for more detail.<br><code>参见 MDN 页面。</code></p><p>TypeScript has corresponding primitive types for the built-in types:<br><code>TypeScript 有对应的内置类型的原始类型：</code><br>number<br>string<br>bigint<br>boolean<br>symbol<br>null<br>undefined<br>object</p><h3 id="Other-important-TypeScript-types"><a href="#Other-important-TypeScript-types" class="headerlink" title="Other important TypeScript types"></a>Other important TypeScript types</h3><p><code>其他重要的 TypeScript 类型</code><br>Type Explanation<br><code>类型说明</code><br>unknown the top type.<br><code>未知类型，顶级类型。</code><br>never the bottom type.<br><code>永远不会是类型，底级类型。</code><br>object literal eg { property: Type }<br><code>对象字面量，例如 &#123; property: 类型 &#125;。</code><br>void a subtype of undefined intended for use as a return type.<br><code>void 类型，作为返回类型。</code><br>T[] mutable arrays, also written Array<T><br><code>T[] 可变数组，也称为 Array&lt;T&gt;。</code><br>[T, T] tuples, which are fixed-length but mutable<br><code>[T, T] 元组，固定长度但可变。</code><br>(t: T) &#x3D;&gt; U functions<br><code>(t: T) =&gt; U 函数。</code><br>Notes:<br><code>注意：</code><br>Function syntax includes parameter names. This is pretty hard to get used to!<br><code>函数语法包括参数名。这很难使用！</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let fst: (a: any, b: any) &#x3D;&gt; any &#x3D; (a, b) &#x3D;&gt; a;&#x2F;&#x2F; or more precisely: 或者更准确地：let fst: &lt;T, U&gt;(a: T, b: U) &#x3D;&gt; T &#x3D; (a, b) &#x3D;&gt; a;&#x2F;&#x2F; Object literal type syntax closely mirrors object literal value syntax:&#x2F;&#x2F; 模式匹配字面量类型语法与对象字面量值语法类似。let o: &#123; n: number; xs: object[] &#125; &#x3D; &#123; n: 1, xs: [] &#125;;[T, T] is a subtype of T[].&#x2F;&#x2F; This is different than Haskell, where tuples are not related to lists.&#x2F;&#x2F; 此外，这是不同于 Haskell 的，元组不和列表相关。</code></pre><h3 id="Boxed-types"><a href="#Boxed-types" class="headerlink" title="Boxed types"></a>Boxed types</h3><p><code>包装类型</code><br>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type number and the boxed type Number. The boxed types are rarely needed, since their methods return primitives.<br><code>JavaScript 有对应的包装类型，包含与这些类型相关的方法。</code></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">(1).toExponential();&#x2F;&#x2F; equivalent toNumber.prototype.toExponential.call(1);</code></pre><p>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.<br><code>调用方法在数字字面量上需要在括号中，以帮助解析器。</code></p><h3 id="Gradual-typing"><a href="#Gradual-typing" class="headerlink" title="Gradual typing"></a>Gradual typing</h3><p><code>渐进类型</code><br>TypeScript uses the type any whenever it can’t tell what the type of an expression should be. Compared to Dynamic, calling any a type is an overstatement. It just turns off the type checker wherever it appears. For example, you can push any value into an any[] without marking the value in any way:<br><code>TypeScript 使用 any 时，当它不能确定表达式的类型时。</code><br>&#x2F;&#x2F; with “noImplicitAny”: false in tsconfig.json, anys: any[]<br><code>在 tsconfig.json 中，加入 &quot;noImplicitAny&quot;: false 可以禁用 anys: any[]。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const anys &#x3D; [];anys.push(1);anys.push(&quot;oh no&quot;);anys.push(&#123; anything: &quot;goes&quot; &#125;);</code></pre><p>And you can use an expression of type any anywhere:<br><code>你可以在任何地方使用 any 类型表达式。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">anys.map(anys[1]); &#x2F;&#x2F; oh no, &quot;oh no&quot; is not a function</code></pre><p>any is contagious, too — if you initialize a variable with an expression of type any, the variable has type any too.<br><code>any 类型是传播的，</code> 如果初始化一个变量为 any 类型，变量的类型也是 any。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let sepsis &#x3D; anys[0] + anys[1]; &#x2F;&#x2F; this could mean anything</code></pre><p>To get an error when TypeScript produces an any, use “noImplicitAny”: true, or “strict”: true in tsconfig.json.<br><code>为了在 TypeScript 生成 any 时得到错误提示，使用 &quot;noImplicitAny&quot;: true 或 &quot;strict&quot;: true 在 tsconfig.json 中。</code></p><h3 id="Structural-typing"><a href="#Structural-typing" class="headerlink" title="Structural typing"></a>Structural typing</h3><p><code>结构类型</code><br>Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:<br><code>结构性类型是大多数函数编程程序员熟悉的概念，尽管 Haskell 和大多数 ML 不是结构性类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; @strict: falselet o &#x3D; &#123; x: &quot;hi&quot;, extra: 1 &#125;; &#x2F;&#x2F; oklet o2: &#123; x: string &#125; &#x3D; o; &#x2F;&#x2F; ok</code></pre><p>Here, the object literal { x: “hi”, extra: 1 } has a matching literal type { x: string, extra: number }. That type is assignable to { x: string } since it has all the required properties and those properties have assignable types. The extra property doesn’t prevent assignment, it just makes it a subtype of { x: string }.<br><code>这里，对象字面量 &#123; x: &quot;hi&quot;, extra: 1 &#125; 有一个匹配的字面量类型 &#123; x: string, extra: number &#125;。</code><br>Named types just give a name to a type; for assignability purposes there’s no difference between the type alias One and the interface type Two below. They both have a property p: string. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)<br><code>命名类型只是给一个类型命名；用于类型赋值的目的不同于接口下面的类型别名和类型参数，但是它们都有属性 p: string。 (类型别名和接口的递归定义和类型参数有所不同。)</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type One &#x3D; &#123; p: string &#125;;interface Two &#123;  p: string;&#125;class Three &#123;  p &#x3D; &quot;Hello&quot;;&#125;let x: One &#x3D; &#123; p: &quot;hi&quot; &#125;;let two: Two &#x3D; x;two &#x3D; new Three();</code></pre><h3 id="Unions-1"><a href="#Unions-1" class="headerlink" title="Unions"></a>Unions</h3><p><code>联合类型</code></p><p>In TypeScript, union types are untagged. In other words, they are not discriminated unions like data in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.<br>在 TypeScript 中，联合类型是无标签的。<code> 在其他语言中，联合类型是标签化的。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function start(  arg: string | string[] | (() &#x3D;&gt; string) | &#123; s: string &#125;): string &#123;  &#x2F;&#x2F; this is super common in JavaScript  if (typeof arg &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;    return commonCase(arg);  &#125; else if (Array.isArray(arg)) &#123;    return arg.map(commonCase).join(&quot;,&quot;);  &#125; else if (typeof arg &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;    return commonCase(arg());  &#125; else &#123;    return commonCase(arg.s);  &#125;  function commonCase(s: string): string &#123;    &#x2F;&#x2F; finally, just convert a string to another string    return s;  &#125;&#125;</code></pre><p>string, Array and Function have built-in type predicates, conveniently leaving the object type for the else branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it’s best to build only discriminated unions.<br><code>字符串、数组和函数有内置类型推断，</code> 可以在 else 分支中推断出对象类型。<code>The following types have built-in predicates:</code>下面的类型有内置推断：<code>Type Predicate</code>类型推断&#96;</p><p>string typeof s &#x3D;&#x3D;&#x3D; “string”<br>number typeof n &#x3D;&#x3D;&#x3D; “number”<br>bigint typeof m &#x3D;&#x3D;&#x3D; “bigint”<br>boolean typeof b &#x3D;&#x3D;&#x3D; “boolean”<br>symbol typeof g &#x3D;&#x3D;&#x3D; “symbol”<br>undefined typeof undefined &#x3D;&#x3D;&#x3D; “undefined”<br>function typeof f &#x3D;&#x3D;&#x3D; “function”<br>array Array.isArray(a)<br>object typeof o &#x3D;&#x3D;&#x3D; “object”</p><p>Note that functions and arrays are objects at runtime, but have their own predicates.<br><code>函数和数组在运行时是对象，</code> 但是有自己的推断。&#96;</p><h3 id="Intersections"><a href="#Intersections" class="headerlink" title="Intersections"></a>Intersections</h3><p><code>交叉类型</code></p><p>In addition to unions, TypeScript also has intersections:<br><code>在 TypeScript 中，还有交叉类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Combined &#x3D; &#123; a: number &#125; &amp; &#123; b: string &#125;;type Conflicting &#x3D; &#123; a: number &#125; &amp; &#123; a: string &#125;;</code></pre><p>Combined has two properties, a and b, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so Conflicting.a: number &amp; string.<br><code>Combined 有两个属性，a 和 b， 如果写成一个对象字面量类型， 则 a 和 b 都是 number 和 string 类型。</code></p><h3 id="Unit-types"><a href="#Unit-types" class="headerlink" title="Unit types"></a>Unit types</h3><p><code>单元类型</code><br>Unit types are subtypes of primitive types that contain exactly one primitive value. For example, the string “foo” has the type “foo”. Since JavaScript has no built-in enums, it is common to use a set of well-known strings instead. Unions of string literal types allow TypeScript to type this pattern:<br><code>单元类型是原始类型的子类型， 它们包含一个原始值。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare function pad(s: string, n: number, direction: &quot;left&quot; | &quot;right&quot;): string;pad(&quot;hi&quot;, 10, &quot;left&quot;);</code></pre><p>When needed, the compiler widens — converts to a supertype — the unit type to the primitive type, such as “foo” to string. This happens when using mutability, which can hamper some uses of mutable variables:<br><code>当需要时，编译器会扩展， 将单元类型转换为原始类型， 例如 &quot;foo&quot; 转换为 string。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let s &#x3D; &quot;right&quot;;pad(&quot;hi&quot;, 10, s); &#x2F;&#x2F; error: &#39;string&#39; is not assignable to &#39;&quot;left&quot; | &quot;right&quot;&#39;Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot;&#39;.</code></pre><p>Here’s how the error happens:<br><code>这里有一个错误：</code><br>“right”: “right”</p><p>s: string because “right” widens to string on assignment to a mutable variable.<br>string is not assignable to “left” | “right”</p><p>You can work around this with a type annotation for s, but that in turn prevents assignments to s of variables that are not of type “left” | “right”.<br><code>你可以使用类型注解来解决这个问题， 但是这会导致 s 的赋值， 只能赋值给 &quot;left&quot; | &quot;right&quot; 类型的变量。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let s: &quot;left&quot; | &quot;right&quot; &#x3D; &quot;right&quot;;pad(&quot;hi&quot;, 10, s);</code></pre><h3 id="Concepts-similar-to-Haskell"><a href="#Concepts-similar-to-Haskell" class="headerlink" title="Concepts similar to Haskell"></a>Concepts similar to Haskell</h3><p><code>与 Haskell 类似的概念</code></p><h3 id="Contextual-typing"><a href="#Contextual-typing" class="headerlink" title="Contextual typing"></a>Contextual typing</h3><p><code>上下文类型</code></p><p>TypeScript has some obvious places where it can infer types, like variable declarations:<br><code>TypeScript 有一些明显的地方， 可以推断类型， 如变量声明。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let s &#x3D; &quot;I&#39;m a string!&quot;;</code></pre><p>But it also infers types in a few other places that you may not expect if you’ve worked with other C-syntax languages:<br><code>TypeScript 也可以推断在某些地方没有声明类型的情况下， 如果你已经使用其他 C-语言语法：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare function map&lt;T, U&gt;(f: (t: T) &#x3D;&gt; U, ts: T[]): U[];let sns &#x3D; map((n) &#x3D;&gt; n.toString(), [1, 2, 3]);</code></pre><p>Here, n: number in this example also, despite the fact that T and U have not been inferred before the call. In fact, after [1,2,3] has been used to infer T&#x3D;number, the return type of n &#x3D;&gt; n.toString() is used to infer U&#x3D;string, causing sns to have the type string[].<br><code>这里， n: number 在这个例子中也， 即使在调用之前没有推断 T 和 U 的类型。 在实际上， 在 [1,2,3] 被用来推断 T=number 的时候， n =&gt; n.toString() 的返回类型会被用来推断 U=string， 导致 sns 的类型为 string[]。</code><br>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare map with the array first:<br><code>注意， 推断会工作在任何顺序， 但是 intellisense 只会从左到右， 因此 TypeScript 只会优先声明 map 函数， 先声明数组。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare function map&lt;T, U&gt;(ts: T[], f: (t: T) &#x3D;&gt; U): U[];</code></pre><p>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as string or number. And it can infer return types from context:<br><code>上下文类型也可以递归地通过对象字面量， 和单元类型， 如果没有声明类型， 则会被推断为 string 或 number。 并且可以从上下文中推断函数的返回类型。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare function run&lt;T&gt;(thunk: (t: T) &#x3D;&gt; void): T;let i: &#123; inference: string &#125; &#x3D; run((o) &#x3D;&gt; &#123;  o.inference &#x3D; &quot;INSERT STATE HERE&quot;;&#125;);</code></pre><p>The type of o is determined to be { inference: string } because<br><code>这个 o 的类型是由 run 函数的参数类型决定的， 因为</code><br>Declaration initializers are contextually typed by the declaration’s type: { inference: string }.<br><code>声明初始值是由声明的类型决定的</code><br>The return type of a call uses the contextual type for inferences, so the compiler infers that T&#x3D;{ inference: string }.<br><code>调用的返回类型是由上下文类型决定的， 因此编译器会推断 T=&#123; inference: string &#125;。</code><br>Arrow functions use the contextual type to type their parameters, so the compiler gives o: { inference: string }.<br><code>箭头函数使用上下文类型来类型参数， 因此编译器会给 o: &#123; inference: string &#125;。</code><br>And it does so while you are typing, so that after typing o., you get completions for the property inference, along with any other properties you’d have in a real program.<br><code>而且这样， 在你输入 o. 的时候， 你会得到 inference 的属性的完整补全， 同时也会有其他实际程序中的属性。</code><br>Altogether, this feature can make TypeScript’s inference look a bit like a unifying type inference engine, but it is not.<br><code>这个功能可以让 TypeScript 的推断看起来像一个统一类型推断引擎， 但是它不是。</code></p><h3 id="Type-aliases"><a href="#Type-aliases" class="headerlink" title="Type aliases"></a>Type aliases</h3><p><code>类型别名</code></p><p>Type aliases are mere aliases, just like type in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.<br><code>类型别名是类型别名， 像 Haskell 中的类型。 编译器会尝试使用别名名称在源代码中使用， 但不一定成功。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Size &#x3D; [number, number];let x: Size &#x3D; [101.1, 999.9];</code></pre><p>The closest equivalent to newtype is a tagged intersection:<br><code>最接近的等价是标记交集：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type FString &#x3D; string &amp; &#123; **compileTimeOnly: any &#125;;</code></pre><p>An FString is just like a normal string, except that the compiler thinks it has a property named **compileTimeOnly that doesn’t actually exist. This means that FString can still be assigned to string, but not the other way round.<br><code>FString 是一个普通字符串， 但是编译器认为它有一个名为 **compileTimeOnly 的属性， 这个属性并不存在。 这意味着 FString 仍然可以被赋值给 string， 但是不能被赋值给其他类型。</code></p><h3 id="Discriminated-Unions"><a href="#Discriminated-Unions" class="headerlink" title="Discriminated Unions"></a>Discriminated Unions</h3><p><code>可识别联合</code></p><p>The closest equivalent to data is a union of types with discriminant properties, normally called discriminated unions in TypeScript:<br><code>最接近的等价是数据的一个联合类型， 常见的是 TypeScript 中的分层联合：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Shape &#x3D;  | &#123; kind: &quot;circle&quot;; radius: number &#125;  | &#123; kind: &quot;square&quot;; x: number &#125;  | &#123; kind: &quot;triangle&quot;; x: number; y: number &#125;;</code></pre><p>Unlike Haskell, the tag, or discriminant, is just a property in each object type. Each variant has an identical property with a different unit type. This is still a normal union type; the leading | is an optional part of the union type syntax. You can discriminate the members of the union using normal JavaScript code:<br><code>与 Haskell 不同， 标记， 或者说分层联合的标记， 在每个对象类型中都是一个属性。 每个变体都有一个相同的属性， 并且它的单元类型不同。 这仍然是一个联合类型； 前面的 | 是联合类型的可选部分。 你可以使用普通的 JavaScript 代码来区分联合成员：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Shape &#x3D;| &#123; kind: &quot;circle&quot;; radius: number &#125;| &#123; kind: &quot;square&quot;; x: number &#125;| &#123; kind: &quot;triangle&quot;; x: number; y: number &#125;;function area(s: Shape) &#123;  if (s.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return Math.PI _ s.radius _ s.radius;  &#125; else if (s.kind &#x3D;&#x3D;&#x3D; &quot;square&quot;) &#123;    return s.x _ s.x;  &#125; else &#123;  r eturn (s.x _ s.y) &#x2F; 2;  &#125;&#125;</code></pre><p>Note that the return type of area is inferred to be number because TypeScript knows the function is total. If some variant is not covered, the return type of area will be number | undefined instead.<br><code>注意， area 的返回类型被推断为 number， 因为 TypeScript 知道函数是完全的。 如果某个变体没有被覆盖， area 的返回类型将会是 number | undefined。</code><br>Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:<br><code>与 Haskell 不同， 共有属性在联合中显示， 你可以使用有效的方式来区分联合成员：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function height(s: Shape) &#123;  if (s.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;    return 2 \* s.radius;  &#125; else &#123;  &#x2F;&#x2F; s.kind: &quot;square&quot; | &quot;triangle&quot;    return s.x;  &#125;&#125;</code></pre><h3 id="Type-Parameters"><a href="#Type-Parameters" class="headerlink" title="Type Parameters"></a>Type Parameters</h3><p><code>参数类型</code><br>Like most C-descended languages, TypeScript requires declaration of type parameters:<br><code>类似于大多数 C-descended 语言， TypeScript 需要声明类型参数：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function liftArray&lt;T&gt;(t: T): Array&lt;T&gt; &#123;  return [t];&#125;</code></pre><p>There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:<br><code>没有要求， 但是类型参数是一个惯例， 单大写字母。 类型参数可以被限制为一个类型， 这个类型行为类似于类型约束：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function firstish&lt;T extends &#123; length: number &#125;&gt;(t1: T, t2: T): T &#123;  return t1.length &gt; t2.length ? t1 : t2;&#125;</code></pre><p>TypeScript can usually infer type arguments from a call based on the type of the arguments, so type arguments are usually not needed.<br><code>TypeScript 可以通过调用参数的类型推断出类型参数， 因此通常不需要指定类型参数。</code><br>Because TypeScript is structural, it doesn’t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to propagate type information, such as constraining parameters to be the same type:<br><code>TypeScript 是结构性的， 不需要类型参数， 因为它们不需要使一个函数多态。 类型参数只是用来传递类型信息， 如限制参数为相同类型：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function length&lt;T extends ArrayLike&lt;unknown&gt;&gt;(t: T): number &#123;&#125;function length(t: ArrayLike&lt;unknown&gt;): number &#123;&#125;</code></pre><p>In the first length, T is not necessary; notice that it’s only referenced once, so it’s not being used to constrain the type of the return value or other parameters.<br><code>在第一个 length， T 没有必要； 可以注意， 它只被引用一次， 因此它不会被用来限制返回值或其他参数的类型。</code></p><h3 id="Higher-kinded-types"><a href="#Higher-kinded-types" class="headerlink" title="Higher-kinded types"></a>Higher-kinded types</h3><p><code>高阶类型</code></p><p>TypeScript does not have higher kinded types, so the following is not legal:<br><code>TypeScript 不支持高阶类型， 因此下面的不合法：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function length&lt;T extends ArrayLike&lt;unknown&gt;, U&gt;(m: T&lt;U&gt;) &#123;&#125;</code></pre><h3 id="Point-free-programming"><a href="#Point-free-programming" class="headerlink" title="Point-free programming"></a>Point-free programming</h3><p>Point-free programming — heavy use of currying and function composition — is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you’ll end up specifying type parameters instead of value parameters. The result is so verbose that it’s usually better to avoid point-free programming.<br><code>点-free 编程 — 重量级的使用 curry 和函数组合 — 在 JavaScript 中可以， 但是可能会很多。 在 TypeScript 中， 类型推断对点-free 编程失败， 因此你会指定类型参数而不是值参数。 结果是这样的多， 因此比较适合避免点-free 编程。</code></p><h3 id="Module-system"><a href="#Module-system" class="headerlink" title="Module system"></a>Module system</h3><p><code>模块系统</code></p><p>JavaScript’s modern module syntax is a bit like Haskell’s, except that any file with import or export is implicitly a module:<br><code>JavaScript 的现代模块语法和 Haskell 类似， 只是任何带有 import 或 export 的文件都是隐式的模块：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import &#123; value, Type &#125; from &quot;npm-package&quot;;import &#123; other, Types &#125; from &quot;.&#x2F;local-package&quot;;import \* as prefix from &quot;..&#x2F;lib&#x2F;third-package&quot;;</code></pre><p>You can also import commonjs modules — modules written using node.js’ module system:<br><code>你也可以导入 commonjs 模块 — 使用 node.js 的模块系统写的模块：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import f &#x3D; require(&quot;single-function-package&quot;);</code></pre><p>You can export with an export list:<br><code>你可以使用 export 列表导出：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export &#123; f &#125;;function f() &#123;  return g();&#125;function g() &#123;&#125; &#x2F;&#x2F; g is not exported</code></pre><p>Or by marking each export individually:<br><code>或者通过单独标记每个导出：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export function f &#123; return g() &#125;function g() &#123; &#125;</code></pre><p>The latter style is more common but both are allowed, even in the same file.<br><code>后者更常见， 但是都可以， 即使在同一个文件中。</code></p><h3 id="readonly-and-const"><a href="#readonly-and-const" class="headerlink" title="readonly and const"></a>readonly and const</h3><p>In JavaScript, mutability is the default, although it allows variable declarations with const to declare that the reference is immutable. The referent is still mutable:<br><code>在 JavaScript 中， 可变性是默认的， 即使它允许使用 const 声明的变量声明引用是不可变的。 引用仍然可变：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const a &#x3D; [1, 2, 3];a.push(102); &#x2F;&#x2F; ):a[0] &#x3D; 101; &#x2F;&#x2F; D:</code></pre><p>TypeScript additionally has a readonly modifier for properties.<br><code>TypeScript 还有一个 readonly 属性修饰符。</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Rx &#123;  readonly x: number;&#125;let rx: Rx &#x3D; &#123; x: 1 &#125;;rx.x &#x3D; 12; &#x2F;&#x2F; error</code></pre><p>It also ships with a mapped type Readonly<T> that makes all properties readonly:<br><code>它还有一个映射类型 Readonly&lt;T&gt;， 让所有属性都变成只读的：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface X &#123;  x: number;&#125;let rx: Readonly&lt;X&gt; &#x3D; &#123; x: 1 &#125;;rx.x &#x3D; 12; &#x2F;&#x2F; error</code></pre><p>And it has a specific ReadonlyArray<T> type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:<br><code>它还有一个特殊的 ReadonlyArray&lt;T&gt; 类型， 去除了侧影响的方法和防止写入数组索引， 同时还有这种类型的特殊语法：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let a: ReadonlyArray&lt;number&gt; &#x3D; [1, 2, 3];let b: readonly number[] &#x3D; [1, 2, 3];a.push(102); &#x2F;&#x2F; errorb[0] &#x3D; 101; &#x2F;&#x2F; error</code></pre><p>You can also use a const-assertion, which operates on arrays and object literals:<br><code>你也可以使用 const 断言， 它操作了数组和对象字面量：</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let a &#x3D; [1, 2, 3] as const;a.push(102); &#x2F;&#x2F; errora[0] &#x3D; 101; &#x2F;&#x2F; error</code></pre><p>However, none of these options are the default, so they are not consistently used in TypeScript code.<br><code>但是， 没有这些选项是默认的， 因此它们不是一致地使用在 TypeScript 代码中。</code></p><h3 id="Next-Steps-2"><a href="#Next-Steps-2" class="headerlink" title="Next Steps"></a>Next Steps</h3><p><code>下一步</code></p><p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:<br><code>此文档是日常代码中的语法和类型一个高级的概览， 从这里你应该：</code><br>Read the full Handbook from start to finish (30m)<br><code>阅读完整的手册（30分钟）</code><br>Explore the Playground examples<br><code>探索 Playground 示例</code></p><h2 id="5-分钟内了解-Typescript"><a href="#5-分钟内了解-Typescript" class="headerlink" title="5 分钟内了解 Typescript"></a>5 分钟内了解 Typescript</h2><p>跳过，这部分比较简单，看原文吧，之后重点放到手册里。</p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https</title>
      <link href="//post/2022-06-05https.html"/>
      <url>//post/2022-06-05https.html</url>
      
        <content type="html"><![CDATA[<h2 id="吐槽掘金"><a href="#吐槽掘金" class="headerlink" title="吐槽掘金"></a>吐槽掘金</h2><ul><li>后台有定时器在运行，一直发送请求，打开多个 web 标签页面，cpu 直接飙升到 100% +，鉴于掘金太卡，所以转载</li></ul><h2 id="为什么要有-HTTPS"><a href="#为什么要有-HTTPS" class="headerlink" title="为什么要有 HTTPS"></a>为什么要有 HTTPS</h2><p>在 HTTPS 出现之前，所有请求都是以明文方式送出的，那么如果有人在传输途中偷听或者抓包的话，你的所有通信内容都会泄漏。<br>比较安全的方法是将通信内容加密在发送给对方。加密方法有两种，对称加密和非对称加密。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ul><li>对称加密指的是加密和解密用同一个密钥。</li><li>但是在通信之前，客户端和服务端是不会有这样同一把密钥的。需要其中一方将密钥发送给对方。</li><li>在整个传输过程没有任何验证操作，所以黑客也可以截取到这把密钥从而破译出加密的内容。<br>所以纯对称加密是不安全的。</li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密指的是加密和解密用不同的密钥。可以是用私钥加密，公钥解密，也可以是用公钥加密，私钥解密。<br>但是会有这种情况。</p><ul><li>服务端拥有私钥和公钥，将公钥发给客户端。<br>既然客户端可以获得公钥，黑客也可以获得公钥。那么服务端发送给客户端的所有内容黑客也是可以解读的。</li><li>客户端用公钥加密发送给服务端不受影响，因为黑客手上没有服务器的私钥。<br>所以纯非对称加密也是不安全的。</li></ul><h2 id="传输密钥的过程"><a href="#传输密钥的过程" class="headerlink" title="传输密钥的过程"></a>传输密钥的过程</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/17217c84d03a66a9~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="图解传输密钥的过程"><a href="#图解传输密钥的过程" class="headerlink" title="图解传输密钥的过程"></a>图解传输密钥的过程</h2><p>HTTPS 采用对称加密来加密通信内容，所用的密钥称为 A。用非对称加密来加密密钥 A 再发送给对方（有点绕）。只要密钥 A 不落入他人手中，那传输的数据就不会被别人破译。</p><p>那么问题来了，要如何安全的将这把密钥送到对方手上呢？</p><p>我们来看密钥的传输过程<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/17218630ec9be8b3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="为什么-HTTPS-是可靠的？"><a href="#为什么-HTTPS-是可靠的？" class="headerlink" title="为什么 HTTPS 是可靠的？"></a>为什么 HTTPS 是可靠的？</h2><p>HTTPS 是可靠的，因为它解决了三个问题。</p><ol><li>加密通信，即使别人获取到了信息也没法复原成原来的信息。</li><li>防止中间人攻击。黑客没法冒充服务端。因为在第 2 步，服务端给了客户端一个 CA 证书。</li></ol><ul><li>如果客户端验证了这个证书，说明这个证书和公钥是由服务端发来的且真实可靠。</li><li>如果客户端验证不了这个证书，就说明这个证书不可靠，有可能是假的。</li></ul><ol start="3"><li>CA 证书的公信力<br>CA 证书需要由公司或者个人发出申请，再通过邮箱验证等方法验证域名存在。避免了黑客冒充网站获取证书的可能。<br>在技术层面上，CA 机构的公钥是写在操作系统或者浏览器里的。只有用 CA 机构的私钥加密的内容才能完成解密。确保了证书的确是 CA 机构发行的。</li></ol><h2 id="密钥的作用"><a href="#密钥的作用" class="headerlink" title="密钥的作用"></a>密钥的作用</h2><p>最后让我们再来回顾一下每一把密钥的作用<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/17217e2ee1709bcd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="HTTPS一定安全吗"><a href="#HTTPS一定安全吗" class="headerlink" title="HTTPS一定安全吗"></a>HTTPS一定安全吗</h2><p>非全站HTTPS并不安全</p><p>登录页面支持HTTPS不就行了，首页又没有涉及账户信息<br>其实这是非常不安全的行为，黑客会利用这一点进行攻击，一般是以下流程：</p><p>1.用户在首页点击「登录」，页面跳转到有htps的网银页面，但此时由于首页是htp请求，所以是明文的，这就会被黑客劫持<br>2.黑客劫持用户的跳转请求，将https网银页面地址转换为http的地址再发送给银行</p><p>用户&lt;&#x3D;&#x3D;HTTP&#x3D;&#x3D;&gt;黑客&lt;&#x3D;&#x3D;HTTPS&#x3D;&#x3D;&gt;银行</p><p>1.此时如果用户输入账户信息，那么会被中间的黑客获取，此时的账号密码就被泄露了</p><p>好在是银行的网银页面,只支持htps,因此上述攻击暂时是无效的</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1w4411m7GL">【web 安全 3】【硬核】HTTPS 原理全解析</a></p><p>作者：站在书脊之上<br>链接：<a href="https://juejin.cn/post/6844904160089882631">https://juejin.cn/post/6844904160089882631</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-7 最佳实践</title>
      <link href="//post/2022-06-02vue-7.html"/>
      <url>//post/2022-06-02vue-7.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602200611.webp"></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><img src="http://t-blog-images.aijs.top/img/20220602200621.webp"></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><img src="http://t-blog-images.aijs.top/img/20220602200638.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-8 typescript</title>
      <link href="//post/2022-06-02vue-8.html"/>
      <url>//post/2022-06-02vue-8.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602201222.webp"></p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a>组合式</h3><p><img src="http://t-blog-images.aijs.top/img/20220602201022.webp"></p><h3 id="选项式"><a href="#选项式" class="headerlink" title="选项式"></a>选项式</h3><p><img src="http://t-blog-images.aijs.top/img/20220602201032.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-6 升级规模</title>
      <link href="//post/2022-06-02vue-6.html"/>
      <url>//post/2022-06-02vue-6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602200123.webp"></p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p><img src="http://t-blog-images.aijs.top/img/20220602200102.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-5 内置组件</title>
      <link href="//post/2022-06-02vue-5.html"/>
      <url>//post/2022-06-02vue-5.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602195846.webp"></p><h2 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h2><p><img src="http://t-blog-images.aijs.top/img/20220602195059.webp"></p><h3 id="teleport·传送门"><a href="#teleport·传送门" class="headerlink" title="teleport·传送门"></a>teleport·传送门</h3><p><img src="http://t-blog-images.aijs.top/img/20220602195124.webp"></p><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p><img src="http://t-blog-images.aijs.top/img/20220602195153.webp"></p><h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><p> <img src="http://t-blog-images.aijs.top/img/20220602195252.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-4 可重用性</title>
      <link href="//post/2022-06-02vue-4.html"/>
      <url>//post/2022-06-02vue-4.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602185624.webp"></p><h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p><img src="http://t-blog-images.aijs.top/img/20220602193659.webp"></p><h3 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193738.webp"></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193751.webp"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-3 深入组件</title>
      <link href="//post/2022-06-02vue-3.html"/>
      <url>//post/2022-06-02vue-3.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602185624.webp"></p><h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><p><img src="http://t-blog-images.aijs.top/img/20220602193405.webp"></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193158.webp"></p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193205.webp"></p><h3 id="透传-Attribute"><a href="#透传-Attribute" class="headerlink" title="透传 Attribute"></a>透传 Attribute</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193213.webp"></p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193228.webp"></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193235.webp"></p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193244.webp"></p><h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p><img src="http://t-blog-images.aijs.top/img/20220602193659.webp"></p><h3 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193738.webp"></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><img src="http://t-blog-images.aijs.top/img/20220602193751.webp"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-2 v3</title>
      <link href="//post/2022-06-02vue-2.html"/>
      <url>//post/2022-06-02vue-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><p><img src="http://t-blog-images.aijs.top/img/20220602191916.webp"></p><h3 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192006.webp"></p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192306.webp"></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192315.webp"></p><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192323.webp"></p><h3 id="模版-ref"><a href="#模版-ref" class="headerlink" title="模版 ref"></a>模版 ref</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192333.webp"></p><h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><p><img src="http://t-blog-images.aijs.top/img/20220602192342.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-1 基础</title>
      <link href="//post/2022-06-02vue-1.html"/>
      <url>//post/2022-06-02vue-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><h2 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h2><p><img src="http://t-blog-images.aijs.top/img/20220602190150.webp"></p><h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><!-- ![](http://t-blog-images.aijs.top/img/20220602190219.webp) --><p><img src="http://t-blog-images.aijs.top/img/20220602191619.webp"></p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><!-- ![](http://t-blog-images.aijs.top/img/20220602190321.webp) --><p><img src="http://t-blog-images.aijs.top/img/20220602191251.webp"></p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p><img src="http://t-blog-images.aijs.top/img/20220602190525.webp"></p><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p><img src="http://t-blog-images.aijs.top/img/20220602190828.webp"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><img src="http://t-blog-images.aijs.top/img/20220602191049.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再学Vue3-0 概览</title>
      <link href="//post/2022-06-02vue-0.html"/>
      <url>//post/2022-06-02vue-0.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><ul><li>使用 proxy 重写了 vue2，并增加了组合式 api</li><li>以下思维导图以<a href="https://staging-cn.vuejs.org/">vue3 文档</a>内容为依据，在学习过程中绘制</li><li>学习过程中对比了 vue3 和 react</li><li>很长一段时间没看vue了，vue3一直没接触，媳妇不学。万一哪天媳妇需要用vue3了，没人带岂不是要失业，赶紧学起来～<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2></li></ul><!-- ![](http://t-blog-images.aijs.top/img/20220602185624.webp) --><!-- ![](http://t-blog-images.aijs.top/img/20220602201338.webp) --><img src="http://t-blog-images.aijs.top/img/20220602201338.webp" style="max-width:240px" /><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>念叨着 <code>渐进式</code> <code>依赖收集</code> 去学习<a href="https://staging-cn.vuejs.org/guide/introduction.html">vue指南</a></li></ul><p><img src="http://t-blog-images.aijs.top/img/20220602201731.webp"></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react useState 错误使用</title>
      <link href="//post/2022-05-31bug.html"/>
      <url>//post/2022-05-31bug.html</url>
      
        <content type="html"><![CDATA[<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const Share: FC&lt;ShareProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const &#123; entityType, entityCode &#125; &#x3D; props  const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;    value: props.value,    title: props.title,    shareId: props.shareId,    mappingPassword: props.mappingPassword,    passwordEnable: props.passwordEnable,    mappingState: props.mappingState,    expireTime: props.expireTime,    shortCode: props.shortCode,  &#125;)  const &#123; value &#125; &#x3D; state  ...  return (    &lt;div&gt;      &#123;renderBtn&#125;      &lt;ShareModal        entityType&#x3D;&#123;entityType&#125;        entityCode&#x3D;&#123;entityCode&#125;        &#123;...modalProps&#125;        state&#x3D;&#123;state&#125;        setState&#x3D;&#123;setState&#125;      &#x2F;&gt;    &lt;&#x2F;div&gt;  )&#125;export default Share</code></pre><h2 id="ShareModal"><a href="#ShareModal" class="headerlink" title="ShareModal"></a>ShareModal</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">interface ShareModalProps extends ModalFuncProps &#123;  entityType: EntityType  entityCode: string  className?: string  state: StateProps  setState: (state: StateProps) &#x3D;&gt; void&#125;const Copy &#x3D; (&#123; text, children &#125;: &#123; text: string; children: string &#125;) &#x3D;&gt; &#123;  return (    &lt;CopyToClipboard      text&#x3D;&#123;text&#125;      onCopy&#x3D;&#123;() &#x3D;&gt; &#123;        message.success(&#39;链接已复制&#39;)      &#125;&#125;    &gt;      &lt;span&gt;&#123;children&#125;&lt;&#x2F;span&gt;    &lt;&#x2F;CopyToClipboard&gt;  )&#125;const ShareModal: FC&lt;ShareModalProps&gt; &#x3D; (props) &#x3D;&gt; &#123;  const [form] &#x3D; HookForm.useForm()  const &#123; state, setState, entityType, entityCode, ...restProps &#125; &#x3D; props  const &#123; value, title, mappingPassword, shortCode, expireTime &#125; &#x3D; state  const &#123;    onChange: toggle,    resetPassword: reset,    update,  &#125; &#x3D; useShare(&#123;    entityCode,    entityType,    state,    setState,  &#125;)  ....  return (    &lt;Modal      &#123;...restProps&#125;      className&#x3D;&#123;styles[&#39;share-modal-wrap&#39;]&#125;      title&#x3D;&quot;链接分享&quot;      destroyOnClose      width&#x3D;&#123;420&#125;      footer&#x3D;&#123;null&#125;    &gt;      &lt;ConditionComponent isShow&#x3D;&#123;value&#125;&gt;        ....        &lt;HookForm form&#x3D;&#123;form&#125; style&#x3D;&#123;&#123; marginBottom: 10, width: &#39;100%&#39; &#125;&#125; layout&#x3D;&quot;vertical&quot;&gt;          &lt;HookForm.Item noStyle shouldUpdate&gt;            &#123;() &#x3D;&gt; &#123;              const &#123; url, mappingPassword, expireTime &#125; &#x3D; form.getFieldsValue()              const text &#x3D; &#96;$&#123;url&#125;（密码：$&#123;mappingPassword&#125;）《$&#123;title&#125;》$&#123;moment(                expireTime,              ).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)&#125;过期&#96;              return (                &lt;HookForm.Item name&#x3D;&quot;url&quot; label&#x3D;&quot;&quot;&gt;                  &lt;Input                    className&#x3D;&#123;styles[&#39;share-copy&#39;]&#125;                    addonAfter&#x3D;&#123;&lt;Copy text&#x3D;&#123;text&#125;&gt;复制链接和密码&lt;&#x2F;Copy&gt;&#125;                    disabled                  &#x2F;&gt;                &lt;&#x2F;HookForm.Item&gt;              )            &#125;&#125;          &lt;&#x2F;HookForm.Item&gt;        &lt;&#x2F;HookForm&gt;      &lt;&#x2F;ConditionComponent&gt;    &lt;&#x2F;Modal&gt;  )&#125;export default ShareModal</code></pre><h2 id="用户反馈"><a href="#用户反馈" class="headerlink" title="用户反馈"></a>用户反馈</h2><p>为什么分享的链接与要分享的链接对不上？</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useCallback受依赖项的影响，不更新，之前改过同事的代码，这次扫了一样，没有callback，就这问题修改几个了</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><ul><li>找了下数据<code>ShareModal</code>组件,看到两个入参<code>state, setState</code> ，我艹</li><li>继续往上层找<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&lt;ShareModal  entityType&#x3D;&#123;entityType&#125;  entityCode&#x3D;&#123;entityCode&#125;  &#123;...modalProps&#125;  state&#x3D;&#123;state&#125; &#x2F;&#x2F; 😓  setState&#x3D;&#123;setState&#125; &#x2F;&#x2F;😓 &#x2F;&gt;</code></pre></li><li>再往上找，useState 内部只执行一次，数据初始化完成不再改变</li></ul><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;  value: props.value,  title: props.title,  shareId: props.shareId,  mappingPassword: props.mappingPassword,  passwordEnable: props.passwordEnable,  mappingState: props.mappingState,  expireTime: props.expireTime,  shortCode: props.shortCode,&#125;)const &#123; value &#125; &#x3D; state</code></pre><ul><li>这里代码这么写，其他地方肯定也有这样的写法，😓</li></ul><h2 id="改一下"><a href="#改一下" class="headerlink" title="改一下"></a>改一下</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [state, setState] &#x3D; useState&lt;StateProps&gt;(&#123;&#125;)useEffect(() &#x3D;&gt; &#123;  setState(&#123; ...props &#125;)&#125;, [props.shareId])</code></pre>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程范式-函数式编程简单了解</title>
      <link href="//post/2022-05-28func.html"/>
      <url>//post/2022-05-28func.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>js 为了实现面向对象的思想，做了很多事情，导致大家在学习 js 的时候，会遇到复杂的原型、原型链、继承，还有对人不友好的 this ；而当我们用这些东西组合起来模拟面向对象的特性的时候，就更加痛苦了。但我们可以使用一种更友好的方式，函数式编程。<br><strong>简单来说就是：面向对象的思想在js中不是很好用</strong></p><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>函数式编程（functional programing）是编程范式之一。我们常见的范式还有面向过程、面向行为、面向对象等。</p><p>范式：我们可以认为它是一种<code>思维模式</code>加上它的实现方法，<code>简单说就是编程的方法论</code>。</p><ul><li><p><strong>面向过程编程</strong>：简单解释就是按照步骤来实现。</p></li><li><p><strong>面向行为编程</strong>：它是函数式编程的衍生范型，将电脑运算平展为一系列的变化，并且避免使用程序指令以及堆叠的对象。</p></li><li><p><strong>面向对象编程</strong>：它的思维方式是把现实世界中的事物抽象成程序世界中的类和对象，然后通过封装，继承和多态来演示事物之间的联系。</p></li><li><p><strong>面向函数式编程</strong>：它的思维方式是把现实世界中的事物和事物之间的联系，抽象到程序世界中。</p></li></ul><h2 id="函数式编程特点："><a href="#函数式编程特点：" class="headerlink" title="函数式编程特点："></a>函数式编程特点：</h2><ul><li><p>程序的本质：就是利用计算机的计算能力将输入转化成对应的输出。</p></li><li><p>函数式编程中的函数指的不是编程语言里的函数，而是数学意义上的映射关系。比如 y&#x3D;sin(x) 中 x 和 y 值的映射关系。</p></li><li><p>纯函数：相同的输入获得相同的输出（无副作用）。</p></li><li><p>函数式编程就是对数据(函数)映射关系的抽象。</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>高阶函数</li><li>闭包</li><li>纯函数</li><li>柯里化</li><li>组合函数</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zoo.team/article/function-production"></a></p>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wiki Laser Pen</title>
      <link href="//post/2022-05-27wiki-laserPen.html"/>
      <url>//post/2022-05-27wiki-laserPen.html</url>
      
        <content type="html"><![CDATA[<h2 id="Laser-Pen"><a href="#Laser-Pen" class="headerlink" title="Laser Pen"></a>Laser Pen</h2><p><code>Laser Pen </code>是一套用来在 web canvas 上绘制鼠标轨迹的工具集。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>wiki</code>全屏演示时候，为了便于听众跟随演讲者进度，给鼠标轨迹加上标记。</p><p><img src="http://t-blog-images.aijs.top/img/demo.gif"></p><p>注：公司项目由于版权问题，不便演示</p><h2 id="初步上手"><a href="#初步上手" class="headerlink" title="初步上手"></a>初步上手</h2><p>首先在你的项目中添加对 Laser Pen 的依赖：</p><pre class="line-numbers language-none"><code class="language-none">yarn add laser-pen</code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">npm i laser-pen</code></pre><p>然后监听鼠标的 move 事件，获取鼠标移动轨迹的坐标，并同时记录 move 事件触发时的时间戳。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 获取 canvas 元素的坐标const canvasDom &#x3D; document.querySelector(&#39;canvas&#39;)const canvasPos &#x3D; canvasDom.getBoundingClientRect()const ctx &#x3D; canvas.getContext(&#39;2d&#39;)&#x2F;&#x2F; 用来存储所有鼠标轨迹数据let mouseTrack &#x3D; []&#x2F;&#x2F; 监听鼠标事件document.addEventListener(&#39;mousemove&#39;, (event) &#x3D;&gt; &#123;  mouseTrack.push(&#123;    x: event.clientX - canvasPos.x,    y: event.clientY - canvasPos.y,    time: Date.now(),  &#125;)&#125;)</code></pre><p>最后在调用 drawLaserPen 方法绘制鼠标轨迹</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; drainPoints, drawLaserPen &#125; from &#39;laser-pen&#39;function draw() &#123;  &#x2F;&#x2F; 过滤掉一些失效的轨迹坐标  mouseTrack &#x3D; drainPoints(mouseTrack)  if (mouseTrack.length &gt;&#x3D; 3) &#123;    &#x2F;&#x2F; 绘制鼠标轨迹    drawLaserPen(ctx, mouseTrack)  &#125;  requestAnimation(draw)&#125;</code></pre><p>到这里，你应该已经可以在 canvas 上实现鼠标轨迹的绘制了。</p><h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>如果默认的轨迹效果不能满足你的要求，Laser Pen 还提供了一些接口让你可以方便的修改鼠标轨迹的样式。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 设置延迟时间，mousemove 事件产生的坐标点在超过延迟时间后就不会被绘制，会直接影响轨迹的长度setDelay: (millisecond: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的最大宽度，轨迹是一条由粗变细的曲线，maxWidth 表示粗的那一头的线宽setMaxWidth: (width: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的最小宽度，轨迹是一条由粗变细的曲线，minWidth 表示细的那一头的线宽setMinWidth: (width: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置曲线张力大小，张力越大拐点处越平滑，反之越尖锐setTension: (t: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的最小透明度，轨迹是一条由不透明变透明的曲线，opacity 表示轨迹末尾的不透明度setOpacity: (o: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹的颜色setColor: (r: number, g: number, b: number) &#x3D;&gt; void;&#x2F;&#x2F; 设置轨迹头部是否是圆形setRoundCap: (b: boolean) &#x3D;&gt; void;</code></pre><p>在任何时候调用上述接口修改鼠标轨迹的样式，都会在紧接着的下一次绘制中生效。所以如果你想实现一个类似 RGB 跑马灯的鼠标轨迹也是可以的。</p><h2 id="定制化开发"><a href="#定制化开发" class="headerlink" title="定制化开发"></a>定制化开发</h2><p>如果上面的接口都不能满足你的要求，那么你就需要做一些定制化的开发了。</p><p>绘制鼠标轨迹的过程大概分为 5 个步骤：</p><p>清洗轨迹坐标数据<br>根据轨迹坐标计算每个坐标的控制点<br>通过坐标点和控制点数据生成 Bezier 曲线<br>将上一步生成的曲线分割为更短的 Bezier 曲线，并计算每条曲线的绘制样式<br>依次绘制每条 Bezier 曲线<br>这 5 个步骤对应下面的第 1 到第 5 个接口，最后的 drawLaserPen 接口是对前面 5 个接口的组合。 如果直接调用 drawLaserPen 不能满足你的要求，你可以在前 5 个接口的基础上自行组合，实现你想要的效果。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 去掉原始鼠标坐标数据中不合理的数据，包括超过延迟时间的坐标，和一些排列不合法的坐标drainPoints: (originalPoints: IOriginalPointData[]) &#x3D;&gt; IOriginalPointData[];&#x2F;&#x2F; 根据鼠标坐标数据计算每个坐标点的前后控制点calControlPoints: (points: IPoint[]) &#x3D;&gt; IControlPoint[];&#x2F;&#x2F; 将鼠标坐标数据和控制点数据组合为贝塞尔曲线transformPointToBezier: (  points: IPoint[],  controlPoints: IControlPoint[]) &#x3D;&gt; Bezier[];&#x2F;&#x2F; 根据原始的贝塞尔曲线数据，计算出用于绘制的数据结构calDrawingData: (  bzArray: Bezier[],  totalLength: number) &#x3D;&gt; IDrawingBezierData[];&#x2F;&#x2F; 根据计算出的绘制数据，将曲线绘制到画布上drawDrawingBezierData: (  ctx: CanvasRenderingContext2D,  data: IDrawingBezierData[]) &#x3D;&gt; void;&#x2F;&#x2F; 一个方便简单使用的入口方法，直接通过处理好的鼠标坐标数据，绘制鼠标轨迹drawLaserPen: (ctx: CanvasRenderingContext2D, points: IPoint[]) &#x3D;&gt; void;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/SilentTiger/laser-pen">laser-pen</a></li><li>突然有个想法：王者荣耀的拖尾效果实现原理，是不是和这个类似？</li></ul>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-logger源码</title>
      <link href="//post/2022-05-27redux-logger.html"/>
      <url>//post/2022-05-27redux-logger.html</url>
      
        <content type="html"><![CDATA[<h2 id="redux-日志中间件"><a href="#redux-日志中间件" class="headerlink" title="redux 日志中间件"></a>redux 日志中间件</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">.├── core.js├── defaults.js├── diff.js├── helpers.js &#x2F;&#x2F; 一些帮助函数└── index.js0 directories, 5 files</code></pre><h2 id="defaultLogger"><a href="#defaultLogger" class="headerlink" title="defaultLogger"></a>defaultLogger</h2><p><strong>v3 版本，破坏性变更</strong></p><p>之前</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import createLogger from &quot;redux-logger&quot;;</code></pre><p>之后</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; createLogger &#125; from &quot;redux-logger&quot;;</code></pre><p><strong>源码</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; src&#x2F;index.jsconst defaultLogger &#x3D; (&#123; dispatch, getState &#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123;  if (typeof dispatch &#x3D;&#x3D;&#x3D; &quot;function&quot; || typeof getState &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;    &#x2F;&#x2F; createLogger，柯里化 工厂模式    return createLogger()(&#123; dispatch, getState &#125;);  &#125;  &#x2F;&#x2F; 如果没有传递dispatch和getState，打印错误信息  &#x2F;&#x2F; v3版本，破坏性变更, 根据《语义化版本》不看内容也知道有破坏性变更  &#x2F;&#x2F; Since 3.0.0 redux-logger exports by default logger with default settings  &#x2F;&#x2F; import createLogger from &#39;redux-logger&#39; &#x3D;&gt; import &#123; createLogger &#125; from &#39;redux-logger&#39;  console.error(&#96;[redux-logger v3] BREAKING CHANGE[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.[redux-logger v3] Change[redux-logger v3] import createLogger from &#39;redux-logger&#39;[redux-logger v3] to[redux-logger v3] import &#123; createLogger &#125; from &#39;redux-logger&#39;&#96;);&#125;;export &#123; defaults, createLogger, defaultLogger as logger &#125;;export default defaultLogger;</code></pre><h2 id="createLogger"><a href="#createLogger" class="headerlink" title="createLogger"></a>createLogger</h2><ul><li>使用传入的 options， 创建日志记录器</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;** * Creates logger with following options * 创建日志记录器，配置如下： * @namespace * @param &#123;object&#125; options - options for logger * @param &#123;string | function | object&#125; options.level - console[level] 日志级别 * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间 * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳 * @param &#123;object&#125; options.colors - custom colors 定制颜色 * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现 * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出 * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组 * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为 * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换 * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换 * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换 * * @returns &#123;function&#125; logger middleware 返回中间件 *&#x2F;function createLogger(options &#x3D; &#123;&#125;) &#123;  const loggerOptions &#x3D; Object.assign(&#123;&#125;, defaults, options);  const &#123;    logger,    stateTransformer,    errorTransformer,    predicate,    logErrors,    diffPredicate,  &#125; &#x3D; loggerOptions;  &#x2F;&#x2F; Return if &#39;console&#39; object is not defined  &#x2F;&#x2F; 如果&#39;console&#39;对象未定义，返回  if (typeof logger &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);  &#125;  &#x2F;&#x2F; Detect if &#39;createLogger&#39; was passed directly to &#39;applyMiddleware&#39;.  &#x2F;&#x2F; 判断是否传递给applyMiddleware  if (options.getState &amp;&amp; options.dispatch) &#123;    &#x2F;&#x2F; eslint-disable-next-line no-console    console.error(&#96;[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:&#x2F;&#x2F; Logger with default optionsimport &#123; logger &#125; from &#39;redux-logger&#39;const store &#x3D; createStore(  reducer,  applyMiddleware(logger))&#x2F;&#x2F; Or you can create your own logger with custom options http:&#x2F;&#x2F;bit.ly&#x2F;redux-logger-optionsimport &#123; createLogger &#125; from &#39;redux-logger&#39;const logger &#x3D; createLogger(&#123;  &#x2F;&#x2F; ...options&#125;);const store &#x3D; createStore(  reducer,  applyMiddleware(logger))&#96;);    &#x2F;&#x2F; 中间件书写套路    return () &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; next(action);  &#125;  const logBuffer &#x3D; [];  return (&#123; getState &#125;) &#x3D;&gt;    (next) &#x3D;&gt;    (action) &#x3D;&gt; &#123;      &#x2F;&#x2F; Exit early if predicate function returns &#39;false&#39; 如果predicate函数返回false，退出      if (typeof predicate &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; !predicate(getState, action)) &#123;        return next(action);      &#125;      const logEntry &#x3D; &#123;&#125;;      logBuffer.push(logEntry);      logEntry.started &#x3D; timer.now();      logEntry.startedTime &#x3D; new Date();      logEntry.prevState &#x3D; stateTransformer(getState());      logEntry.action &#x3D; action;      let returnedValue;      if (logErrors) &#123;        try &#123;          returnedValue &#x3D; next(action);        &#125; catch (e) &#123;          logEntry.error &#x3D; errorTransformer(e);        &#125;      &#125; else &#123;        returnedValue &#x3D; next(action);      &#125;      logEntry.took &#x3D; timer.now() - logEntry.started;      logEntry.nextState &#x3D; stateTransformer(getState());      const diff &#x3D;        loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;          ? diffPredicate(getState, action)          : loggerOptions.diff;      printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;));      logBuffer.length &#x3D; 0;      if (logEntry.error) throw logEntry.error;      return returnedValue;    &#125;;&#125;</code></pre><p><strong>defaults 默认配置</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; src&#x2F;default.jsexport default &#123;  level: &quot;log&quot;,  logger: console,  logErrors: true,  collapsed: undefined,  predicate: undefined,  duration: false,  timestamp: true,  stateTransformer: (state) &#x3D;&gt; state,  actionTransformer: (action) &#x3D;&gt; action,  errorTransformer: (error) &#x3D;&gt; error,  colors: &#123;    title: () &#x3D;&gt; &quot;inherit&quot;,    prevState: () &#x3D;&gt; &quot;#9E9E9E&quot;,    action: () &#x3D;&gt; &quot;#03A9F4&quot;,    nextState: () &#x3D;&gt; &quot;#4CAF50&quot;,    error: () &#x3D;&gt; &quot;#F20404&quot;,  &#125;,  diff: false,  diffPredicate: undefined,  &#x2F;&#x2F; Deprecated options 已废弃配置  transformer: undefined,&#125;;&#x2F;&#x2F; 字段释义&#x2F;** * Creates logger with following options * 创建日志记录器，配置如下： * @namespace * @param &#123;object&#125; options - options for logger * @param &#123;string | function | object&#125; options.level - console[level] 日志级别 * @param &#123;boolean&#125; options.duration - print duration of each action? 打印每个action的时间 * @param &#123;boolean&#125; options.timestamp - print timestamp with each action? 打印每个action的时间戳 * @param &#123;object&#125; options.colors - custom colors 定制颜色 * @param &#123;object&#125; options.logger - implementation of the &#96;console&#96; API 打印日志的实现 * @param &#123;boolean&#125; options.logErrors - should errors in action execution be caught, logged, and re-thrown? 是否捕获action执行错误，打印错误，并重新抛出 * @param &#123;boolean&#125; options.collapsed - is group collapsed? 是否折叠组 * @param &#123;boolean&#125; options.predicate - condition which resolves logger behavior 条件，决定日志记录器行为 * @param &#123;function&#125; options.stateTransformer - transform state before print 打印前的状态转换 * @param &#123;function&#125; options.actionTransformer - transform action before print 打印前的action转换 * @param &#123;function&#125; options.errorTransformer - transform error before print  打印前的错误转换 * * @returns &#123;function&#125; logger middleware 返回中间件 *&#x2F;</code></pre><p><strong>奇怪</strong></p><ul><li>这两个配置在测试文件中，没找到相关测试代码</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"> &#x2F;&#x2F; 配置 diff: false, &#x2F;&#x2F; diffPredicate: undefined, &#x2F;&#x2F; ... const diff &#x3D;       loggerOptions.diff &amp;&amp; typeof diffPredicate &#x3D;&#x3D;&#x3D; &quot;function&quot;         ? diffPredicate(getState, action)         : loggerOptions.diff; &#x2F;&#x2F; 打印日志中 printBuffer(logBuffer, Object.assign(&#123;&#125;, loggerOptions, &#123; diff &#125;)); &#x2F;&#x2F; src&#x2F;core.js printBuffer的定义function printBuffer(buffer, options) &#123;   const &#123;     &#x2F;&#x2F; ...       diff,   &#125; &#x3D; options;   &#x2F;&#x2F; 如果开启   if (diff) &#123;     &#x2F;&#x2F; 执行了 diffLogger     diffLogger(prevState, nextState, logger, isCollapsed);   &#125;&#125;&#x2F;&#x2F; src&#x2F;diff.jsexport default function diffLogger(prevState, newState, logger, isCollapsed) &#123;  &#x2F;&#x2F; import differ from &#39;deep-diff&#39;;计算对象差异化的包  const diff &#x3D; differ(prevState, newState);  try &#123;    if (isCollapsed) &#123;      logger.groupCollapsed(&#39;diff&#39;);    &#125; else &#123;      logger.group(&#39;diff&#39;);    &#125;  &#125; catch (e) &#123;    logger.log(&#39;diff&#39;);  &#125;  &#x2F;&#x2F; 有差异执行输出，这个差异包含类型kind E:编辑 N:新增 D:删除 A:数组  &#x2F;&#x2F; dictionary为对象，对kind值进行枚举  &#x2F;&#x2F; 遍历输出  if (diff) &#123;    diff.forEach((elem) &#x3D;&gt; &#123;      const &#123; kind &#125; &#x3D; elem;      const output &#x3D; render(elem);      logger.log(&#96;%c $&#123;dictionary[kind].text&#125;&#96;, style(kind), ...output);    &#125;);  &#125; else &#123;    logger.log(&#39;—— no diff ——&#39;);  &#125;  try &#123;    logger.groupEnd();  &#125; catch (e) &#123;    logger.log(&#39;—— diff end —— &#39;);  &#125;&#125;</code></pre><h2 id="helpers"><a href="#helpers" class="headerlink" title="helpers"></a>helpers</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; repeat + pad &#x3D; padLeft 左侧补零， es多少有个apiexport const repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);export const pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;&#x2F;&#x2F; 时间格式化export const formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;&#x2F;&#x2F; Use performance API if it&#39;s available in order to get better precisionexport const timer &#x3D;(typeof performance !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; performance !&#x3D;&#x3D; null) &amp;&amp; typeof performance.now &#x3D;&#x3D;&#x3D; &#39;function&#39; ?  performance :  Date;</code></pre><p><strong>运行测试下</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const repeat &#x3D; (str, times) &#x3D;&gt; (new Array(times + 1)).join(str);const pad &#x3D; (num, maxLength) &#x3D;&gt; repeat(&#39;0&#39;, maxLength - num.toString().length) + num;const formatTime &#x3D; time &#x3D;&gt; &#96;$&#123;pad(time.getHours(), 2)&#125;:$&#123;pad(time.getMinutes(), 2)&#125;:$&#123;pad(time.getSeconds(), 2)&#125;.$&#123;pad(time.getMilliseconds(), 3)&#125;&#96;;console.log(formatTime(new Date()))&#x2F;&#x2F; 输出18:58:15.667</code></pre><h2 id="源码图"><a href="#源码图" class="headerlink" title="源码图"></a>源码图</h2><p><img src="http://t-blog-images.aijs.top/img/20220527190102.webp"></p><h2 id="deep-diff"><a href="#deep-diff" class="headerlink" title="deep-diff"></a>deep-diff</h2><ul><li>看下两个对象比较的事例</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">var lhs &#x3D; &#123;name: &#39;my object&#39;,description: &#39;it\&#39;s an object!&#39;,details: &#123;it: &#39;has&#39;,an: &#39;array&#39;,with: [&#39;a&#39;, &#39;few&#39;, &#39;elements&#39;]&#125;&#125;;var rhs &#x3D; &#123;name: &#39;updated object&#39;,description: &#39;it\&#39;s an object!&#39;,details: &#123;it: &#39;has&#39;,an: &#39;array&#39;,with: [&#39;a&#39;, &#39;few&#39;, &#39;more&#39;, &#39;elements&#39;, &#123; than: &#39;before&#39; &#125;]&#125;&#125;;var differences &#x3D; deep.diff(lhs, rhs);&#x2F;&#x2F; 输出27 May 17:27:12 - [  DiffEdit &#123;    kind: &#39;E&#39;,    path: [ &#39;name&#39; ],    lhs: &#39;my object&#39;,    rhs: &#39;updated object&#39;  &#125;,  DiffArray &#123;    kind: &#39;A&#39;,    path: [ &#39;details&#39;, &#39;with&#39; ],    index: 4,    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#123; than: &#39;before&#39; &#125; &#125;  &#125;,  DiffArray &#123;    kind: &#39;A&#39;,    path: [ &#39;details&#39;, &#39;with&#39; ],    index: 3,    item: DiffNew &#123; kind: &#39;N&#39;, rhs: &#39;elements&#39; &#125;  &#125;,  DiffEdit &#123;    kind: &#39;E&#39;,    path: [ &#39;details&#39;, &#39;with&#39;, 2 ],    lhs: &#39;elements&#39;,    rhs: &#39;more&#39;  &#125;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode i18n-ally</title>
      <link href="//post/2022-05-27i18n.html"/>
      <url>//post/2022-05-27i18n.html</url>
      
        <content type="html"><![CDATA[<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><ul><li>大型公司的国际化需求很高，需要支持多语言，比如中文、英文、日文等等。</li><li>i18n-ally是一个基于vscode的国际化工具，可以帮助你快速的实现国际化。</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>如果经常做国际化的研发，应该很清楚，代码中写多语言，然而，多语言在项目中维护是非常困难的。</li><li>当遇到大型项目，业务要做拆分成为<code>微前端架构</code>，多语言要在多个项目中维护，浪费时间不说，还可能造成不一致问题</li><li>处理方式：<ol><li>将对应的多语言开发为npm包，在项目中引入</li><li>拆多语言为一个应用平台，实现多项目共享，实现可视化交互（我们目前使用，自研localize平台，实现多语言管理）</li></ol></li></ul><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p><strong>应用平台</strong></p><ul><li>动态生效： 修改多语言不需要重启、发布服务</li><li>翻译管理：多人协同在线翻译</li><li>版本管理： 记录翻译变更记录以及对应的操作人，方便定位与排错</li><li>自动多区同步：只需在中国区修改，系统会自动同步到国外5区</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>提示优雅，未处理的多语言会有提示</li><li>编辑方便</li></ul><p align="center"><img src="https://github.com/lokalise/i18n-ally/blob/main/screenshots/full-logo-new.png?raw=true" alt="logo" width="450"/></p><p align='center'>English | <a href="https://github.com/lokalise/i18n-ally/blob/main/README.zh-CN.md">简体中文</a></p><p align="center" style="display: flex; flex-wrap: wrap"><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://img.shields.io/visual-studio-marketplace/v/lokalise.i18n-ally.svg?color=blue&amp;label=VS%20Code%20Marketplace&logo=visual-studio-code" alt="Visual Studio Marketplace Version" /></a><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://img.shields.io/visual-studio-marketplace/d/lokalise.i18n-ally.svg?color=4bdbe3" alt="Visual Studio Marketplace Downloads" /></a><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://img.shields.io/visual-studio-marketplace/i/lokalise.i18n-ally.svg?color=63ba83" alt="Visual Studio Marketplace Installs" /></a><a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally" target="__blank"><img src="https://vsmarketplacebadge.apphb.com/trending-monthly/lokalise.i18n-ally.svg?color=a1b858" alt="Marketplace Trending Monthly" /></a><br/><a href="https://github.com/lokalise/i18n-ally/wiki" target="__blank"><img alt="Wiki" src="https://img.shields.io/static/v1?label=docs&message=wiki&color=e3897b"></a><a href="https://github.com/lokalise/i18n-ally" target="__blank"><img src="https://img.shields.io/github/last-commit/lokalise/i18n-ally.svg?color=c977be" alt="GitHub last commit" /></a><a href="https://github.com/lokalise/i18n-ally/issues" target="__blank"><img src="https://img.shields.io/github/issues/lokalise/i18n-ally.svg?color=a38eed" alt="GitHub issues" /></a><a href="https://github.com/lokalise/i18n-ally" target="__blank"><img alt="GitHub stars" src="https://img.shields.io/github/stars/lokalise/i18n-ally?style=social"></a></p><p align='center'><b>v2.0</b> is released with new <a href='https://github.com/lokalise/i18n-ally/wiki/Editor-UI'>Editor UI</a> and <a href='https://github.com/lokalise/i18n-ally/wiki/Review-&-Collaboration-System'>Review System</a> 🎉</p><p align='center'><i><a href="https://github.com/lokalise/i18n-ally/wiki/Migration-v1.x">Migrate from v1.x</a></i></p><br><p align="center"><a href='https://github.com/lokalise/i18n-ally/wiki/Supported-Frameworks' target="__blank"><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/supported-frameworks.png?raw=true" alt="Supported Frameworks" width="550"/></a></p><h3 align="center">Maintained by</h3><p align="center"><a title="Lokalise: accelerate localization from code to delivery" href="https://lokalise.com/?utm_source=vscmarket&amp;utm_campaign=i18nally&amp;utm_medium=banner"><img src="https://github.com/lokalise/i18n-ally/raw/screenshots/lokalise-logo.png?raw=true" alt="Lokalise logo" width="275px"></a><br><sup>Lokalise is the fastest growing language cloud technology made by developers, for developers.<br>As a collaborative productivity platform, it helps structure and automate the translation and localization process for any company in the world.<br>Lokalise是开发人员为开发人员开发的增长最快的语言云技术<br>作为一个协作生产力平台，它可以帮助世界上任何公司构建和自动化翻译和本地化过程。<a title="Lokalise: accelerate localization from code to delivery" href="https://lokalise.com/?utm_source=vscmarket&amp;utm_campaign=i18nally&amp;utm_medium=banner">Learn more</a></sup></p><br><br><h4 align="center"><a href="https://github.com/lokalise/i18n-ally/wiki">📖 Docs 文档</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/FAQ">💭 FAQ 问答</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/Configurations">⚙️ Configs 配置</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/Locale-Formats#supported-locale-formats">📜 Supported Formats 支持格式</a>&nbsp;|&nbsp;<a href="https://github.com/lokalise/i18n-ally/wiki/Contribute">🧱 Contribute 贡献</a></h4><br><br><h3 align='center'>Inline Annotations 行内提示</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/annotation-animated.gif?raw=true"></p><h3 align='center'>Hover and Direct Actions 悬停和直接操作</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/hover.png?raw=true"></p><h3 align='center'>Manage All Translations in One Place 在一个位置管理所有翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/review-sidebar.png?raw=true"></p><h3 align='center'><a href='https://github.com/lokalise/i18n-ally/wiki/Editor-UI'>Editor UI编辑界面</a> & <a href='https://github.com/lokalise/i18n-ally/wiki/Review-&-Collaboration-System'>Review System 预览系统</a></h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/review-editor.png?raw=true"></p><h3 align='center'>Extract Translations from Code 从代码中提取翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/extract.png?raw=true"></p><h3 align='center'>Report Missing Translations 报告缺失的翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/problems.png?raw=true"></p><h3 align='center'>Machine Translation 机器翻译</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/quick-actions.png?raw=true"></p><h3 align='center'>Annotations for JSON and YAML 来源于JSON 和 YAML的提示</h3><p><img src="https://github.com/lokalise/i18n-ally/blob/screenshots/annotation-locale.png?raw=true"></p><h3 align="center">General Features</h3><ul><li>Supports multi-root workspaces  支持多个工作空间</li><li>Supports remote development 支持远程开发</li><li>Supports numerous popular frameworks 支持多种流行框架</li><li>Supports <a href="https://kazupon.github.io/vue-i18n/guide/messages.html#linked-locale-messages">linked locale messages 链接的区域设置消息</a></li><li>Uses i18n for the extension itself, of course. 当然，将i18n用于扩展本身。 <a href="https://github.com/lokalise/i18n-ally#-multilingual-support">Translation List 翻译列表</a></li></ul><h2 id="🌍-Multilingual-Support-多语言支持"><a href="#🌍-Multilingual-Support-多语言支持" class="headerlink" title="🌍 Multilingual Support 多语言支持"></a>🌍 Multilingual Support 多语言支持</h2><p>This extension itself supports i18n as well. It will be auto-matched to the display language you use in your VS Code editor. We currently support the following languages.<br>这个扩展支持多语言。它将自动匹配到你在VS Code编辑器中使用的语言。我们目前支持的语言有：</p><table><thead><tr><th>Language</th><th>Maintainer</th><th>Contributors</th></tr></thead><tbody><tr><td>English   英语</td><td><a href="https://github.com/antfu">@antfu</a></td><td><a href="https://github.com/rubjo">@rubjo</a>, <a href="https://github.com/EdRands">@EdRands</a></td></tr><tr><td>Simplified Chinese (简体中文)</td><td><a href="https://github.com/antfu">@antfu</a></td><td></td></tr><tr><td>Traditional Chinese (繁體中文)</td><td><a href="https://github.com/antfu">@antfu</a></td><td></td></tr><tr><td>Norwegian (Norsk) 挪威语</td><td></td><td><a href="https://github.com/rubjo">@rubjo</a></td></tr><tr><td>Spanish (Español) 西班牙的</td><td></td><td><a href="https://github.com/Baltimer">@Baltimer</a></td></tr><tr><td>Japanese (日本語) 日语</td><td></td><td><a href="https://github.com/isdh">@isdh</a></td></tr><tr><td>Dutch (Nederlands) 荷兰语</td><td></td><td><a href="https://github.com/Niekvdm">@Niekvdm</a>, <a href="https://github.com/Excalibaard">@Excalibaard</a></td></tr><tr><td>Portuguese (Brazilian) 葡萄牙语</td><td></td><td><a href="https://github.com/Ibcs16">@Ibcs16</a></td></tr><tr><td>French (Français) 法语</td><td></td><td><a href="https://github.com/Nicoxx45">@Nicoxx45</a>, <a href="https://github.com/eri">@eri</a></td></tr><tr><td>Swedish (Svenska)瑞典语</td><td><a href="https://github.com/vladdeSV">@vladdeSV</a></td><td></td></tr><tr><td>Ukrainian (Українська) 乌克兰语</td><td></td><td><a href="https://github.com/uhodav">@uhodav</a></td></tr><tr><td>Russian (Русский) 俄语</td><td></td><td><a href="https://github.com/uhodav">@uhodav</a></td></tr><tr><td>German (Deutsch) 德语</td><td><a href="https://github.com/alexanderniebuhr">@alexanderniebuhr</a></td><td></td></tr><tr><td>Turkish (Türkçe) 土耳其语</td><td></td><td><a href="https://github.com/eri">@eri</a></td></tr></tbody></table><p><a href="https://github.com/lokalise/i18n-ally/wiki/Contribute#working-on-translations"><strong>帮忙翻译</strong></a></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>👨‍💻 如果您想帮助一种语言的翻译更新，请在<strong>维护者</strong>字段中输入您的姓名。我会在需要的时候提到你。非常感谢。</p></blockquote><h2 id="❤️-感谢"><a href="#❤️-感谢" class="headerlink" title="❤️ 感谢"></a>❤️ 感谢</h2><p>此插件的灵感来源于<a href="https://github.com/think2011/vscode-vue-i18n">think2011&#x2F;vscode-vue-i18n</a>. 如果没有<a href="https://github.com/think2011">@think2011</a>,i18n-ally不会存在</p><p>对Vue单文件组件（SFC）的支持由[kazupon&#x2F;Vue-i18n-locale-message]提供支持(<a href="https://github.com/kazupon/vue-i18n-locale-message)%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%B1vue-i18n%E7%9A%84%E4%BD%9C%E8%80%85%E5%88%9B%E5%BB%BA%E7%9A%84%E3%80%82%E8%B0%A2%E8%B0%A2%E4%BD%A0%E5%81%9A%E8%BF%99%E4%B8%AA%EF%BC%81">https://github.com/kazupon/vue-i18n-locale-message)，它是由vue-i18n的作者创建的。谢谢你做这个！</a></p><h3 id="代码共享者"><a href="#代码共享者" class="headerlink" title="代码共享者"></a>代码共享者</h3><p>非常感谢所有杰出的贡献者：<br><a href="https://github.com/lokalise/i18n-ally/graphs/contributors"><img src="https://opencollective.com/i18n-ally/contributors.svg?width=890"/></a></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><a href="https://github.com/lokalise/i18n-ally/blob/master/LICENSE">MIT License</a> © 2019-PRESENT <a href="https://github.com/antfu">Anthony Fu</a></p><p>MIT License © 2018-2019 <a href="https://github.com/think2011">think2011</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally">Visual Studio Code&gt;Other&gt;i18n Ally</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/lokalise/i18n-ally">github 官网</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-thunk源码</title>
      <link href="//post/2022-05-27redux-thunk.html"/>
      <url>//post/2022-05-27redux-thunk.html</url>
      
        <content type="html"><![CDATA[<h2 id="源码版本"><a href="#源码版本" class="headerlink" title="源码版本"></a>源码版本</h2><p><a href="https://github.com/reduxjs/redux-thunk/releases/tag/v2.4.1">v2.4.1</a></p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>通过redux源码applyMiddleware了解到，是对store.dispatch进行增强</li><li>可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。</li><li>可以在这个函数中执行一些异步的操作</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export function addCount() &#123;  return &#123;type: ADD_COUNT&#125;&#125; export function addCountAsync() &#123;  return dispatch &#x3D;&gt; &#123; &#x2F;&#x2F; dispatch对应源码的 ： action(dispatch, getState, extraArgument);的第一个参数    setTimeout( () &#x3D;&gt; &#123;      dispatch(addCount())    &#125;,2000)  &#125;&#125;</code></pre><ul><li>addCountAsync函数就返回了一个函数，将dispatch作为函数的第一个参数传递进去，在函数内进行异步操作就可以了。</li></ul><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><ul><li>这个文件结构与redux、react-redux相比，没有什么特别之处，这里及以后如无必要不在进行阅读</li><li>简单扫一眼就好</li></ul><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;** A function that accepts a potential &quot;extra argument&quot; value to be injected later, * and returns an instance of the thunk middleware that uses that value *&#x2F;&#x2F;** 一个函数接收一个可能的&quot;extra argument&quot;值，并返回一个thunk中间件，它使用这个值 *&#x2F;function createThunkMiddleware&lt;  State &#x3D; any,  BasicAction extends Action &#x3D; AnyAction,  ExtraThunkArg &#x3D; undefined&gt;(extraArgument?: ExtraThunkArg) &#123;  &#x2F;&#x2F; Standard Redux middleware definition pattern:  &#x2F;&#x2F; 标准Redux中间件定义模式:  &#x2F;&#x2F; See: https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#writing-custom-middleware  const middleware: ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt; &#x3D;    (&#123; dispatch, getState &#125;) &#x3D;&gt; (next) &#x3D;&gt;  (action) &#x3D;&gt; &#123;      &#x2F;&#x2F; The thunk middleware looks for any functions that were passed to &#96;store.dispatch&#96;.      &#x2F;&#x2F; If this &quot;action&quot; is really a function, call it and return the result.      &#x2F;&#x2F; 这个thunk中间件会查找store.dispatch传入的任何函数。如果这个&quot;action&quot;是一个函数，调用它并返回结果。      if (typeof action &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;        &#x2F;&#x2F; Inject the store&#39;s &#96;dispatch&#96; and &#96;getState&#96; methods, as well as any &quot;extra arg&quot;        &#x2F;&#x2F; 注入store的dispatch和getState方法，以及任意的&quot;extra arg&quot;        return action(dispatch, getState, extraArgument);      &#125;      &#x2F;&#x2F; 否则，像往常一样将操作传递给中间件链      &#x2F;&#x2F; Otherwise, pass the action down the middleware chain as usual      return next(action);    &#125;;  return middleware;&#125;</code></pre><p><strong>中间件模式</strong></p><p>柯里化：将一个函数的参数分解成多个参数，并且返回一个新的函数，这个新的函数可以被调用，并且返回原函数的结果。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const anotherExampleMiddleware &#x3D; storeAPI &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;  &#x2F;&#x2F; Do something in here, when each action is dispatched  return next(action)&#125;</code></pre><p><strong>storeAPI</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; storeAPIconst store &#x3D; &#123;  dispatch: dispatch as Dispatch&lt;A&gt;,  subscribe,  getState,  replaceReducer,  [$$observable]: observable&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext</code></pre><p><em>工厂模式</em></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const thunk &#x3D; createThunkMiddleware() as ThunkMiddleware &amp; &#123;  withExtraArgument&lt;    ExtraThunkArg,    State &#x3D; any,    BasicAction extends Action &#x3D; AnyAction  &gt;(    extraArgument: ExtraThunkArg  ): ThunkMiddleware&lt;State, BasicAction, ExtraThunkArg&gt;&#125;&#x2F;&#x2F; Attach the factory function so users can create a customized version&#x2F;&#x2F; with whatever &quot;extra arg&quot; they want to inject into their thunks&#x2F;&#x2F; 尝试将工厂函数附加到用户可以创建任何额外的&quot;extra arg&quot;的thunk中间件thunk.withExtraArgument &#x3D; createThunkMiddlewareexport default thunk</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/reduxjs/redux-thunk/blob/master/src/index.ts">redux-thunk源码</a><br><a href="https://blog.csdn.net/hsany330/article/details/105951197">Redux中间件之redux-thunk使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
            <tag> redux-thunk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 包发布相关</title>
      <link href="//post/2022-04-28npm.html"/>
      <url>//post/2022-04-28npm.html</url>
      
        <content type="html"><![CDATA[<h2 id="npm-包发布"><a href="#npm-包发布" class="headerlink" title="npm 包发布"></a>npm 包发布</h2><pre class="line-numbers language-none"><code class="language-none">npm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; npm notice name:          @tutu-fe&#x2F;wiki-ui                        npm notice version:       0.1.1-beta                              npm notice filename:      @tutu-fe&#x2F;wiki-ui-0.1.1-beta.tgz         npm notice package size:  85.7 kB                                 npm notice unpacked size: 449.9 kB                                npm notice shasum:        973f5eb8d74de04c34b8e9c94536f8924b1f9570npm notice integrity:     sha512-Uyo3zS0eaMOYE[...]60Ywmrmb&#x2F;brxQ&#x3D;&#x3D;npm notice total files:   205                                     npm notice npm ERR! code E403npm ERR! 403 403 Forbidden - PUT https:&#x2F;&#x2F;registry- - [maintainers_error] haotian.chen does not in maintainer listnpm ERR! 403 In most cases, you or one of your dependencies are requestingnpm ERR! 403 a package version that is forbidden by your security policy, ornpm ERR! 403 on a server you do not have access to.npm ERR! A complete log of this run can be found in:npm ERR!     &#x2F;Users&#x2F;haotian&#x2F;.npm&#x2F;_logs&#x2F;2022-04-28T09_58_10_365Z-debug.log</code></pre><h2 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;maintainers&quot;: [  &quot;davishua&quot;,å  &quot;haotian.chen&quot;],</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://t-blog-images.aijs.top/img/20220428180656.png"><br><img src="http://t-blog-images.aijs.top/img/20220428180602.png"></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业微信： 图片附件无法预览的问题</title>
      <link href="//post/2022-04-19wework-preview.html"/>
      <url>//post/2022-04-19wework-preview.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://t-blog-images.aijs.top/img/11460713-13685d46ead24558.png"></p><ul><li>背景：安卓预览正常，部分iOS预览有问题（大部分手机都是正常的）<pre class="line-numbers language-none"><code class="language-none">downloadAttachment(downloadUrl).then(res &#x3D;&gt; &#123;      if (getWechatUserAgent(navigator.userAgent)) &#123; &#x2F;&#x2F; 判断是企业微信        const blob &#x3D; new Blob([res]);        wx.previewFile(&#123;          url: location.origin + downloadUrl, &#x2F;&#x2F; 需要预览文件的地址(必填，可以使用相对路径)          name: attachment.name, &#x2F;&#x2F; 需要预览文件的文件名，必须有带文件格式的后缀，例如.doc(不填的话取url的最后部分，最后部分是个包含格式后缀的文件名)          size: blob.size &#x2F;&#x2F; 需要预览文件的字节大小(必填，而且大小必须正确，否则会打开失败)        &#125;);        Toast.loading(i18n.loading, false)        return      &#125;      var reader &#x3D; new FileReader();      reader.readAsDataURL(res);   &#x2F;&#x2F; 转换为base64，可以直接放入a标签href      reader.onload &#x3D; function (e) &#123;        const anchorEle &#x3D; document.createElement(&#39;a&#39;)        document.body.appendChild(anchorEle)        anchorEle.href &#x3D; e?.target?.result as any        anchorEle.download &#x3D; attachment.name        anchorEle.click()        document.body.removeChild(anchorEle)      &#125;      Toast.loading(i18n.loading, false)    &#125;).catch(() &#x3D;&gt; &#123;      Toast.loading(i18n.loading, false)    &#125;)</code></pre><code>自研移动端</code>、<code>web端</code>、<code>企业微信桌面端</code>都没问题，当然喽，每一个端展示效果是不一样的，代码也不一样。排查了耗费一定时间。</li></ul><ol><li>排查 企业微信版本， 比对后发现，和正常使用的微信版本一致</li><li>排查手机版本不一致，客户iphone12和 系统版本15.1，我们开发人员是14.+，所以我把我的手机升级到最新，我的手机升级后是正常的，那么可能是数据问题，数据</li><li>排查数据，这是老系统的数据，和新系统数据走不同的业务代码，经排查也没问题</li><li>排查<code>size</code>如果不准确也会出现上述问题，由于预发环境获取票据的信息与线上是不一致的，所以无法在预发进行排查，能做的事保证代码执行到<code> const blob = new Blob([res]);</code>，并且能够获取到正确的size，所以进行了alert调试，这个在手机上比较直观，当然也可以<code>vconsole</code>【暂不考虑,因为之前开发人员没加，部门被砍掉，很多人被裁员了，所有项目都我来维护，没时间，不整了】，调试结果是size: 88214,各个手机都一样，用户手机也是88214，故排除size</li><li>最后可能问题在于，用户手机上版本与手机不匹配，有兼容性bug，尝试升级企业微信，最后解决</li></ol><br/><p>总结：如果考虑直接升级用户app版本，或许在第三步就解决问题了，我的iphoneX也不用升级到15.3了</p>]]></content>
      
      
      <categories>
          
          <category> WeWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WeWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 代码注释</title>
      <link href="//post/2022-05-26code.html"/>
      <url>//post/2022-05-26code.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p><code>//</code>这种js注释代码在vscode其他地方引用时候，没有提示， 如果需要有提示，需要写成<code>/** 提示 **/</code></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">写法1export enum ELeaveType &#123;  MATERNITY_ &#x3D; 17, &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),&#125;写法2export enum ELeaveType &#123;  &#x2F;&#x2F; &quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),  MATERNITY_ &#x3D; 17, &#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220526153244.webp"></p><h2 id="有提示注释写法"><a href="#有提示注释写法" class="headerlink" title="有提示注释写法"></a>有提示注释写法</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export enum ELeaveType &#123;...  &#x2F;**&quot;产假&amp;补充假&quot;, &quot;连续使用，预产期前15天&quot;),**&#x2F;  MATERNITY_ &#x3D; 17, ...&#125;</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220526153709.webp"></p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux 源码 2</title>
      <link href="//post/2022-05-25.redux2.html"/>
      <url>//post/2022-05-25.redux2.html</url>
      
        <content type="html"><![CDATA[<h2 id="redux-简介"><a href="#redux-简介" class="headerlink" title="redux 简介"></a>redux 简介</h2><p>Predictable state container for JavaScript apps</p><p>字面意思</p><p>js应用可预测状态容器</p><p><img src="http://t-blog-images.aijs.top/img/20220527091836.webp"></p><h2 id="怎么用，为什么用"><a href="#怎么用，为什么用" class="headerlink" title="怎么用，为什么用"></a>怎么用，为什么用</h2><p><a href="https://redux.js.org/">看官网。。。</a></p><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><p><strong>代码注释如下</strong></p><ul><li>redux store持有state树，唯一可以改变store中数据的方式是dispatch</li><li>在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer</li><li>一个根据当前state和行为返回新state的函数</li><li>初始state，</li><li>store中间件。可以使用第三方中间件增强store</li><li>redux store 可以读取state，dispatch行为，订阅改变</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call &#96;dispatch()&#96; on it. *  * redux store持有state树，唯一可以改变store中数据的方式是dispatch *  * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using &#96;combineReducers&#96;. * * 在你的app中应该有唯一一个store.为了区分不同部分响应操作的的状态树，可以将几个reducer通过combinereducers合并为一个reducer *  * @param reducer A function that returns the next state tree, given * the current state tree and the action to handle. *  * 一个根据当前state和行为返回新state的函数 * * @param preloadedState The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use &#96;combineReducers&#96; to produce the root reducer function, this must be * an object with the same shape as &#96;combineReducers&#96; keys. * * 初始state， *  * @param enhancer The store enhancer. You may optionally specify it * to enhance the store with third-party capabilities such as middleware, * time travel, persistence, etc. The only store enhancer that ships with Redux * is &#96;applyMiddleware()&#96;. * * store中间件。可以使用第三方中间件增强store *  * @returns A Redux store that lets you read the state, dispatch actions * and subscribe to changes. *  * redux store 可以读取state，dispatch行为，订阅改变 *&#x2F;</code></pre><p><strong>函数声明</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function createStore&lt;  S,  A extends Action,  Ext &#x3D; &#123;&#125;,  StateExt &#x3D; never&gt;(  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Extexport default function createStore&lt;  S,  A extends Action,  Ext &#x3D; &#123;&#125;,  StateExt &#x3D; never&gt;(  reducer: Reducer&lt;S, A&gt;, &#x2F;&#x2F; reducer  preloadedState?: PreloadedState&lt;S&gt;, &#x2F;&#x2F; &#x2F;&#x2F;初始状态  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt; &#x2F;&#x2F; 中间件): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Extexport default function createStore&lt;  S,  A extends Action,  Ext &#x3D; &#123;&#125;,  StateExt &#x3D; never&gt;(  reducer: Reducer&lt;S, A&gt;,&#x2F;&#x2F; reducer  preloadedState?: PreloadedState&lt;S&gt; | StoreEnhancer&lt;Ext, StateExt&gt;, &#x2F;&#x2F;初始状态  enhancer?: StoreEnhancer&lt;Ext, StateExt&gt;&#x2F;&#x2F; 中间件  &#x2F;&#x2F; 这里可以看到 preloadedState的参数| StoreEnhancer&lt;Ext, StateExt&gt; 与 enhancer类型一致， 这里处理第二参数可能是 enhancer  &#x2F;&#x2F; 代码主体分有做判断：  &#x2F;&#x2F; if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;  &#x2F;&#x2F;   enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;  &#x2F;&#x2F;   preloadedState &#x3D; undefined  &#x2F;&#x2F; &#125; ): Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext &#123;&#125;</code></pre><p><strong>createStore 主体代码</strong></p><ul><li>一些入参校验</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">if (  (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39;) ||  (typeof enhancer &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof arguments[3] &#x3D;&#x3D;&#x3D; &#39;function&#39;)) &#123;  throw new Error(    &#39;It looks like you are passing several store enhancers to &#39; +      &#39;createStore(). This is not supported. Instead, compose them &#39; +      &#39;together to a single function. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#creating-a-store-with-enhancers for an example.&#39;  )&#125;if (typeof preloadedState &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; typeof enhancer &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;  enhancer &#x3D; preloadedState as StoreEnhancer&lt;Ext, StateExt&gt;  preloadedState &#x3D; undefined&#125;if (typeof enhancer !&#x3D;&#x3D; &#39;undefined&#39;) &#123;  if (typeof enhancer !&#x3D;&#x3D; &#39;function&#39;) &#123;    throw new Error(      &#96;Expected the enhancer to be a function. Instead, received: &#39;$&#123;kindOf(        enhancer      )&#125;&#39;&#96;    )  &#125;  return enhancer(createStore)(    reducer,    preloadedState as PreloadedState&lt;S&gt;  ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext&#125;if (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;  throw new Error(    &#96;Expected the root reducer to be a function. Instead, received: &#39;$&#123;kindOf(      reducer    )&#125;&#39;&#96;  )&#125;&#x2F;&#x2F; 当前reducerlet currentReducer &#x3D; reducer&#x2F;&#x2F; 当前状态let currentState &#x3D; preloadedState as S&#x2F;&#x2F; 当前订阅let currentListeners: (() &#x3D;&gt; void)[] | null &#x3D; []&#x2F;&#x2F; 新的订阅let nextListeners &#x3D; currentListenerslet isDispatching &#x3D; false&#x2F;** * This makes a shallow copy of currentListeners so we can use * nextListeners as a temporary list while dispatching. * * This prevents any bugs around consumers calling * subscribe&#x2F;unsubscribe in the middle of a dispatch. *&#x2F;&#x2F;&#x2F; 浅拷贝当前currentListeners得到 nextListeners 用于 dispatching   &#x2F;&#x2F; 确定新的可变监听function ensureCanMutateNextListeners() &#123;  。。。&#125;&#x2F;&#x2F; 获取store的状态function getState(): S &#123;  。。。&#125;&#x2F;&#x2F; 传入监听，返回监听移除的函数function subscribe(listener: () &#x3D;&gt; void) &#123;  。。。  return function unsubscribe() &#123;    。。。。  &#125;&#125;function dispatch(action: A) &#123;  。。。&#125;&#x2F;&#x2F; 用于同构更新reducerfunction replaceReducer&lt;NewState, NewActions extends A&gt;(  nextReducer: Reducer&lt;NewState, NewActions&gt;): Store&lt;ExtendState&lt;NewState, StateExt&gt;, NewActions, StateExt, Ext&gt; &amp; Ext &#123;  。。。&#125;&#x2F;** * Interoperability point for observable&#x2F;reactive libraries. * @returns A minimal observable of state changes. * For more information, see the observable proposal: * https:&#x2F;&#x2F;github.com&#x2F;tc39&#x2F;proposal-observable *&#x2F;&#x2F;&#x2F; 实现小型观察状态变更function observable() &#123;  。。。&#125;&#x2F;&#x2F; 当store被创建，初始化操作会被dispatch，，每个reducer会返回最初的state. 有效地填充初始状态树。dispatch(&#123; type: ActionTypes.INIT &#125; as A)const store &#x3D; &#123;  dispatch: dispatch as Dispatch&lt;A&gt;,  subscribe,  getState,  replaceReducer,  [$$observable]: observable&#125; as unknown as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Extreturn store &#x2F;&#x2F; store上的api我们又熟悉了</code></pre><p><strong>ensureCanMutateNextListeners</strong></p><ul><li>浅拷贝当前currentListeners得到 nextListeners 用于 dispatching</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function ensureCanMutateNextListeners() &#123;  if (nextListeners &#x3D;&#x3D;&#x3D; currentListeners) &#123;    nextListeners &#x3D; currentListeners.slice()  &#125;&#125;</code></pre><p><strong>getState</strong></p><ul><li>获取store的状态</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getState(): S &#123;  if (isDispatching) &#123;    throw new Error(      &#39;You may not call store.getState() while the reducer is executing. &#39; +        &#39;The reducer has already received the state as an argument. &#39; +        &#39;Pass it down from the top reducer instead of reading it from the store.&#39;    )  &#125;  return currentState as S&#125;</code></pre><p><strong>subscribe</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;**   * Adds a change listener. It will be called any time an action is dispatched,   * and some part of the state tree may potentially have changed. You may then   * call &#96;getState()&#96; to read the current state tree inside the callback.   *   * You may call &#96;dispatch()&#96; from a change listener, with the following   * caveats:   *   * 1. The subscriptions are snapshotted just before every &#96;dispatch()&#96; call.   * If you subscribe or unsubscribe while the listeners are being invoked, this   * will not have any effect on the &#96;dispatch()&#96; that is currently in progress.   * However, the next &#96;dispatch()&#96; call, whether nested or not, will use a more   * recent snapshot of the subscription list.   *   * 2. The listener should not expect to see all state changes, as the state   * might have been updated multiple times during a nested &#96;dispatch()&#96; before   * the listener is called. It is, however, guaranteed that all subscribers   * registered before the &#96;dispatch()&#96; started will be called with the latest   * state by the time it exits.   *   * @param listener A callback to be invoked on every dispatch.   * @returns A function to remove this change listener.   *&#x2F;  &#x2F;&#x2F; 上述注释  &#x2F;** 添加一个监听，在action被触发时候会调用，state会进行更新，在回调中可以用getState方法获取当前状态树   * 两个注意：订阅的是在每个dispatch之前的快照，   * 1.   * 订阅是在每次&#39;dispatch（）&#39;调用之前进行快照的。   * 如果在调用侦听器时订阅或取消订阅，这将不会对当前正在进行的“dispatch（）”产生任何影响。   * 但是，下一个&#39;dispatch（）&#39;调用（无论是否嵌套）将使用订阅列表的最新快照。   * 2。   * 监听器不应该期望看到所有的状态更改，因为在调用监听器之前，状态可能在嵌套的&#39;dispatch（）&#39;期间被多次更新。   * 但是，可以保证在“dispatch（）”启动之前注册的所有订阅者在退出时都将以最新状态调用。   * *&#x2F;  function subscribe(listener: () &#x3D;&gt; void) &#123;    if (typeof listener !&#x3D;&#x3D; &#39;function&#39;) &#123;      throw new Error(        &#96;Expected the listener to be a function. Instead, received: &#39;$&#123;kindOf(          listener        )&#125;&#39;&#96;      )    &#125;    if (isDispatching) &#123;      throw new Error(        &#39;You may not call store.subscribe() while the reducer is executing. &#39; +          &#39;If you would like to be notified after the store has been updated, subscribe from a &#39; +          &#39;component and invoke store.getState() in the callback to access the latest state. &#39; +          &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;      )    &#125;    let isSubscribed &#x3D; true    ensureCanMutateNextListeners()    nextListeners.push(listener) &#x2F;&#x2F; 增加    return function unsubscribe() &#123;      if (!isSubscribed) &#123;        return      &#125;      if (isDispatching) &#123;        throw new Error(          &#39;You may not unsubscribe from a store listener while the reducer is executing. &#39; +            &#39;See https:&#x2F;&#x2F;redux.js.org&#x2F;api&#x2F;store#subscribelistener for more details.&#39;        )      &#125;      isSubscribed &#x3D; false      ensureCanMutateNextListeners()      const index &#x3D; nextListeners.indexOf(listener)      nextListeners.splice(index, 1) &#x2F;&#x2F; 移除      currentListeners &#x3D; null    &#125;  &#125;</code></pre><p><strong>dispatch</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;** * Dispatches an action. It is the only way to trigger a state change. * * The &#96;reducer&#96; function, used to create the store, will be called with the * current state tree and the given &#96;action&#96;. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the &#96;redux-thunk&#96; package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling &#96;redux-devtools&#96;. An action must have * a &#96;type&#96; property which may not be &#96;undefined&#96;. It is a good idea to use * string constants for action types. * * @returns For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap &#96;dispatch()&#96; to * return something else (for example, a Promise you can await). *&#x2F;function dispatch(action: A) &#123;  if (!isPlainObject(action)) &#123; &#x2F;&#x2F; 只能是简单的对象    throw new Error(      &#96;Actions must be plain objects. Instead, the actual type was: &#39;$&#123;kindOf(        action      )&#125;&#39;. You may need to add middleware to your store setup to handle dispatching other values, such as &#39;redux-thunk&#39; to handle dispatching functions. See https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-4-store#middleware and https:&#x2F;&#x2F;redux.js.org&#x2F;tutorials&#x2F;fundamentals&#x2F;part-6-async-logic#using-the-redux-thunk-middleware for examples.&#96;    )  &#125;  if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;    throw new Error(      &#39;Actions may not have an undefined &quot;type&quot; property. You may have misspelled an action type string constant.&#39;    )  &#125;  if (isDispatching) &#123;    throw new Error(&#39;Reducers may not dispatch actions.&#39;)  &#125;  try &#123;    isDispatching &#x3D; true    currentState &#x3D; currentReducer(currentState, action) &#x2F;&#x2F; 传入当前状态和操作，返回新的状态  &#125; finally &#123;    isDispatching &#x3D; false  &#125;  const listeners &#x3D; (currentListeners &#x3D; nextListeners) &#x2F;&#x2F; 触发更新  for (let i &#x3D; 0; i &lt; listeners.length; i++) &#123;    const listener &#x3D; listeners[i]    listener()  &#125;  return action&#125;</code></pre><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><ul><li>使用时候以键值对形式存在</li></ul><p><strong>使用</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">import useInfoReducer from &#39;.&#x2F;userInfo&#39;import recordReducer from &#39;.&#x2F;record&#39;const rootReducer &#x3D; combineReducers(&#123;  useInfoReducer,  recordReducer&#125;)const store &#x3D; createStore(rootReducer)</code></pre><p><strong>源码</strong></p><ul><li>返回不期望的state型警告信息</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getUnexpectedStateShapeWarningMessage(  inputState: object,  reducers: ReducersMapObject,  action: Action,  unexpectedKeyCache: &#123; [key: string]: true &#125;) &#123;  const reducerKeys &#x3D; Object.keys(reducers)  const argumentName &#x3D;    action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.INIT      ? &#39;preloadedState argument passed to createStore&#39;      : &#39;previous state received by the reducer&#39;  if (reducerKeys.length &#x3D;&#x3D;&#x3D; 0) &#123;    return (      &#39;Store does not have a valid reducer. Make sure the argument passed &#39; +      &#39;to combineReducers is an object whose values are reducers.&#39;    )  &#125;  if (!isPlainObject(inputState)) &#123;    return (      &#96;The $&#123;argumentName&#125; has unexpected type of &quot;$&#123;kindOf(        inputState      )&#125;&quot;. Expected argument to be an object with the following &#96; +      &#96;keys: &quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;&#96;    )  &#125;  const unexpectedKeys &#x3D; Object.keys(inputState).filter(    key &#x3D;&gt; !reducers.hasOwnProperty(key) &amp;&amp; !unexpectedKeyCache[key]  )  unexpectedKeys.forEach(key &#x3D;&gt; &#123;    unexpectedKeyCache[key] &#x3D; true  &#125;)  if (action &amp;&amp; action.type &#x3D;&#x3D;&#x3D; ActionTypes.REPLACE) return  if (unexpectedKeys.length &gt; 0) &#123;    return (      &#96;Unexpected $&#123;unexpectedKeys.length &gt; 1 ? &#39;keys&#39; : &#39;key&#39;&#125; &#96; +      &#96;&quot;$&#123;unexpectedKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot; found in $&#123;argumentName&#125;. &#96; +      &#96;Expected to find one of the known reducer keys instead: &#96; +      &#96;&quot;$&#123;reducerKeys.join(&#39;&quot;, &quot;&#39;)&#125;&quot;. Unexpected keys will be ignored.&#96;    )  &#125;&#125; &#x2F;&#x2F; 对 reducer型进行断言function assertReducerShape(reducers: ReducersMapObject) &#123;  Object.keys(reducers).forEach(key &#x3D;&gt; &#123;    const reducer &#x3D; reducers[key]    const initialState &#x3D; reducer(undefined, &#123; type: ActionTypes.INIT &#125;)    if (typeof initialState &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;      throw new Error(         &#x2F;&#x2F; 初始化initialState时候可以用null,但是不可以用undefined        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined during initialization. &#96; +          &#96;If the state passed to the reducer is undefined, you must &#96; +          &#96;explicitly return the initial state. The initial state may &#96; +          &#96;not be undefined. If you don&#39;t want to set a value for this reducer, &#96; +          &#96;you can use null instead of undefined.&#96;      )    &#125;    if (      typeof reducer(undefined, &#123;        type: ActionTypes.PROBE_UNKNOWN_ACTION()      &#125;) &#x3D;&#x3D;&#x3D; &#39;undefined&#39;    ) &#123;      throw new Error(         &#x2F;&#x2F; 1.随机类型&#x2F; redux&#x2F;*类型 的操作类型为redux私有，不允许使用         &#x2F;&#x2F; 2.初始化状态不可以是undefined,         &#x2F;&#x2F; 3.新状态如果是undefined的，必须返回初始状态        &#96;The slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined when probed with a random type. &#96; +          &#96;Don&#39;t try to handle &#39;$&#123;ActionTypes.INIT&#125;&#39; or other actions in &quot;redux&#x2F;*&quot; &#96; +          &#96;namespace. They are considered private. Instead, you must return the &#96; +          &#96;current state for any unknown actions, unless it is undefined, &#96; +          &#96;in which case you must return the initial state, regardless of the &#96; +          &#96;action type. The initial state may not be undefined, but can be null.&#96;      )    &#125;  &#125;)&#125;&#x2F;&#x2F; combineReducers的实现，其实就是将多个值，合并在一个对象中export default function combineReducers(reducers: ReducersMapObject) &#123;  const reducerKeys &#x3D; Object.keys(reducers)  const finalReducers: ReducersMapObject &#x3D; &#123;&#125;  for (let i &#x3D; 0; i &lt; reducerKeys.length; i++) &#123;    const key &#x3D; reducerKeys[i]    if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;      finalReducers[key] &#x3D; reducers[key]    &#125;  &#125;  const finalReducerKeys &#x3D; Object.keys(finalReducers)  &#x2F;&#x2F; This is used to make sure we don&#39;t warn about the same  &#x2F;&#x2F; keys multiple times.  &#x2F;&#x2F;这用于确保我们不会多次警告相同的key。  let unexpectedKeyCache: &#123; [key: string]: true &#125;  return function combination(    state: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;,    action: AnyAction  ) &#123;    &#x2F;&#x2F;校验信息...    let hasChanged &#x3D; false    const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; &#x3D; &#123;&#125;    for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;      const key &#x3D; finalReducerKeys[i]      &#x2F;&#x2F; reducer      const reducer &#x3D; finalReducers[key]      &#x2F;&#x2F; 之前状态      const previousStateForKey &#x3D; state[key]      &#x2F;&#x2F; 新状态      const nextStateForKey &#x3D; reducer(previousStateForKey, action)      if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;        const actionType &#x3D; action &amp;&amp; action.type        throw new Error(          &#96;When called with an action of type $&#123;            actionType ? &#96;&quot;$&#123;String(actionType)&#125;&quot;&#96; : &#39;(unknown type)&#39;          &#125;, the slice reducer for key &quot;$&#123;key&#125;&quot; returned undefined. &#96; +            &#96;To ignore an action, you must explicitly return the previous state. &#96; +            &#96;If you want this reducer to hold no value, you can return null instead of undefined.&#96;        )      &#125;      nextState[key] &#x3D; nextStateForKey      &#x2F;&#x2F; 判断是否发生更新      hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey    &#125;    hasChanged &#x3D;      hasChanged || finalReducerKeys.length !&#x3D;&#x3D; Object.keys(state).length      &#x2F;&#x2F; 更新返回新的状态，否则返回之前状态    return hasChanged ? nextState : state  &#125;&#125;</code></pre><h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><ul><li>给action包裹层dispatch</li><li>action有两种类型： 函数、键值对</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function bindActionCreators(  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,  dispatch: Dispatch) &#123;  &#x2F;&#x2F; 函数类型直接bindActionCreator返回  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;    return bindActionCreator(actionCreators, dispatch)  &#125;  if (typeof actionCreators !&#x3D;&#x3D; &#39;object&#39; || actionCreators &#x3D;&#x3D;&#x3D; null) &#123;    throw new Error(      &#96;bindActionCreators expected an object or a function, but instead received: &#39;$&#123;kindOf(        actionCreators      )&#125;&#39;. &#96; +        &#96;Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?&#96;    )  &#125;  const boundActionCreators: ActionCreatorsMapObject &#x3D; &#123;&#125;  &#x2F;&#x2F; 对象遍历调用bindActionCreator  for (const key in actionCreators) &#123;    const actionCreator &#x3D; actionCreators[key]    if (typeof actionCreator &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;      boundActionCreators[key] &#x3D; bindActionCreator(actionCreator, dispatch)    &#125;  &#125;  return boundActionCreators&#125;</code></pre><p><strong>使用及测试代码见</strong></p><p><code>redux/test/typescript/actionCreators.ts</code></p><p><strong>bindActionCreator</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 作用是每个actionCreator增加一个dispatch包裹function bindActionCreator&lt;A extends AnyAction &#x3D; AnyAction&gt;(  actionCreator: ActionCreator&lt;A&gt;,  dispatch: Dispatch) &#123;  return function (this: any, ...args: any[]) &#123;    return dispatch(actionCreator.apply(this, args)) &#x2F;&#x2F; 主要代码  &#125;&#125;</code></pre><h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><ul><li>中间件</li><li>对store能力进行增强</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function applyMiddleware(  ...middlewares: Middleware[]): StoreEnhancer&lt;any&gt; &#123;  return (createStore: StoreEnhancerStoreCreator) &#x3D;&gt;    &lt;S, A extends AnyAction&gt;(      reducer: Reducer&lt;S, A&gt;,      preloadedState?: PreloadedState&lt;S&gt;    ) &#x3D;&gt; &#123;      const store &#x3D; createStore(reducer, preloadedState)      &#x2F;&#x2F; 声明      let dispatch: Dispatch &#x3D; () &#x3D;&gt; &#123;        throw new Error(          &#39;Dispatching while constructing your middleware is not allowed. &#39; +            &#39;Other middleware would not be applied to this dispatch.&#39;        )      &#125;      const middlewareAPI: MiddlewareAPI &#x3D; &#123;        getState: store.getState,                                      &#x2F;&#x2F;使用上述函数进行        dispatch: (action, ...args) &#x3D;&gt; dispatch(action, ...args)      &#125;      &#x2F;&#x2F; 中间件数组      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))      &#x2F;&#x2F; 增强的是dispatch      dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)      return &#123;        ...store,        dispatch      &#125;    &#125;&#125;&#96;&#96;&#96;ts      const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))            dispatch &#x3D; compose&lt;typeof dispatch&gt;(...chain)(store.dispatch)      return &#123;        ...store,        dispatch      &#125;    &#125;&#125;</code></pre><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><ul><li>洋葱模型</li></ul><p><strong>使用</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">compose(f, g, h)(...args) &#x3D;&gt; f(g(h(...args)))</code></pre><p><strong>源码</strong></p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function compose(...funcs: Function[]) &#123;  &#x2F;&#x2F; 参数长度判断  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F; infer the argument type so it is usable in inference down the line    return &lt;T&gt;(arg: T) &#x3D;&gt; arg  &#125;  &#x2F;&#x2F; 长度为1  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;    return funcs[0]  &#125;  &#x2F;&#x2F; 主要代码一行  return funcs.reduce((a, b) &#x3D;&gt; (...args: any) &#x3D;&gt;  a(b(...args)))&#125;</code></pre><p><strong>讲compose的文章</strong></p><p><a href="http://givencui.com/index.php/archives/28/" target="_blank" >这里有一篇非常好</a></p><h2 id="DO-NOT-USE-ActionTypes"><a href="#DO-NOT-USE-ActionTypes" class="headerlink" title="__DO_NOT_USE__ActionTypes"></a>__DO_NOT_USE__ActionTypes</h2><ul><li>一些私有的action被redux保留，对于不明确的action，必须返回当前state.</li><li>如果当前状态是undefined,必须返回初始状态</li><li>不要在代码中直接涉及这些action</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const ActionTypes &#x3D; &#123;  INIT: &#96;@@redux&#x2F;INIT$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,  REPLACE: &#96;@@redux&#x2F;REPLACE$&#123;&#x2F;* #__PURE__ *&#x2F; randomString()&#125;&#96;,  PROBE_UNKNOWN_ACTION: () &#x3D;&gt; &#96;@@redux&#x2F;PROBE_UNKNOWN_ACTION$&#123;randomString()&#125;&#96;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="http://t-blog-images.aijs.top/img/redux源码内容.png"/><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="http://t-blog-images.aijs.top/img/20220527091836.webp"></p><h2 id="巩固"><a href="#巩固" class="headerlink" title="巩固"></a>巩固</h2><p><img src="http://t-blog-images.aijs.top/img/20220527095407.webp"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/u_15283585/2958523">最精简的Redux源码解析，看完从此再也不怕面试官</a><br><a href="https://www.jianshu.com/p/490fc0d89029">Redux 源码解析</a><br><a href="https://github.com/841660202/redux">github 源码</a></p>]]></content>
      
      
      <categories>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux 源码 1</title>
      <link href="//post/2022-05-25.redux.html"/>
      <url>//post/2022-05-25.redux.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>A Predictable State Container for JS Apps</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;redux&quot;,  &quot;version&quot;: &quot;5.0.0-alpha.0&quot;,  &quot;description&quot;: &quot;Predictable state container for JavaScript apps&quot;,  &quot;keywords&quot;: [    &quot;redux&quot;,    &quot;reducer&quot;,  &#x2F;&#x2F; reducer, redux构成组成之一    &quot;state&quot;,    &#x2F;&#x2F; 状态管理    &quot;predictable&quot;,   &#x2F;&#x2F; 可预测的    &quot;functional&quot;,    &#x2F;&#x2F; 纯函数的    &quot;immutable&quot;,     &#x2F;&#x2F; 不可变的    &quot;hot&quot;,    &quot;live&quot;,    &quot;replay&quot;,        &#x2F;&#x2F; 回放    &quot;flux&quot;,          &#x2F;&#x2F; redux对flux的改进    &quot;elm&quot;            &#x2F;&#x2F; Elm 是一门专注于Web前端的纯函数式语言, reducer受elm启发  ],  &#x2F;&#x2F; 入口  &quot;main&quot;: &quot;lib&#x2F;redux.js&quot;,  &#x2F;&#x2F; unpkg 是一个内容源自 npm 的全球快速 CDN, 它能以快速而简单的方式提供任意包、任意文件，通过类似这样的 URL ：unpkg.com&#x2F;:package@:version&#x2F;:file  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.3&#x2F;dist&#x2F;redux.min.js 是对应redux@4.0.3版本的压缩后的js文件  &#x2F;&#x2F; 当你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux ——根据package.json配置的unpkg, 重定向为--—&gt; https:&#x2F;&#x2F;unpkg.com&#x2F;redux@4.0.4&#x2F;dist&#x2F;redux.js , 做了两次重定向  &#x2F;&#x2F; 如何你访问: https:&#x2F;&#x2F;unpkg.com&#x2F;redux&#x2F; (注意redux后有&#x2F;), 是一个页面  &quot;unpkg&quot;: &quot;dist&#x2F;redux.js&quot;, &#x2F;&#x2F; 用unpkg的裸url访问时, 指定到该文件  &#x2F;**    module      点击 Setting up multi-platform npm packages 查看相关介绍。      就像 main 字段一样，定义一个针对 es6 模块及语法的入口文件。      构建工具在构建项目的时候，如果发现了这个字段，会首先使用这个字段指向的文件，如果未定义，则回退到 main 字段指向的文件。      支持的工具：      rollup      webpack  **&#x2F;  &quot;module&quot;: &quot;es&#x2F;redux.js&quot;,&#x2F;&#x2F; TypeScript是javascript 的超集, typings&#x2F;types字段, 定义了TypeScript的入口文件  &quot;types&quot;: &quot;types&#x2F;index.d.ts&quot;,  &#x2F;&#x2F; 发布上传内容  &#x2F;&#x2F; 是一个可选字段, 用来描述作将软件包作为依赖项安装时要包含的条目, 相当于白名单, 类似.gitignore类似的语法, files字段中包含的文件不能通过.npmignore或.gitignore排除  &quot;files&quot;: [    &quot;dist&quot;,    &quot;lib&quot;,    &quot;es&quot;,    &quot;src&quot;,    &quot;types&quot;  ],  &quot;scripts&quot;: &#123;    ...  &#125;,  &#x2F;&#x2F; 表示在生产环境下使用该依赖, 对应 npm install xx -S 或 npm install xx --save  &quot;dependencies&quot;: &#123;    &quot;@babel&#x2F;runtime&quot;: &quot;^7.16.7&quot;  &#125;,  &#x2F;&#x2F; 表示仅在开发环境下使用, 不会在生产环境中使用的依赖, 对应 npm install xx -D 或 npm install xx --save-dev  &quot;devDependencies&quot;: &#123;   ...  &#125;,  &quot;npmName&quot;: &quot;redux&quot;,  &#x2F;&#x2F; npm文件映射。把需要同步到 cdnjs 的文件配置在这里。  &quot;npmFileMap&quot;: [    &#123;      &quot;basePath&quot;: &quot;&#x2F;dist&#x2F;&quot;,      &quot;files&quot;: [        &quot;*.js&quot;      ]    &#125;  ],  &#x2F;&#x2F; webpack相关字段, 声明该模块是否包含 sideEffects（副作用），从而可以为 tree-shaking 提供更大的优化空间。  &quot;sideEffects&quot;: false&#125;</code></pre><h2 id="version字段"><a href="#version字段" class="headerlink" title="version字段"></a>version字段</h2><p>包的版本, 必须有, 要符合<a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning guidelines</a>, 参考 <a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a>, 建议仔细通读<br><img src="http://t-blog-images.aijs.top/img/20220525140247.webp" width=600 style="object-fit: content"/></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://givencui.com/index.php/archives/29/">配合redux项目深度了解package.json</a><br><a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning guidelines</a><br><a href="https://semver.org/lang/zh-CN/">语义化版本控制规范</a></p><h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.├── applyMiddleware.ts├── bindActionCreators.ts├── combineReducers.ts├── compose.ts├── createStore.ts├── index.ts├── types│   ├── actions.ts│   ├── middleware.ts│   ├── reducers.ts│   └── store.ts└── utils    ├── actionTypes.ts    ├── formatProdErrorMessage.ts    ├── isPlainObject.ts    ├── kindOf.ts    ├── symbol-observable.ts    └── warning.ts2 directories, 16 files</code></pre><h2 id="index-ts"><a href="#index-ts" class="headerlink" title="index.ts"></a>index.ts</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export &#123;  createStore,  combineReducers,  bindActionCreators,  applyMiddleware,  compose,  __DO_NOT_USE__ActionTypes&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux  源码2</title>
      <link href="//post/2022-05-24react-redux2.html"/>
      <url>//post/2022-05-24react-redux2.html</url>
      
        <content type="html"><![CDATA[<p>源码版本<code>&quot;version&quot;: &quot;8.0.2&quot;,</code></p><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><ul><li>主要作用通过subscription调用redux中store的subscription产生订阅，订阅内容是onStateChange的回调</li><li>通过react的Provider功能，提供传递给根的store和根的subscription给后续使用了connect的组件</li></ul><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;* provider 组件代码 *&#x2F;function Provider(&#123; store, context, children &#125;) &#123;   &#x2F;* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  *&#x2F;   const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;      &#x2F;* 创建了一个根 Subscription 订阅器 *&#x2F;    const subscription &#x3D; new Subscription(store)    &#x2F;* subscription 的 notifyNestedSubs 方法 ，赋值给  onStateChange方法 *&#x2F;    &#x2F;&#x2F;onStateChange就是之后触发的listenr    subscription.onStateChange &#x3D; subscription.notifyNestedSubs      return &#123;      store,      subscription    &#125; &#x2F;*  store 改变创建新的contextValue *&#x2F;  &#125;, [store])  &#x2F;*  获取更新之前的state值 ，函数组件里面的上下文要优先于组件更新渲染  *&#x2F;  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])  useEffect(() &#x3D;&gt; &#123;    const &#123; subscription &#125; &#x3D; contextValue    &#x2F;* 触发trySubscribe方法执行，创建listens *&#x2F;    subscription.trySubscribe() &#x2F;&#x2F; 发起订阅    if (previousState !&#x3D;&#x3D; store.getState()) &#123;        &#x2F;* 组件更新渲染之后，如果此时state发生改变，那么立即触发 subscription.notifyNestedSubs 方法  *&#x2F;        &#x2F;&#x2F;触发所有的listener      subscription.notifyNestedSubs()     &#125;    &#x2F;*   *&#x2F;    return () &#x3D;&gt; &#123;      subscription.tryUnsubscribe()  &#x2F;&#x2F; 卸载订阅      subscription.onStateChange &#x3D; null    &#125;    &#x2F;*  contextValue state 改变出发新的 effect *&#x2F;  &#125;, [contextValue, previousState])  &#x2F;&#x2F;若Provider没有显示传入context，则为使用React.createContext创建的上下文  const Context &#x3D; context || ReactReduxContext  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt;&#125;</code></pre><h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><ul><li>订阅消息、发起更新</li><li>在根的Provider的作用是调用redux中store的订阅方法，将根的onStateChange进行订阅</li><li>在子代中是收集所有被 connect 包裹的组件中的Subscription的更新函数 onstatechange，然后形成一个 callback 链表，再由父级 Subscription 统一派发执行更新，只会往上传递一层，不会一直传递使得每一个上级都有自身的更新函数</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;* 发布订阅者模式 *&#x2F;export default class Subscription &#123;  constructor(store, parentSub) &#123;    this.store &#x3D; store    this.parentSub &#x3D; parentSub    this.unsubscribe &#x3D; null    this.listeners &#x3D; nullListeners    this.handleChangeWrapper &#x3D; this.handleChangeWrapper.bind(this)  &#125;  &#x2F;* 负责检测是否该组件订阅，然后添加订阅者也就是listener *&#x2F;    &#x2F;&#x2F;当父代调用过trySubscribe后，子代再调用，因为this.unsubscribe有值，所以并不会实际执行父代的trySubscribe，而只是将listener放进父代中管理  addNestedSub(listener) &#123;    this.trySubscribe()    return this.listeners.subscribe(listener)  &#125;  &#x2F;* 向listeners发布通知 *&#x2F;  notifyNestedSubs() &#123;    this.listeners.notify()  &#125;  &#x2F;* 对于 Provide onStateChange 就是 notifyNestedSubs 方法，  对于 connect 包裹接受更新的组件 ，onStateChange 就是 负责更新组件的函数 。   *&#x2F;  handleChangeWrapper() &#123;    if (this.onStateChange) &#123;      this.onStateChange()    &#125;  &#125;   &#x2F;* 判断有没有开启订阅 *&#x2F;  isSubscribed() &#123;    return Boolean(this.unsubscribe)  &#125;  &#x2F;* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 *&#x2F;  trySubscribe() &#123;    &#x2F;*    parentSub即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription    *&#x2F;    &#x2F;&#x2F;当Subscription执行过一次改方法后，再调用因为this.unsubscribe有值    &#x2F;&#x2F;所以该方法调用一次后就不会再被调用了    &#x2F;&#x2F;意味着addNestedSub中只会添加listener，而不会再调用trySubscribe，使得listener不会往上传递    if (!this.unsubscribe) &#123;      this.unsubscribe &#x3D; this.parentSub        ? this.parentSub.addNestedSub(this.handleChangeWrapper)        &#x2F;* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   *&#x2F;        : this.store.subscribe(this.handleChangeWrapper)      this.listeners &#x3D; createListenerCollection()    &#125;  &#125;  &#x2F;* 取消订阅 *&#x2F;  tryUnsubscribe() &#123;    if (this.unsubscribe) &#123;      this.unsubscribe()      this.unsubscribe &#x3D; null      this.listeners.clear()      this.listeners &#x3D; nullListeners    &#125;  &#125;&#125;</code></pre><ul><li>首先Provider创建 Subscription 时候没有第二个参数，就说明provider 中的Subscription 不存在 parentSub 。</li><li>那么再调用Provider组件中useEffect钩子中trySubscribe的时候,会触发this.store.subscribe , subscribe 就是 redux 的 subscribe ,此时真正发起了订阅</li><li>订阅的内容是notifyNestedSubs，即通知根管理的listeners触发<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">subscription.onStateChange &#x3D; subscription.notifyNestedSubs &#x2F;* 向listeners发布通知 *&#x2F;notifyNestedSubs() &#123;  this.listeners.notify()&#125;</code></pre><h2 id="createListenerCollection"><a href="#createListenerCollection" class="headerlink" title="createListenerCollection"></a>createListenerCollection</h2>通过双向链表的结构管理每一个listener<br>以链表的形式收集对应的 listeners (每一个Subscription) 的handleChangeWrapper函数即onStateChange。<br>通过 batch 方法( react-dom 中的 unstable_batchedUpdates ) 来进行批量更新，许将一次事件循环中的所有 React 更新都一起批量处理到一个渲染过程中。<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">import &#123; unstable_batchedUpdates as batch &#125; from &#39;.&#x2F;utils&#x2F;reactBatchedUpdates&#39;setBatch(batch)function createListenerCollection() &#123;   &#x2F;* batch 由getBatch得到的 unstable_batchedUpdates 方法 *&#x2F;  const batch &#x3D; getBatch()  let first &#x3D; null  let last &#x3D; null  return &#123;    &#x2F;* 清除当前listeners的所有listener *&#x2F;    clear() &#123;      first &#x3D; null      last &#x3D; null    &#125;,    &#x2F;* 派发更新 *&#x2F;    notify() &#123;      batch(() &#x3D;&gt; &#123;        let listener &#x3D; first        while (listener) &#123;          listener.callback()          listener &#x3D; listener.next        &#125;      &#125;)    &#125;,    &#x2F;* 获取listeners的所有listener *&#x2F;    get() &#123;      let listeners &#x3D; []      let listener &#x3D; first      while (listener) &#123;        listeners.push(listener)        listener &#x3D; listener.next      &#125;      return listeners    &#125;,     &#x2F;* 接收订阅，将当前的callback（handleChangeWrapper）存到当前的链表中  *&#x2F;    subscribe(callback) &#123;      let isSubscribed &#x3D; true      let listener &#x3D; (last &#x3D; &#123;        callback,        next: null,        prev: last &#x2F;&#x2F;首次last为空      &#125;)         if (listener.prev) &#123;        listener.prev.next &#x3D; listener      &#125; else &#123;        first &#x3D; listener      &#125;      &#x2F;* 取消当前 handleChangeWrapper 的订阅*&#x2F;      return function unsubscribe() &#123;        if (!isSubscribed || first &#x3D;&#x3D;&#x3D; null) return        isSubscribed &#x3D; false&#x2F;&#x2F;双向链表删除节点的操作        if (listener.next) &#123;          listener.next.prev &#x3D; listener.prev        &#125; else &#123;          last &#x3D; listener.prev        &#125;        if (listener.prev) &#123;          listener.prev.next &#x3D; listener.next        &#125; else &#123;          first &#x3D; listener.next        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2>基本使用<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)const mapStateToProps &#x3D; state &#x3D;&gt; (&#123; todos: state.todos &#125;)const mapDispatchToProps &#x3D; dispatch &#x3D;&gt; &#123;  return &#123;    increment: () &#x3D;&gt; dispatch(&#123; type: &#39;INCREMENT&#39; &#125;),    decrement: () &#x3D;&gt; dispatch(&#123; type: &#39;DECREMENT&#39; &#125;),    reset: () &#x3D;&gt; dispatch(&#123; type: &#39;RESET&#39; &#125;)  &#125;&#125;&#x2F;** stateProps , state 映射到 props 中的内容* dispatchProps， dispatch 映射到 props 中的内容。* ownProps 组件本身的 props当未传递时，默认的合并规则为&#123; ...ownProps, ...stateProps, ...dispatchProps &#125;*&#x2F;mergeProps&#x3D;(stateProps, dispatchProps, ownProps) &#x3D;&gt; Objectoptions&#x3D;&#123;  context?: Object,   &#x2F;&#x2F; 自定义上下文  pure?: boolean, &#x2F;&#x2F; 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。  areStatesEqual?: Function, &#x2F;&#x2F; 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean  areOwnPropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) &#x3D;&gt; boolean  areStatePropsEqual?: Function, &#x2F;&#x2F; 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) &#x3D;&gt; boolean  areMergedPropsEqual?: Function, &#x2F;&#x2F; 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) &#x3D;&gt; boolean  forwardRef?: boolean, &#x2F;&#x2F;当为true 时候,可以通过ref 获取被connect包裹的组件实例。&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/20220525105732.webp"></li></ul><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;** * Connects a React component to a Redux store. * * - Without arguments, just wraps the component, without changing the behavior &#x2F; props * * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior * is to override ownProps (as stated in the docs), so what remains is everything that&#39;s * not a state or dispatch prop * * - When 3rd param is passed, we don&#39;t know if ownProps propagate and whether they * should be valid component props, because it depends on mergeProps implementation. * As such, it is the user&#39;s responsibility to extend ownProps interface from state or * dispatch props or both when applicable * * @param mapStateToProps A function that extracts values from state * @param mapDispatchToProps Setup for dispatching actions * @param mergeProps Optional callback to merge state and dispatch props together * @param options Options for configuring the connection * *&#x2F;function connect&lt;  TStateProps &#x3D; &#123;&#125;,  TDispatchProps &#x3D; &#123;&#125;,  TOwnProps &#x3D; &#123;&#125;,  TMergedProps &#x3D; &#123;&#125;,  State &#x3D; unknown&gt;(  mapStateToProps?: MapStateToPropsParam&lt;TStateProps, TOwnProps, State&gt;,  mapDispatchToProps?: MapDispatchToPropsParam&lt;TDispatchProps, TOwnProps&gt;,  mergeProps?: MergeProps&lt;TStateProps, TDispatchProps, TOwnProps, TMergedProps&gt;,  &#123;    &#x2F;&#x2F; The &#96;pure&#96; option has been removed, so TS doesn&#39;t like us destructuring this to check its existence.    &#x2F;&#x2F; @ts-ignore    pure,    areStatesEqual &#x3D; strictEqual,    areOwnPropsEqual &#x3D; shallowEqual,    areStatePropsEqual &#x3D; shallowEqual,    areMergedPropsEqual &#x3D; shallowEqual,    &#x2F;&#x2F; use React&#39;s forwardRef to expose a ref of the wrapped component    forwardRef &#x3D; false,    &#x2F;&#x2F; the context consumer to use    context &#x3D; ReactReduxContext,  &#125;: ConnectOptions&lt;unknown, unknown, unknown, unknown&gt; &#x3D; &#123;&#125;): unknown &#123;    const Context &#x3D; context  &#x2F;*  * stateProps , state 映射到 props 中的内容  * dispatchProps， dispatch 映射到 props 中的内容。  * ownProps 组件本身的 props  当未传递时，默认的合并规则为  &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;  *&#x2F; &#x2F;* 经过代理包装后的 mapStateToProps,完成传入store等操作*&#x2F;  const initMapStateToProps &#x3D; mapStateToPropsFactory(mapStateToProps)  &#x2F;* 经过代理包装后的 mapDispatchToProps，完成传入store.dispatch等操作*&#x2F;  const initMapDispatchToProps &#x3D; mapDispatchToPropsFactory(mapDispatchToProps)  &#x2F;* 经过代理包装后的 mergeProps，用于形成真正的 mergeProps函数，合并业务组件的 props , state 映射的 props , dispatch 映射的 props *&#x2F;  const initMergeProps &#x3D; mergePropsFactory(mergeProps)  const shouldHandleStateChanges &#x3D; Boolean(mapStateToProps)  &#x2F;&#x2F;默认的高阶组件connectAdvanced，实际渲染的组件是其中返回的一个ConnectFunction&#x2F;&#x2F;selectorFactory为整合connect更新过程中的形成新props的主要函数&#x2F;&#x2F;selectorFactory为后面的finalPropsSelectorFactory  const wrapWithConnect: AdvancedComponentDecorator&lt;    TOwnProps,    WrappedComponentProps  &gt; &#x3D; (WrappedComponent) &#x3D;&gt; &#123;    ...  &#125;&#125;</code></pre><ul><li>当我们不向connect传递第三个参数mergeProps 的时候，默认的defaultMergeProps如下，作为新的 props 传递给了业务组件</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export function defaultMergeProps(stateProps, dispatchProps, ownProps) &#123;  return &#123; ...ownProps, ...stateProps, ...dispatchProps &#125;&#125;</code></pre><h2 id="selectorFactory"><a href="#selectorFactory" class="headerlink" title="selectorFactory"></a>selectorFactory</h2><p><img src="http://t-blog-images.aijs.top/img/20220525101153.webp"></p><ul><li>首先得到真正connect 经过一层代理函数 mapStateToProps ,mapDispatchToProps ,mergeProps</li><li>然后调用selectorFactory (在pure模式下，selectorFactory 就是 pureFinalPropsSelectorFactory )<pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function finalPropsSelectorFactory(  dispatch,  &#123; initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options &#125;) &#123;  &#x2F;&#x2F; mapStateToProps mapDispatchToProps mergeProps 为真正connect 经过一层代理的 proxy 函数  const mapStateToProps &#x3D; initMapStateToProps(dispatch, options)  const mapDispatchToProps &#x3D; initMapDispatchToProps(dispatch, options)  const mergeProps &#x3D; initMergeProps(dispatch, options)  &#x2F;&#x2F;默认pure为true，selectorFactory默认为pureFinalPropsSelectorFactory  const selectorFactory &#x3D; options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory   &#x2F;&#x2F; 返回一个 函数用于生成新的 props   return selectorFactory(    mapStateToProps,    mapDispatchToProps,    mergeProps,    dispatch,    options  )&#125;</code></pre></li></ul><h2 id="pureFinalPropsSelectorFactory"><a href="#pureFinalPropsSelectorFactory" class="headerlink" title="pureFinalPropsSelectorFactory"></a>pureFinalPropsSelectorFactory</h2><p><img src="http://t-blog-images.aijs.top/img/20220525100640.webp"></p><ul><li>如果是第一次，那么直接调用mergeProps合并ownProps,stateProps,dispatchProps 形成最终的props。</li><li>如果不是第一次，那么判断到底是props还是 store.state 发生改变，然后针对那里变化，重新生成对应的props，最终合并到真正的props</li><li>整个 selectorFactory 逻辑就是形成新的props传递给我们的业务组件。</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;** pure组件处理 ， 对比 props 是否发生变化 然后 合并props *&#x2F;export function pureFinalPropsSelectorFactory(  mapStateToProps,  mapDispatchToProps,  mergeProps,  dispatch,  &#123; areStatesEqual, areOwnPropsEqual, areStatePropsEqual &#125; &#x2F;&#x2F;判断 state prop 是否相等) &#123;  let hasRunAtLeastOnce &#x3D; false  let state  let ownProps  let stateProps  let dispatchProps  let mergedProps   &#x2F;* 第一次 直接形成 ownProps  stateProps  dispatchProps 合并  形成新的 props *&#x2F;  function handleFirstCall(firstState, firstOwnProps) &#123;    state &#x3D; firstState    ownProps &#x3D; firstOwnProps    &#x2F;&#x2F;获取业务组件中mapStateToProps函数的返回值    stateProps &#x3D; mapStateToProps(state, ownProps)    &#x2F;&#x2F;获取业务组件中mapDispatchToProps函数的返回值    dispatchProps &#x3D; mapDispatchToProps(dispatch, ownProps)    &#x2F;&#x2F;合并state、dispatch、组件自身的props，形成最终传递给组件的props    mergedProps &#x3D; mergeProps(stateProps, dispatchProps, ownProps)    hasRunAtLeastOnce &#x3D; true    return mergedProps  &#125;    function handleNewPropsAndNewState() &#123;    &#x2F;&#x2F;  props 和 state 都改变  mergeProps   &#125;  function handleNewProps() &#123;    &#x2F;&#x2F; props 改变  mergeProps  &#125;  function handleNewState() &#123;     &#x2F;&#x2F; state 改变 mergeProps  &#125;  &#x2F;*  不是第一次的情况 props 或者 store.state 发生改变的情况。 *&#x2F;  function handleSubsequentCalls(nextState, nextOwnProps) &#123;      &#x2F;* 判断两次 props 是否相等 *&#x2F;    const propsChanged &#x3D; !areOwnPropsEqual(nextOwnProps, ownProps)       &#x2F;* 判断两次 store.state 是否相等 *&#x2F;    const stateChanged &#x3D; !areStatesEqual(nextState, state)    state &#x3D; nextState    ownProps &#x3D; nextOwnProps        &#x2F;&#x2F;根据改变的类型不同，返回对应合并策略下的props    if (propsChanged &amp;&amp; stateChanged) return handleNewPropsAndNewState()    if (propsChanged) return handleNewProps()    if (stateChanged) return handleNewState()    return mergedProps  &#125;    &#x2F;&#x2F;根据是否第一次形成props，执行对应方法  return function pureFinalPropsSelector(nextState, nextOwnProps) &#123;    return hasRunAtLeastOnce      ? handleSubsequentCalls(nextState, nextOwnProps)      : handleFirstCall(nextState, nextOwnProps)  &#125;&#125;</code></pre><h2 id="connectHOC"><a href="#connectHOC" class="headerlink" title="connectHOC"></a>connectHOC</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const mapStateToProp &#x3D; (store) &#x3D;&gt; (&#123; userInfo: store.root.userInfo &#125;)function Index()&#123;    &#x2F;* ..... *&#x2F;    return &lt;div&gt; &#123; &#x2F;* .... *&#x2F; &#125; &lt;&#x2F;div&gt;&#125;export default connect(mapStateToProp)(Index)</code></pre><ul><li>connect(mapStateToProp)&#x3D;&#x3D;&#x3D;connectAdvanced()</li></ul><details class="custom-details"><summary>点击查看更多</summary><p><ul><li>这部分代码，在8.x.x版本在conncet中直接处理，并没有拆分为单独函数</li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function connectAdvanced(  selectorFactory, &#x2F;&#x2F; 每次 props,state改变执行 ，用于生成新的 props。  &#123;    getDisplayName &#x3D; name &#x3D;&gt; &#96;ConnectAdvanced($&#123;name&#125;)&#96;,    &#x2F;&#x2F;可能被包装函数（如connect（））重写    methodName &#x3D; &#39;connectAdvanced&#39;,    &#x2F;&#x2F;如果定义了，则传递给包装元素的属性的名称，指示要呈现的调用。用于监视react devtools中不必要的重新渲染。    renderCountProp &#x3D; undefined,    shouldHandleStateChanges &#x3D; true,  &#x2F;&#x2F;确定此HOC是否订阅存储更改    storeKey &#x3D; &#39;store&#39;,    withRef &#x3D; false,    forwardRef &#x3D; false, &#x2F;&#x2F; 是否 用 forwarRef 模式    context &#x3D; ReactReduxContext,&#x2F;&#x2F; Provider 保存的上下文    ...connectOptions  &#125; &#x3D; &#123;&#125;) &#123;  &#x2F;* ReactReduxContext 就是store存在的context *&#x2F;  const Context &#x3D; context   &#x2F;* WrappedComponent 为connect 包裹的组件本身  *&#x2F;     return  function wrapWithConnect(WrappedComponent)&#123;      &#x2F;&#x2F; WrappedComponent 被 connect 的业务组件本身  &#125;&#125;</code></pre><ul><li>拿到Provider提供的context上下文</li></ul></p></details><h2 id="wrapWithConnect"><a href="#wrapWithConnect" class="headerlink" title="wrapWithConnect"></a>wrapWithConnect</h2><p>wrapWithConnect作为高阶组件，会返回一个组件，这个组件会对原有的业务组件，进行一系列增强等工作<br>判断是否是 pure 纯组件模式，如果是用react.memo包裹,这样做的好处是，会向 pureComponent 一样对 props 进行浅比较<br>如果 connect 有forwardRef配置项，用React.forwardRef处理</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function wrapWithConnect(WrappedComponent) &#123;&#x2F;&#x2F;WrappedComponent为实际传递的业务组件    const wrappedComponentName &#x3D;      WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;      const displayName &#x3D; getDisplayName(wrappedComponentName)        &#x2F;&#x2F;要合并都内容，connectOptions为上一步闭包拿到的内容    const selectorFactoryOptions &#x3D; &#123;      ...connectOptions,      getDisplayName,      methodName,      renderCountProp,      shouldHandleStateChanges,      storeKey,      displayName,      wrappedComponentName,      WrappedComponent    &#125;    const &#123; pure &#125; &#x3D; connectOptions        &#x2F;&#x2F;selectorFactory为finalPropsSelectorFactory    function createChildSelector(store) &#123;      &#x2F;&#x2F; 合并函数 mergeprops 得到最新的props      &#x2F;&#x2F; 及默认返回pureFinalPropsSelectorFactory，会根据是否第一次合并、修改类型等进行不同策略等合并以及返回最终都props      return selectorFactory(store.dispatch, selectorFactoryOptions)    &#125;    &#x2F;&#x2F;判断是否是pure纯组件模式 如果是将用 useMemo 缓存组件提升性能    const usePureOnlyMemo &#x3D; pure ? useMemo : callback &#x3D;&gt; callback()    &#x2F;&#x2F; 负责更新的容器子组件，可以看作是实际渲染的类组件    function ConnectFunction (props)&#123;        &#x2F;&#x2F; props 为 业务组件 真正的 props     &#125;    &#x2F;&#x2F;如果    const Connect &#x3D; pure ? React.memo(ConnectFunction) : ConnectFunction      Connect.WrappedComponent &#x3D; WrappedComponent    Connect.displayName &#x3D; displayName    &#x2F;* forwardRef *&#x2F;    if (forwardRef) &#123;      const forwarded &#x3D; React.forwardRef(function forwardConnectRef(        props,        ref      ) &#123;      &#x2F;&#x2F;connect中是否传递了forwardRef选项        return &lt;Connect &#123;...props&#125; reactReduxForwardedRef&#x3D;&#123;ref&#125; &#x2F;&gt;      &#125;)        forwarded.displayName &#x3D; displayName      forwarded.WrappedComponent &#x3D; WrappedComponent      &#x2F;&#x2F;hoistStatics为一个第三方库，负责把一个类中的静态属性拷贝到另一个类中      return hoistStatics(forwarded, WrappedComponent)    &#125;      return hoistStatics(Connect, WrappedComponent)  &#125;&#125;</code></pre><h2 id="为何要传递forwardRef？"><a href="#为何要传递forwardRef？" class="headerlink" title="为何要传递forwardRef？"></a>为何要传递forwardRef？</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">connect(mapStateToProp,mapDispatchToProps,mergeProps,&#123; forwardRef:true  &#125;)(Child)</code></pre><p>如果不传递，而是在其他组件中直接放ref到使用了connect的组件，则ref实际应用到的是ConncectFunction组件，而非真正的WrappedComponent组件<br>所以react-redux提供forwardRef选项，使用React.forwardRef，将ref实际放到真正的WrappedComponent上</p><h2 id="ConnectFunction"><a href="#ConnectFunction" class="headerlink" title="ConnectFunction"></a>ConnectFunction</h2><ul><li><p>实际渲染的组件</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">function ConnectFunction(props) &#123;    &#x2F;* TODO:  第一步 把 context ForwardedRef props 取出来 *&#x2F;    &#x2F;&#x2F;取出forwardRef和传递给ConnectFunction的所有除forwardRef的props    &#x2F;&#x2F;除了forwardRef以外的props也就是实际业务代码中传递给conncec包裹组件都props    const [      reactReduxForwardedRef,      wrapperProps &#x2F;&#x2F; props 传递的props    ] &#x3D; useMemo(() &#x3D;&gt; &#123;      const &#123; reactReduxForwardedRef, ...wrapperProps &#125; &#x3D; props      return [reactReduxForwardedRef, wrapperProps]    &#125;, [props])   &#x2F;&#x2F; 获取上层Provider提供的context，多个Provider只会取最近的Provider    &#x2F;&#x2F; 获取 context内容 里面含有  redux 中store 和 subscription    const contextValue &#x3D; useContext(Context)    &#x2F;&#x2F;TODO: 判断 store 是否来自props  didStoreComeFromProps ,正常情况下 ，prop 中是不存在 store 所以  didStoreComeFromProps &#x3D; false    const didStoreComeFromProps &#x3D;      Boolean(props.store) &amp;&amp;      Boolean(props.store.getState) &amp;&amp;      Boolean(props.store.dispatch)    &#x2F;&#x2F;store是否来自Provider提供的上下文    const didStoreComeFromContext &#x3D;      Boolean(contextValue) &amp;&amp; Boolean(contextValue.store)    &#x2F;&#x2F;根据两种情况获取store    const store &#x3D; didStoreComeFromProps ? props.store : contextValue.store          &#x2F;&#x2F;返回merge函数 用于生成真正传给子组件 props    const childPropsSelector &#x3D; useMemo(() &#x3D;&gt; &#123;    &#x2F;&#x2F;默认情况下pure为true，返回的是pureFinalPropsSelectorFactory      return createChildSelector(store)    &#125;, [store])    &#x2F;&#x2F; TODO:  第二步  创建connect组件自身的subscription 监听者实例      const [subscription, notifyNestedSubs] &#x3D; useMemo(() &#x3D;&gt; &#123;        &#x2F;&#x2F; 如果没有订阅更新，那么直接返回，默认情况下开启了订阅      if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY&#x2F;&#x2F;为每一个conncet的组件创建订阅器，获取上层Provider提供的contextValue.subscription&#x2F;&#x2F;connct的组件获取的是上层的Provder提供的subscription，有多个Provider，只会取层级最近的一个&#x2F;&#x2F;所以connect中的connect组件，获取到的是离它最近的Provider中的订阅器，通过它来管理自身的listener更新函数      const subscription &#x3D; new Subscription(        store,        didStoreComeFromProps ? null : contextValue.subscription &#x2F;&#x2F; 和 上级 &#96;subscription&#96; 建立起关系。 this.parentSub &#x3D; contextValue.subscription      )      &#x2F;&#x2F; notifyNestedSubs 触发 noticy 所有子代 listener 监听者 -&gt; 触发batch方法,触发 batchupdate方法 ,批量更新      &#x2F;&#x2F;并更新一下this指向      const notifyNestedSubs &#x3D; subscription.notifyNestedSubs.bind(        subscription      )      return [subscription, notifyNestedSubs]    &#125;, [store, didStoreComeFromProps, contextValue])    &#x2F;*  创建出一个新的contextValue ,把父级的 subscription 换成自己的 subscription   *&#x2F;    const overriddenContextValue &#x3D; useMemo(() &#x3D;&gt; &#123;         if (didStoreComeFromProps) &#123;         return contextValue      &#125;      &#x2F;&#x2F;默认情况下，返回自身的订阅器以及redux中的store给自身的子代connect中获取      return &#123;        ...contextValue,        subscription      &#125;    &#125;, [didStoreComeFromProps, contextValue, subscription])        &#x2F;&#x2F;定义了一个useReducer，当actualChildProps变化时，调用dispatch方法forceComponentUpdateDispatch进行组件更新    const [      [previousStateUpdateResult], &#x2F;&#x2F;调用dispatch更新后的内容      forceComponentUpdateDispatch  &#x2F;*  *&#x2F;    ] &#x3D; useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates)    &#x2F;&#x2F; TODO: 第三步缓存组件本次的props等内容，在下一次组件更新时做比较    const lastChildProps &#x3D; useRef() &#x2F;&#x2F;保存上一次 合并过的 props信息（经过 ownprops ,stateProps , dispatchProps 合并过的 ）    const lastWrapperProps &#x3D; useRef(wrapperProps) &#x2F;&#x2F;保存本次业务组件的 props     const childPropsFromStoreUpdate &#x3D; useRef() &#x2F;&#x2F;用来保存更新后的最新的props    const renderIsScheduled &#x3D; useRef(false) &#x2F;&#x2F; 当前组件是否处于渲染阶段        &#x2F;&#x2F; actualChildProps 为当前真正处理过后，经过合并的 props    const actualChildProps &#x3D; usePureOnlyMemo(() &#x3D;&gt; &#123;        &#x2F;&#x2F; 调用 mergeProps 进行合并，返回合并后的最新 porps        &#x2F;&#x2F;及调用pureFinalPropsSelectorFactory后的合并结果      return childPropsSelector(store.getState(), wrapperProps)         &#x2F;&#x2F;会在store、调用了checkForUpdates、传递给组建的props发生变化后，重新计算获取合并后的props     &#125;, [store, previousStateUpdateResult, wrapperProps])   &#x2F;* 负责更新缓存变量，方便下一次更新的时候比较 *&#x2F;    useEffect(()&#x3D;&gt;&#123;      captureWrapperProps(...[          lastWrapperProps,          lastChildProps,          renderIsScheduled,          wrapperProps,          actualChildProps,          childPropsFromStoreUpdate,          notifyNestedSubs       ])    &#125;)        &#x2F;&#x2F;实际订阅更新组件的地方    useEffect(()&#x3D;&gt;&#123;        subscribeUpdates(...[        shouldHandleStateChanges,        store,        subscription,        childPropsSelector,        lastWrapperProps,        lastChildProps,        renderIsScheduled,        childPropsFromStoreUpdate,        notifyNestedSubs,        forceComponentUpdateDispatch       ])    &#125;,[store, subscription, childPropsSelector])    &#x2F;&#x2F; TODO: 第四步：渲染实际挂载的组件，通过useMemo进行组件的缓存    const renderedWrappedComponent &#x3D; useMemo(      () &#x3D;&gt; (        &lt;WrappedComponent          &#123;...actualChildProps&#125;          ref&#x3D;&#123;reactReduxForwardedRef&#125;        &#x2F;&gt;      ),      &#x2F;&#x2F;当actualChildProps发生变化的时候重新渲染组件      &#x2F;&#x2F;这里就是组件重新渲染的原因：主要通过监听actualChildProps的变化      [reactReduxForwardedRef, WrappedComponent, actualChildProps]    )    &#x2F;&#x2F; 将上一步的renderedWrappedComponent包裹一层Provider    &#x2F;&#x2F; 提供该connect组件自身的订阅器、store给子代中的connect组件获取    const renderedChild &#x3D; useMemo(() &#x3D;&gt; &#123;      &#x2F;&#x2F;shouldHandleStateChanges 来源 connect是否有第一个参数      if (shouldHandleStateChanges) &#123;        return (          &#x2F;&#x2F; ContextToUse 传递 context           &lt;ContextToUse.Provider value&#x3D;&#123;overriddenContextValue&#125;&gt;            &#123;renderedWrappedComponent&#125;          &lt;&#x2F;ContextToUse.Provider&gt;        )      &#125;      return renderedWrappedComponent    &#125;, [ContextToUse, renderedWrappedComponent, overriddenContextValue])    return renderedChild  &#125;</code></pre></li><li><p>创建该connect组件自身的subscription, 并使用Provider包裹，层层传递新的context(很重要)</p></li><li><p>所以connect组件的子代connect组件，获取到的都是其上层最近的connect提供的Provider中的订阅器，然后将更新函数checkForUpdates放进其中管理</p></li><li><p>然后通过 useMemo 创建出一个新的 contextValue ,把父级的 subscription 换成自己的 subscription。用于通过 Provider 传递新的 context</p></li><li><p>接下来通过useReducer制造出真正触发更新的forceComponentUpdateDispatch 这个dispatch函数。也就是整个 state 或者是 props改变，触发组件更新的函数，这个函数放进checkForUpdates中执行</p></li></ul><h2 id="captureWrapperProps"><a href="#captureWrapperProps" class="headerlink" title="captureWrapperProps"></a>captureWrapperProps</h2><ul><li>进行内容缓存，为了下次组件更新进行比较<pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F;获取包装的props function captureWrapperProps(  lastWrapperProps,  lastChildProps,  renderIsScheduled,  wrapperProps,  actualChildProps,  childPropsFromStoreUpdate,  notifyNestedSubs) &#123;  lastWrapperProps.current &#x3D; wrapperProps  &#x2F;&#x2F;子props   lastChildProps.current &#x3D; actualChildProps &#x2F;&#x2F;经过 megeprops 之后形成的新prop  renderIsScheduled.current &#x3D; false  &#x2F;&#x2F; 当前组件渲染完成&#125;</code></pre></li></ul><h2 id="subscribeUpdates"><a href="#subscribeUpdates" class="headerlink" title="subscribeUpdates"></a>subscribeUpdates</h2><ul><li><p>实际添加更新回调的地方</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function subscribeUpdates(  shouldHandleStateChanges,  store,  subscription,  childPropsSelector,  lastWrapperProps,  &#x2F;&#x2F;子props   lastChildProps, &#x2F;&#x2F;经过 megeprops 之后形成的 prop  renderIsScheduled,  childPropsFromStoreUpdate,  notifyNestedSubs,  forceComponentUpdateDispatch) &#123;  if (!shouldHandleStateChanges) return   &#x2F;&#x2F; 捕获值以检查此组件是否卸载以及何时卸载  let didUnsubscribe &#x3D; false  let lastThrownError &#x3D; null   &#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调  const checkForUpdates &#x3D; ()&#x3D;&gt;&#123;      &#x2F;&#x2F;....  &#125;  &#x2F;&#x2F;将checkForUpdates作为listener  subscription.onStateChange &#x3D; checkForUpdates  &#x2F;&#x2F;开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中。  subscription.trySubscribe()  &#x2F;&#x2F;在第一次呈现之后从存储中提取数据，以防存储从我们开始就改变了。  &#x2F;&#x2F;确保获取到的最新的store.getState,然后判断是否更新组件  checkForUpdates()  &#x2F;* 卸载订阅起 *&#x2F;  const unsubscribeWrapper &#x3D; () &#x3D;&gt; &#123;    didUnsubscribe &#x3D; true    subscription.tryUnsubscribe()    subscription.onStateChange &#x3D; null  &#125;  return unsubscribeWrapper&#125;</code></pre></li><li><p>首先声明 store 更新订阅传播到此组件时的回调函数checkForUpdates把它赋值给onStateChange,如果store中的state发生改变，那么在组件订阅了state内容之后，相关联的state改变就会触发当前组件的onStateChange,来合并得到新的props</p></li><li><p>subscription.trySubscribe()把订阅函数onStateChange绑定给父级subscription,进行了层层订阅</p></li><li><p>为了确保拿到的store内容是最新的，所以首先执行了一次checkForUpdates<br><img src="https://img-blog.csdnimg.cn/d03af8b00dcd4deaad5bcb09c5cc2903.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA56We5aWH5aSn5Y-U,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="checkForUpdates"><a href="#checkForUpdates" class="headerlink" title="checkForUpdates"></a>checkForUpdates</h2></li><li><p>判断是否需要更新的函数</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F;store更新订阅传播到此组件时，运行此回调const checkForUpdates &#x3D; () &#x3D;&gt; &#123;  if (didUnsubscribe) &#123;    &#x2F;&#x2F;如果取消订阅了    return  &#125;   &#x2F;&#x2F; 获取 store 里state  const latestStoreState &#x3D; store.getState()q  let newChildProps, error  try &#123;    &#x2F;* 得到最新的 props *&#x2F;    newChildProps &#x3D; childPropsSelector(      latestStoreState,      lastWrapperProps.current    )  &#125;   &#x2F;&#x2F;如果新的合并的 props没有更改，则此处不做任何操作-层叠订阅更新  if (newChildProps &#x3D;&#x3D;&#x3D; lastChildProps.current) &#123;     if (!renderIsScheduled.current) &#123;        notifyNestedSubs() &#x2F;* 通知子代 subscription 触发 checkForUpdates 来检查是否需要更新。 *&#x2F;    &#125;  &#125; else &#123;    lastChildProps.current &#x3D; newChildProps    childPropsFromStoreUpdate.current &#x3D; newChildProps    renderIsScheduled.current &#x3D; true    &#x2F;&#x2F; 触发useReducer的dispatch来进行更新，该dispatch会改变useReducer返回的previousStateUpdateResult    &#x2F;&#x2F; 而previousStateUpdateResult是作为actualChildProps的依赖项引发actualChildProps的改变    &#x2F;&#x2F; actualChildProps又是实际渲染组件的依赖性，从而引发组件的重新渲染更新    forceComponentUpdateDispatch(&#123;      type: &#39;STORE_UPDATED&#39;,      payload: &#123;        error      &#125;    &#125;)  &#125;&#125;</code></pre></li><li><p>checkForUpdates 通过调用 childPropsSelector来形成新的props,然后判断之前的 prop 和当前新的 prop 是否相等。如果相等，证明没有发生变化,无须更新当前组件，那么通过调用notifyNestedSubs来通知子代容器组件，检查是否需要更新。如果不相等证明订阅的store.state发生变化，那么立即执行forceComponentUpdateDispatch来触发组件的更新</p></li></ul><h2 id="整个订阅流程"><a href="#整个订阅流程" class="headerlink" title="整个订阅流程"></a>整个订阅流程</h2><p>整个订阅的流程是，如果被connect包裹，并且具有第一个参数。首先通过context获取最近的 subscription，然后创建一个新的subscription,并且和父级的subscription建立起关联。当第一次hoc容器组件挂在完成后，在useEffect里，进行订阅，将自己的订阅函数checkForUpdates,作为回调函数，通过trySubscribe 和this.parentSub.addNestedSub ,加入到父级subscription的listeners中。由此完成整个订阅流程</p><h2 id="整个发布流程"><a href="#整个发布流程" class="headerlink" title="整个发布流程"></a>整个发布流程</h2><p>整个更新流程是，当组件中调用dispatch触发了redux的state改变和redux的订阅器，从而触发根订阅器的触发listeners.notify ,也就是checkForUpdates函数，然后checkForUpdates函数首先根据mapStoretoprops，mergeprops等操作，验证该组件是否发起订阅，props 是否改变，并更新，如果发生改变，那么触发useReducer的forceComponentUpdateDispatch函数，来更新业务组件，如果没有发生更新，那么通过调用notifyNestedSubs,来通知当前subscription的listeners检查是否更新，然后尽心层层checkForUpdates,逐级向下，借此完成整个更新流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>connect使用柯里化</li><li>useMemo缓存渲染组件的操作</li><li>发布订阅模式以及通过双向链表来管理</li><li>如何通过Provider进行层层订阅</li><li>react-redux触发更新的依据是actualChildProps是否改变</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_43294560/article/details/123284317">react-redux源码解析</a><br><a href="https://github.com/841660202/react-redux">github 源码</a><br><a href="https://blog.csdn.net/qq_33715850/article/details/122535984">React-redux源码解析–准备知识</a><br><a href="https://blog.csdn.net/qq_33715850/article/details/122590433">React-redux源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> react-redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-redux </tag>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-redux 源码1</title>
      <link href="//post/2022-05-24react-redux.html"/>
      <url>//post/2022-05-24react-redux.html</url>
      
        <content type="html"><![CDATA[<h2 id="react-redux官方介绍"><a href="#react-redux官方介绍" class="headerlink" title="react-redux官方介绍"></a>react-redux官方介绍</h2><ul><li>官方UI绑定层。 React Redux is the <code>official React UI bindings layer</code> for Redux. </li><li>从redux的store读数据。 It lets your React components <code>read data from a Redux store</code>,</li><li>触发行为给store来更新状态。and <code>dispatch actions to the store to update state</code>.</li></ul><h2 id="react-redux-源码"><a href="#react-redux-源码" class="headerlink" title="react-redux 源码"></a>react-redux 源码</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">.├── alternate-renderers.ts├── components│   ├── Context.ts│   ├── Provider.tsx│   └── connect.tsx # 大部分代码都在这里├── connect # 给 connect.tsx使用│   ├── invalidArgFactory.ts│   ├── mapDispatchToProps.ts│   ├── mapStateToProps.ts│   ├── mergeProps.ts│   ├── selectorFactory.ts│   ├── verifySubselectors.ts│   └── wrapMapToProps.ts├── exports.ts├── hooks│   ├── useDispatch.ts│   ├── useReduxContext.ts│   ├── useSelector.ts│   └── useStore.ts├── index.ts├── next.ts├── types.ts└── utils    ├── Subscription.ts    ├── batch.ts    ├── bindActionCreators.ts    ├── isPlainObject.ts    ├── reactBatchedUpdates.native.ts    ├── reactBatchedUpdates.ts    ├── shallowEqual.ts    ├── useIsomorphicLayoutEffect.native.ts    ├── useIsomorphicLayoutEffect.ts    ├── useSyncExternalStore.ts    ├── verifyPlainObject.ts    └── warning.ts</code></pre><h2 id="packge-json"><a href="#packge-json" class="headerlink" title="packge.json"></a>packge.json</h2><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; packge.json&#123;  &quot;name&quot;: &quot;react-redux&quot;,  &quot;version&quot;: &quot;8.0.2&quot;,  &quot;description&quot;: &quot;Official React bindings for Redux&quot;,  &quot;keywords&quot;: [    &quot;react&quot;,    &quot;reactjs&quot;,    &quot;redux&quot;  ],  &quot;license&quot;: &quot;MIT&quot;,  &quot;author&quot;: &quot;Dan Abramov &lt;dan.abramov@me.com&gt; (https:&#x2F;&#x2F;github.com&#x2F;gaearon)&quot;,  &quot;homepage&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&quot;,  &quot;repository&quot;: &quot;github:reduxjs&#x2F;react-redux&quot;,  &quot;bugs&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;reduxjs&#x2F;react-redux&#x2F;issues&quot;,  &#x2F;&#x2F; 找找入口，入口有3种：  &quot;main&quot;: &quot;.&#x2F;lib&#x2F;index.js&quot;, &#x2F;&#x2F; 常规操作入口  &quot;types&quot;: &quot;.&#x2F;es&#x2F;index.d.ts&quot;, &#x2F;&#x2F; 类型入口  &quot;unpkg&quot;: &quot;dist&#x2F;react-redux.js&quot;, &#x2F;&#x2F; cdn入口  &quot;module&quot;: &quot;es&#x2F;index.js&quot;,&#x2F;&#x2F;esm入口  &#x2F;&#x2F; npm发布上传的文件  &quot;files&quot;: [    &quot;dist&quot;,    &quot;lib&quot;,    &quot;src&quot;, &#x2F;&#x2F; 一般用于开发阶段代码调试,soucemap    &quot;es&quot;  ],  &quot;scripts&quot;: &#123;    &#x2F;&#x2F; 脚本不看了...  &#125;,  &#x2F;&#x2F; 配置了依赖项，这些依赖项不需要在本包安装，在项目中安装即可  &quot;peerDependencies&quot;: &#123;    &quot;@types&#x2F;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;@types&#x2F;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;react&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;react-dom&quot;: &quot;^16.8 || ^17.0 || ^18.0&quot;,    &quot;react-native&quot;: &quot;&gt;&#x3D;0.59&quot;,    &quot;redux&quot;: &quot;^4&quot;  &#125;,  &quot;peerDependenciesMeta&quot;: &#123;    &quot;@types&#x2F;react&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;@types&#x2F;react-dom&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;react-dom&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;react-native&quot;: &#123;      &quot;optional&quot;: true    &#125;,    &quot;redux&quot;: &#123;      &quot;optional&quot;: true    &#125;  &#125;,  &#x2F;&#x2F; 发布后，业务开发者使用，需要安装，&#x2F;&#x2F;自动安装  &quot;dependencies&quot;: &#123;    &quot;@babel&#x2F;runtime&quot;: &quot;^7.12.1&quot;,    &quot;@types&#x2F;hoist-non-react-statics&quot;: &quot;^3.3.1&quot;,    &quot;@types&#x2F;use-sync-external-store&quot;: &quot;^0.0.3&quot;,    &quot;hoist-non-react-statics&quot;: &quot;^3.3.2&quot;,    &quot;react-is&quot;: &quot;^18.0.0&quot;,    &quot;use-sync-external-store&quot;: &quot;^1.0.0&quot;  &#125;,  &#x2F;&#x2F; 开发阶段需要用到的，一般是examples中demo使用  &quot;devDependencies&quot;: &#123;    &#x2F;&#x2F;...  &#125;&#125;</code></pre><h2 id="exports-ts"><a href="#exports-ts" class="headerlink" title="exports.ts"></a>exports.ts</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export &#123;  Provider, &#x2F;&#x2F; import Provider from &#39;.&#x2F;components&#x2F;Provider&#39;  ReactReduxContext, &#x2F;&#x2F; import &#123; ReactReduxContext &#125; from &#39;.&#x2F;components&#x2F;Context&#39;  connect, &#x2F;&#x2F; import connect from &#39;.&#x2F;components&#x2F;connect&#39;  useDispatch, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;  createDispatchHook, &#x2F;&#x2F; import &#123; useDispatch, createDispatchHook &#125; from &#39;.&#x2F;hooks&#x2F;useDispatch&#39;  useSelector, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;  createSelectorHook, &#x2F;&#x2F; import &#123; useSelector, createSelectorHook &#125; from &#39;.&#x2F;hooks&#x2F;useSelector&#39;  useStore, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;  createStoreHook, &#x2F;&#x2F; import &#123; useStore, createStoreHook &#125; from &#39;.&#x2F;hooks&#x2F;useStore&#39;  shallowEqual, &#x2F;&#x2F; import shallowEqual from &#39;.&#x2F;utils&#x2F;shallowEqual&#39;&#125;</code></pre><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>先看下 ，最熟悉的api</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; components&#x2F;Provider.tsx&#x2F;&#x2F; 这个组件做的事情&#x2F;&#x2F; 1. 合并浏览器和服务器的状态&#x2F;&#x2F; 2. 对于同构的应用，处理subscription订阅function Provider&lt;A extends Action &#x3D; AnyAction&gt;(&#123;  store,  context,  children,  serverState,&#125;: ProviderProps&lt;A&gt;) &#123;  &#x2F;&#x2F; 1.useMemo，对入参进行格式化「处理了store和 服务端的 serverState」  const contextValue &#x3D; useMemo(() &#x3D;&gt; &#123;    const subscription &#x3D; createSubscription(store)    return &#123;      store,      subscription,      getServerState: serverState ? () &#x3D;&gt; serverState : undefined,    &#125;  &#125;, [store, serverState])  &#x2F;&#x2F; 2.之前的state状态从store中直接获取  const previousState &#x3D; useMemo(() &#x3D;&gt; store.getState(), [store])  &#x2F;&#x2F; 3.同构相关，跳过  useIsomorphicLayoutEffect(() &#x3D;&gt; &#123;    const &#123; subscription &#125; &#x3D; contextValue    subscription.onStateChange &#x3D; subscription.notifyNestedSubs    subscription.trySubscribe()    if (previousState !&#x3D;&#x3D; store.getState()) &#123;      subscription.notifyNestedSubs()    &#125;    return () &#x3D;&gt; &#123;      subscription.tryUnsubscribe()      subscription.onStateChange &#x3D; undefined    &#125;  &#125;, [contextValue, previousState])  &#x2F;&#x2F; 4.react-redux上下文  const Context &#x3D; context || ReactReduxContext  &#x2F;&#x2F; @ts-ignore &#39;AnyAction&#39; is assignable to the constraint of type &#39;A&#39;, but &#39;A&#39; could be instantiated with a different subtype  return &lt;Context.Provider value&#x3D;&#123;contextValue&#125;&gt;&#123;children&#125;&lt;&#x2F;Context.Provider&gt; &#x2F;&#x2F; 这行代码是不是非常熟悉了&#125;export default Provider</code></pre><h2 id="ReactReduxContext"><a href="#ReactReduxContext" class="headerlink" title="ReactReduxContext"></a>ReactReduxContext</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; .&#x2F;components&#x2F;Context.tsx&#x2F;&#x2F; 这个组件做的事情&#x2F;&#x2F; 1.创建个createContext&#x2F;&#x2F; 2.给个名字displayName&#x2F;&#x2F; ...类型代码不关注export const ReactReduxContext &#x3D;&#x2F;*#__PURE__*&#x2F; React.createContext&lt;ReactReduxContextValue&gt;(null as any)&#x2F;&#x2F; ...类型代码不关注if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;  ReactReduxContext.displayName &#x3D; &#39;ReactRedux&#39;&#125;export default ReactReduxContext</code></pre><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; .&#x2F;components&#x2F;connect.tsx&#x2F;&#x2F; 这个文件比较长，先不看&#x2F;&#x2F; hoist-non-react-statics这个依赖可以帮助我们自动拷贝非React的静态方法</code></pre><h2 id="useDispatch、createDispatchHook"><a href="#useDispatch、createDispatchHook" class="headerlink" title="useDispatch、createDispatchHook"></a>useDispatch、createDispatchHook</h2><p>把ts类型删删，看上去更简单了</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; .&#x2F;hooks&#x2F;useDispatch&#x2F;&#x2F; 用createDispatchHook钩子工厂创建了个钩子useDispatchexport function createDispatchHook(context) &#123;  &#x2F;&#x2F; TODO: createStoreHook下面再看，先跳过  const useStore &#x3D; context &#x3D;&#x3D;&#x3D; ReactReduxContext ? useDefaultStore : createStoreHook(context)  return function useDispatch() &#123;    const store &#x3D; useStore()    &#x2F;&#x2F; @ts-ignore    return store.dispatch  &#125;&#125;&#x2F;** * A hook to access the redux &#96;dispatch&#96; function. * * @returns &#123;any|function&#125; redux store&#39;s &#96;dispatch&#96; function * * @example * * import React, &#123; useCallback &#125; from &#39;react&#39; * import &#123; useDispatch &#125; from &#39;react-redux&#39; * * export const CounterComponent &#x3D; (&#123; value &#125;) &#x3D;&gt; &#123; *   const dispatch &#x3D; useDispatch() *   const increaseCounter &#x3D; useCallback(() &#x3D;&gt; dispatch(&#123; type: &#39;increase-counter&#39; &#125;), []) *   return ( *     &lt;div&gt; *       &lt;span&gt;&#123;value&#125;&lt;&#x2F;span&gt; *       &lt;button onClick&#x3D;&#123;increaseCounter&#125;&gt;Increase counter&lt;&#x2F;button&gt; *     &lt;&#x2F;div&gt; *   ) * &#125; *&#x2F;export const useDispatch &#x3D; &#x2F;*#__PURE__*&#x2F; createDispatchHook()</code></pre><h2 id="useSelector、createSelectorHook"><a href="#useSelector、createSelectorHook" class="headerlink" title="useSelector、createSelectorHook"></a>useSelector、createSelectorHook</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; .&#x2F;hooks&#x2F;useSelector&#x2F;&#x2F; 用 createSelectorHook 钩子工厂创建了个钩子 useSelectorlet useSyncExternalStoreWithSelector &#x3D; notInitialized as uSESWSexport const initializeUseSelector &#x3D; (fn: uSESWS) &#x3D;&gt; &#123;  useSyncExternalStoreWithSelector &#x3D; fn&#125;const refEquality: EqualityFn&lt;any&gt; &#x3D; (a, b) &#x3D;&gt; a &#x3D;&#x3D;&#x3D; b&#x2F;&#x2F; 下面的代码保留范型，Selectedexport function createSelectorHook(  context &#x3D; ReactReduxContext): &lt;TState &#x3D; unknown, Selected &#x3D; unknown&gt;(  selector: (state: TState) &#x3D;&gt; Selected,  equalityFn?: EqualityFn&lt;Selected&gt;) &#x3D;&gt; Selected &#123;  const useReduxContext &#x3D;    context &#x3D;&#x3D;&#x3D; ReactReduxContext      ? useDefaultReduxContext      : () &#x3D;&gt; useContext(context)  return function useSelector(    selector,    equalityFn &#x3D; refEquality  ) &#123;    const &#123; store, subscription, getServerState &#125; &#x3D; useReduxContext()!    const selectedState &#x3D; useSyncExternalStoreWithSelector(      subscription.addNestedSub,      store.getState,      getServerState || store.getState,      selector,      equalityFn    )    useDebugValue(selectedState) &#x2F;&#x2F; 标记    return selectedState  &#125;&#125;&#x2F;** * A hook to access the redux store&#39;s state. This hook takes a selector function * as an argument. The selector is called with the store state. * * This hook takes an optional equality comparison function as the second parameter * that allows you to customize the way the selected state is compared to determine * whether the component needs to be re-rendered. * * @param &#123;Function&#125; selector the selector function * @param &#123;Function&#x3D;&#125; equalityFn the function that will be used to determine equality * * @returns &#123;any&#125; the selected state * * @example * * import React from &#39;react&#39; * import &#123; useSelector &#125; from &#39;react-redux&#39; * * export const CounterComponent &#x3D; () &#x3D;&gt; &#123; *   const counter &#x3D; useSelector(state &#x3D;&gt; state.counter) *   return &lt;div&gt;&#123;counter&#125;&lt;&#x2F;div&gt; * &#125; *&#x2F;export const useSelector &#x3D; &#x2F;*#__PURE__*&#x2F; createSelectorHook()</code></pre><h2 id="useStore、createStoreHook"><a href="#useStore、createStoreHook" class="headerlink" title="useStore、createStoreHook"></a>useStore、createStoreHook</h2><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 1.用钩子工厂创建了个钩子&#x2F;&#x2F; 2.从   const &#123; store &#125; &#x3D; useReduxContext()! 获取store&#x2F;** * Hook factory, which creates a &#96;useStore&#96; hook bound to a given context. * * @param &#123;React.Context&#125; [context&#x3D;ReactReduxContext] Context passed to your &#96;&lt;Provider&gt;&#96;. * @returns &#123;Function&#125; A &#96;useStore&#96; hook bound to the specified context. *&#x2F;export function createStoreHook&lt;  S &#x3D; unknown,  A extends BasicAction &#x3D; AnyAction  &#x2F;&#x2F; @ts-ignore&gt;(context?: Context&lt;ReactReduxContextValue&lt;S, A&gt;&gt; &#x3D; ReactReduxContext) &#123;  const useReduxContext &#x3D;    &#x2F;&#x2F; @ts-ignore    context &#x3D;&#x3D;&#x3D; ReactReduxContext      ? useDefaultReduxContext      : () &#x3D;&gt; useContext(context)  return function useStore&lt;    State &#x3D; S,    Action extends BasicAction &#x3D; A    &#x2F;&#x2F; @ts-ignore  &gt;() &#123;    const &#123; store &#125; &#x3D; useReduxContext()!    &#x2F;&#x2F; @ts-ignore    return store as Store&lt;State, Action&gt;  &#125;&#125;&#x2F;** * A hook to access the redux store. * * @returns &#123;any&#125; the redux store * * @example * * import React from &#39;react&#39; * import &#123; useStore &#125; from &#39;react-redux&#39; * * export const ExampleComponent &#x3D; () &#x3D;&gt; &#123; *   const store &#x3D; useStore() *   return &lt;div&gt;&#123;store.getState()&#125;&lt;&#x2F;div&gt; * &#125; *&#x2F;export const useStore &#x3D; &#x2F;*#__PURE__*&#x2F; createStoreHook()</code></pre><h2 id="connect-1"><a href="#connect-1" class="headerlink" title="connect"></a>connect</h2><p> 见：react-redux 源码2</p>]]></content>
      
      
      <categories>
          
          <category> react-redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-redux </tag>
            
            <tag> redux </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex width:0</title>
      <link href="//post/2022-05-23width0.html"/>
      <url>//post/2022-05-23width0.html</url>
      
        <content type="html"><![CDATA[<h2 id="flex嵌套"><a href="#flex嵌套" class="headerlink" title="flex嵌套"></a>flex嵌套</h2><p>内部元素宽度默认100%，撑开父元素，父元素的根元素限制最大宽度，子元素并不受flex控制</p><p>遇到多次了，这次是维护其他同事的代码，又撞见了，说明这个问题很常见，一个不留神，就踩到了</p><pre class="line-numbers language-none"><code class="language-none">根元素  ……  - 父元素flex  …… flex   - 子元素flex(默认宽度100%)</code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">.doc-tree-base-title-node .doc-tree-base-title-text &gt; a &#123;    display: flex;    align-items: center;    color: #777;    white-space: nowrap;    overflow: hidden;    text-overflow: ellipsis;    flex: 1;&#125;</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="http://t-blog-images.aijs.top/img/20220523171556.webp"></p><p> 观察下发现，flex是嵌套的，最外层的还是flex，一层一层，最外层的宽度，却是由最内层的宽度决定（这个调试可以看到）</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>图1</li></ul><p> <img src="http://t-blog-images.aijs.top/img/20220523171802.webp"></p><ul><li>图2</li></ul><p> <img src="http://t-blog-images.aijs.top/img/20220523171918.webp"></p><ul><li>图3</li></ul><p> <img src="http://t-blog-images.aijs.top/img/20220523172024.webp"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p> 图1 元素没有宽度，宽度默认是<code>100%</code></p><p> 图1到图3是由a标签子元素撑开的，宽度是<code>100%</code>,加上操作按钮，元素宽度超100%</p><p> 而在侧边树结构的最外层设置了<code>max-width: 500px</code>,而内部子元素尺寸却是<code>599.48 x 36</code></p><p> 显然是不合理的</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2> <pre class="line-numbers language-none"><code class="language-none">根元素  ……  - 父元素flex  …… flex   - 子元素flex(默认宽度设置宽度0 或者其他小点的宽度，越小越好)</code></pre><p> <img src="http://t-blog-images.aijs.top/img/20220523173256.webp"></p><h2 id="什么原因导致的"><a href="#什么原因导致的" class="headerlink" title="什么原因导致的"></a>什么原因导致的</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">MDN flex</a></p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 关键字值 *&#x2F;flex: auto;flex: initial;flex: none;&#x2F;* 一个值, 无单位数字: flex-grow *&#x2F;flex: 2;&#x2F;* 一个值, width&#x2F;height: flex-basis *&#x2F;flex: 10em;flex: 30px;flex: min-content;&#x2F;* 两个值: flex-grow | flex-basis *&#x2F;flex: 1 30px;&#x2F;* 两个值: flex-grow | flex-shrink *&#x2F;flex: 2 2;&#x2F;* 三个值: flex-grow | flex-shrink | flex-basis *&#x2F;flex: 2 2 10%;&#x2F;*全局属性值 *&#x2F;flex: inherit;flex: initial;flex: unset;</code></pre><p>可以使用一个，两个或三个值来指定 flex属性。</p><p>1.<strong>单值语法</strong>: 值必须为以下其中之一:</p><ul><li>一个无单位数(<code>&lt;number&gt;</code>): 它会被当作flex:<number> 1 0; <flex-shrink>的值被假定为1，然后<flex-basis> 的值被假定为0。</li><li>一个有效的宽度(width)值: 它会被当作 <flex-basis>的值。</li><li>关键字none，auto或initial.</li></ul><p>2.<strong>双值语法</strong>: 第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。第二个值必须为以下之一：</p><ul><li>一个无单位数：它会被当作 <flex-shrink> 的值。</li><li>一个有效的宽度值: 它会被当作 <flex-basis> 的值。</li></ul><p>3.<strong>三值语法</strong>:</p><ul><li>第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作  <flex-shrink> 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 <flex-basis> 的值。</li></ul><p> 可以看到单值，作为双值处理</p> <pre class="line-numbers language-css" data-language="css"><code class="language-css">flex-shrink:1;flex-basis: 0;</code></pre><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p> 自来看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis">flex-base</a></p><p> 查看文档后发现，文档上没说关于<code>flex-basic: 0 </code>的事情,给了个演示，也看不出来想表达什么</p><p><a href="https://blog.csdn.net/u010951953/article/details/124145786">flex-basis 属性的含义</a><br><a href="https://www.w3.org/TR/2018/CR-css-flexbox-1-20181119/#flex-basis-property">w3c flex-basis-property</a><br>flex布局一般由flex容器（display 属性值为 flex 或 inline-flex）和其子元素（后文亦称flex子项或flex item）构成。flex-basis 属性一般作用在flex子项上，它定义了：在flex容器分配剩余空间前flex子项在主轴方向上的初始尺寸。flex子项在主轴方向上的实际尺寸是根据元素自身尺寸、flex-basis、flex-grow、flex-shrink 等属性共同决定的。如何计算实际尺寸不是本文重点，不继续展开。</p><h2 id="flex-basis-0px与0"><a href="#flex-basis-0px与0" class="headerlink" title="flex-basis:0px与0%"></a>flex-basis:0px与0%</h2><ul><li>如果 flex-basis 的值为百分数，且它flex容器的尺寸没有被显式设置，此时 flex-basis 的值会被解析为 content</li><li></li></ul><h2 id="其他，值得一看"><a href="#其他，值得一看" class="headerlink" title="其他，值得一看"></a>其他，值得一看</h2><h2 id="flex-1"><a href="#flex-1" class="headerlink" title="flex: 1"></a>flex: 1</h2><p>在浏览器中，flex: 1 的 flex-basis 值为什么不是W3C文档中提到的 0 ？</p><p>当使用 flex 属性但又省略不写它其中的 flex-basis 值时，会将 flex-basis 设置为 0.</p><p>这里的 0 单位是 px 还是 % 我们在Chrome浏览器里就能验证：</p><img src="http://t-blog-images.aijs.top/img/20220523181618.webp" width=400  style="object-fit: content"/><p>答案是 px.</p><p>这段是2015年修正日志里的，意思是将之前 flex 简写语法里的 flex-basis 的解析值从 0% 恢复为原来的 0.</p><p>注意： 这个值的解析规则经历了 0px -&gt; 0% -&gt; 0px 的变化，这是W3C flex 标准文档的视角。</p><p>简而言之就是有兼容性问题。现在已有很多网页都利用了 flex 属性的这个特性来开发。如果简写语法里 flex-basis 的解析从 0% 变为 0px 会导致部分情况下flex容器塌陷，致使很多网页异常</p><p><a href="https://blog.csdn.net/u010951953/article/details/124145786">建议看原文</a></p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS如何工作</title>
      <link href="//post/2022-05-23css.html"/>
      <url>//post/2022-05-23css.html</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当浏览器展示一个文件的时候，它必须兼顾文件的内容和文件的样式信息</p></blockquote><h2 id="如何加载CSS和HTML"><a href="#如何加载CSS和HTML" class="headerlink" title="如何加载CSS和HTML"></a>如何加载CSS和HTML</h2><p>下面的步骤是浏览加载网页的简化版本:</p><ol><li>浏览器载入HTML文件（比如从网络上获取）。</li><li>将HTML文件转化成一个DOM（Document Object Model），DOM是文件在计算机内存中的表现形式，下一节将更加详细的解释DOM。</li><li>接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理，简单起见，同时此节主讲CSS，所以这里对如何加载JavaScript不会展开叙述。</li><li>浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。</li><li>上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。</li><li>网页展示在屏幕上（这一步被称为着色）。</li></ol><p><strong>运行图</strong></p><img src="http://t-blog-images.aijs.top/img/rendering.svg" width=400 style="object-fit:content; background: #fff"/><hr/><h2 id="无法解析的CSS会发生什么"><a href="#无法解析的CSS会发生什么" class="headerlink" title="无法解析的CSS会发生什么"></a>无法解析的CSS会发生什么</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>答案就是浏览器什么也不会做，继续解析下一个CSS样式！</p></blockquote><p>以下是废话：</p><ul><li><p>浏览器并不会同时实现所有的新CSS，此外很多人也不会使用最新版本的浏览器。鉴于CSS一直不断的开发，因此领先于浏览器可以识别的范围，那么你也许会好奇当浏览器遇到无法解析的CSS选择器或声明的时候会发生什么呢？</p></li><li><p>CSS规则： 如果一个浏览器在解析你所书写的CSS规则的过程中遇到了无法理解的属性或者值，它会忽略这些并继续解析下面的CSS声明。在你书写了错误的CSS代码（或者误拼写），又或者当浏览器遇到对于它来说很新的还没有支持的CSS代码的时候上述的情况同样会发生（直接忽略）。</p></li><li><p>选择器： 相似的，当浏览器遇到无法解析的选择器的时候，他会<code>直接忽略整个选择器规则</code>，然后解析下一个CSS选择器。</p></li></ul><hr/><h2 id="关于DOM"><a href="#关于DOM" class="headerlink" title="关于DOM"></a>关于DOM</h2><p>一个DOM有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node&#x2F;DOM或DOM node）。节点由节点本身和其他DOM节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。</p><p>对于DOM的理解会很大程度上帮助你设计、调试和维护你的CSS，因为DOM是你的CSS样式和文件内容的结合。当你使用浏览器F12调试的时候你需要操作DOM以查看使用了哪些规则。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;p&gt;  Let&#39;s use:  &lt;span&gt;Cascading&lt;&#x2F;span&gt;  &lt;span&gt;Style&lt;&#x2F;span&gt;  &lt;span&gt;Sheets&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">P├─ &quot;Let&#39;s use:&quot;├─ SPAN|  └─ &quot;Cascading&quot;├─ SPAN|  └─ &quot;Style&quot;└─ SPAN   └─ &quot;Sheets&quot;</code></pre><hr/><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works">MDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>monorepo</title>
      <link href="//post/2022-05-23monorepo.html"/>
      <url>//post/2022-05-23monorepo.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>调试源码时候，总会遇到多包的仓库，遇到了不晓得如何调试</li><li>开发个库或者是插件之类的开发的比较混乱</li><li>经历多个项目的毒打，终于有时间学下<code>monorepo</code></li></ul><h2 id="lerna、yarn-workspace"><a href="#lerna、yarn-workspace" class="headerlink" title="lerna、yarn workspace"></a>lerna、yarn workspace</h2><ul><li>和java微服务架构代码很像</li><li>很多项目是 lerna+yarn workspace，如果不懂，或者了解了一点<code>lerna</code>。上去一顿操作，各种报错，在所难免（亲身经历）</li></ul><h2 id="monorepo管理"><a href="#monorepo管理" class="headerlink" title="monorepo管理"></a>monorepo管理</h2><p>对于维护过多个package(功能相近)的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块&#x2F;包 (package)，不同于常见的每个模块建一个 repo。</p><p>目前有不少大型开源项目采用了这种方式，如 Babel，React, Meteor, Ember, Angular,Jest, Umijs, Vue, 还有 create-react-app, react-router 等。几乎我们熟知的仓库，都无一例外的采用了monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages目录中、分多个 package 进行管理。</p><p>目录结构如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">├── packages|   ├── pkg1|   |   ├── package.json|   ├── pkg2|   |   ├── package.json├── package.json</code></pre><p>monorepo 最主要的好处是统一的工作流和Code Sharing。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。</p><p>一图胜千言:<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOThmNTYwZDgxZDg"></p><p>前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p><p>虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。</p><p>结合shop-service门户的实际场景和业务需要，天然的 MonoRepo ! 一个理想的开发环境可以抽象成这样：</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”</p></blockquote><p>在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。</p><p>上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。</p><h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p><p>2.1 安装<br>推荐全局安装，因为会经常用到 lerna 命令</p><pre class="line-numbers language-none"><code class="language-none">npm i -g lerna</code></pre><p>2.2 初始化项目</p><pre class="line-numbers language-none"><code class="language-none">lerna init</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWE5MDhiMTkyOWQ"></p><p>其中 package.json &amp; lerna.json 如下:</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; package.json&#123;  &quot;name&quot;: &quot;root&quot;,  &quot;private&quot;: true, &#x2F;&#x2F; 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦  &quot;devDependencies&quot;: &#123;    &quot;lerna&quot;: &quot;^3.15.0&quot;  &#125;&#125; &#x2F;&#x2F; lerna.json&#123;  &quot;packages&quot;: [    &quot;packages&#x2F;*&quot;  ],  &quot;version&quot;: &quot;0.0.0&quot;&#125;</code></pre><p>2.3 创建npm包<br>增加两个 packages</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWIyOTgzNjExZDE"></p><p>2.4 增加模块依赖<br>分别给相应的 package 增加依赖模块</p><pre class="line-numbers language-none"><code class="language-none">lerna add chalk &#x2F;&#x2F; 为所有 package 增加 chalk 模块 lerna add semver --scope @mo-demo&#x2F;cli-shared-utils &#x2F;&#x2F; 为 @mo-demo&#x2F;cli-shared-utils 增加 semver 模块 lerna add @mo-demo&#x2F;cli-shared-utils --scope @mo-demo&#x2F;cli &#x2F;&#x2F; 增加内部模块之间的依赖</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWI2NTNmMGQ5NjQ"></p><p>2.5 发布</p><pre class="line-numbers language-none"><code class="language-none">lerna publish</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWJiMWY4MjhjZjk"></p><p>2.6 依赖包管理<br>上述1-5步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。</p><p>我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本。</p><pre class="line-numbers language-none"><code class="language-none">lerna bootstrap --hoist</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWJmNjUxZDkxMWY"></p><p>为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;packages&quot;: [    &quot;packages&#x2F;*&quot;  ],  &quot;command&quot;: &#123;    &quot;bootstrap&quot;: &#123;      &quot;hoist&quot;: true    &#125;  &#125;,  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;&#125;</code></pre><p>配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：</p><pre class="line-numbers language-none"><code class="language-none">lerna clean</code></pre><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOWM2OTdjODVjMWM" width=350 style="object-fit:contain"/>然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 `node_modules` 中了。<h2 id="Lerna-Monorepo-最佳实践"><a href="#Lerna-Monorepo-最佳实践" class="headerlink" title="Lerna + Monorepo 最佳实践"></a>Lerna + Monorepo 最佳实践</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>lerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p></blockquote><p>目前最常见的 monorepo 解决方案是 Lerna 和 yarn 的 workspaces 特性，基于lerna和yarn workspace的monorepo工作流。由于yarn和lerna在功能上有较多的重叠,我们采用yarn官方推荐的做法,用yarn来处理依赖问题，用lerna来处理发布问题。能用yarn做的就用yarn做吧</p><h2 id="yarn-workspace"><a href="#yarn-workspace" class="headerlink" title="yarn workspace"></a>yarn workspace</h2><p>3.1.1 搭建环境<br>普通项目：clone下来后通过yarn install,即可搭建完项目，有时需要配合postinstall hooks,来进行自动编译，或者其他设置。</p><p>monorepo: 各个库之间存在依赖，如A依赖于B，因此我们通常需要将B link到A的node_module里，一旦仓库很多的话，手动的管理这些link操作负担很大，因此需要自动化的link操作，按照拓扑排序将各个依赖进行link</p><p>解决方式：通过使用workspace，yarn install会自动的帮忙解决安装和link问题</p><pre class="line-numbers language-none"><code class="language-none">yarn install # 等价于 lerna bootstrap --npm-client yarn --use-workspaces</code></pre><p>3.1.2 清理环境<br>在依赖乱掉或者工程混乱的情况下，清理依赖</p><p>普通项目： 直接删除node_modules以及编译后的产物。</p><p>monorepo： 不仅需要删除root的node_modules的编译产物还需要删除各个package里的node_modules以及编译产物</p><p>解决方式：使用lerna clean来删除所有的node_modules，使用yarn workspaces run clean来执行所有package的清理工作</p><pre class="line-numbers language-none"><code class="language-none">lerna clean # 清理所有的node_modulesyarn workspaces run clean # 执行所有package的clean操作</code></pre><p>3.1.3 安装|删除依赖<br>普通项目： 通过yarn add和yarn remove即可简单姐解决依赖库的安装和删除问题</p><p>monorepo: 一般分为三种场景</p><p>给某个package安装依赖：yarn workspace packageB add packageA 将packageA作为packageB的依赖进行安装</p><p>给所有的package安装依赖: 使用yarn workspaces add lodash 给所有的package安装依赖</p><p>给root 安装依赖：一般的公用的开发工具都是安装在root里，如typescript,我们使用yarn add -W -D typescript来给root安装依赖</p><p>对应的三种场景删除依赖如下</p><pre class="line-numbers language-none"><code class="language-none">yarn workspace packageB remove packageAyarn workspaces remove lodashyarn remove -W -D typescript</code></pre><p>3.1.4 项目构建<br>普通项目：建立一个build的npm script，使用yarn build即可完成项目构建</p><p>monorepo:区别于普通项目之处在于各个package之间存在相互依赖，如packageB只有在packageA构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。</p><p>我们可以自己构建拓扑排序规则，很不幸的是yarn的workspace暂时并未支持按照拓扑排序规则执行命令,虽然该 rfc已经被accepted，但是尚未实现, 幸运的是lerna支持按照拓扑排序规则执行命令, –sort参数可以控制以拓扑排序规则执行命令</p><pre class="line-numbers language-none"><code class="language-none">lerna run --stream --sort build</code></pre><p>3.1.5 版本升级及发包<br>项目测试完成后，就涉及到版本发布，版本发布一般涉及到如下一些步骤</p><p>条件验证: 如验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作</p><p>version_bump:发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循 semVer语义，</p><p>生成changelog: 为了方便查看每个package每个版本解决了哪些功能，我们需要给每个package都生成一份changelog方便用户查看各个版本的功能变化。</p><p>生成git tag：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个git tag</p><p>git 发布版本：每次发版我们都需要单独生成一个commit记录来标记milestone</p><p>发布npm包：发布完git后我们还需要将更新的版本发布到npm上，以便外部用户使用</p><p>我们发现手动的执行这些操作是很麻烦的且及其容易出错，幸运的是lerna可以帮助我们解决这些问题</p><p>yarn官方并不打算支持发布流程，只是想做好包管理工具，因此这部分还是需要通过lerna支持</p><p>lerna提供了publish和version来支持版本的升级和发布, publish的功能可以即包含version的工作，也可以单纯的只做发布操作。</p><p>3.2 优雅的提交<br>3.2.1 <code>commitizen</code> &amp;&amp; <code>cz-lerna-changelog</code><br>commitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。</p><p>cz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTNmZGEyMTA3MGI"></p><p>我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。</p><p>因为这是整个工程的开发依赖，所以在根目录安装：</p><pre class="line-numbers language-none"><code class="language-none">yarn add  -D commitizenyarn add  -D cz-lerna-changelog</code></pre><p>安装完成后，在 <code>package.json</code> 中增加 <code>config</code> 字段，把 <code>cz-lerna-changelog</code> 配置给 <code>commitizen</code>。同时因为<code>commitizen</code>不是全局安全的，所以需要添加 <code>scripts</code> 脚本来执行 <code>git-cz</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;name&quot;: &quot;root&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;git-cz&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;    &#125;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;commitizen&quot;: &quot;^3.1.1&quot;,    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,    &quot;lerna&quot;: &quot;^3.15.0&quot;  &#125;&#125;</code></pre><p>之后在常规的开发中就可以使用 yarn run commit 来根据提示一步一步输入，来完成代码的提交。</p><p>3.2.2 commitlint &amp;&amp; husky<br>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用<code>yarn run commit</code> 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p><p>安装 commitlint 以及要遵守的规范</p><pre class="line-numbers language-none"><code class="language-none">yarn add -D @commitlint&#x2F;cli @commitlint&#x2F;config-conventional</code></pre><p>在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范</p><pre class="line-numbers language-none"><code class="language-none">module.exports &#x3D; &#123; extends: [&#39;@commitlint&#x2F;config-conventional&#39;] &#125;</code></pre><p>安装 husky</p><pre class="line-numbers language-none"><code class="language-none">yarn add -D husky</code></pre><p>在 package.json 中增加如下配置</p><pre class="line-numbers language-none"><code class="language-none">&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123;    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;     &#125;&#125;</code></pre><p>“commit-msg”是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 yarn run commit 来提交。</p><p>3.2.3 eslint &amp;&amp; lint-staged<br>除了规范提交信息，代码本身肯定也少了靠规范来统一风格。</p><p>安装</p><pre class="line-numbers language-none"><code class="language-none">yarn add  -D standard lint-staged</code></pre><p>eslint就是完整的一套 JavaScript（typescript） 代码规范，自带 linter &amp; 代码自动修正。自动格式化代码并修正，提前发现风格以及程序问题, 同时也支持typescript的代码规范校验，<code>eslintrc.json</code>配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;extends&quot;: [        &quot;yayajing&quot;,        &quot;plugin:@typescript-eslint&#x2F;recommended&quot;    ],    &quot;parser&quot;: &quot;typescript-eslint-parser&quot;,    &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],    &quot;rules&quot;: &#123;        &quot;eqeqeq&quot;:&quot;off&quot;,        &quot;@typescript-eslint&#x2F;explicit-function-return-type&quot;: &quot;off&quot;,        &quot;no-template-curly-in-string&quot;: &quot;off&quot;    &#125;  &#125;</code></pre><p><code>lint-staged staged</code> 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。<br>package.json配置</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; package.json&#123;  &quot;name&quot;: &quot;root&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;c&quot;: &quot;git-cz&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;    &#125;  &#125;,  &quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;pre-commit&quot;: &quot;lint-staged&quot;,      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;    &#125;  &#125;,  &quot;lint-staged&quot;: &#123;    &quot;*.ts&quot;: [      &quot;eslint --fix&quot;,      &quot;git add&quot;    ]  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@commitlint&#x2F;cli&quot;: &quot;^8.1.0&quot;,    &quot;@commitlint&#x2F;config-conventional&quot;: &quot;^8.1.0&quot;,    &quot;commitizen&quot;: &quot;^3.1.1&quot;,    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,    &quot;husky&quot;: &quot;^3.0.0&quot;,    &quot;lerna&quot;: &quot;^3.15.0&quot;,    &quot;lint-staged&quot;: &quot;^9.2.0&quot;  &#125;&#125;</code></pre><p>安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 eslint –fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加pre-commit的钩子用来执行 lint-staged 的校验操作。</p><p>此时提交 ts 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。</p><p>3.3 发布自动生成日志<br>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：</p><p>3.3.1 lerna version 更新版本</p><ul><li><p>找出从上一个版本发布以来有过变更的 package</p></li><li><p>提示开发者确定要发布的版本号</p></li><li><p>将所有更新过的的 package 中的package.json的version字段更新</p></li><li><p>将依赖更新过的 package 的 包中的依赖版本号更新</p></li><li><p>更新 lerna.json 中的 version 字段</p></li><li><p>提交上述修改，并打一个 tag</p></li><li><p>推送到 git 仓库<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTMzNTMzMzhkYTA"></p></li></ul><p>3.3.2 使用 npm publish 将新版本推送到 npm<br><code>CHANGELOG</code> 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 <code>--conventional-commits</code>。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 <code>lerna.json</code>中，如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;packages&quot;: [    &quot;packages&#x2F;*&quot;  ],  &quot;command&quot;: &#123;    &quot;bootstrap&quot;: &#123;      &quot;hoist&quot;: true    &#125;,    &quot;version&quot;: &#123;      &quot;conventionalCommits&quot;: true    &#125;  &#125;,  &quot;ignoreChanges&quot;: [    &quot;**&#x2F;*.md&quot;  ],  &quot;version&quot;: &quot;0.0.1-alpha.1&quot;&#125;</code></pre><p><code>lerna version</code> 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 <code>ignoreChanges</code> 配置排除。如上。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTM3NTQwN2Y0MzY"></p><p>实际 <code>lerna version</code>很少直接使用，因为它包含在 <code>lerna publish</code> 中了，直接使用 <code>lerna publish</code>就好了。</p><p>3.4 完善的测试用例<br>monorepo项目：测试有两种方式</p><ul><li><p>使用统一的jest测试配置这样方便全局的跑jest即可，好处是可以方便统计所有代码的测试覆盖率，坏处是如果package比较异构（如小程序，前端，node 服务端等），统一的测试配置不太好编写</p></li><li><p>每个package单独支持test命令，使用yarn workspace run test，坏处是不好统一收集所有代码的测试覆盖率</p></li></ul><p>如果采用jest编写测试用例，支持typescript的话，需要初始化配置jest.config.js：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">module.exports &#x3D; &#123;  preset: &#39;ts-jest&#39;,  moduleFileExtensions: [&#39;ts&#39;],  testEnvironment: &#39;node&#39;&#125;</code></pre><p>4 实践总结<br>到这里，基本上已经构建了基于lerna和yarn workspace的monorepo项目的最佳实践了，该有的功能都有：</p><ul><li><p>完善的工作流</p></li><li><p>typescript支持</p></li><li><p>风格统一的编码</p></li><li><p>完整的单元测试</p></li><li><p>一键式的发布机制</p></li><li><p>完美的更新日志</p></li></ul><p>……</p><p>当然，构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/i10630226/article/details/99702447">lerna+yarn workspace+monorepo项目的最佳实践</a><br><a href="https://www.jianshu.com/p/c10d0b8c5581">5分钟搞懂Monorepo</a><br><a href="https://www.easemob.com/news/5948">2021年管理Monorepo代码库的11种出色工具</a></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> npm </tag>
            
            <tag> monorepo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信标（Beacon ）</title>
      <link href="//post/2022-05-23beacon.html"/>
      <url>//post/2022-05-23beacon.html</url>
      
        <content type="html"><![CDATA[<h2 id="Beacon-特点"><a href="#Beacon-特点" class="headerlink" title="Beacon  特点"></a>Beacon  特点</h2><ul><li>接口用于将<em>异步</em>和<em>非阻塞</em>请求发送到服务器。</li><li>请求使用HTTP协议中的POST方法，请求通常<em>不需要响应</em>。</li><li>这个请求被保证在，页面的unload状态从发起到完成之前，被发送。而并不需要一个阻塞请求，例如 XMLHttpRequest 。<h2 id="Beacon-场景"><a href="#Beacon-场景" class="headerlink" title="Beacon  场景"></a>Beacon  场景</h2>发送异步非阻塞数据到服务端<h2 id="为什么是信标？"><a href="#为什么是信标？" class="headerlink" title="为什么是信标？"></a>为什么是信标？</h2>Beacon 接口满足了<em>分析</em>和<em>诊断代码</em>的需要，这些代码通常会尝试在<em>卸载文档之前将数据发送到 web服务器</em>。发送数据的任何过早时机都可能导致错失收集数据的机会。但是，确保在卸载文档期间发送数据是开发人员难以做到的。</li></ul><p>用户代理通常会忽略卸载文档处理程序中的异步 XMLHttpRequests 请求。若要解决此问题，为了分析和诊断代码，通常会在 unload (en-US) 事件或 beforeunload (en-US) 事件中创建同步 XMLHttpRequest 请求以提交数据。同步 XMLHttpRequest 请求强制浏览器延迟卸载文档，并使下一个页面跳转看起来较慢。下一页面没有任何办法来避免这种页面加载性能不佳的感觉。</p><h2 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h2><p>其中一种技术是通过创建 Image 元素并在卸载文档处理程序中设置其 src 属性来延迟卸载以提交数据。由于大多数用户代理会延迟文档卸载，以完成挂起的图片加载，因此可以在卸载过程中提交数据。另一种方法是在卸载处理程序中创建一个无操作循环，花费数秒以延迟卸载并将数据提交到服务器。</p><p>但是上述技术不仅代表了较差的编码模式，其中一些还是不可靠的，会导致下一个导航的页面加载性能较差的感觉。信标 API 提供了解决这些问题的标准方法。</p><h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><p>Beacon API 的 Navigator.sendBeacon() 方法用于在全局浏览上下文中向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。</p><h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>Beacon API的 WorkerNavigator.sendBeacon() 方法用于从 worker global scope 向服务器发送数据信标。该方法有两个参数，URL和要在请求中发送的数据data。data参数是可选的，其类型可以是 ArrayBufferView、Blob、DOMString 或 FormData。如果浏览器成功的以队列形式排列了用于传递的请求，则该方法返回“true”，否则返回“false”。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>API 提供了解决这些问题的标准方法</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>浏览器兼容性<br>Navigator.sendBeacon().Browser_compatibility表说明了该方法具有相对广泛地实现。但是，WorkerNavigator.sendBeacon().Browser_compatibility数据显示该方法没有被实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter Bruno</title>
      <link href="//post/2022-05-20fluter-bruno.html"/>
      <url>//post/2022-05-20fluter-bruno.html</url>
      
        <content type="html"><![CDATA[<h1 id="Bruno"><a href="#Bruno" class="headerlink" title="Bruno"></a>Bruno</h1><p><img src="http://t-blog-images.aijs.top/img/20220520105610.webp"><br>Bruno 是由贝壳「用户体验中心 &amp; 移动端作业组」联合打造的一套企业级移动端 Flutter 组件库，于 12 月 10 日正式开源:</p><p><a href="https://bruno.ke.com/">官网</a></p><p><a href="https://pub.flutter-io.cn/packages/bruno">Pub 地址</a></p><p><a href="https://github.com/LianjiaTech/bruno">GitHub 仓库</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>贝壳自 2018 年底开始对 Flutter 的探索和实践，Flutter 落地业务有效地提升了产研效率。但跨业务线协同效率较低，重复劳动力大，代码维护成本高等问题依旧凸显。Bruno 是贝壳针对上述问题在公司内发起的提效专项，致力于打造贝壳标准 Flutter 生态。经过两年的打磨和沉淀，Bruno 现已服务贝壳 B 端全线业务，涵盖 30 多种类型 100+  组件，为近 18 个 App 服务，新增页面组件覆盖率平均达到 80% 以上。</p><p>相信贝壳遇到的问题也是大型团队或者个人开发者不可避免的问题，目前针对该类问题的中后台解决方案层出不穷，但在 Flutter 生态中类似成熟解决方案匮乏。我们希望将贝壳在 Flutter 领域的实践经验回馈给社区，更加完善 Flutter 生态，因此 Bruno 正式开源。</p><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><p>Bruno 基于生长、包容、联接的设计理念，赋予组件轻巧灵活、拥抱变化、包容万物的品质。</p><h1 id="Bruno-的优势"><a href="#Bruno-的优势" class="headerlink" title="Bruno 的优势"></a>Bruno 的优势</h1><ol><li>适度灵活、充分可扩展</li></ol><p>Bruno 倡导标准化下的自由、简单、灵活，基于 Flutter 基础组件的封装，使其具备适度灵活，使用组件提效尤为重要。同时组件支持充分可扩展，既可满足多产品的快速接入又能包容特殊场景。</p><p>经过两年的业务实践，我们最终产出了 102 个组件，覆盖类型有 图表、导航、数据录入、操作反馈、内容展示 等。</p><p><img src="http://t-blog-images.aijs.top/img/54b2f46cdc6ee8467b67d92d9c0d2d98.gif"><br>2. 连接设计&lt;–&gt;开发</p><p>Bruno 基于 Sketch MeaXure 二次开发，实现组件自动识别和标注。开发者可以从设计侧产出的标注稿中清晰的看到页面涵盖的组件，信息无缝传达，高效连接设计与开发。</p><p><img src="http://t-blog-images.aijs.top/img/a72e4aee43eb8e32589bef23dd95c75d.gif"><br>3. 主题定制、品牌风格自定义</p><p>Bruno 不仅支持全局色号的替换，还支持组件圆角、字体大小、内部间距等属性的定制。在定制全局样式打造自有品牌风格的同时，支持单个组件自定义满足特异化场景需求。</p><ul><li>默认基础规范</li></ul><img src="http://t-blog-images.aijs.top/img/20220520105949.webp" style="width:400px;object-fit:contain" /><img src="http://t-blog-images.aijs.top/img/20220520110003.webp" style="width:400px;object-fit:contain" /><ul><li>全局样式定制</li></ul><p><img src="http://t-blog-images.aijs.top/img/61dc33d90cd80e88c4a52cccdc713c48.gif"></p><ul><li>单组件样式定制</li></ul><p><img src="http://t-blog-images.aijs.top/img/6da0a3d9b63b47e64a127320597900eb.gif"><br>Bruno 还可支持单业务的全局配置，也就是说如果你是组件化工程结构，那么你可以定义每个业务组件的特有风格。</p><ol start="4"><li>物料承载、教程指引</li></ol><p>Bruno 官网承载产品设计物料、组件配套文档、Demo 下载、搜索等基础能力，同时配有教程指引开发也可操作 Sketch 插件设计页面，实现零设计资源介入。</p><p><img src="http://t-blog-images.aijs.top/img/ea334037633605e094d03338cc151045.gif"><br>Bruno 官网: <a href="https://bruno.ke.com/">https://bruno.ke.com</a></p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><ol><li>丰富和完善组件</li></ol><p>目前 Bruno 组件涵盖种类可以覆盖常见使用场景，满足企业建立自有品牌形象 App 需求。未来我们会根据业务发展和产品升级不断迭代组件，丰富产品内容提升视觉体验。</p><ol start="2"><li>提升落地效率</li></ol><p>我们不止关注组件的设计与研发，组件落地也是提升产研效率至关重要的环节，因此我们对 Sketch MeaXure 做了二次改造，实现组件自动化标注。同时贝壳产研团队把自动化标注能力线上化，进一步提升组件落地效率。</p><p>3、UI 自动化走查</p><p>贝壳产研团队也在探索 UI 自动化走查方向，期望解放设计侧走查人力，让设计师更多投入对产品的洞察理解，创造优质设计，提升视觉体验。</p>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> flutter </tag>
            
            <tag> mobile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm开发wiki编辑器问题总结</title>
      <link href="//post/2022-05-19npm-pkg.html"/>
      <url>//post/2022-05-19npm-pkg.html</url>
      
        <content type="html"><![CDATA[<h2 id="原架构"><a href="#原架构" class="headerlink" title="原架构"></a>原架构</h2><p><img src="http://t-blog-images.aijs.top/img/wiki-ui.webp"></p><h2 id="重构后"><a href="#重构后" class="headerlink" title="重构后"></a>重构后</h2><p><img src="http://t-blog-images.aijs.top/img/slate-wiki.webp"></p><h2 id="tsconfig-ts"><a href="#tsconfig-ts" class="headerlink" title="tsconfig.ts"></a>tsconfig.ts</h2><pre class="line-numbers language-none"><code class="language-none">&#123;  &#x2F;&#x2F; 编译选项  &quot;compilerOptions&quot;: &#123;    &#x2F;&#x2F; 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码    &quot;target&quot;: &quot;es5&quot;,    &#x2F;&#x2F; 指定要包含在编译中的 library    &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;TypeScript&#x2F;blob&#x2F;90e83adb44&#x2F;lib&#x2F;lib.dom.iterable.d.ts    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],    &#x2F;&#x2F; 允许 ts 编译器编译 js 文件    &quot;allowJs&quot;: true,    &#x2F;&#x2F; 跳过类型声明文件的类型检查    &quot;skipLibCheck&quot;: true,    &#x2F;&#x2F; es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异    &quot;esModuleInterop&quot;: true,    &#x2F;&#x2F; 允许通过 import x from &#39;y&#39; 即使模块没有显式指定 default 导出    &quot;allowSyntheticDefaultImports&quot;: true,    &#x2F;&#x2F; 开启严格模式    &quot;strict&quot;: true,    &#x2F;&#x2F; 对文件名称强制区分大小写    &quot;forceConsistentCasingInFileNames&quot;: true,    &#x2F;&#x2F; 为 switch 语句启用错误报告    &quot;noFallthroughCasesInSwitch&quot;: true,    &#x2F;&#x2F; 生成代码的模块化标准    &quot;module&quot;: &quot;esnext&quot;,    &#x2F;&#x2F; 模块解析（查找）策略    &quot;moduleResolution&quot;: &quot;node&quot;,    &#x2F;&#x2F; 允许导入扩展名为.json的模块    &quot;resolveJsonModule&quot;: true,    &#x2F;&#x2F; 是否将没有 import&#x2F;export 的文件视为旧（全局而非模块化）脚本文件    &quot;isolatedModules&quot;: true,    &#x2F;&#x2F; 编译时不生成任何JS文件（只进行类型检查）    &quot;noEmit&quot;: true,    &#x2F;&#x2F; 指定将 JSX 编译成什么形式    &quot;jsx&quot;: &quot;react-jsx&quot;  &#125;,  &#x2F;&#x2F; 指定允许 ts 处理的目录  &quot;include&quot;: [&quot;src&quot;]&#125;&#x2F;&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_62118859&#x2F;article&#x2F;details&#x2F;124543485</code></pre><h2 id="Cannot-read-properties-of-null"><a href="#Cannot-read-properties-of-null" class="headerlink" title="Cannot read properties of null"></a>Cannot read properties of null</h2><pre class="line-numbers language-none"><code class="language-none">react.development.js:1621 Uncaught TypeError: Cannot read properties of null</code></pre><hr/><h2 id="ahooks-版本"><a href="#ahooks-版本" class="headerlink" title="ahooks  版本"></a>ahooks  版本</h2><ol><li><p>useControlledValue</p><pre class="line-numbers language-none"><code class="language-none">Uncaught SyntaxError: The requested module &#39;&#x2F;node_modules&#x2F;.vite&#x2F;deps&#x2F;ahooks.js?v&#x3D;a7b43f7a&#39; does not provide an export named &#39;useControlledValue&#39; (at index.tsx:2:1)</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Deprecated the useControlledValue naming left over from 1.0, please use useControllableValue instead<br><a href="https://github.com/alibaba/hooks/releases?page=5#:~:text=Deprecated%20the%20useControlledValue%20naming%20left%20over%20from%201.0%2C%20please%20use%20useControllableValue%20instead"><a href="https://github.com/alibaba/hooks/releases/tag/v3.0.0-alpha.4">v3.0.0-alpha.4</a></a></p></blockquote></li><li><p>useRequest</p></li></ol><pre class="line-numbers language-none"><code class="language-none">react_devtools_backend.js:4026 Warning: Failed prop type: The prop &#96;loadMore&#96; is marked as required in &#96;InfiniteScroll&#96;, but its value is &#96;undefined&#96;.</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Removed loadMore related attributes, it is recommended to use useInfiniteScroll to achieve unlimited loading capacity.<br><a href="https://github.com/alibaba/hooks/releases/tag/v3.0.0-alpha.4">v3.0.0-alpha.4</a></p></blockquote><p><a href="http://quanzhan.applemei.com/webStack/TmpJeE1BPT0=">除了 dependencies 和 devDependencies，其他的依赖有什么作用呢</a></p><pre class="line-numbers language-none"><code class="language-none">Pre-bundling dependencies:reactrecoilreact-domreact-router-domantd(...and 29 more)</code></pre><h3 id="本地npm-link处理不了依赖冲突"><a href="#本地npm-link处理不了依赖冲突" class="headerlink" title="本地npm link处理不了依赖冲突"></a>本地<code>npm link</code>处理不了依赖冲突</h3><ul><li>老版本可以运行</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220519183558.webp"></p><ul><li>新版本报错</li><li>原因 ahooks^3.x.x没有v2版本api</li></ul><hr/><h3 id="发布安装到项目中测试"><a href="#发布安装到项目中测试" class="headerlink" title="发布安装到项目中测试"></a>发布安装到项目中测试</h3><ul><li>发布</li></ul><ol><li><p>npm 脚本</p><pre class="line-numbers language-none"><code class="language-none">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite --port 3004&quot;,    &quot;start&quot;: &quot;yarn build:css &amp;&amp; webpack serve --config config&#x2F;webpack.dev.config.js&quot;,    &quot;copy:css&quot;: &quot;cp src&#x2F;**&#x2F;*.css dist&#x2F; &amp;&amp; rsync src&#x2F;styles&#x2F;*.css dist&#x2F;styles&#x2F;&quot;,    &quot;build&quot;: &quot;tsc&quot;,    &quot;build:css&quot;: &quot;node-sass src&#x2F; -o src&#x2F; &quot;,    &quot;prepublishOnly&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,    &quot;t&quot;: &quot;rm -rf dist&#x2F; &amp;&amp; yarn build &amp;&amp; yarn build:css &amp;&amp; yarn copy:css&quot;,    &quot;push:beta&quot;: &quot;npm publish --tag beta&quot;  &#125;,</code></pre></li><li><p>执行脚本<br><code>$ yarn push:beta</code></p></li><li><p>发布结果</p></li></ol><pre class="line-numbers language-none"><code class="language-none">## Current Tags*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           beta (a few seconds ago)*   [0.0.1 ](https:&#x2F;&#x2F;tnpm.ty-inc.top&#x2F;package&#x2F;@ty-fe&#x2F;slate-wiki-pro&#x2F;v&#x2F;0.0.1)                               ...           latest (a few seconds ago)</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220519183625.webp"><br><img src="http://t-blog-images.aijs.top/img/20220519183638.webp"></p><hr/><h2 id="图片没有渲染，修改，打包重新发布0-0-1-220519beta版本测试"><a href="#图片没有渲染，修改，打包重新发布0-0-1-220519beta版本测试" class="headerlink" title="图片没有渲染，修改，打包重新发布0.0.1-220519beta版本测试"></a>图片没有渲染，修改，打包重新发布<code>0.0.1-220519beta</code>版本测试</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">slate-wiki@0.0.1-220519betanpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; npm notice name:          @ty-fe&#x2F;slate-wiki                     npm notice version:       0.0.1-220519beta                        npm notice filename:      @ty-fe&#x2F;slate-wiki-0.0.1-220519beta.tgznpm notice package size:  228.0 kB                                npm notice unpacked size: 1.2 MB                                  npm notice shasum:        a2991de4933a9e5039ceb7082c5e0a80c2db828cnpm notice integrity:     sha512-iHQKpR2LM+F6Z[...]XDN40tHfwMxNg&#x3D;&#x3D;npm notice total files:   417                                     npm notice + @ty-fe&#x2F;slate-wiki@0.0.1-220519beta✨  Done in 16.36s.slate-wiki-pro@0.0.1-220519betanpm notice &#x3D;&#x3D;&#x3D; Tarball Details &#x3D;&#x3D;&#x3D; npm notice name:          @ty-fe&#x2F;slate-wiki-pro                     npm notice version:       0.0.1-220519beta                            npm notice filename:      @ty-fe&#x2F;slate-wiki-pro-0.0.1-220519beta.tgznpm notice package size:  83.5 kB                                     npm notice unpacked size: 413.7 kB                                    npm notice shasum:        85cbe6fbffafc75db16e02427d1eac9b6a906ec3    npm notice integrity:     sha512-3viVco6ssb2N3[...]xxisHN9+qYnCA&#x3D;&#x3D;    npm notice total files:   205                                         npm notice + @ty-fe&#x2F;slate-wiki-pro@0.0.1-220519beta✨  Done in 14.68s.</code></pre><hr/><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>传染性<br>slate-wiki-pro,依赖于slate-wiki。slate-wiki改动，项目依赖slate-wiki-pro，需要发slate-wiki和slate-wiki-pro，项目要安装slate-wiki-pro</li></ol><p><code>是否可以让项目直接依赖slate-wiki、slate-wiki-pro改动哪个发布哪个，互不影响？</code></p><ol start="2"><li>项目很卡</li></ol><p><code>将slate、slate-wiki、slate-wiki-pro使用umd资源，避免重复编译是否可以？</code></p><ol start="3"><li>依赖贼多</li></ol><pre class="line-numbers language-none"><code class="language-none">[######--------------------------------------------------] 49992&#x2F;102014</code></pre><ol start="4"><li>启动没有想象中那么快了</li></ol><p>vite预编译时间过长  130262ms &#x2F; 1000 &#x2F; 60 大概两分钟，加载编译大概几分钟，慢的吓人</p><pre class="line-numbers language-none"><code class="language-none">vite v2.7.1 dev server running at:&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;&gt; Network: use &#96;--host&#96; to exposeready in 130262ms.  #首次编译vite v2.7.1 dev server running at:&gt; Local: http:&#x2F;&#x2F;localhost:3005&#x2F;&gt; Network: use &#96;--host&#96; to exposeready in 43312ms. #非首次编译</code></pre><hr/><h2 id="代码放仓库"><a href="#代码放仓库" class="headerlink" title="代码放仓库"></a>代码放仓库</h2><ul><li>slate-wiki</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220519183700.webp"></p><p>Command line instructions<br>You can also upload existing files from your computer using the instructions below.</p><p>Git global setup</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;陈海龙&quot;git config --global user.email &quot;haotian.chen@ty.com&quot;</code></pre><p>Create a new repository</p><pre class="line-numbers language-none"><code class="language-none">git clone ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.gitcd slate-wikitouch README.mdgit add README.mdgit commit -m &quot;add README&quot;</code></pre><p>Push an existing folder</p><pre class="line-numbers language-none"><code class="language-none">cd existing_foldergit initgit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.gitgit add .git commit -m &quot;Initial commit&quot;</code></pre><p>Push an existing Git repository</p><pre class="line-numbers language-none"><code class="language-none">cd existing_repogit remote rename origin old-origingit remote add origin ssh:&#x2F;&#x2F;git@registry.code.ty-inc.top:10023&#x2F;fe-efficacy&#x2F;slate-wiki.git</code></pre><ul><li>slate-wiki-pro<br>略<hr/></li></ul><p>深入了解打包，本站请搜<a href="https://v.aijs.top/post/2022-05-19npm"><code>npm 版本的依赖</code></a></p><h2 id="react-codemirror使用版本react16-插件及项目使用react18"><a href="#react-codemirror使用版本react16-插件及项目使用react18" class="headerlink" title="react-codemirror使用版本react16,插件及项目使用react18"></a>react-codemirror使用版本react16,插件及项目使用react18</h2><pre class="line-numbers language-none"><code class="language-none">react-dom.development.js:22738 Uncaught TypeError: cm is not a function    at UnControlled.componentDidMount (react-codemirror.tsx:718:19)    at commitLayoutEffectOnFiber (react-dom.development.js:23204:30)    at commitLayoutMountEffects_complete (react-dom.development.js:24578:9)    at commitLayoutEffects_begin (react-dom.development.js:24564:7)    at commitLayoutEffects (react-dom.development.js:24502:3)    at commitRootImpl (react-dom.development.js:26779:5)    at commitRoot (react-dom.development.js:26638:5)    at performSyncWorkOnRoot (react-dom.development.js:26073:3)    at flushSyncCallbacks (react-dom.development.js:12009:22)    at flushSyncCallbacksOnlyInLegacyMode (react-dom.development.js:11988:5)</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220520141611.webp"></p><h2 id="vite-关于-global-is-not-defined-问题"><a href="#vite-关于-global-is-not-defined-问题" class="headerlink" title="vite 关于 global is not defined 问题"></a>vite 关于 global is not defined 问题</h2><p><a href="https://github.com/scniro/react-codemirror2/blob/0f2bb13cad2fb1364eb063cbd7ec9aae726a55eb/src/index.tsx#L7">react-codemirror2 源码</a></p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">declare let global: any;declare let require: any;const SERVER_RENDERED &#x3D; (typeof navigator &#x3D;&#x3D;&#x3D; &#39;undefined&#39; || (typeof global !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; global[&#39;PREVENT_CODEMIRROR_RENDER&#39;] &#x3D;&#x3D;&#x3D; true));let cm;if (!SERVER_RENDERED) &#123;  cm &#x3D; require(&#39;codemirror&#39;);&#125;</code></pre><h2 id="vite-404"><a href="#vite-404" class="headerlink" title="vite 404"></a>vite 404</h2><pre class="line-numbers language-none"><code class="language-none">Could not load content for http:&#x2F;&#x2F;localhost:3005&#x2F;node_modules&#x2F;@tuya-fe&#x2F;slate-wiki&#x2F;src&#x2F;slate&#x2F;3rd&#x2F;react-codemirror.tsx (HTTP error: status code 404, net::ERR_HTTP_RESPONSE_CODE_FAILURE)</code></pre><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li>codemirror 在vite中运行报错，codemirror找不到，webpack打包正常</li></ul>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 版本的依赖</title>
      <link href="//post/2022-05-19npm.html"/>
      <url>//post/2022-05-19npm.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。</p><h1 id="npm-安装机制"><a href="#npm-安装机制" class="headerlink" title="npm 安装机制"></a>npm 安装机制</h1><p>A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。</p><h2 id="A-和-B-同时依赖-C，这个包会被安装在哪里呢？"><a href="#A-和-B-同时依赖-C，这个包会被安装在哪里呢？" class="headerlink" title="A 和 B 同时依赖 C，这个包会被安装在哪里呢？"></a>A 和 B 同时依赖 C，这个包会被安装在哪里呢？</h2><p>假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。执行完毕后，我们会看到 <code>./node_modules</code> 这层目录只含有这两个子目录：</p><pre class="line-numbers language-none"><code class="language-none">node_modules&#x2F; ├─┬ A │ ├── C ├─┬ B │ └── C </code></pre><p>如果使用 npm 3 来进行安装的话，<code>./node_modules</code> 下的目录将会包含三个子目录：</p><pre class="line-numbers language-none"><code class="language-none">node_modules&#x2F; ├─┬ A ├─┬ B ├─┬ C </code></pre><p>为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：</p><h2 id="npm-2-和-npm-3-模块安装机制的差异"><a href="#npm-2-和-npm-3-模块安装机制的差异" class="headerlink" title="npm 2 和 npm 3 模块安装机制的差异"></a>npm 2 和 npm 3 模块安装机制的差异</h2><p>虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异。</p><p>npm 2 在安装依赖包时，采用简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。执行完毕后，我们会看到 .&#x2F;node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：</p><p><img src="http://t-blog-images.aijs.top/img/20220519181427.webp"></p><p>这样的目录有较为明显的好处：</p><p>1）层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录；</p><p>2）在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置；</p><p>3）如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录；</p><p>但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 <code>npm install</code> 后，D 会被重复下载三次，而随着我们的项目越来越复杂，<code>node_modules</code> 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；</p><p>为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。</p><h2 id="npm-3-对于同一依赖的不同版本会怎么处理呢？"><a href="#npm-3-对于同一依赖的不同版本会怎么处理呢？" class="headerlink" title="npm 3 对于同一依赖的不同版本会怎么处理呢？"></a>npm 3 对于同一依赖的不同版本会怎么处理呢？</h2><p>npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):</p><p><img src="http://t-blog-images.aijs.top/img/20220519181500.webp"></p><p>但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：</p><p><img src="http://t-blog-images.aijs.top/img/20220519181517.webp"></p><p>由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。</p><h2 id="为什么会出现-package-lock-json-呢？"><a href="#为什么会出现-package-lock-json-呢？" class="headerlink" title="为什么会出现 package-lock.json 呢？"></a>为什么会出现 package-lock.json 呢？</h2><p>为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。</p><h2 id="package-json-的不足之处"><a href="#package-json-的不足之处" class="headerlink" title="package.json 的不足之处"></a>package.json 的不足之处</h2><p>npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因：</p><p>1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 <code>A: &#39;^1.0.5&#39;</code> ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug；</p><p>2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 <code>A: &#39;1.0.5&#39;</code> 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。</p><h2 id="针对-package-json-不足的解决方法"><a href="#针对-package-json-不足的解决方法" class="headerlink" title="针对 package.json 不足的解决方法"></a>针对 package.json 不足的解决方法</h2><p>为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。</p><h2 id="package-lock-json-文件的结构"><a href="#package-lock-json-文件的结构" class="headerlink" title="package-lock.json 文件的结构"></a>package-lock.json 文件的结构</h2><p>package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 <a href="https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires">package-lock-json官方文档</a>，主要的结构如下：</p><ul><li><p>version ：包版本，即这个包当前安装在 node_modules 中的版本</p></li><li><p>resolved ：包具体的安装来源</p></li><li><p>integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效</p></li><li><p>requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同</p></li><li><p>dependencies ：结构和外层的 <code>dependencies</code> 结构相同，存储安装在子依赖 <code>node_modules</code> 中的依赖包</p></li></ul><p>需要注意的是，并不是所有的子依赖都有 <code>dependencies</code> 属性，只有子依赖的依赖和当前已安装在根目录的 <code>node_modules</code> 中的依赖冲突之后，才会有这个属性。</p><h2 id="package-lock-json-文件的作用"><a href="#package-lock-json-文件的作用" class="headerlink" title="package-lock.json 文件的作用"></a>package-lock.json 文件的作用</h2><p>在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；</p><p>node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。</p><p>由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。</p><p>在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。</p><h1 id="依赖的区别与使用场景"><a href="#依赖的区别与使用场景" class="headerlink" title="依赖的区别与使用场景"></a>依赖的区别与使用场景</h1><h2 id="npm-目前支持以下几类依赖包管理包括"><a href="#npm-目前支持以下几类依赖包管理包括" class="headerlink" title="npm 目前支持以下几类依赖包管理包括"></a>npm 目前支持以下几类依赖包管理包括</h2><ol><li><p>dependencies</p></li><li><p>devDependencies</p></li><li><p>optionalDependencies 可选择的依赖包</p></li><li><p>peerDependencies 同等依赖</p></li><li><p>bundledDependencies 捆绑依赖包</p></li></ol><p>下面我们来看一下这几种依赖的区别以及各自的应用场景：</p><h2 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h2><p>dependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 <code>npm install XXX --save</code> 下载 dependencies 中的包；</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;devDependencies&quot;:&#123;  &quot;eslint&quot;: &quot;^5.0.0&quot;,  &quot;debug&quot;: &quot;^3.1.0&quot;,&#125;</code></pre><h2 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h2><p>devDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 <code>npm install packageName --save-dev</code> 下载的包都会在 devDependencies 对象中；</p><p>dependencies 和 devDependencies 最大的区别是在打包运行时，执行 <code>npm install</code> 时默认会把所有依赖全部安装，但是如果使用 <code>npm install --production</code> 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。</p><h2 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h2><p>optionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。</p><p>optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">try &#123;   var axios &#x3D; require(&#39;axios&#39;)   var fooVersion &#x3D; require(&#39;axios&#x2F;package.json&#39;).version &#125; catch (er) &#123;   foo &#x3D; null &#125; &#x2F;&#x2F; .. then later in your program .. if (foo) &#123;   foo.doFooThings() &#125; </code></pre><h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h2><p>peerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 <code>ant-design@3.x</code> 的 <code>package.json</code> 中的配置如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;peerDependencies&quot;: &#123;   &quot;react&quot;: &quot;&gt;&#x3D;16.9.0&quot;,   &quot;react-dom&quot;: &quot;&gt;&#x3D;16.9.0&quot;  &#125;, </code></pre><p>假设我们创建了一个名为 project 的项目，在此项目中我们要使用 <code>ant-design@3.x</code> 这个插件，此时我们的项目就必须先安装 React &gt;&#x3D; 16.9.0 和 React-dom &gt;&#x3D; 16.9.0 的版本。</p><p>在 npm 2 中，当我们下载 <code>ant-design@3.x</code> 时，peerDependencies 中指定的依赖会随着 <code>ant-design@3.x</code> 一起被强制安装，所以我们不需要在宿主项目的 <code>package.json</code> 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖；</p><h2 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h2><p>这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;   &quot;name&quot;: &quot;project&quot;,   &quot;version&quot;: &quot;1.0.0&quot;,   &quot;bundleDependencies&quot;: [     &quot;axios&quot;,      &quot;lodash&quot;   ] &#125; </code></pre><p>当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 <code>npm install project-1.0.0.tgz</code> 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;bundleDependencies&quot;: [     &quot;axios&quot;,     &quot;lodash&quot;   ], &quot;dependencies&quot;: &#123;   &quot;axios&quot;: &quot;*&quot;,   &quot;lodash&quot;: &quot;*&quot; &#125;, </code></pre><p>如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.zoo.team/article/npm-details">原文</a></li><li><a href="https://docs.npmjs.com/files/package.json#peerdependencies">package.json官方文档</a></li><li><a href="https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires">package-lock-json官方文档</a></li><li><a href="https://juejin.im/post/6844903582337237006#heading-0">npm文档总结</a></li><li><a href="https://www.npmjs.cn/cli/pack/">npm-pack</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript noEmit</title>
      <link href="//post/2022-05-18ts.html"/>
      <url>//post/2022-05-18ts.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>No Emit -<br>noEmit<br>Do not emit compiler output files like JavaScript source code, source-maps or declarations.<br>不要发出编译器输出文件，如JavaScript源代码、源映射或声明。</p><p>This makes room for another tool like Babel, or swc to handle converting the TypeScript file to a file which can run inside a JavaScript environment.</p><p>You can then use TypeScript as a tool for providing editor integration, and as a source code type-checker.</p><p><code>导致outDir不输出</code></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slate 学习</title>
      <link href="//post/2022-04-29slate-lean.html"/>
      <url>//post/2022-04-29slate-lean.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://doodlewind.github.io/slate-doc-cn/">slate 中文文档</a><br><a href="https://docs.slatejs.org/">slate 英文文档</a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://doodlewind.github.io/slate-doc-cn/">Slate</a> 是一个 完全 可定制的富文本编辑框架。<br>通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。</p></blockquote><h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>通过 Slate，你可以构建出类似 Medium、Dropbox Paper 或者 Canvas 这样使用直观、富交互、体验业已成为 Web 应用标杆的编辑器。同时，你也无需担心在代码实现上陷入复杂度的泥潭之中。<br>Slate 之所以能做到这一点，是因为它的所有逻辑都是通过一系列的插件实现的。这样，你就再也不会被某项特性 在 或 不在 编辑器【核心】边界之内的问题所困扰了。你可以将它理解为在 React 和 Immutable 基础上，一种可插拔的 contenteditable 实现。另外，它的灵感来自于 Draft.js，Prosemirror 和 Quill 等类库。</p></blockquote><h2 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为什么发明 Slate 呢？好吧…（注意，这部分内容包含了一些我的个人观点！）</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在发明 Slate 之前，我尝试了许多不同的富文本编辑器。我发现虽然它们在编写简单示例时基本没有问题，但一旦想要构建一些类似 Medium、Dropbox Paper 或者 Google Docs 这样的内容，你就会发现一些深层次的问题，比如…</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>编辑器硬编码了文档的结构规范，难以定制</strong>。类似加粗和斜体的结构可以开箱即用，但评论、嵌入内容以及更多的定制性需求呢？</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>对文档的编程式变换非常错综复杂</strong>。用户的编写体验可能不错，但在执行编程式变更时却不必要地复杂，而这对于构建高级的编辑行为至关重要。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>对 HTML、Markdown 等内容的序列化支持看起来像是事后加上的</strong>。这是一个非常常见的使用场景，但要实现将文档转换为 HTML 或 Markdown 的简单功能都需要编写大量的模板代码。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>重新学习一个新的视图层效率不高且十分受限</strong>。各种编辑器在重新发明视图层的轮子，而非使用 React 这样已有的技术方案。你必须学习一套带着自有限制和陷阱的新系统。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>**<code>对协同编辑没有预先设计好的支持</code>**。编辑器内部的数据结构使其无法用于实时、协作的编辑场景中，除非重写编辑器。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>代码仓库是单体的，而非小而可复用的</strong>。许多编辑器没有对外开放本应为开发者所复用的内部工具，以至于不得不重新发明轮子。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>无法构建复杂而存在嵌套关系的文档</strong>。不少编辑器是围绕简单的【扁平】文档结构设计的，这使得表格、嵌入内容和字幕等内容难以理解，有时甚至无法实现。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当然，并非所有的编辑器都存在以上的问题，但如果你已经尝试过一些编辑器，你可能已经踩过类似的坑了。为了摆脱它们在 API 上的限制来达到你期望的用户体验，你得使用各种奇技淫巧，有些体验甚至是完全无法实现的。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>如果你遇到了相似的问题，那么也许你会喜欢上 Slate。让我来介绍一下 Slate 是如何解决这些问题的吧…</p></blockquote><h2 id="提供了什么能力"><a href="#提供了什么能力" class="headerlink" title="提供了什么能力"></a>提供了什么能力</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Slate 尝试通过一些原则来解决 “Why?” 这一节中的问题：</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>作为一等公民的插件</strong>。 在 Slate 中最重要的一点是，插件是一等公民（first-class）的实体——甚至连编辑器的核心逻辑都是通过插件实现的。这意味着你能够 完全地 定制编辑体验，构建出对标 Medium 和 Canvas 那样的复杂编辑器，而无需对抗各种类库的预设条件。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>精简 Schema 的核心</strong>。 Slate 的核心逻辑并不对你所编辑的数据结构做任何假设，这意味着你在需要应对复杂场景时不会被编辑器预置的内容所束缚（译者注：此处 Schema 可理解为类似 XML Schema 的文档结构规范）。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>支持嵌套的文档模型</strong>。 Slate 所使用的文档模型是一棵嵌套的、递归的树，和 DOM 本身十分接近。这使得构建表格和嵌套引用等能够满足进阶需求的复杂组件成为了可能。当然，你同样可以使用单一的层级关系以保证简单性。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>无状态、不可变的数据</strong>。 通过使用 React 和 Immutable.js，我们是基于不可变数据结构，以无状态的方式构建 Slate 编辑器的。这大大降低了理解代码的难度，也节约了大量开发插件的时间。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><strong>直观的 changes</strong>。 Slate 中的内容是通过 “change” 来编辑的，这是一种被设计为支持高阶使用，且极其符合直觉的概念。这样，我们就能够通过它来尽可能简单地编写插件和自定义功能了。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>**<code>为协同编辑准备的数据模型</code>**。 Slate 使用的数据模型——尤其是由 change 更改文档的方式——在设计时就已考虑到对协同编辑的支持。所以，如果你决定为编辑器添加协作功能，你不需要进行彻底的重构。（当然，这还需要你投入更多的努力！）</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>明确的【核心】边界划分。 通过插件优先的架构与精简 Schema 的内核，Slate 对于【核心】和【自定义】有着明确得多的划分，从而保证核心的编辑体验不会为各种边缘情况所困扰。</p></blockquote><h2 id="协同编辑，这个后面会持续关注"><a href="#协同编辑，这个后面会持续关注" class="headerlink" title="协同编辑，这个后面会持续关注"></a>协同编辑，这个后面会持续关注</h2><p><img src="http://t-blog-images.aijs.top/img/20220429152337.png"><br><a href="https://docs.slate-yjs.dev/">slate-yjs</a><br><a href="https://docs.yjs.dev/">yjs</a></p><h2 id="slate-文档不是很多，半小时看完"><a href="#slate-文档不是很多，半小时看完" class="headerlink" title="slate 文档不是很多，半小时看完"></a>slate 文档不是很多，半小时看完</h2><p>主要内容 </p><ul><li>插件定制化</li><li>渲染节点定制化</li><li>按键监听处理</li><li>数据格式编码、反编码</li><li>数据存储</li></ul><h2 id="就这点东西😱"><a href="#就这点东西😱" class="headerlink" title="就这点东西😱"></a>就这点东西😱</h2><p>竟然有些同学凭借slate的使用拿了3.75,赶紧学～</p>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="//post/2022-05-13design_mode.html"/>
      <url>//post/2022-05-13design_mode.html</url>
      
        <content type="html"><![CDATA[<h2 id="先聊用到过哪些，背后的设计模式是什么"><a href="#先聊用到过哪些，背后的设计模式是什么" class="headerlink" title="先聊用到过哪些，背后的设计模式是什么"></a>先聊用到过哪些，背后的设计模式是什么</h2><ol><li>实例化一个 axios 实例，全局都来使用它 <em>单例模式</em></li><li>兄弟组件通信,事件监听 <em>观察者模式</em></li><li>构造函数继承、类的继承 <em>构造函数模式</em></li><li>实例化不同的实例 <em>工厂模式</em></li><li>优化中的<code>事件代理</code><em>代理模式</em></li><li>esm、commonjs<em>模块模式</em></li></ol><p><em>熟悉而又陌生</em>：熟悉的是一直在用，陌生的是学名竟然是这些。我都有点怀疑了，这是真的吗？是真的吗？～～～</p><p><img    src="https://img1.baidu.com/it/u=1902986975,2375222058&fm=253&fmt=auto&app=138&f=JPEG?w=535&h=500"    width=100 style="border-radius: 10px"    /></p>   <div style="font-size: 20px; color: orange;margin-top: 30px">来～来～来～，我们继续。。。</div><h2 id="啥呀"><a href="#啥呀" class="headerlink" title="啥呀"></a>啥呀</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>“设计模式(英语 design pattern)是对面向对象设计中<code>反复出现的问题的解决方案</code>。这个术语是在1990年代由Erich Gamma等人从建筑设计领域<code>引入到</code>计算机科学中来的。”</p></blockquote><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><ul><li>作用：访问控制</li><li>场景：事件代理、Proxy、Object.defineProperty</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>定义：唯一实例，全局可访问</li><li>场景：请求实例、全局缓存、线程池、window 对象、登录浮框</li><li>实现：已经创建过的直接返回，不重复创建</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>作用：创建同一类对象</li><li>分类：<em>简单工厂_、_方法工厂</em></li></ul><h3 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1. 简单工厂"></a>1. 简单工厂</h3><ul><li>例如：项目中根据用户权限渲染不同的页面，在不同权限等级用户的构造函数中，保存用户可以看到的页面</li><li>优点：一个正确的参数，就可以获取到所需要的对象，无需知道其创建的具体细节</li><li>缺点：函数会成为一个超级函数，难以维护，简单工厂适用于创建少量对象，对象的逻辑不能复杂</li></ul><h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2. 工厂方法"></a>2. 工厂方法</h3><ul><li>本质：将创建对象的工作，推迟到子类中，这样核心类就变成抽象类</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">let UserFactory &#x3D; function (type) &#123;  if (this instanceof UserFactory) &#123;    return new this[type]();  &#125; else &#123;    return new UserFactory(type);  &#125;&#125;;&#x2F;&#x2F; 工厂方法，函数的原型中设置所有对象的构造函数UserFactory.prototype &#x3D; &#123;  SuperAdmin: function () &#123;    this.name &#x3D; &quot;超级管理员&quot;;    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;, &quot;应用管理&quot;, &quot;权限管理&quot;];  &#125;,  Admin: function () &#123;    this.name &#x3D; &quot;管理员&quot;;    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;, &quot;用户管理&quot;];  &#125;,  NormalUser: function () &#123;    this.name &#x3D; &quot;普通用户&quot;;    this.viewPage &#x3D; [&quot;首页&quot;, &quot;订单管理&quot;];  &#125;,&#125;;&#x2F;&#x2F; 调用let superAdmin &#x3D; new UserFactory(&quot;SuperAdmin&quot;);let admin &#x3D; new UserFactory(&quot;Admin&quot;);let normalUser &#x3D; new UserFactory(&quot;NormalUser&quot;);</code></pre><h3 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3. 抽象工厂"></a>3. 抽象工厂</h3><ul><li></li></ul><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><h2 id="👀-观察者模式"><a href="#👀-观察者模式" class="headerlink" title="👀 观察者模式"></a>👀 观察者模式</h2><ul><li>定义： 对象间的一种一对多的依赖关系</li><li>作用：一个对象状态发生变化时，所有依赖他的对象，都将得到通知</li><li>优点：解耦</li><li>组成：发布者、订阅者</li><li>场景：事件监听、eventBus</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">document.body.addEventListener(&quot;click&quot;, function () &#123;&#125;, false);</code></pre><h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><ul><li>作用：避免全局污染，按需暴露</li><li>实现：多采用闭包</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">var Person &#x3D; (function () &#123;  var name &#x3D; &quot;xxx&quot;;  function sayName(params) &#123;    console.log(name);  &#125;  return &#123;    name,    sayName,  &#125;;&#125;)();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ant design form设置值 !== 获取值</title>
      <link href="//post/2022-05-13react.html"/>
      <url>//post/2022-05-13react.html</url>
      
        <content type="html"><![CDATA[<h2 id="有意思的事"><a href="#有意思的事" class="headerlink" title="有意思的事"></a>有意思的事</h2><ul><li>今天维护项目遇到一个有意思的事，直观感受，设置值，再取出来，貌似没毛病<pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">  &#x2F;&#x2F; ...  const [values, setValues] &#x3D; useState&lt;Record&lt;string, any&gt;&gt;()  const &#123; applyStartTime, applyEndTime, attendanceType, staffId &#125; &#x3D; values || &#123;&#125;  const getDetail &#x3D; usePersistFn(async () &#x3D;&gt; &#123;    &#x2F;&#x2F; ...略    const obj: Record&lt;string, any&gt; &#x3D; &#123;      staffId: applyStaff.staffId,      attendanceType: res.result.attendanceType,      applyStartTime: &#123;        value: moment(res.result.applyStartTime),        half: res.result.startDayType,      &#125;,      applyEndTime: &#123;        value: moment(res.result.applyEndTime),        half: res.result.endDayType,      &#125;,      applyReason,      applyAttachments,    &#125;    &#x2F;&#x2F; ...略    form.setFieldsValue(obj)    setValues(form.getFieldsValue())  &#125;)  &#x2F;&#x2F; ...略  const &#123; total, loading: totalLoading &#125; &#x3D; useCaculateDays(    &#123;      start: applyStartTime,      end: applyEndTime,    &#125;,    staffId,    attendanceType,  )  &#x2F;&#x2F; ...略  &#x2F;&#x2F; AnualForm组件  &lt;Form.Item name&#x3D;&quot;applyStartTime&quot; label&#x3D;&quot;起始日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;      &lt;HalftDatePicker predict&#x3D;&#123;&#123; lessThan: end?.value &#125;&#125; &#x2F;&gt;    &lt;&#x2F;Form.Item&gt;  &lt;Form.Item name&#x3D;&quot;applyEndTime&quot; label&#x3D;&quot;结束日期&quot; rules&#x3D;&#123;[&#123; required: true &#125;]&#125;&gt;    &lt;HalftDatePicker predict&#x3D;&#123;&#123; moreThan: start?.value &#125;&#125; &#x2F;&gt;  &lt;&#x2F;Form.Item&gt;  type IValue &#x3D; &#123;    value?: moment.Moment    half: 1 | 2  &#125; &#x2F;&#x2F; HalftDatePicker组件const HalftDatePicker: React.ForwardRefRenderFunction&lt;any, PickerProps&lt;moment.Moment&gt; &amp; &#123;  value?: IValue  onChange?: (v?: IValue) &#x3D;&gt; void  predict?: &#123;    lessThan?: moment.Moment    moreThan?: moment.Moment    holiday?: boolean  &#125;&#125;&gt; &#x3D; (props, ref) &#x3D;&gt; &#123;  &#x2F;&#x2F; ...略&#125;</code></pre></li></ul><p>代码的目的是： </p><ol><li>请求详情</li><li>装配数据，更新values</li><li>useCaculateDays 通过后台动态计算有效工作日，返回total请假天数，</li><li>渲染total到表单对应位置</li></ol><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>经过一点一点回溯调试，发现 useCaculateDays 没请求，被判断拦截掉了，往上找找，</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">form.setFieldsValue(obj)setValues(form.getFieldsValue())</code></pre><h3 id="打上日志"><a href="#打上日志" class="headerlink" title="打上日志"></a>打上日志</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">&#x2F;&#x2F; ...略console.log(&quot;obj&quot;,obj);form.setFieldsValue(obj)console.log(&quot;obj1&quot;,form.getFieldsValue());setValues(obj)</code></pre><p>发现<code>obj</code>键值内容不等于<code>obj1</code></p><ul><li>obj</li></ul><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;staffId&quot;: &quot;02333&quot;,    &quot;attendanceType&quot;: 11,    &quot;applyStartTime&quot;: &#123;        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,        &quot;half&quot;: 1    &#125;,    &quot;applyEndTime&quot;: &#123;        &quot;value&quot;: &quot;2022-03-23T16:00:00.000Z&quot;,        &quot;half&quot;: 2    &#125;,    &quot;applyReason&quot;: &quot;&quot;,    &quot;applyAttachments&quot;: []&#125;</code></pre><ul><li>obj1<pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;staffId&quot;: &quot;02333&quot;,    &quot;attendanceType&quot;: 11,    &quot;applyReason&quot;: &quot;&quot;,    &quot;applyAttachments&quot;: []&#125;</code></pre></li></ul><p><em>猜想</em></p><ul><li>会不会<code>form.setFieldsValue</code>异步？查了下api是同步的<em>排除这种可能</em></li><li>断点调试过程中，也会遇到表单渲染一半的情况，<code>AnualForm组件</code>是条件渲染，如果这块表单没有渲染出来，通过<code>form.getFieldsValue</code>就拿不到</li></ul><h3 id="修改代码验证下猜想"><a href="#修改代码验证下猜想" class="headerlink" title="修改代码验证下猜想"></a>修改代码验证下猜想</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">console.log(&quot;obj&quot;,obj);form.setFieldsValue(obj)console.log(&quot;obj1&quot;,form.getFieldsValue());setTimeout(() &#x3D;&gt; &#123;  setValues(form.getFieldsValue())  &#125;, 5000);&#125;</code></pre><img src="http://t-blog-images.aijs.top/img/Kapture%202022-05-13%20at%2016.01.46.gif" width=300 /><h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">form.setFieldsValue(obj)setValues(obj)</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ModHeader</title>
      <link href="//post/2022-05-13modeheader.html"/>
      <url>//post/2022-05-13modeheader.html</url>
      
        <content type="html"><![CDATA[<h2 id="通过不同请求头字段标识请求不同的环境"><a href="#通过不同请求头字段标识请求不同的环境" class="headerlink" title="通过不同请求头字段标识请求不同的环境"></a>通过不同请求头字段标识请求不同的环境</h2><img src="http://t-blog-images.aijs.top/img/20220513145839.webp" width=400 /><h3 id="Requesr-Headers"><a href="#Requesr-Headers" class="headerlink" title="Requesr Headers"></a>Requesr Headers</h3><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Accept: *&#x2F;*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,zh-TW;q&#x3D;0.7Cache-Control: no-cacheConnection: keep-alivecontent-type: application&#x2F;json; charset&#x3D;utf-8Cookie: perfLang&#x3D;zh; envtag: ladon-1        Host: localhost:3119Pragma: no-cacheReferer: http:&#x2F;&#x2F;localhost:3119&#x2F;sec-ch-ua: &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Chromium&quot;;v&#x3D;&quot;101&quot;, &quot;Google Chrome&quot;;v&#x3D;&quot;101&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;macOS&quot;</code></pre><h3 id="不生效了"><a href="#不生效了" class="headerlink" title="不生效了"></a>不生效了</h3><p>理论上是没问题，应该是由于某些原因导致这个插件内部运行出了问题，具体什么问题不知<br><em>处理：</em>将浏览器重启动后,请求头<code>envtag: ladon-1</code>增加成功</p>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器首屏优化-首屏时间获取</title>
      <link href="//post/2022-05-12performance.html"/>
      <url>//post/2022-05-12performance.html</url>
      
        <content type="html"><![CDATA[<h2 id="优化的指标"><a href="#优化的指标" class="headerlink" title="优化的指标"></a>优化的指标</h2><p>白屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器出现第一个元素<br>首屏时间 &#x3D; 地址栏输入网址后回车 - 浏览器第一屏渲染完成</p><p>影响白屏时间的因素：网络，服务端性能，前端页面结构设计。<br>影响首屏时间的因素：白屏时间，资源下载执行时间。</p><p>通常在 head 解析完，body 开始渲染此时是白屏结束<br>白屏时间 &#x3D; firstPaint - performance.timing.navigationStart || pageStartTime</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>首屏模块标签标记， 你觉得首屏完成的地方插入脚本</li><li>同级首屏内加载最慢的图片&#x2F;iframe</li></ol><p>这个图看不懂没关系，往下看，后面会以简书代码和掘金来验证这幅图的正确性</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9sejV6LmNvbS9hc3NldHMvaW1nL3BlcmZvcm1hbmNlLnBuZw?x-oss-process=image/format,png"></p><h2 id="输入-url-发生了什么"><a href="#输入-url-发生了什么" class="headerlink" title="输入 url 发生了什么"></a>输入 url 发生了什么</h2><ul><li>1、当浏览器地址中输入 url 后，<code>navigationStart</code>如果之前有前一个网页（与当前页面不一定同域）unload 的时间戳,如果无前一个网页 unload ，则与 fetchStart 值相等,</li><li>2、接着，是否有重定向（<code>redirect</code> ）</li><li>3、接着，准备用 HTTP 抓取文档的内容（<code>fetchStart</code>）<ul><li>域名查询（<code>domainLookupStart、domainLookupEnd</code>）</li><li>TCP 连接（<code>connectStart、connectEnd</code>）,如果是安全链接，在 connectEnd 之前，会有 SSL 连接(secureConnectionStart)</li></ul></li><li>4、接着，HTTP 请求（<code>requestStart、responseStart、responseEnd</code>）,如果有缓存，在 responseStart 之前，会有 cacheStart，如果之前有网页，还涉及到网页的 unload，在 cacheStart 之前，会有<code>unloadStart、unloadEnd</code></li><li>5、接着，dom 解析<ul><li><code>domLoading</code>Document.readyState 变为 loading，并将抛出 readystatechange 相关事件</li><li><code>domInteractive</code>Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件</li><li><code>domContentLoadedEventStart、domContentLoadedEventEnd </code>DOM 解析完成后，<ul><li>网页内资源加载开始，并将抛出 readystatechange 相关事件</li><li>网页内资源加载完成，并将抛出 readystatechange 相关事件</li></ul></li><li><code>loadEventStart</code>load 事件发送给文档，也即 load 回调函数开始执行</li><li><code>loadEventEnd</code>load 事件的回调函数执行完毕的时间</li><li><code>domComplete</code>Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</li><li>说明：dom 解析过程，HTML 生成 dom 树，解析 CSS 文件生成 CSSOM 树，DOM 树和 CSSOM 树生成 render 树，也就是渲染树， render 树中对每个节点进行布局，计算每个元素的大小，确定其在屏幕中的位置，绘制。根据 render 树和布局将显示页面</li></ul></li></ul><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>左边红线代表的是网络传输层面的过程，右边红线代表了服务器传输回字节后浏览器的各种事件状态，这个阶段包含了浏览器对文档的解析，DOM 树构建，布局，绘制等等。<br><em>1. prompt for unload</em></p><ul><li>navigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。<br><em>2. 前一个网页卸载</em></li><li>unloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。</li><li>unloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。<br><em>3. 重定向</em></li><li>redirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。</li><li>redirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。<br><em>4. 使用 HTTP 请求</em></li><li>fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。<br><em>5. 域名解析</em></li><li>domainLookupStart&#x2F;domainLookupEnd: DNS 域名查询开始&#x2F;结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等<br><em>6. tcp 链接</em></li><li>connectStart: HTTP（TCP）开始&#x2F;重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。</li><li>connectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。<br><em>7. ssl 建立</em></li><li>secureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。<br><em>8. 读取文档</em></li><li>requestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。<br><em>9. 响应</em></li><li>responseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。</li><li>responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。<br><em>10. 解析 dom</em></li><li>domLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。<br><em>11. dom 可交互</em></li><li>domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。<br><em>12. 页面内资源加载</em></li><li>domContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。</li><li>domContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。<br><em>13. dom 树解析完成</em></li><li>domComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。<br><em>14. load 事件</em></li><li>loadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。</li><li>loadEventEnd: load 事件的回调函数执行完毕的时间。</li></ul><h2 id="Performance-接口"><a href="#Performance-接口" class="headerlink" title="Performance 接口"></a>Performance 接口</h2><p>Performance 接口可以获取到当前页面与性能相关的信息。</p><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">TIP</p><p><strong>数据先不要关注时间循序，后面我们会从多个角度来验证顺序</strong></p></div><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;timeOrigin&quot;: 1652338539312.5,  &#x2F;&#x2F; 顺序已经排好了  &quot;timing&quot;: &#123;    &#x2F;&#x2F; 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等    &quot;navigationStart&quot;: 1652338539312,    &#x2F;&#x2F; 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0    &quot;redirectStart&quot;: 0,    &#x2F;&#x2F; 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0    &quot;redirectEnd&quot;: 0,    &#x2F;&#x2F; 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前    &quot;fetchStart&quot;: 1652338539316,    &#x2F;&#x2F; DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等    &quot;domainLookupStart&quot;: 1652338539353,    &#x2F;&#x2F; DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等    &quot;domainLookupEnd&quot;: 1652338539353,    &#x2F;&#x2F; HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间    &quot;connectStart&quot;: 1652338539353,    &#x2F;&#x2F; HTTPS 连接开始的时间，如果不是安全连接，则值为 0    &quot;secureConnectionStart&quot;: 1652338539401,    &#x2F;&#x2F; HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等    &#x2F;&#x2F; 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间    &#x2F;&#x2F; 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过    &quot;connectEnd&quot;: 1652338539504,    &#x2F;&#x2F; HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存    &#x2F;&#x2F; 连接错误重连时，这里显示的也是新建立连接的时间    &quot;requestStart&quot;: 1652338539505,    &#x2F;&#x2F; HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存    &quot;responseStart&quot;: 1652338539807,    &#x2F;&#x2F; 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0    &quot;unloadEventStart&quot;: 0,    &#x2F;&#x2F; 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳    &quot;unloadEventEnd&quot;: 0,    &#x2F;&#x2F; HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存    &quot;responseEnd&quot;: 1652338539828,    &#x2F;&#x2F; 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件    &quot;domLoading&quot;: 1652338539823,    &#x2F;&#x2F; 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件    &#x2F;&#x2F; 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源    &quot;domInteractive&quot;: 1652338540574,    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载开始的时间    &#x2F;&#x2F; 在 DOMContentLoaded 事件抛出前发生    &quot;domContentLoadedEventStart&quot;: 1652338540574,    &#x2F;&#x2F; DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）    &quot;domContentLoadedEventEnd&quot;: 1652338540575,    &#x2F;&#x2F; load 事件发送给文档，也即 load 回调函数开始执行的时间    &#x2F;&#x2F; 注意如果没有绑定 load 事件，值为 0    &quot;loadEventStart&quot;: 1652338542489,    &#x2F;&#x2F; load 事件的回调函数执行完毕的时间    &quot;loadEventEnd&quot;: 1652338542492,    &#x2F;&#x2F; DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件    &quot;domComplete&quot;: 1652338542489  &#125;,  &quot;navigation&quot;: &#123;    &#x2F;&#x2F; 0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）    &#x2F;&#x2F; 1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面    &#x2F;&#x2F; 2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）    &#x2F;&#x2F; 255 即 TYPE_UNDEFINED    非以上方式进入的页面    &quot;type&quot;: 0,    &quot;redirectCount&quot;: 0 &#x2F;&#x2F; &#x2F;&#x2F; 如果有重定向的话，页面通过几次重定向跳转而来  &#125;&#125;</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">function getPerfermanceTiming() &#123;  let t &#x3D; performance.timing;  &#x2F;&#x2F; 重定向结束时间 - 重定向开始时间  let redirect &#x3D; t.redirectEnd - t.redirectStart;  &#x2F;&#x2F; DNS 查询开始时间 - fetech start 时间  let appCache &#x3D; t.domainLookupStart - t.fetchStart;  &#x2F;&#x2F; DNS 查询结束时间 - DNS 查询开始时间  let dns &#x3D; t.domainLookupEnd - t.domainLookupStart;  &#x2F;&#x2F; 完成 TCP 连接握手时间 - TCP 连接开始时间  let tcp &#x3D; t.connectEnd - t.connectStart;  &#x2F;&#x2F; 从请求开始到接收到第一个响应字符的时间  let ttfb &#x3D; t.responseStart - t.requestStart;  &#x2F;&#x2F; 资源下载时间，响应结束时间 - 响应开始时间  let contentDL &#x3D; t.responseEnd - t.responseStart;  &#x2F;&#x2F; 从请求开始到响应结束的时间  let httpTotal &#x3D; t.responseEnd - t.requestStart;  &#x2F;&#x2F; 从页面开始到 domContentLoadedEventEnd  let domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;  &#x2F;&#x2F; 从页面开始到 loadEventEnd  let loaded &#x3D; t.loadEventEnd - t.navigationStart;  let result &#x3D; [    &#123; key: &quot;Redirect&quot;, desc: &quot;网页重定向的耗时&quot;, value: redirect &#125;,    &#123; key: &quot;AppCache&quot;, desc: &quot;检查本地缓存的耗时&quot;, value: appCache &#125;,    &#123; key: &quot;DNS&quot;, desc: &quot;DNS查询的耗时&quot;, value: dns &#125;,    &#123; key: &quot;TCP&quot;, desc: &quot;TCP连接的耗时&quot;, value: tcp &#125;,    &#123;      key: &quot;Waiting(TTFB)&quot;,      desc: &quot;从客户端发起请求到接收到响应的时间 &#x2F; Time To First Byte&quot;,      value: ttfb,    &#125;,    &#123;      key: &quot;Content Download&quot;,      desc: &quot;下载服务端返回数据的时间&quot;,      value: contentDL,    &#125;,    &#123; key: &quot;HTTP Total Time&quot;, desc: &quot;http请求总耗时&quot;, value: httpTotal &#125;,    &#123;      key: &quot;DOMContentLoaded&quot;,      desc: &quot;dom加载完成的时间&quot;,      value: domContentloaded,    &#125;,    &#123; key: &quot;Loaded&quot;, desc: &quot;页面load的总耗时&quot;, value: loaded &#125;,  ];  return result;&#125;getPerfermanceTiming();</code></pre><hr/><h2 id="聊下性能计算"><a href="#聊下性能计算" class="headerlink" title="聊下性能计算"></a>聊下性能计算</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 计算加载时间function getPerformanceTiming() &#123;  var performance &#x3D; window.performance;  if (!performance) &#123;    &#x2F;&#x2F; 当前浏览器不支持    console.log(&quot;你的浏览器不支持 performance 接口&quot;);    return;  &#125;  var t &#x3D; performance.timing;  var times &#x3D; &#123;&#125;;  &#x2F;&#x2F;【重要】页面加载完成的时间  &#x2F;&#x2F;【原因】这几乎代表了用户等待页面可用的时间  times.loadPage &#x3D; t.loadEventEnd - t.navigationStart;  &#x2F;&#x2F;【重要】解析 DOM 树结构的时间  &#x2F;&#x2F;【原因】反省下你的 DOM 树嵌套是不是太多了！  times.domReady &#x3D; t.domComplete - t.responseEnd;  &#x2F;&#x2F;【重要】重定向的时间  &#x2F;&#x2F;【原因】拒绝重定向！比如，http:&#x2F;&#x2F;example.com&#x2F; 就不该写成 http:&#x2F;&#x2F;example.com  times.redirect &#x3D; t.redirectEnd - t.redirectStart;  &#x2F;&#x2F;【重要】DNS 查询时间  &#x2F;&#x2F;【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？  &#x2F;&#x2F; 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000000633364)  times.lookupDomain &#x3D; t.domainLookupEnd - t.domainLookupStart;  &#x2F;&#x2F;【重要】读取页面第一个字节的时间  &#x2F;&#x2F;【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？  &#x2F;&#x2F; TTFB 即 Time To First Byte 的意思  &#x2F;&#x2F; 维基百科：https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Time_To_First_Byte  times.ttfb &#x3D; t.responseStart - t.navigationStart;  &#x2F;&#x2F;【重要】内容加载完成的时间  &#x2F;&#x2F;【原因】页面内容经过 gzip 压缩了么，静态资源 css&#x2F;js 等压缩了么？  times.request &#x3D; t.responseEnd - t.requestStart;  &#x2F;&#x2F;【重要】执行 onload 回调函数的时间  &#x2F;&#x2F;【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？  times.loadEvent &#x3D; t.loadEventEnd - t.loadEventStart;  &#x2F;&#x2F; DNS 缓存时间  times.appcache &#x3D; t.domainLookupStart - t.fetchStart;  &#x2F;&#x2F; 卸载页面的时间  times.unloadEvent &#x3D; t.unloadEventEnd - t.unloadEventStart;  &#x2F;&#x2F; TCP 建立连接完成握手的时间  times.connect &#x3D; t.connectEnd - t.connectStart;  return times;&#125;</code></pre><h2 id="聊下性能优化"><a href="#聊下性能优化" class="headerlink" title="聊下性能优化"></a>聊下性能优化</h2><p><strong>假设你对 performance API 很熟悉</strong></p><ul><li>减少重定向次数</li><li>DNS 查询时间：HTML5 Prefetch 预查询</li><li>TCP 连接: http1.1 开启 connect: keep-alive, http2.0， 如果可以的话 <strong>http3.0 可以看本站另一篇文章</strong></li><li>资源压缩：gzip、brotli、图片压缩、tree-shaking、console 移除</li><li>资源整合：减少请求次数、减少网络请求，雪碧图（虽然 http2 提供了<strong>多路复用</strong>[多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制,单个连接上可以并行交错的请求和响应，之间互不干扰,但是数量猛增，服务器要处理，多多少少也耗性能]的能力，而且现在还有使用的常见，比聊天表情，飞书也在用）</li><li>资源加载：CDN、强缓存和协商缓存、按需加载</li><li>DOM 解析：自上而下，script 标签放在底部，css 放在上面，无论是 html 还是 css 的层级，应尽量少的解析，解析消耗性能</li><li>渲染时候：回流和重绘、懒加载、虚拟列表</li></ul><h2 id="两个事例"><a href="#两个事例" class="headerlink" title="两个事例"></a>两个事例</h2><p><strong>飞书雪碧图</strong></p><ul><li>为什么拿飞书桌端数据来说（之前开发桌面端Electron，扒拉过飞书应用包的数据)</li></ul><img src="http://t-blog-images.aijs.top/img/20220606170307.webp" width=200 style="object-fit:content"/><p><strong>京东移动端 dns-prefetch</strong></p><ul><li>为什么拿京东数据来说（之前爬取过京东移动端数据开发 RN)</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220606172316.webp"></p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;head&gt;  &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;    window.alert &#x3D; console.log;  &lt;&#x2F;script&gt;  &lt;script&gt;    window._PFM_TIMING &#x3D; [[1351, new Date()]]; &#x2F;&#x2F;TODO  &lt;&#x2F;script&gt;  &lt;meta    name&#x3D;&quot;viewport&quot;    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0&quot;  &#x2F;&gt;  &lt;title&gt;多快好省，购物上京东！&lt;&#x2F;title&gt;  &lt;!-- 强缓存Cache-Control --&gt;  &lt;meta http-equiv&#x3D;&quot;Cache-Control&quot; content&#x3D;&quot;max-age&#x3D;180&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;black&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;  &lt;!-- 京东 &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt; 写重复了 --&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;m.360buyimg.com&quot; &#x2F;&gt;  &lt;meta name&#x3D;&quot;format-detection&quot; content&#x3D;&quot;telephone&#x3D;no&quot; &#x2F;&gt;  &lt;meta    name&#x3D;&quot;viewport&quot;    content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;0, shrink-to-fit&#x3D;no, viewport-fit&#x3D;cover&quot;  &#x2F;&gt;  &lt;!-- X-DNS-Prefetch-Control 头控制着浏览器的 DNS 预读取功能  DNS 预读取是一项使浏览器主动去执行域名解析的功能--&gt;  &lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img11.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img10.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img12.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img13.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img14.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img20.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;img30.360buyimg.com&quot; &#x2F;&gt;  &lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;wq.360buyimg.com&quot; &#x2F;&gt;&lt;&#x2F;head&gt;</code></pre><h2 id="performance-数据能干啥用？"><a href="#performance-数据能干啥用？" class="headerlink" title="performance 数据能干啥用？"></a>performance 数据能干啥用？</h2><p>（开发者）熟悉 Chrome 开发者工具的朋友应该知道：在开发环境下，其实我们自己打开 Chrome 的开发者工具，切换到网络面板，就能很详细的看到网页性能相关的数据。</p><p>（网站用户）但当我们需要统计分析用户打开我们网页时的性能如何时，我们将 performance 原始信息或通过简单计算后的信息 (如上面写到的 getPerformanceTiming()) 上传到服务器，配合其他信息（如 HTTP 请求头信息），就完美啦~</p><h2 id="来看下简书"><a href="#来看下简书" class="headerlink" title="来看下简书"></a>来看下简书</h2><ul><li>链接 <a href="https://www.jianshu.com/p/464593cea4dc" target="_blank" >简书</a> ,打开控制台可以看到输出结果一个数组（<strong>如果简书没将此日志去除</strong>）</li><li>简书代码</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">window.addEventListener(&quot;load&quot;, function () &#123;  setTimeout(function () &#123;    var e &#x3D; window.performance;    if (e) &#123;      var t &#x3D; e.getEntriesByType(&quot;navigation&quot;)[0],        r &#x3D; 0;      t || (r &#x3D; (t &#x3D; e.timing).navigationStart);      var n &#x3D; [        &#123;          key: &quot;Redirect&quot;,          desc: &quot;\u7f51\u9875\u91cd\u5b9a\u5411\u7684\u8017\u65f6&quot;,          value: t.redirectEnd - t.redirectStart,        &#125;,        &#123;          key: &quot;AppCache&quot;,          desc: &quot;\u68c0\u67e5\u672c\u5730\u7f13\u5b58\u7684\u8017\u65f6&quot;,          value: t.domainLookupStart - t.fetchStart,        &#125;,        &#123;          key: &quot;DNS&quot;,          desc: &quot;DNS\u67e5\u8be2\u7684\u8017\u65f6&quot;,          value: t.domainLookupEnd - t.domainLookupStart,        &#125;,        &#123;          key: &quot;TCP&quot;,          desc: &quot;TCP\u8fde\u63a5\u7684\u8017\u65f6&quot;,          value: t.connectEnd - t.connectStart,        &#125;,        &#123;          key: &quot;Waiting(TTFB)&quot;,          desc: &quot;\u4ece\u5ba2\u6237\u7aef\u53d1\u8d77\u8bf7\u6c42\u5230\u63a5\u6536\u5230\u54cd\u5e94\u7684\u65f6\u95f4 &#x2F; Time To First Byte&quot;,          value: t.responseStart - t.requestStart,        &#125;,        &#123;          key: &quot;Content Download&quot;,          desc: &quot;\u4e0b\u8f7d\u670d\u52a1\u7aef\u8fd4\u56de\u6570\u636e\u7684\u65f6\u95f4&quot;,          value: t.responseEnd - t.responseStart,        &#125;,        &#123;          key: &quot;HTTP Total Time&quot;,          desc: &quot;http\u8bf7\u6c42\u603b\u8017\u65f6&quot;,          value: t.responseEnd - t.requestStart,        &#125;,        &#123;          key: &quot;DOMContentLoaded&quot;,          desc: &quot;dom\u52a0\u8f7d\u5b8c\u6210\u7684\u65f6\u95f4&quot;,          value: t.domContentLoadedEventEnd - r,        &#125;,        &#123;          key: &quot;Loaded&quot;,          desc: &quot;\u9875\u9762load\u7684\u603b\u8017\u65f6&quot;,          value: t.loadEventEnd - r,        &#125;,      ];      if (Math.random() &gt; 0.75) &#123;        var s &#x3D; window.location,          i &#x3D; s.href,          c &#x3D; s.pathname,          u &#x3D; navigator.userAgent,          d &#x3D; i.split(&quot;?&quot;)[0];        o.a          .post(&quot;https:&#x2F;&#x2F;tr.jianshu.com&#x2F;fe&#x2F;1&#x2F;mon&#x2F;atf&quot;, &#123;            app: &quot;shakespeare-performance&quot;,            url: d,            ua: u,            path: c,            stats_ttfb: t.responseStart - t.requestStart,            stats_domLoaded: t.domContentLoadedEventEnd - r,            stats_loaded: t.loadEventEnd - r,          &#125;)          .then(a.a)          .catch(a.a);      &#125;      console &amp;&amp; console.log &amp;&amp; console.log(n);    &#125;  &#125;, 0);&#125;);</code></pre><h2 id="简书截图"><a href="#简书截图" class="headerlink" title="简书截图"></a>简书截图</h2><p><img src="http://t-blog-images.aijs.top/img/20220605112219.webp"></p><h2 id="domContentLoaded-与-loaded"><a href="#domContentLoaded-与-loaded" class="headerlink" title="domContentLoaded 与 loaded"></a>domContentLoaded 与 loaded</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 从页面开始到 domContentLoadedEventEndlet domContentloaded &#x3D; t.domContentLoadedEventEnd - t.navigationStart;&#x2F;&#x2F; 从页面开始到 loadEventEndlet loaded &#x3D; t.loadEventEnd - t.navigationStart;</code></pre><p><strong>domContentLoadedEventEnd 比 loaded 先触发</strong></p><p><img src="http://t-blog-images.aijs.top/img/20220605133905.webp"></p><hr/><h2 id="掘金页面"><a href="#掘金页面" class="headerlink" title="掘金页面"></a>掘金页面</h2><ul><li><p>话说已经到了 6 月 6 号，闲逛掘金，遇到面试题：<code>从输入url到页面展示发生了什么</code>，突然想起个 performance,就拿掘金的一个页面来验证这幅图</p><p><img src="http://t-blog-images.aijs.top/img/20220606151451.webp"></p></li></ul><div class="custom-quote warning"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 8V13"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12 15.99V16.01"></path></svg></span><p class="custom-quote-title">WARNING</p><p>注意：此代码放到 dayjs 网站的 Sources&#x2F;Snippets 中执行，利用全局的 dayjs，无需引入 dayjs</div><p><a href="https://dayjs.fenxianglu.cn/category/display.html#%E6%A0%BC%E5%BC%8F%E5%8C%96" target="_blank" >dayjs 网站</a></p><p><img src="http://t-blog-images.aijs.top/img/20220606152413.webp"></p><ul><li>代码是为了对performance.timing按照时间值进行排序，排序结果大致是执行的顺序，稍微有出入，会手动做调整</li><li>代码如下：</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">var timing &#x3D; &#123;  connectStart: 1654499041800,  navigationStart: 1654499041744,  loadEventEnd: 1654499043641,  domLoading: 1654499042279,  secureConnectionStart: 1654499041820,  fetchStart: 1654499041746,  domContentLoadedEventStart: 1654499042718,  responseStart: 1654499042247,  responseEnd: 1654499042304,  domInteractive: 1654499042495,  domainLookupEnd: 1654499041800,  redirectStart: 0,  requestStart: 1654499041849,  unloadEventEnd: 1654499042267,  unloadEventStart: 1654499042267,  domComplete: 1654499043640,  domainLookupStart: 1654499041750,  loadEventStart: 1654499043641,  domContentLoadedEventEnd: 1654499042718,  redirectEnd: 0,  connectEnd: 1654499041849,&#125;;&#x2F;&#x2F; YYYY-MM-DD HH:一定一致，这个就不看了var fmt &#x3D; &quot;mm:ss:SSS&quot;;var arr &#x3D; [];var sort_obj &#x3D; &#123;&#125;;function fmt_sort_key(obj) &#123;  for (let [key, value] of Object.entries(obj)) &#123;    arr.push(&#123;      key,      value,    &#125;);  &#125;  const sortArr &#x3D; arr.sort((a, b) &#x3D;&gt; a.value - b.value);  const fmtSortArr &#x3D; sortArr.map((item) &#x3D;&gt; &#123;    if (!item.value) return item;    return &#123;      ...item,      value: dayjs(item.value).format(fmt),    &#125;;  &#125;);  console.log(fmtSortArr);&#125;fmt_sort_key(timing);</code></pre><h2 id="非无痕首次访问"><a href="#非无痕首次访问" class="headerlink" title="非无痕首次访问"></a>非无痕首次访问</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">const timing &#x3D; &#123;  connectStart: 1654391072118,  navigationStart: 1654391071928,  loadEventEnd: 1654391076402,  domLoading: 1654391072670,  secureConnectionStart: 1654391072118,  fetchStart: 1654391071969,  domContentLoadedEventStart: 1654391074189,  responseStart: 1654391072621,  responseEnd: 1654391072664,  domInteractive: 1654391073865,  domainLookupEnd: 1654391072118,  redirectStart: 0,  requestStart: 1654391072199,  &#x2F;&#x2F; 没有之前页面的卸载  unloadEventEnd: 0,  unloadEventStart: 0,  domComplete: 1654391076400,  domainLookupStart: 1654391072118,  loadEventStart: 1654391076400,  domContentLoadedEventEnd: 1654391074189,  redirectEnd: 0,  connectEnd: 1654391072199,&#125;;&#x2F;&#x2F; 时间戳 1654391072118： connectStart、secureConnectionStart、domainLookupStart、domainLookupEnd ，这个值是相同的&#x2F;&#x2F; 把上述 timing 使用dayjs进行转化，看下每个key对应的time,对于0是没有进行的操作，我们跳过不处理（知道没进行）var timingfmt &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;04:31:928&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;04:31:969&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;04:32:118&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;04:32:199&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;04:32:199&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;04:32:621&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;04:32:664&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;04:32:670&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;04:33:865&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;04:34:189&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;04:34:189&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;04:36:400&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;04:36:400&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;04:36:402&quot; &#125;,];</code></pre><p><strong>我们看下结果 2022-06-05 09:04，年月日时分都是一致的，我们只关心三位的毫秒数</strong></p><h2 id="非无痕第二次访问"><a href="#非无痕第二次访问" class="headerlink" title="非无痕第二次访问"></a>非无痕第二次访问</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">const timing2 &#x3D; &#123;  connectStart: 1654494048918,  navigationStart: 1654494048902,  loadEventEnd: 1654494054146,  domLoading: 1654494049851,  secureConnectionStart: 0, &#x2F;&#x2F; 走缓存  fetchStart: 1654494048918,  domContentLoadedEventStart: 1654494051380,  responseStart: 1654494049430,  responseEnd: 1654494049514,  domInteractive: 1654494051115,  domainLookupEnd: 1654494048918,  redirectStart: 0,  requestStart: 1654494048942,  &#x2F;&#x2F; 有之前页面卸载  unloadEventEnd: 1654494049537,  unloadEventStart: 1654494049536,  domComplete: 1654494054143,  domainLookupStart: 1654494048918,  loadEventStart: 1654494054143,  domContentLoadedEventEnd: 1654494051381,  redirectEnd: 0,  connectEnd: 1654494048918,&#125;;var timingfmt2 &#x3D; [  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;40:48:902&quot; &#125;,  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;40:48:918&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;40:48:942&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;40:49:430&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;40:49:514&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: &quot;40:49:536&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;40:49:537&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;40:49:851&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;40:51:115&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;40:51:380&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;40:51:381&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;40:54:143&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;40:54:143&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;40:54:146&quot; &#125;,];</code></pre><h2 id="非无痕-f5-手动刷新"><a href="#非无痕-f5-手动刷新" class="headerlink" title="非无痕 f5 手动刷新"></a>非无痕 f5 手动刷新</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">var timing3 &#x3D; &#123;  connectStart: 1654495600379,  navigationStart: 1654495600360,  loadEventEnd: 1654495604101,  domLoading: 1654495601005,  secureConnectionStart: 1654495600389,  fetchStart: 1654495600364,  domContentLoadedEventStart: 1654495601947,  responseStart: 1654495600935,  responseEnd: 1654495600989,  domInteractive: 1654495601794,  domainLookupEnd: 1654495600379,  redirectStart: 0,  requestStart: 1654495600404,  unloadEventEnd: 1654495600971,  unloadEventStart: 1654495600970,  domComplete: 1654495604099,  domainLookupStart: 1654495600379,  loadEventStart: 1654495604099,  domContentLoadedEventEnd: 1654495601947,  redirectEnd: 0,  connectEnd: 1654495600403,&#125;;var timingfmt3 &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;06:40:360&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;06:40:364&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;06:40:379&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;06:40:379&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;06:40:379&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;06:40:389&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;06:40:403&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;06:40:404&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;06:40:935&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: &quot;06:40:970&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;06:40:971&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;06:40:989&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;06:41:005&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;06:41:794&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;06:41:947&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;06:41:947&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;06:44:099&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;06:44:099&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;06:44:101&quot; &#125;,];</code></pre><h2 id="无痕模式首次"><a href="#无痕模式首次" class="headerlink" title="无痕模式首次"></a>无痕模式首次</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">var timing4 &#x3D; &#123;  connectStart: 1654496795083,  navigationStart: 1654496795041,  loadEventEnd: 1654496799718,  domLoading: 1654496795428,  secureConnectionStart: 1654496795093,  fetchStart: 1654496795050,  domContentLoadedEventStart: 1654496796111,  responseStart: 1654496795420,  responseEnd: 1654496795469,  domInteractive: 1654496795680,  domainLookupEnd: 1654496795083,  redirectStart: 0,  requestStart: 1654496795123,  unloadEventEnd: 0,  unloadEventStart: 0,  domComplete: 1654496799718,  domainLookupStart: 1654496795057,  loadEventStart: 1654496799718,  domContentLoadedEventEnd: 1654496796111,  redirectEnd: 0,  connectEnd: 1654496795123,&#125;;var timing4fmt &#x3D; [  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;26:35:041&quot; &#125;,  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;26:35:050&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;26:35:057&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;26:35:083&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;26:35:083&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: &quot;26:35:093&quot; &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;26:35:123&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;26:35:123&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;26:35:420&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: 0 &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: 0 &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;26:35:428&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;26:35:469&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;26:35:680&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;26:36:111&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;26:36:111&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;26:39:718&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;26:39:718&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;26:39:718&quot; &#125;,];</code></pre><h2 id="无痕模式刷新"><a href="#无痕模式刷新" class="headerlink" title="无痕模式刷新"></a>无痕模式刷新</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">var timing5 &#x3D; &#123;  connectStart: 1654496848681,  navigationStart: 1654496848679,  loadEventEnd: 1654496850263,  domLoading: 1654496848983,  secureConnectionStart: 0,  fetchStart: 1654496848681,  domContentLoadedEventStart: 1654496849277,  responseStart: 1654496848959,  responseEnd: 1654496849017,  domInteractive: 1654496849096,  domainLookupEnd: 1654496848681,  redirectStart: 0,  requestStart: 1654496848702,  unloadEventEnd: 1654496848979,  unloadEventStart: 1654496848979,  domComplete: 1654496850262,  domainLookupStart: 1654496848681,  loadEventStart: 1654496850262,  domContentLoadedEventEnd: 1654496849277,  redirectEnd: 0,  connectEnd: 1654496848681,&#125;;var timing5fmt &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;27:28:679&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;27:28:681&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;27:28:681&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;27:28:702&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;27:28:959&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;27:28:979&quot; &#125;,  &#123; key: &quot;unloadEventStart&quot;, value: &quot;27:28:979&quot; &#125;,  &#123; key: &quot;domLoading&quot;, value: &quot;27:28:983&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;27:29:017&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;27:29:096&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;27:29:277&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;27:29:277&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;27:30:262&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;27:30:262&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;27:30:263&quot; &#125;,];</code></pre><h2 id="无痕模式刷新-disable-cache"><a href="#无痕模式刷新-disable-cache" class="headerlink" title="无痕模式刷新 + disable-cache"></a>无痕模式刷新 + disable-cache</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">var timing6 &#x3D; &#123;  connectStart: 1654496917781,  navigationStart: 1654496917780,  loadEventEnd: 1654496921224,  domLoading: 1654496918186,  secureConnectionStart: 0,  fetchStart: 1654496917781,  domContentLoadedEventStart: 1654496918836,  responseStart: 1654496918156,  responseEnd: 1654496918293,  domInteractive: 1654496918654,  domainLookupEnd: 1654496917781,  redirectStart: 0,  requestStart: 1654496917784,  unloadEventEnd: 1654496918182,  unloadEventStart: 1654496918182,  domComplete: 1654496921224,  domainLookupStart: 1654496917781,  loadEventStart: 1654496921224,  domContentLoadedEventEnd: 1654496918836,  redirectEnd: 0,  connectEnd: 1654496917781,&#125;;var timing6fmt &#x3D; [  &#x2F;&#x2F; 以下按照时间排序  &#123; key: &quot;navigationStart&quot;, value: &quot;28:37:780&quot; &#125;,  &#x2F;&#x2F; 时间为0是没有进行相应的操作，跳过不处理  &#123; key: &quot;redirectStart&quot;, value: 0 &#125;,  &#123; key: &quot;redirectEnd&quot;, value: 0 &#125;,  &#123; key: &quot;fetchStart&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;domainLookupEnd&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;domainLookupStart&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;connectStart&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;connectEnd&quot;, value: &quot;28:37:781&quot; &#125;,  &#123; key: &quot;secureConnectionStart&quot;, value: 0 &#125;,  &#123; key: &quot;requestStart&quot;, value: &quot;28:37:784&quot; &#125;,  &#123; key: &quot;responseStart&quot;, value: &quot;28:38:156&quot; &#125;,  &#x2F;&#x2F; 和 timing5fmt比较，之前页面的卸载，非常快  &#123; key: &quot;unloadEventStart&quot;, value: &quot;28:38:182&quot; &#125;,  &#123; key: &quot;unloadEventEnd&quot;, value: &quot;28:38:182&quot; &#125;,  &#x2F;&#x2F; 注意 domLoading 和 responseEnd,这两个，顺序不定  &#123; key: &quot;domLoading&quot;, value: &quot;28:38:186&quot; &#125;,  &#123; key: &quot;responseEnd&quot;, value: &quot;28:38:293&quot; &#125;,  &#123; key: &quot;domInteractive&quot;, value: &quot;28:38:654&quot; &#125;,  &#123; key: &quot;domContentLoadedEventStart&quot;, value: &quot;28:38:836&quot; &#125;,  &#123; key: &quot;domContentLoadedEventEnd&quot;, value: &quot;28:38:836&quot; &#125;,  &#123; key: &quot;loadEventEnd&quot;, value: &quot;28:41:224&quot; &#125;,  &#123; key: &quot;domComplete&quot;, value: &quot;28:41:224&quot; &#125;,  &#123; key: &quot;loadEventStart&quot;, value: &quot;28:41:224&quot; &#125;,];</code></pre><p>这个操作竟然有一个 base64 编码图片依然被缓存了,浏览器 disable-cache 对于有些内存缓存的图片竟然是无效的.</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Request URL: data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCCRequest Method: GETStatus Code: 200 OK (from memory cache)Referrer Policy: strict-origin-when-cross-origin</code></pre><p><img src="http://t-blog-images.aijs.top/img/20220606143138.webp"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/z9061/article/details/101454438">Web 性能优化-首屏和白屏时间</a><br><a href="http://www.alloyteam.com/2015/09/explore-performance/">初探 performance – 监控网页与程序性能</a><br><a href="https://blog.csdn.net/abuanden/article/details/114530985">简述浏览器渲染机制</a></p>]]></content>
      
      
      <categories>
          
          <category> performance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> performance </tag>
            
            <tag> 浏览器原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode插件 paste code to snippets</title>
      <link href="//post/2022-05-11vscode.html"/>
      <url>//post/2022-05-11vscode.html</url>
      
        <content type="html"><![CDATA[<h2 id="粘贴代码，生成用户代码片段"><a href="#粘贴代码，生成用户代码片段" class="headerlink" title="粘贴代码，生成用户代码片段"></a>粘贴代码，生成用户代码片段</h2><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol><li>其他插件具有<code>共性</code>，而<code>不具特性 </code>，每次写代码，要么用第三方插件，现成的代码片段，时常不能满足日常开发需要</li><li>自定义代码片段，手写 <code>费时费力</code>，一般步骤，粘贴、修改、格式化</li><li>其他插件类似vscode宏变量的使用少之又少， 要么将开源插件定制化，要么重新开发</li><li>快捷变量记不住</li></ol><h2 id="paste-code-to-snippets-优点："><a href="#paste-code-to-snippets-优点：" class="headerlink" title="paste code to snippets 优点："></a>paste code to snippets 优点：</h2><ol><li>高度定制化</li><li>跨语言（任何vscode支持的语言，都可在对应类型片段文件中进行增加）</li><li>使用简单 （复制、唤起命令、挖孔）</li><li>快捷变量完全自定义（想怎么写就怎么写）</li></ol><h2 id="操作GIF"><a href="#操作GIF" class="headerlink" title="操作GIF"></a>操作GIF</h2><p><img src="http://t-blog-images.aijs.top/img/Kapture%202022-05-11%20at%2009.39.01.gif"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>如果配置了代码片段，没有提示, 查看<code>settings.json</code>对应</li><li>打开 <code>settings.json</code> 命令： <code>command + shift + p</code>, 搜 <code>&gt;settings</code></li></ul><p><strong>以markdown为例</strong> 默认只读配置在升级后变成了false</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; Configure settings to be overridden for the markdown language.&quot;[markdown]&quot;:  &#123;&quot;editor.unicodeHighlight.ambiguousCharacters&quot;: false,&quot;editor.unicodeHighlight.invisibleCharacters&quot;: false,&quot;editor.wordWrap&quot;: &quot;on&quot;,&quot;editor.quickSuggestions&quot;: false &#125;,</code></pre><ul><li>修改<br><img src="http://t-blog-images.aijs.top/img/20220602184856.webp"></li></ul><h2 id="有想法"><a href="#有想法" class="headerlink" title="有想法"></a>有想法</h2><p>TODO: 之前代码片段复制之后是手动粘贴到对应的片段文件中的，我有个想法，既然我复制文件的文件类型我已经知道了，我复制的代码和输出的片段代码也已经处理了，那么之后我就能实现<code>复制某个文件的代码，自动同步到对应的片段文件中，如果不需要定制化，也不用打开片段文件修改了</code></p><p>TODO:想到这里我又有一个想法，既然我每次要命令，然后再找啊找，我可以用一个快捷键<code>&quot;复制&quot;</code>的同时，唤起要定制的代码片段对应的类型文件，直接进去，不用弯弯绕绕的</p>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP3</title>
      <link href="//post/2022-05-11http.html"/>
      <url>//post/2022-05-11http.html</url>
      
        <content type="html"><![CDATA[<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><img src="https://www.upyun.com/static/img/title@3x.5597f51.png" />HTTP/3 的基础即谷歌多年探索的基于 UDP 的 QUIC 协议。与 TCP 相比，使用 UDP 可以提供更大的灵活性，并且可以使 QUIC 完全于用户空间中实现——对协议实现的更新不像 TCP 那样需要绑定到操作系统更新。使用 QUIC，可以简单地将 HTTP 级别的流映射到 QUIC 流的顶部，从而继承 HTTP/2 的所有优点，而不会产生队头阻塞。HTTP/3 虽仍处于草案状态，但很多用户已经跃跃欲试。</blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>HTTP&#x2F;3 利用 QUIC 加速 HTTP 请求，QUIC 提供比 TCP 和 TLS 更高的加密和性能</li><li>QUIC 是一种默认加密的新传输协议，旨在加快 HTTP 传输速度以及使其更加安全</li><li>HTTP&#x2F;3 基于 UDP，如果数据包丢失，只会中断一个流，而不会中断所有流，提高了同时获取多个对象的性能</li><li>支持 0-RTT，消除服务器的 TLS 确认，使后续连接的启动速度更快</li></ol><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>下图表示 HTTP&#x2F;2 和 HTTP&#x2F;3 多路复用两个请求时，数据包丢失及其影响（请求及其相关的响应分别为深蓝和浅蓝色）</p><p>HTTP&#x2F;2 多路复用 2 个请求。响应被分解为多个数据包，一旦一个数据包丢失了，两个请求都被阻止。<br><img src="https://www.upyun.com/static/img/http_3%20&%20QUIC.d73f941.gif" /><br>HTTP&#x2F;3 复用 2 个请求。虽然浅色的数据包丢失了，但是深色的数据包传输得很好。<br><img src="https://www.upyun.com/static/img/http2.27d52a1.gif" /><br>在相同丢包率的条件下，HTTP&#x2F;3 和 HTTP&#x2F;2 性能测试对比如下<br>测试环境：服务端（HTTP&#x2F;3 with cubic &amp; HTTP&#x2F;2 with bbr）、客户端（cubic）<br><img src="https://www.upyun.com/static/img/%E5%BB%BA%E8%BF%9E%E6%97%B6%E9%97%B4.35656db.png" /><br><img src="https://www.upyun.com/static/img/%E8%AF%B7%E6%B1%82%E6%97%B6%E9%97%B41x.7069918.png" /></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://www.upyun.com/tech/tags/HTTP3" target="_blank" >查看更多</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slate wiki-ui评论功能光标乱跳</title>
      <link href="//post/2022-04-29slate.html"/>
      <url>//post/2022-04-29slate.html</url>
      
        <content type="html"><![CDATA[<h2 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h2><pre class="line-numbers language-none"><code class="language-none">bug复现 (node:29) UnhandledPromiseRejectionWarning: Error: Forbidden at &amp;#x2F;code&amp;#x2F;client&amp;#x2F;.next&amp;#x2F;server&amp;#x2F;pages&amp;#x2F;_app-a05...</code></pre><p><img src="https://t-blog-images.aijs.top/img/Kapture%202022-04-29%20at%2015.41.56.gif"></p><p>在vite react项目上，输入汉字的同时按住删除键，光标会乱跳</p><h3 id="排查1"><a href="#排查1" class="headerlink" title="排查1:"></a>排查1:</h3><p>wiki（esm）组件问题，检查wiki-ui组件库，运行正常</p><pre class="line-numbers language-none"><code class="language-none">&quot;react&quot;: &quot;^16.8.0&quot;,&quot;react-dom&quot;: &quot;^16.8.0&quot;,</code></pre><h3 id="排查2"><a href="#排查2" class="headerlink" title="排查2:"></a>排查2:</h3><p>vite加载wiki-ui组件时候，因为vite只能处理esm，在vite.config.ts, esbuildOptions自定义插件进行处理<br>wiki-ui，不是很懂，换个角度</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">esbuildOptions: &#123;  plugins: [    &#123;      name: &#39;originjs:commonjs&#39;,      setup(build) &#123;        build.onLoad(          &#123;            filter: &#x2F;@敏感数据-fe\&#x2F;wiki-ui\&#x2F;dist&#x2F;,            namespace: &#39;file&#39;,          &#125;,          async (&#123; path: id &#125;) &#x3D;&gt; &#123;            const code &#x3D; readFileSync(id).toString()            const result &#x3D; transformRequire(code, id)            return &#123;              contents: result,              loader: &#39;js&#39;,            &#125;          &#125;,        ),          build.onLoad(            &#123;              filter: &#x2F;@敏感数据-fe\&#x2F;wiki-ui\&#x2F;dist\&#x2F;components\&#x2F;iconfont&#x2F;,              namespace: &#39;file&#39;,            &#125;,            async (&#123; path: id &#125;) &#x3D;&gt; &#123;              const code &#x3D; readFileSync(id).toString()              const result &#x3D; transformRequire(code, id)              return &#123;                contents: result,                loader: &#39;js&#39;,              &#125;            &#125;,          )      &#125;,    &#125;,    esbuildPluginMonacoEditorNls(&#123;      locale: Languages.zh_hans,    &#125;),  ],&#125;,</code></pre><h3 id="排查3"><a href="#排查3" class="headerlink" title="排查3:"></a>排查3:</h3><p>将wiki-ui组件放到umijs应用中运行</p><pre class="line-numbers language-none"><code class="language-none"># 搭建个项目# 移动demo组件到新项目# 运行，发现有相同的问题</code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><h4 id="1-dom"><a href="#1-dom" class="headerlink" title="1.dom"></a>1.dom</h4><p>输入过程中点击删除操作，那么在这个过程中，输入的内容是在<code>contenteditable=&quot;true&quot; </code>中运行</p><pre class="line-numbers language-none"><code class="language-none">&lt;div data-gramm&#x3D;&quot;false&quot; role&#x3D;&quot;textbox&quot; spellcheck&#x3D;&quot;false&quot; class&#x3D;&quot;slash-slate-core&quot; id&#x3D;&quot;SLASH_SLATE_CORE&quot; data-app-id&#x3D;&quot;5A9BEA&quot; autocorrect&#x3D;&quot;false&quot; autocapitalize&#x3D;&quot;false&quot; data-slate-editor&#x3D;&quot;true&quot; data-slate-node&#x3D;&quot;value&quot; contenteditable&#x3D;&quot;true&quot; style&#x3D;&quot;position: relative; outline: none; white-space: pre-wrap; overflow-wrap: break-word;&quot;&gt;&lt;p data-slate-node&#x3D;&quot;element&quot;&gt;&lt;span data-slate-node&#x3D;&quot;text&quot;&gt;&lt;span data-slate-leaf&#x3D;&quot;true&quot;&gt;&lt;span data-slate-string&#x3D;&quot;true&quot;&gt;12121212哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈h h h h h h h h h h h h hs f s d f&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;</code></pre><h4 id="2-合成事件"><a href="#2-合成事件" class="headerlink" title="2.合成事件"></a>2.合成事件</h4><p>应该会走合成事件，合成事件之后会执行渲染，web端走的是react-dom，比对正常运行的项目，和新项目的版本</p><pre class="line-numbers language-none"><code class="language-none"># react 17版本# react-dom 17版本</code></pre><h4 id="3-react"><a href="#3-react" class="headerlink" title="3.react"></a>3.react</h4><p>先进行<code>react</code>降版本 <code>16.14.0</code>，检查合成事件是否有问题，降版本后，运行，问题同样存在，大概可以断定是<code>react-dom</code>渲染出了问题，</p><h4 id="4-react-dom"><a href="#4-react-dom" class="headerlink" title="4.react-dom"></a>4.react-dom</h4><p>对<code>react-dom</code>降低版本到<code>16.14.0</code>, 后运行正常，那么问题应该在<code>react-dom</code>上</p><h4 id="5-github版本-16-14-0"><a href="#5-github版本-16-14-0" class="headerlink" title="5.github版本 16.14.0"></a>5.github版本 16.14.0</h4><p>两个版本有什么不同：查看<code>react</code>发布日志，16.14.0之后的一个版本是<a href="https://github.com/facebook/react/releases#:~:text=17.0.0%20(October%2020%2C%202020)">17.0.0 (October 20, 2020)</a> 看上去与事件和渲染相关的东西不多</p><pre class="line-numbers language-none"><code class="language-none">Use browser focusin and focusout for onFocus and onBlur. (@trueadm in #19186)Make all Capture events use the browser capture phase. (@trueadm in #19221)Throw if forwardRef or memo component returns undefined. (@gaearon in #19550)Remove event pooling. (@trueadm in #18969)Fix onBeforeInput reporting an incorrect event.type. (@eps1lon in #19561)Fix event.relatedTarget reported as undefined in Firefox. (@claytercek in #19607)Fix rendering into a shadow root. (@Jack-Works in #15894)Fix movementX&#x2F;Y polyfill with capture events. (@gaearon in #19672)Artifactsreact: https:&#x2F;&#x2F;unpkg.com&#x2F;react@17.0.1&#x2F;umd&#x2F;react-art: https:&#x2F;&#x2F;unpkg.com&#x2F;react-art@17.0.1&#x2F;umd&#x2F;react-dom: https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@17.0.1&#x2F;umd&#x2F;react-is: https:&#x2F;&#x2F;unpkg.com&#x2F;react-is@17.0.1&#x2F;umd&#x2F;react-test-renderer: https:&#x2F;&#x2F;unpkg.com&#x2F;react-test-renderer@17.0.1&#x2F;umd&#x2F;scheduler: https:&#x2F;&#x2F;unpkg.com&#x2F;scheduler@0.20.1&#x2F;umd&#x2F;</code></pre><h4 id="6-github版本-18-1-0"><a href="#6-github版本-18-1-0" class="headerlink" title="6.github版本 18.1.0"></a>6.github版本 18.1.0</h4><p>在往后找最新的版本，发现在<a href="https://github.com/facebook/react/releases#:~:text=Compare-,18.1.0%20(April%2026%2C%202022),-Latest">18.1.0 (April 26, 2022)</a>，改了一堆<code>react-dom</code>的bug,看上去也没相关的</p><pre class="line-numbers language-none"><code class="language-none">Fix the false positive warning about react-dom&#x2F;client when using UMD bundle. (@alireza-molaee in #24274)Fix suppressHydrationWarning to work in production too. (@gaearon in #24271)Fix componentWillUnmount firing twice inside of Suspense. (@acdlite in #24308)Fix some transition updates being ignored. (@acdlite in #24353)Fix useDeferredValue causing an infinite loop when passed an unmemoized value. (@acdlite in #24247)Fix throttling of revealing Suspense fallbacks. (@sunderls in #24253)Fix an inconsistency in whether the props object is the same between renders. (@Andarist and @acdlite in #24421)Fix a missing warning about a setState loop in useEffect. (@gaearon in #24298)Fix a spurious hydration error. (@gnoff in #24404)Warn when calling setState in useInsertionEffect. (@gaearon in #24295)Ensure the reason for hydration errors is always displayed. (@gaearon in #24276)</code></pre><h3 id="可用版本"><a href="#可用版本" class="headerlink" title="可用版本"></a>可用版本</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;react&quot;: &quot;^16.14.0&quot;,&quot;react-dom&quot;: &quot;16.14.0&quot;,</code></pre><h3 id="这个演示代码正常"><a href="#这个演示代码正常" class="headerlink" title="这个演示代码正常"></a>这个演示代码正常</h3><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;embed type&#x3D;&quot;text&#x2F;html&quot; src&#x3D;&quot;https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview&quot; width&#x3D;&quot;100%&quot; height&#x3D;&quot;200&quot;&gt;&lt;!--加载太慢，复制地址查看吧--&gt; &lt;!--https:&#x2F;&#x2F;stackblitz.com&#x2F;edit&#x2F;react-ts-m3y5yv?embed&#x3D;1&amp;file&#x3D;App.tsx&amp;view&#x3D;preview--&gt; </code></pre><h2 id="懵逼。。。"><a href="#懵逼。。。" class="headerlink" title="懵逼。。。"></a>懵逼。。。</h2><p>从头开始</p><pre class="line-numbers language-none"><code class="language-none">待办事项中的评论功能（组件问题）光标乱跳的问题；0. 项目 + wiki-ui 异常1. 单运行wiki-ui demo 正常2. 运行slate + umijs 正常3. 运行wiki-ui  + umijs 异常4. slate 与  wiki-ui  不一样在于slate版本5. wiki-ui 做了什么事情： 定制化一些节点展示，光标的渲染和wiki-ui无关</code></pre><h2 id="贫僧先去slate官网化缘，回来再战"><a href="#贫僧先去slate官网化缘，回来再战" class="headerlink" title="贫僧先去slate官网化缘，回来再战"></a>贫僧先去slate官网<code>化缘</code>，回来再战</h2><p><a href="http://localhost:4000/post/2022-04-29slate-lean">slate-lean</a></p><h2 id="化缘归来"><a href="#化缘归来" class="headerlink" title="化缘归来"></a>化缘归来</h2><p>问题怎么解决</p>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="//post/2022-05-09cors.html"/>
      <url>//post/2022-05-09cors.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>浏览器安全策略限制跨域访问</p><p>内容安全策略是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><ol><li>使用方式<br>为使 CSP 可用, 你需要配置你的网络服务器返回 Content-Security-Policy，或者在 HTML <meta> 元素种也可配置该策略, 例如：</li></ol><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;meta  http-equiv&#x3D;&quot;Content-Security-Policy&quot;  content&#x3D;&quot;default-src &#39;self&#39;; img-src https:&#x2F;&#x2F;*; child-src &#39;none&#39;;&quot;&#x2F;&gt;</code></pre><ol start="2"><li>配置示例<br>（1）一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</li></ol><pre class="line-numbers language-html" data-language="html"><code class="language-html">Content-Security-Policy: default-src &#39;self&#39;</code></pre><p>（2）一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)</p><pre class="line-numbers language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre><p>（3）一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码。</p><pre class="line-numbers language-none"><code class="language-none">Content-Security-Policy: default-src &#39;self&#39;;img-src *;media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:</p><p>图片可以从任何地方加载(注意 “*“ 通配符)。<br>多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。<br>可运行脚本仅允许来自于 userscripts.example.com。</p><p>作者：菜鸡前端<br>链接：<a href="https://www.jianshu.com/p/a45924e99a6d">https://www.jianshu.com/p/a45924e99a6d</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ul><li>脚本</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">listen 80; # 监听的端⼝   add_header &#39;Access-Control-Allow-Origin&#39; &#39;$http_origin&#39; ;   add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39; ;   add_header &#39;Access-Control-Allow-Methods&#39; &#39;PUT,POST,GET,DELETE,OPTIONS&#39; ;   add_header &#39;Access-Control-Allow-Headers&#39; &#39;Content-Type,Content-Length,Authorization,Accept,X-Requested-With&#39; ;</code></pre><ul><li>实际操作</li></ul><p><img src="http://t-blog-images.aijs.top/img/20220509181853.webp"></p><h3 id="jsonp-方式-lt-动态-script-gt"><a href="#jsonp-方式-lt-动态-script-gt" class="headerlink" title="jsonp 方式 &lt;动态 script&gt;"></a>jsonp 方式 &lt;动态 script&gt;</h3><h3 id="服务端设置，类似-nginx"><a href="#服务端设置，类似-nginx" class="headerlink" title="服务端设置，类似 nginx"></a>服务端设置，类似 nginx</h3><h3 id="其他（不常用）"><a href="#其他（不常用）" class="headerlink" title="其他（不常用）"></a>其他（不常用）</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题汇总</title>
      <link href="//post/2022-05-08interview.html"/>
      <url>//post/2022-05-08interview.html</url>
      
        <content type="html"><![CDATA[<h2 id="值得收藏的链接"><a href="#值得收藏的链接" class="headerlink" title="值得收藏的链接"></a>值得收藏的链接</h2><ol><li><a target="_blank" href="https://juejin.cn/user/1381458394494461">码上通天</a></li><li><a target="_blank" href="https://juejin.cn/post/6844904019165446158#heading-42">面试完50个人后我写下这篇总结</a></li><li><a target="_blank" href="https://juejin.cn/post/6844903897610321934">if 我是前端团队 Leader，怎么制定前端协作规范?</a></li><li><a target="_blank" href="https://juejin.cn/post/7061588533214969892">做了一份前端面试复习计划，保熟～</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js变量和作用域</title>
      <link href="//post/2022-05-08varible.html"/>
      <url>//post/2022-05-08varible.html</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="var-let-const区别"><a href="#var-let-const区别" class="headerlink" title="var let const区别"></a>var let const区别</h3><ul><li><strong>变量提升</strong>：var 存在变量提升，let、const没有（let、const存在暂时性死区）</li><li><strong>作用域的限制</strong>：var不受作用域的限制，而let、const受当前作用域的限制</li><li><strong>重复声明</strong>：var可以重复声明，let、const不可以</li><li><strong>const是常量</strong>，必须有初始值，否则报错，不能更改，但是可以更改对象内部属性</li></ul><h3 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h3><ul><li>js中的变量分为两种：<ul><li>全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；</li><li>而局部变量就只能在函数的内部才能够调用的变量。</li></ul></li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js">var a&#x3D;10;function show()&#123;  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10  var b&#x3D;2;  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2&#125;show();console.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;b is no defined</code></pre><p>　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。</p><p><em>另外需要特别注意的是：</em></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">var a&#x3D;10;function show()&#123;  console.log(&#39;a:&#39;+a); &#x2F;&#x2F;a:10  b&#x3D;2;  console.log(&#39;inside b:&#39;+b); &#x2F;&#x2F;inside b:2&#125;show();console.log(&#39;outside b:&#39;+b); &#x2F;&#x2F;outside b:2</code></pre><p>对比两段代码，<em>如果你在声明b&#x3D;2时没有写var，那么b就隐式地声明为全局变量</em>，在函数外面还是能够被调用到的。<br>虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了<em>缺点</em>：</p><ol><li>一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li><li>影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，</li><li>可移植性: 同时也降低了函数的可移植性。</li></ol><p><strong>因此我们在定义变量时一般要尽可能少的定义全局变量。</strong></p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>函数声明优先于变量声明</p></blockquote><p>　　下面我们通过一段代码来说明.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var a; function a()&#123;&#125;console.log(typeof a); &#x2F;&#x2F;function&#x2F;&#x2F; 或许有人是认为函数声明在后面的原因，那么调换一下位置。</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">function a()&#123;&#125;var a; console.log(typeof a); &#x2F;&#x2F;function&#x2F;&#x2F; 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。&#x2F;&#x2F; 因此函数声明优先于变量的声明。&#x2F;&#x2F; 但是如果我们在声明的同时给a进行赋值。</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">function a()&#123;&#125;var a&#x3D;&#39;xyf&#39;; console.log(typeof a); &#x2F;&#x2F;string&#x2F;&#x2F; 我们将其调换一下位置再次进行验证。</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">var a&#x3D;&#39;xyf&#39;; function a()&#123;&#125;console.log(typeof a); &#x2F;&#x2F;string&#x2F;&#x2F; 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">function a()&#123;&#125;var a;a&#x3D;&#39;xyf&#39;;console.log(typeof a); &#x2F;&#x2F;string&#x2F;&#x2F; a最后被赋值为字符串，因此a的类型自然是字符串</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>　js中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>　js中作用域只有<em>函数作用域</em>和<em>全局作用域</em>，</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>  let const<em>有块级作用域</em>。函数作用域是比较容易理解的，那么什么是块级作用域呢？<br>  <pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;var a &#x3D; 1&#125;console.log(a)VM2355:1 1</code></pre><br>  <pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;let a &#x3D;1&#125;console.log(a)VM2079:1 Uncaught ReferenceError: a is not defined</code></pre></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p></blockquote><p>　　理解了块级作用域，来看一下下面的小例子。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">console.log(v); &#x2F;&#x2F;undefinedvar v &#x3D; &quot;world&quot;;　　&#x2F;&#x2F; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</code></pre><p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p><p>由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var v;console.log(v); &#x2F;&#x2F;undefinedv &#x3D; &quot;world&quot;;&#x2F;&#x2F; 这样就能很清晰地理解为什么变量v是undefined的了。&#x2F;&#x2F;下面我们把变量v放到一个方法中去：</code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js">if(true)&#123;  var v &#x3D; &quot;hello&quot;;&#125;console.log(v); &#x2F;&#x2F;hello&#x2F;&#x2F; 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，&#x2F;&#x2F; 并不能够“阻挡”外面的代码获取里面的变量。</code></pre><p>函数作用域<br>　　我们再把变量v放到函数中去：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function show()&#123;  var v&#x3D;&#39;world&#39;;&#125;show();console.log(v); &#x2F;&#x2F;undefined</code></pre><p>　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var v&#x3D;&#39;hello&#39;;function show()&#123;  console.log(v); &#x2F;&#x2F;undefined  var v&#x3D;&#39;world&#39;;&#125;show();</code></pre><p>　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var v&#x3D;&#39;hello&#39;;function show()&#123;var v;console.log(v); &#x2F;&#x2F;undefinedv&#x3D;&#39;world&#39;;&#125;show();</code></pre><p>　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">var v &#x3D; &quot;hello&quot;;(function()&#123;  console.log(v);  var v &#x3D; &quot;world&quot;;&#125;)();</code></pre><p>　　在这里自执行函数形成了函数作用域</p><p>需要注意的是<br>变量提升只提升函数的声明，并不提升函数的定义</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">show(); &#x2F;&#x2F;show is not a functionvar show&#x3D;function()&#123;&#x2F;&#x2F;...&#125;show(); &#x2F;&#x2F;成功运行</code></pre><p>　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>函数有两种定义方式，一种是<code>函数声明</code>，另一种是<code>函数表达式</code>。那么什么是函数声明什么是函数表达式呢？</p></blockquote><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F;函数声明function show()&#123;&#x2F;&#x2F;....&#125;&#x2F;&#x2F;函数表达式var show&#x3D;function()&#123;&#x2F;&#x2F;...&#125;</code></pre><p>乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。</p><ul><li>js的解析器对<code>函数声明</code>和<code>函数表达式</code>并不是一视同仁的对待的，有点“种族歧视”的意思在里面。</li><li><code>函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了</code>，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。</li><li><code>而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，</code>因此，调用函数表达式要在定义后进行使用。</li></ul><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p><a href="https://juejin.cn/post/6844904019165446158">https://juejin.cn/post/6844904019165446158</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更好的沉淀</title>
      <link href="//post/2022-04-28%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA.html"/>
      <url>//post/2022-04-28%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>工作日常经验性总结放哪？</li><li>存电脑，电脑坏了重做系统没了，</li><li>放到电脑备忘录，卧槽，怎么没及时更新</li><li>放自己的服务器，没时间打理，服务器到期，嗝屁了，没来的及迁移</li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul><li>hexo由于有丰富的插件和主题，使用及部署方便，备受欢迎</li><li>自己购买服务器部署，服务器到期后续费很贵</li><li>放到第三方博客上，好一点的像简书，每天发布限制两篇，可控性太差</li></ul><h2 id="hexo-主题"><a href="#hexo-主题" class="headerlink" title="hexo 主题"></a>hexo 主题</h2><p>这里使用 <code>aurora</code></p><pre class="line-numbers language-none"><code class="language-none">theme: aurora</code></pre><p><a href="https://tridiamond.tech/">tridiamond</a><br><a href="https://github.com/AlphaHinex/AlphaHinex.github.io">AlphaHinex</a></p><h2 id="阿里云oss"><a href="#阿里云oss" class="headerlink" title="阿里云oss"></a>阿里云oss</h2><ul><li>图片资源放到github上，访问较慢，为了提升体验，将资源放到oss上，权限配置为公开，可被任何用户访问</li></ul><h2 id="阿里云域名"><a href="#阿里云域名" class="headerlink" title="阿里云域名"></a>阿里云域名</h2><ul><li>域名访问比较方便，图片资源只有在使用域名的情况下，各资源可以预览，而不仅仅是下载</li></ul><h2 id="PicGo图床「贼好用，"><a href="#PicGo图床「贼好用，" class="headerlink" title="PicGo图床「贼好用，"></a>PicGo图床「贼好用，</h2><ul><li>思考：除此之外，因为其开源我们可以学习下作者是如何处理插件的」</li><li>为博客中md文档提供图片链接，放到阿里云oss上</li><li>上传成功<br><img src="http://t-blog-images.aijs.top/img/20220428101247.png?x-oss-process=image/resize,h_300,w_500"></li><li>因为开发过electron，第一想到的是我要debug,打开控制台</li><li>域名配错不可访问<br><img src="http://t-blog-images.aijs.top/img/20220428104003.png?x-oss-process=image/resize,h_300,w_500"><br><img src="http://t-blog-images.aijs.top/img/20220428104024.png?x-oss-process=image/resize,h_300,w_500"></li><li>遇到图片,作为程序猿第一反应要优化「压缩」<code>compress</code></li><li>插件下载<br><img src="http://t-blog-images.aijs.top/img/20220428104511.png?x-oss-process=image/resize,h_300,w_500" alt="下载插件"></li><li>插件启用<br><img src="http://t-blog-images.aijs.top/img/20220428104919.png?x-oss-process=image/resize,h_300,w_500" alt="需要启动插件，不器用没有效果"></li><li>插件是否生效了<br><img src="http://t-blog-images.aijs.top/img/20220428105126.png?x-oss-process=image/resize,h_300,w_500" alt="压缩后的校验"></li><li>插件列表<br><a href="https://github.com/PicGo/Awesome-PicGo">github链接</a></li></ul><h2 id="书写文章-hexo页面不热重载？"><a href="#书写文章-hexo页面不热重载？" class="headerlink" title="书写文章 hexo页面不热重载？"></a>书写文章 hexo页面不热重载？</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">yarn add global browser-syncyarn add hexo-browsersync</code></pre><h2 id="启用评论"><a href="#启用评论" class="headerlink" title="启用评论"></a>启用评论</h2><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># For local development only!gitalk:  enable: false  autoExpand: true  clientID: &#39;&#39;  clientSecret: &#39;&#39;  repo: &#39;dev-blog-comments&#39;  owner: &#39;TriDiamond&#39;  admin: [&#39;TriDiamond&#39;]  id: uid  language: en  distractionFreeMode: true  recentComment: true  proxy: &#39;&#39;# Valine comment plugin (recommended!)# see https:&#x2F;&#x2F;valine.js.org&#x2F;quickstart.htmlvaline:  enable: true  app_id: 去申请  app_key: 去申请  avatar: &#39;http:&#x2F;&#x2F;t-blog-images.aijs.top&#x2F;img&#x2F;avatar.jpeg&#39;  placeholder: Leave your thoughts behind~  visitor: true  lang: en  avatarForce: false  meta: [&#39;nick&#39;, &#39;mail&#39;]  requiredFields: []  admin: &#39;海龙&#39;  recentComment: true</code></pre><h2 id="图片增加水印"><a href="#图片增加水印" class="headerlink" title="图片增加水印"></a>图片增加水印</h2><p><strong>配置及效果</strong><br><img src="http://t-blog-images.aijs.top/img/20220524104857.webp"></p><h2 id="picgo生成代码"><a href="#picgo生成代码" class="headerlink" title="picgo生成代码"></a>picgo生成代码</h2><ul><li>可选不同的代码方式<img src="http://t-blog-images.aijs.top/img/20220526230443.png"/></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>每次发布后，github page 自定义域名会丢失<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在_posts目录下建立CNAME文件 填写上自己的域名</p></blockquote></li><li>图床picGo，上传了图片，在oss上查看也成功了，但是picGo相册中没有展示<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>/Users/chenhailong/Library/Application Support/picgo</code>目录下，删除 <code>rm picgo.db</code>,重新启动<br>见<a href="https://github.com/Molunerfinn/PicGo/issues/781">issue #781</a></p></blockquote></li><li>调整博客文件时间，运行后文章排序并没有改变，需要清理根目录下<code>db.json</code></li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>总体而言picgo已经很好了，有几点可以优化</p><ul><li>已有图片二次重新上传压缩功能</li><li>窗口实在是太小了，正常情况下可以手动拖拽改变大小</li><li>插件列表插件卡片部分重叠</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Lerna调试开源库遇到的问题</title>
      <link href="//post/2022-05-05lerna.html"/>
      <url>//post/2022-05-05lerna.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">yarn install --mutex network:42424 --non-interactive👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ lerna --version4.0.0👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn global add lerna@3.19.0    Usage Error: The &#39;yarn global&#39; commands have been removed in 2.x - consider using &#39;yarn dlx&#39; or a third-party plugin instead$ yarn run [--inspect] [--inspect-brk] &lt;scriptName&gt; ...👑 ~&#x2F;Desktop&#x2F;slate git:(main) $ yarn --version              3.0.1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC存储空间不足问题</title>
      <link href="//post/2022-05-05mac.html"/>
      <url>//post/2022-05-05mac.html</url>
      
        <content type="html"><![CDATA[<p><img src="http://t-blog-images.aijs.top/img/20220505165350.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String相关面试代码</title>
      <link href="//post/2022-05-03string.html"/>
      <url>//post/2022-05-03string.html</url>
      
        <content type="html"><![CDATA[<h3 id="转化为驼峰命名"><a href="#转化为驼峰命名" class="headerlink" title="转化为驼峰命名"></a>转化为驼峰命名</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><code>var s1 = &quot;get-element-by-id&quot;</code></p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var f &#x3D; function (s) &#123;  return s.replace(&#x2F;-\w&#x2F;g, function (x) &#123;    return x.splice(1).toUpperCase();  &#125;);&#125;;</code></pre><h3 id="模版引擎实现"><a href="#模版引擎实现" class="headerlink" title="模版引擎实现"></a>模版引擎实现</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let template &#x3D; &quot;我是&#123;&#123;name&#125;&#125;,年龄&#123;&#123;age&#125;&#125;,性别&#123;&#123;sex&#125;&#125;&quot;;let data &#x3D; &#123;  name: &quot;姓名&quot;,  age: 18,&#125;;render(template, data); &#x2F;&#x2F;我是姓名,年龄18,性别undefinedfunction render(template, data) &#123;  &#x2F;&#x2F; 模版字符串正则  const resg &#x3D; &#x2F;\&#123;\&#123;(\w+)\&#125;\&#125;&#x2F;;  &#x2F;&#x2F; 判断模版里是否有模版字符串  if (reg.test(template)) &#123;    &#x2F;&#x2F; 查找当前模版里第一个模版字符串的字符    const name &#x3D; reg.exec(template)[1];    &#x2F;&#x2F; 将第一个模版字符串渲染    template &#x3D; template.replace(reg, data[name]);    &#x2F;&#x2F; 递归的渲染并返回渲染后的结构    return render(template, data);  &#125;&#125;</code></pre><h3 id="解析-URL-Params-为对象"><a href="#解析-URL-Params-为对象" class="headerlink" title="解析 URL Params 为对象"></a>解析 URL Params 为对象</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let url &#x3D;  &quot;http:&#x2F;&#x2F;www.domain.com&#x2F;?user&#x3D;anonymouse&amp;id&#x3D;123&amp;id&#x3D;456&amp;city&#x3D;%E5%8C%97%E4%BA%AC&amp;enabled&quot;;&#x2F;** * 结果 * &#123; *  user: &#39;anonymouse&#39;, *  id: [123,456], &#x2F;&#x2F; 重复出现的key，要转化成数组 *  city: &#39;北京&#39;, &#x2F;&#x2F; 中文需要解码 *  enabled: true &#x2F;&#x2F; 未指定值的key，约定为true * * * &#125; * **&#x2F;function paramParam(url) &#123;  const paramsStr &#x3D; &#x2F;.+\?(.+)$&#x2F;.exec(url)[1];  const paramsArr &#x3D; paramsArr.split(&quot;&amp;&quot;);  let paramsObj &#x3D; &#123;&#125;;  paramsArr.forEach((param) &#x3D;&gt; &#123;    if (&#x2F;&#x3D;&#x2F;.test(param)) &#123;      let [key, val] &#x3D; param.split(&quot;&#x3D;&quot;); &#x2F;&#x2F; 拆分键&#x2F;值      val &#x3D; decodeURLComponent(val); &#x2F;&#x2F; 汉字解码      val &#x3D; &#x2F;^\d+$&#x2F;.test(val) ? parseFloat(val) : val; &#x2F;&#x2F; 数字转化      if (paramsObj.hasOwnProperty(key)) &#123;        paramsObj[key] &#x3D; [].concat(paramsObj[key], val); &#x2F;&#x2F; 重复key转数组      &#125; else &#123;        paramsObj[key] &#x3D; val;      &#125;    &#125; else &#123;      paramsObj[key] &#x3D; true; &#x2F;&#x2F; 处理约定    &#125;  &#125;);&#125;</code></pre><h3 id="查找字符串中，出现最多的字符和个数"><a href="#查找字符串中，出现最多的字符和个数" class="headerlink" title="查找字符串中，出现最多的字符和个数"></a>查找字符串中，出现最多的字符和个数</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let str &#x3D; &quot;abcabcabcbbcccc&quot;;let num &#x3D; 0;let char &#x3D; &quot;&quot;;&#x2F;&#x2F; 先排序，后用正则处理个数str &#x3D; str.split(&quot;&quot;).sort().join(&quot;&quot;);let re &#x3D; &#x2F;(\w)\1+&#x2F;g;str.replace(re, ($0, $1) &#x3D;&gt; &#123;  if (num &lt; $0.length) &#123;    num &#x3D; $0.length;    char &#x3D; $1;  &#125;&#125;);</code></pre><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a &#x3D; &quot;34&quot;;b &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回2a &#x3D; &quot;35&quot;;b &#x3D; &quot;1234567&quot;; &#x2F;&#x2F; 返回 -1a &#x3D; &quot;355&quot;;b &#x3D; &quot;1234355&quot;; &#x2F;&#x2F; 返回5function isContain(a, b) &#123;  for (let i in b) &#123;    if (a[0] &#x3D;&#x3D;&#x3D; b[i]) &#123;      let tmp &#x3D; true;      for (let j in a) &#123;        if (a[j] !&#x3D;&#x3D; b[~~i + ~~j]) &#123;          tmp &#x3D; false;        &#125;      &#125;      if (tmp) &#123;        return i;      &#125;    &#125;  &#125;  return -1;&#125;</code></pre><h3 id="实现千分位分隔符"><a href="#实现千分位分隔符" class="headerlink" title="实现千分位分隔符"></a>实现千分位分隔符</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 保留三位小数paraseToMoney(1234.56); &#x2F;&#x2F; return &#39;1,234.56&#39;paraseToMoney(123456789); &#x2F;&#x2F; return 123,456,789paraseToMoney(1087654.321); &#x2F;&#x2F; return 1,087,654.321function paraseToMoney(params) &#123;  num &#x3D; parseFloat(num.toFixed(3));  let [integer, decimal] &#x3D; String.prototype.split.call(num, &quot;.&quot;);  integer &#x3D; integer.replace(&#x2F;\d(?&#x3D;(\d&#123;3&#125;))+$&#x2F;, &quot;$&amp;,&quot;);  return integer + &quot;.&quot; + (decimal ?? &quot;&quot;);&#125;</code></pre><h3 id="判断是否是电话号码"><a href="#判断是否是电话号码" class="headerlink" title="判断是否是电话号码"></a>判断是否是电话号码</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function isPhone(str) &#123;  let regx &#x3D; &#x2F;^1[34578]\d&#123;9&#125;$&#x2F;;  return regx.test(str);&#125;</code></pre><h3 id="判断是否是邮箱"><a href="#判断是否是邮箱" class="headerlink" title="判断是否是邮箱"></a>判断是否是邮箱</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function isEmail(mail) &#123;  var regx &#x3D; &#x2F;^(a-zA-Z0-9_\-)+@(a-zA-Z0-9_\-)+(\.[a-zA-Z0-9_\-])+$&#x2F;;  return regx.test(email);&#125;</code></pre><h3 id="校验身份证"><a href="#校验身份证" class="headerlink" title="校验身份证"></a>校验身份证</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function isCard(number) &#123;  var regx &#x3D; &#x2F;(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)&#x2F;;  return regx.test(number);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计引发的血案</title>
      <link href="//post/2022-04-29nextjs.html"/>
      <url>//post/2022-04-29nextjs.html</url>
      
        <content type="html"><![CDATA[<h2 id="记录个bug-并在此文中规避"><a href="#记录个bug-并在此文中规避" class="headerlink" title="记录个bug,并在此文中规避"></a>记录个bug,并在此文中规避</h2><p>此处记下 hexo-theme-aurora 源码bug，没空时候帮他改</p><pre class="line-numbers language-none"><code class="language-none">.article .article-content p &#123;    font-size: .875rem;    line-height: 1.25rem;    margin-bottom: 0.5rem;    padding-bottom: 1rem;    word-break: break-all;&#125;</code></pre><h2 id="bug复现"><a href="#bug复现" class="headerlink" title="bug复现"></a>bug复现</h2><p><img src="http://t-blog-images.aijs.top/img/20220429103417.png"><br><img src="http://t-blog-images.aijs.top/img/20220429103946.png"></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)    at async Promise.all (index 3)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)(Use &#96;node --trace-warnings ...&#96; to show where the warning was created)(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 19)(node:29) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.(node:29) UnhandledPromiseRejectionWarning: Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)    at async Promise.all (index 3)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)(node:29) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag &#96;--unhandled-rejections&#x3D;strict&#96; (see https:&#x2F;&#x2F;nodejs.org&#x2F;api&#x2F;cli.html#cli_unhandled_rejections_mode). (rejection id: 44)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)    at async Promise.all (index 2)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.getDataReport (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11494:19)    at async Promise.all (index 3)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)Error: invalid json response body at https:&#x2F;&#x2F;login-daily.敏感数据-inc.cn:7799&#x2F;error&#x2F;illegal&#x2F;location reason: Unexpected token &lt; in JSON at position 0    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:13141:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Object.refreshPendingPerformanceNum (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:11487:25)    at async Promise.all (index 2)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-a053507d8512cb10a3ff.js:12208:22)</code></pre><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [resp] &#x3D; await Promise.all([  getLoginInfo(ctx),  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),  CommonModel.effects.getDataReport(req, ctx),])if (resp.success) &#123;  UserModal.actions.setUser(resp.result, req)&#125;</code></pre><h2 id="增加异常捕获"><a href="#增加异常捕获" class="headerlink" title="增加异常捕获"></a>增加异常捕获</h2><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">const [resp] &#x3D; await Promise.all([  getLoginInfo(ctx),  CommonModel.effects.refreshPendingObjectiveNum(req, ctx),  CommonModel.effects.refreshPendingPerformanceNum(req, ctx),  CommonModel.effects.getDataReport(req, ctx),]).catch(e&#x3D;&gt;&#123;  console.log(&quot;发生错误&quot;)  console.log(e)&#125;)</code></pre><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志仅 <code>Forbidden</code> 有效信息，大概是接口</p><pre class="line-numbers language-tsx" data-language="tsx"><code class="language-tsx">发生错误Error: Forbidden    at &#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:13144:29    at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:95:5)    at async Promise.all (index 0)    at async Function.getInitialProps (&#x2F;code&#x2F;client&#x2F;.next&#x2F;server&#x2F;pages&#x2F;_app-7be1c2d9b56a41e863e3.js:12208:22)</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>因为acl 企业权限整了180天（顶配），时不时就出现系统瘫痪的情况，<code>日常</code>、<code>线上</code>都有此问题这架构设计的，估计没谁了。完全可以改成离职后，系统自动将用户禁权即可</li><li>除此之外，sso也有个通病，三个月没改过密码，用户账户无法登录，需要重新密码方可登录</li></ol>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs 结合 knife4j</title>
      <link href="//post/2022-02-29node.html"/>
      <url>//post/2022-02-29node.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.npmjs.com/package/nest-knife4j">nest-knife4j</a><br><a href="https://github.com/xiaoymin/swagger-bootstrap-ui">knife4j github</a><br><a href="https://xiaoym.gitee.io/knife4j/documentation/">knife4j 文档</a><br><code>knife4j</code>可以理解为<code>一套swagger皮肤</code>，不使用knife4j默认是<code>swagger 1</code>版本的样式<br><img src="http://t-blog-images.aijs.top/img/11460713-6cda8a0126f7ee78.png"></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs文件上传</title>
      <link href="//post/2022-02-28node.html"/>
      <url>//post/2022-02-28node.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><a href="https://www.jianshu.com/p/28f8dd9a732e">Nestjs 上传文件</a><br><a href="https://www.cnblogs.com/ajanuw/p/9575278.html">Nestjs 上传文件</a></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 拖拽兼容</title>
      <link href="//post/2022-02-27react.html"/>
      <url>//post/2022-02-27react.html</url>
      
        <content type="html"><![CDATA[<h2 id="拖拽在web-pc-端、iframe、h5移动端"><a href="#拖拽在web-pc-端、iframe、h5移动端" class="headerlink" title="拖拽在web pc 端、iframe、h5移动端"></a>拖拽在web pc 端、iframe、h5移动端</h2><h3 id="存在差异"><a href="#存在差异" class="headerlink" title="存在差异"></a>存在差异</h3><ul><li>web pc 端支持：<code>onMouseDown</code>、<code>onMouseUp</code>、<code>onMousemove</code>、<code>onDragStart</code>、<code>onDragEnd</code>、<code>nDragOver</code></li><li>iframe web pc 端支持：<code>onMouseDown</code>、<code>onMouseUp</code>、<code>onMousemove</code></li><li>h5移动端支持：<code>onTouchStart</code>、<code>onTouchEnd</code>、<code>onTouchmove</code><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">export default function Draggable(props: Props) &#123;  const &#123; children, style, className, onDragFinish, onDraggingStart, onPositionGet, boundary &#x3D; &#123; x: MARGIN_TO_PAGE, y: MARGIN_TO_PAGE &#125; &#125; &#x3D; props  const [dragging, setDragging] &#x3D; useState(false)  const [attaching, setAttaching] &#x3D; useState(false)  const [top, setTop] &#x3D; useState(0)  const [left, setLeft] &#x3D; useState(0)  const ghostRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()  const elRef: MutableRefObject&lt;HTMLDivElement&gt; &#x3D; useRef()  const onDragStart &#x3D; useCallback((e: DragEvent&lt;HTMLDivElement&gt; | TouchEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123;    let x    let y    if (isDrag(e)) &#123;      if (e.target !&#x3D;&#x3D; elRef.current) &#123;        return      &#125;      e.dataTransfer.setDragImage(emptyImg, 0, 0)      x &#x3D; e.clientX      y &#x3D; e.clientY    &#125; else &#123;      if (!e.target || !(e.target instanceof HTMLElement)) &#123;        return      &#125;      if (!parentHasClass(e.target, [rootStyles.feedbackRoot])) &#123;        return      &#125;      x &#x3D; e.touches[0].clientX      y &#x3D; e.touches[0].clientY    &#125;    e.stopPropagation()    const rect &#x3D; e.currentTarget.getBoundingClientRect()    const offsetX &#x3D; x - rect.x    const offsetY &#x3D; y - rect.y    setTop(rect.y)    setLeft(rect.x)    setDragging(true)    if (isDrag(e)) &#123;      dragoverHandle &#x3D; (event: DragEvent) &#x3D;&gt; &#123;        if (event.clientX || event.clientY) &#123;          setTop(event.clientY - offsetY)          setLeft(event.clientX - offsetX)        &#125;      &#125;      &#x2F;&#x2F; firefox 中，ondrag 拿不到鼠标的坐标，所以这里使用 document 的 dragover      document.addEventListener(&#39;dragover&#39;, dragoverHandle)    &#125; else &#123;      dragoverHandle &#x3D; (event: TouchEvent) &#x3D;&gt; &#123;        const touch &#x3D; event.touches[0]        if (touch.clientX || touch.clientY) &#123;          setTop(touch.clientY - offsetY)          setLeft(touch.clientX - offsetX)        &#125;      &#125;      document.addEventListener(&#39;touchmove&#39;, dragoverHandle)    &#125;    onDraggingStart()  &#125;, [])  const onDragEnd &#x3D; useCallback((event) &#x3D;&gt; &#123;    if (!ghostRef.current) &#123;      setDragging(false)      return    &#125;    const rect &#x3D; ghostRef.current.getBoundingClientRect()    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)    setTop(abs.top)    setLeft(abs.left)    setAttaching(true)    if (isDrag(event)) &#123;      document.removeEventListener(&#39;dragover&#39;, dragoverHandle)    &#125; else &#123;      document.removeEventListener(&#39;touchmove&#39;, dragoverHandle)    &#125;    &#x2F;&#x2F; onPosition &amp;&amp; onPosition(rel) &#x2F;&#x2F; 其他业务    dragoverHandle &#x3D; null    setTimeout(() &#x3D;&gt; &#123;      onDragFinish(rel)      setAttaching(false)      setDragging(false)    &#125;, 300)  &#125;, [])  const onMousedown &#x3D; useCallback((e) &#x3D;&gt; &#123;    const x &#x3D; e.clientX    const y &#x3D; e.clientY    const rect &#x3D; e.currentTarget.getBoundingClientRect()    const offsetX &#x3D; x - rect.x    const offsetY &#x3D; y - rect.y    setTop(rect.y)    setLeft(rect.x)    setDragging(true)    if (e.preventDefault) &#123;      e.preventDefault()    &#125; else &#123;      e.returnValue &#x3D; false    &#125;    document.onmousemove &#x3D; function (ev: any) &#123;      const _event &#x3D; ev || window.event      const endx &#x3D; _event.clientX - offsetX      const endy &#x3D; _event.clientY - offsetY      setTop(endy)      setLeft(endx)    &#125;  &#125;, [])  const onMouseup &#x3D; useCallback((e) &#x3D;&gt; &#123;    if (!ghostRef.current) &#123;      setDragging(false)      return    &#125;    const rect &#x3D; ghostRef.current.getBoundingClientRect()    const &#123; rel, abs &#125; &#x3D; calcAttachSide(rect, boundary)    setTop(abs.top)    setLeft(abs.left)    setAttaching(true)    document.onmousemove &#x3D; null    onPositionGet &amp;&amp; onPositionGet(rel)    setTimeout(() &#x3D;&gt; &#123;      onDragFinish(rel)      setAttaching(false)      setDragging(false)    &#125;, 300)  &#125;, []) &#x2F;&#x2F; 能力检测  if (&#39;dragover&#39; in document.documentElement || &#39;ontouchstart&#39; in document.documentElement) &#123;    return (      &lt;div        style&#x3D;&#123;style&#125;        className&#x3D;&#123;className&#125;        draggable        onTouchStart&#x3D;&#123;onDragStart&#125;        onTouchEnd&#x3D;&#123;onDragEnd&#125;        onDragStart&#x3D;&#123;onDragStart&#125;        onDragEnd&#x3D;&#123;onDragEnd&#125;        onDragOver&#x3D;&#123;prevent&#125;        ref&#x3D;&#123;elRef&#125;      &gt;        &lt;div          style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;          className&#x3D;&#123;cn(&#123;            [styles.dragging]: dragging,            [styles.attaching]: attaching,          &#125;)&#125;          ref&#x3D;&#123;ghostRef&#125;        &gt;          &#123;children&#125;        &lt;&#x2F;div&gt;      &lt;&#x2F;div&gt;    )  &#125;  return (    &lt;div      style&#x3D;&#123;style&#125;      className&#x3D;&#123;className&#125;      draggable      onMouseDown&#x3D;&#123;onMousedown&#125;      onMouseUp&#x3D;&#123;onMouseup&#125;      ref&#x3D;&#123;elRef&#125;    &gt;      &lt;div        style&#x3D;&#123;dragging ? &#123; top, left &#125; : null&#125;        className&#x3D;&#123;cn(&#123;          [styles.dragging]: dragging,          [styles.attaching]: attaching,        &#125;)&#125;        ref&#x3D;&#123;ghostRef&#125;      &gt;        &#123;children&#125;      &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;  )&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React DOM</title>
      <link href="//post/2022-05-04react.html"/>
      <url>//post/2022-05-04react.html</url>
      
        <content type="html"><![CDATA[<h2 id="17-0-0-October-20-2020"><a href="#17-0-0-October-20-2020" class="headerlink" title="17.0.0 (October 20, 2020)"></a>17.0.0 (October 20, 2020)</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Delegate events to roots instead of document<br>来看下<a href="https://www.bigbinary.com/blog/react-17-delegates-events-to-root-instead-of-document">原因</a></p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>React自首次发布以来一直在自动执行事件委派。它直接在文档节点上为每个事件类型附加一个处理程序。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>虽然它提高了应用程序的性能，但由于文档节点上的事件委派，已经报告了许多问题。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为了演示其中一个问题，让我们以select下拉列表为例。<br>下面示例中的CountryDropDown是用于国家选择的React组件，它将被呈现给id为React root的div。react DOM容器封装在id为main的div中，该div有一个包含stopPropagation（）的更改事件。</p></blockquote><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!--Div&#39;s change event contains stopPropagation()--&gt;&lt;div id&#x3D;&quot;main&quot;&gt;  &lt;!--Div where react component will be rendered --&gt;  &lt;div id&#x3D;&quot;react-root&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">class CountryDropDown extends React.Component &#123;  state &#x3D; &#123;    country: &#39;&#39;,  &#125;  const handleChange &#x3D; e &#x3D;&gt; &#123;    this.setState(&#123; country: e.target.value &#125;);  &#125;  render() &#123;    return (      &lt;table class&#x3D;&quot;table table-striped table-condensed&quot;&gt;        &lt;thead&gt;          &lt;tr&gt;            &lt;th&gt;Country&lt;&#x2F;th&gt;            &lt;th&gt;Selected country&lt;&#x2F;th&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;thead&gt;        &lt;tbody&gt;          &lt;tr&gt;            &lt;td&gt;              &lt;select value&#x3D;&#123;this.state.country&#125;                onChange&#x3D;&#123;this.handleChange&#125;              &gt;                &lt;option value&#x3D;&quot;&quot;&gt;--Select--&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;India&quot;&gt;India&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;US&quot;&gt;US&lt;&#x2F;option&gt;                &lt;option value&#x3D;&quot;Dubai&quot;&gt;Dubai&lt;&#x2F;option&gt;              &lt;&#x2F;select&gt;            &lt;&#x2F;td&gt;            &lt;td&gt;              &#123;this.state.country&#125;            &lt;&#x2F;td&gt;          &lt;&#x2F;tr&gt;        &lt;&#x2F;tbody&gt;      &lt;&#x2F;table&gt;    );  &#125;&#125;ReactDOM.render(&lt;CountryDropDown &#x2F;&gt;, document.getElementById(&#39;react-root&#39;));</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>将更改事件附加到主div</p></blockquote><pre class="line-numbers language-none"><code class="language-none">document.getElementById(&quot;main&quot;).addEventListener(  &quot;change&quot;,  function (e) &#123;    e.stopPropagation();  &#125;,  false);</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>当选择一个国家时，我们无法看到所选的国家</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>此意外行为的原因是附加到文档节点的onChange dropdown事件。包含e.stopPropagation（）的主div的change事件阻止了下拉菜单的onChange事件。</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>为了解决此类问题，React 17不再在文档级别附加事件处理程序。相反，它将它们附加到根DOM容器中，React树将被渲染到该容器中。<br><img src="https://www.bigbinary.com/blog_images/react17/react_17_event_delegation.png"></p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在React 17中进行更改后，事件被附加到根DOM容器，React树被呈现到该容器中。在我们的示例中，onChange事件的下拉列表将附加到id为react root的div。当选择任何国家&#x2F;地区呈现预期行为时，将触发此事件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentry错误日志获取</title>
      <link href="//post/2021-06-20sentry.html"/>
      <url>//post/2021-06-20sentry.html</url>
      
        <content type="html"><![CDATA[<ul><li>先上图</li></ul><p><img src="http://t-blog-images.aijs.top/img/11460713-94dac7337bf8ed4f.png"></p><p><img src="http://t-blog-images.aijs.top/img/11460713-2d4eb13808a7a16a.png"></p><p>This is a quick getting started guide. For in-depth instructions on integrating Sentry with React, view <a href="https://docs.sentry.io/platforms/javascript/guides/react/">our complete documentation</a>.</p><p>To instrument your React application with Sentry, first install the <code>@sentry/react</code> and <code>@sentry/tracing</code> packages:</p><pre class="line-numbers language-none"><code class="language-none"># Using yarnyarn add @sentry&#x2F;react @sentry&#x2F;tracing# Using npmnpm install --save @sentry&#x2F;react @sentry&#x2F;tracing</code></pre><p>Next, import and initialize the Sentry module as early as possible, before initializing React:</p><pre class="line-numbers language-none"><code class="language-none">import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import * as Sentry from &quot;@sentry&#x2F;react&quot;;import &#123; Integrations &#125; from &quot;@sentry&#x2F;tracing&quot;;import App from &quot;.&#x2F;App&quot;;Sentry.init(&#123;  dsn: &quot;https:&#x2F;&#x2F;a5f1c39789b24bb7a434868b677e0c65@&#x2F;1063&quot;,  integrations: [new Integrations.BrowserTracing()],  &#x2F;&#x2F; Set tracesSampleRate to 1.0 to capture 100%  &#x2F;&#x2F; of transactions for performance monitoring.  &#x2F;&#x2F; We recommend adjusting this value in production  tracesSampleRate: 1.0,&#125;);ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&quot;root&quot;));&#x2F;&#x2F; Can also use with React Concurrent Mode&#x2F;&#x2F; ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App &#x2F;&gt;);</code></pre><p>The above configuration captures both error and performance data. To reduce the volume of performance data captured, change <code>tracesSampleRate</code> to a value between 0 and 1.</p><p>After this step, Sentry will report any uncaught exceptions triggered by your application.</p><p>You can trigger your first event from your development environment by raising an exception somewhere within your application. An example of this would be rendering a button whose <code>onClick</code> handler attempts to invoke a method that does not exist:</p><pre class="line-numbers language-none"><code class="language-none">return &lt;button onClick&#x3D;&#123;methodDoesNotExist&#125;&gt;Break the world&lt;&#x2F;button&gt;;</code></pre><p>Once you’ve verified the library is initialized properly and sent a test event, consider visiting our <a href="https://docs.sentry.io/platforms/javascript/guides/react/">complete React docs</a>. There you’ll find additional instructions for surfacing valuable context from React error boundaries, React Router, Redux, and more.</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 自动生成 .d.ts</title>
      <link href="//post/2021-06-10scss2type.html"/>
      <url>//post/2021-06-10scss2type.html</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-Module-Typed"><a href="#CSS-Module-Typed" class="headerlink" title="CSS Module Typed"></a>CSS Module Typed</h2><p><strong>vscode 插件列表中有好多个，不要安装错了</strong></p><p><img src="http://t-blog-images.aijs.top/img/20220607152316.webp"></p><h2 id="address"><a href="#address" class="headerlink" title="address"></a>address</h2><p><a href="https://marketplace.visualstudio.com/items?itemName=awwit.typed-css-modules-plugin">link</a></p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Install deps first:</p><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p><code>npm install typed-css-modules</code></p><h3 id="if-you-need-less"><a href="#if-you-need-less" class="headerlink" title="if you need less"></a>if you need less</h3><p><code>npm install less</code></p><h3 id="if-you-need-scss-x2F-sass"><a href="#if-you-need-scss-x2F-sass" class="headerlink" title="if you need scss&#x2F;sass"></a>if you need scss&#x2F;sass</h3><p><code>npm install sass</code></p><h3 id="if-you-need-stylus"><a href="#if-you-need-stylus" class="headerlink" title="if you need stylus"></a>if you need stylus</h3><p><code>npm install stylus</code></p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Modules can be installed globally. yarn is supported.</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>To switch the package manager (npm or yarn), you need to change the settings npm.packageManager of the built-in module vscode.npm.</p></blockquote><h3 id="Configuring"><a href="#Configuring" class="headerlink" title="Configuring"></a>Configuring</h3><p>By default, the option to automatically format .d.ts files using eslint is enabled. You can disable this feature through the setting “typed-css-modules.eslint.enable”: false.</p><p>Usage<br>put</p><p><code>// @type</code></p><p>or</p><p><code>/* @type */</code></p><p>ahead of your .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl file, and save, you will get a d.ts file in same directory.</p><h3 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h3><p><img src="https://s2.ax1x.com/2019/01/31/k1yTT1.gif"></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">&#x2F;* @type *&#x2F;.root &#123;  padding: 16px;  min-height: 100%;  .empty-wrapper &#123;    height: 380px;    display: flex;    flex-direction: column;    align-items: center;    justify-content: center;  &#125;  &gt; h3 &#123;    font-size: inherit;    margin-bottom: 4px;  &#125;  .toolbar-wrapper &#123;    position: relative;    .toolbar &#123;      position: absolute;      margin: 12px 0;      z-index: 1;      &amp;.static &#123;        position: static;      &#125;      &gt; *:not(:first-child) &#123;        margin-left: 8px;      &#125;    &#125;  &#125;  .buttons &#123;    button &#123;      margin-right: 8px;    &#125;  &#125;&#125;.use-select &#123;  width: 300px;&#125;</code></pre><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">declare const styles: &#123;  readonly root: string;  readonly &quot;empty-wrapper&quot;: string;  readonly &quot;toolbar-wrapper&quot;: string;  readonly toolbar: string;  readonly static: string;  readonly buttons: string;  readonly &quot;use-select&quot;: string;&#125;;export &#x3D; styles;</code></pre><h3 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Creates .d.ts files from css-modules .css&#x2F;.less&#x2F;.scss&#x2F;.sass&#x2F;.styl files.</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Error: vscode-typed-css-modules: Cannot find global module ‘typed-css-modules’</p></blockquote><pre class="line-numbers language-none"><code class="language-none">npm install -g typed-css-modules</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//post/hello-world.html"/>
      <url>//post/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode GitHub Copilot</title>
      <link href="//post/2022-05-08vscode.html"/>
      <url>//post/2022-05-08vscode.html</url>
      
        <content type="html"><![CDATA[<h2 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h2><a href="https://copilot.github.com/" target="_blank"><img src="https://copilot.github.com/head2x.png"  width= 100/></a><p>Your AI pair programmer</p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="https://copilot.github.com/">官网</a></h3><p><img src="https://copilot.github.com/diagram.png"></p><h3 id="支持开发工具"><a href="#支持开发工具" class="headerlink" title="支持开发工具"></a>支持开发工具</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>support Visual Studio Code, Neovim, and IntelliJ-based IDEs like JetBrains IntelliJ IDEA, Android Studio or PyCharm.</p></blockquote><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul><li>需要人员审批通过，等[1-2 工作日]</li></ul><p><a href="https://github.com/features/copilot/signup">注册&#x2F;结果查看</a><br><img src="http://t-blog-images.aijs.top/img/20220526184023.webp"></p><p><strong>我等到了5月25号才通过</strong>，好像有两周的样子😂</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>Join the GitHub Copilot waitlist<br>Access is limited to a small group of testers during the technical preview of GitHub Copilot. Sign up today for your chance to try it out and help us improve.</p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>You’re already on the waitlist for GitHub Copilot! We’ll notify you when we’ve enabled it on your account. Make sure your primary email address is up-to-date so we can notify you.</p></blockquote><h3 id="vscode-安装插件-Copilot"><a href="#vscode-安装插件-Copilot" class="headerlink" title="vscode 安装插件 Copilot"></a>vscode 安装插件 <code>Copilot</code></h3><p><img src="http://t-blog-images.aijs.top/img/20220508111956.webp"></p><h3 id="读源码的利器"><a href="#读源码的利器" class="headerlink" title="读源码的利器"></a>读源码的利器</h3><p><img src="http://t-blog-images.aijs.top/img/20220527093323.webp"></p><h3 id="写文档的利器"><a href="#写文档的利器" class="headerlink" title="写文档的利器"></a>写文档的利器</h3><ul><li>我这里需要某种格式的翻译效果<br><img src="http://t-blog-images.aijs.top/img/Kapture%202022-06-08%20at%2017.46.08.gif"></li></ul>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> vscode </tag>
            
            <tag> AI编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git public key</title>
      <link href="//post/2016-06-20git.html"/>
      <url>//post/2016-06-20git.html</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.name &quot;hailong.chen&quot;[root@izbp1hun1qsl59e2nzqyvcz ~]# git config --global user.email &quot;841660202@qq.com&quot;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>SSH<br>SSH keys<br>SSH key 可以让你在你的电脑和Code服务器之间建立安全的加密连接。 先执行以下语句来判断是否已经存在本地公钥：<br><code>cat ~/.ssh/id_rsa.pub</code><br>如果你看到一长串以 ssh-rsa或 ssh-dsa开头的字符串, 你可以跳过 ssh-keygen的步骤。<br>提示: 最好的情况是一个密码对应一个ssh key，但是那不是必须的。你完全可以跳过创建密码这个步骤。请记住设置的密码并不能被修改或获取。<br>你可以按如下命令来生成ssh key<br><code>ssh-keygen -t rsa -C &quot;841660202@qq.com&quot;</code><br>这个指令会要求你提供一个位置和文件名去存放键值对和密码，你可以点击Enter键去使用默认值。<br>用以下命令获取你生成的公钥：<br><code>cat ~/.ssh/id_rsa.pub</code><br>复制这个公钥放到你的个人设置中的SSH&#x2F;My SSH Keys下，请完整拷贝从ssh-开始直到你的用户名和主机名为止的内容。<br>如果打算拷贝你的公钥到你的粘贴板下，请参考你的操作系统使用以下的命令：<br>Windows:<br><code>clip &lt; ~/.ssh/id_rsa.pub</code><br>Mac:<br><code>pbcopy &lt; ~/.ssh/id_rsa.pub</code><br>GNU&#x2F;Linux (requires xclip):<br><code>xclip -sel clip &lt; ~/.ssh/id_rsa.pub</code><br>Applications<br>Eclipse<br>如何在Eclipse中添加ssh key: <a href="https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_Configuration">https://wiki.eclipse.org/EGit/User_Guide#Eclipse_SSH_Configuration</a><br>Tip: Non-default OpenSSH key file names or locations<br>如果，不管你有什么理由，当你决定去用一个非默认的位置或文件名去存放你的ssh key。你必须配置好你的ssh客户端以找到你的ssh私钥去连接Code服务器，对于OpenSSH客户端，这个通常是在~&#x2F;.ssh&#x2F;config类似的位置配置的：<br>Host my-git.company.com<br>RSAAuthentication yes<br>IdentityFile ~&#x2F;my-ssh-key-directory&#x2F;company-com-private-key-filename</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Last login: Sun Apr 17 16:06:15 on consoleN&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.You need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.N&#x2F;A: version &quot;N&#x2F;A -&gt; N&#x2F;A&quot; is not yet installed.You need to run &quot;nvm install N&#x2F;A&quot; to install it before using it.The default interactive shell is now zsh.To update your account to use zsh, please run &#96;chsh -s &#x2F;bin&#x2F;zsh&#96;.For more details, please visit https:&#x2F;&#x2F;support.apple.com&#x2F;kb&#x2F;HT208050.chenhailong@chenhailongdeMacBook-Pro:~$ &#x2F;Users&#x2F;chenhailong&#x2F;Desktop -bash: &#x2F;Users&#x2F;chenhailong&#x2F;Desktop: is a directorychenhailong@chenhailongdeMacBook-Pro:~$ cd &#x2F;Users&#x2F;chenhailong&#x2F;Desktop chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.gitCloning into &#39;841660202.github.io&#39;...The authenticity of host &#39;github.com (20.205.243.166)&#39; can&#39;t be established.ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF&#x2F;zLDA0zPMSvHdkr4UvCOqU.This key is not known by any other namesAre you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])? yesWarning: Permanently added &#39;github.com&#39; (ED25519) to the list of known hosts.git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.gitCloning into &#39;841660202.github.io&#39;...git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub-bash: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directorychenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pubcat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directorychenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.name &quot;hailong.chen&quot;chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git config --global user.email &quot;841660202@qq.com&quot;chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ cat ~&#x2F;.ssh&#x2F;id_rsa.pubcat: &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directorychenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ ssh-keygen -t rsa -C &quot;841660202@qq.com&quot;Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsaYour public key has been saved in &#x2F;Users&#x2F;chenhailong&#x2F;.ssh&#x2F;id_rsa.pubThe key fingerprint is:SHA256:bdtIDeRXGKxGTEa&#x2F;Ex3QdPtVoOUiwuiq7YKjKrLakbU 841660202@qq.comThe key&#39;s randomart image is:+---[RSA 3072]----+|         +&#x3D;.o**.o||       o +o.o*.oo||      . o.+.* o..||     .   oo&#x3D; +  o||    . . S.+ +   .||   o o   o + .   || .o E     o .    ||&#x3D;..+             ||@oooo            |+----[SHA256]-----+chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pubchenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ git clone git@github.com:841660202&#x2F;841660202.github.io.gitCloning into &#39;841660202.github.io&#39;...remote: Enumerating objects: 441, done.remote: Counting objects: 100% (441&#x2F;441), done.remote: Compressing objects: 100% (216&#x2F;216), done.remote: Total 441 (delta 208), reused 401 (delta 168), pack-reused 0Receiving objects: 100% (441&#x2F;441), 1.34 MiB | 1.05 MiB&#x2F;s, done.Resolving deltas: 100% (208&#x2F;208), done.chenhailong@chenhailongdeMacBook-Pro:~&#x2F;Desktop$ </code></pre><h2 id="设置github-SSH-keys"><a href="#设置github-SSH-keys" class="headerlink" title="设置github SSH keys"></a>设置github SSH keys</h2><p><a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC Iterm2美化终端</title>
      <link href="//post/2017-07-09item2.html"/>
      <url>//post/2017-07-09item2.html</url>
      
        <content type="html"><![CDATA[<h2 id="MAC-环境"><a href="#MAC-环境" class="headerlink" title="MAC 环境"></a>MAC 环境</h2><p><strong>注意：以下内容仅限MAC,其他环境，请自行谷歌</strong></p><h2 id="oh-my-zsh-插件推荐"><a href="#oh-my-zsh-插件推荐" class="headerlink" title="oh-my-zsh 插件推荐 :"></a>oh-my-zsh 插件推荐 :</h2><ul><li>autojump 这个没用起来，使用没什么效果🥹</li><li>zsh-autosuggestion 命令行输入有提示，（命令下载失败，手动下载，拷贝到 <code>~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code>）</li><li>zsh-syntax-highlighting</li></ul><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><p><strong>1.使用 brew 安装</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew install oh-my-zsh</code></pre><p><strong>2. 手动安装</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zshcp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc</code></pre><h2 id="安装-autojump"><a href="#安装-autojump" class="headerlink" title="安装 autojump"></a>安装 autojump</h2><p><strong>1.安装</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew install autojump</code></pre><p><strong>2.配置</strong><br><code>code ~/.zshrc</code>，把以下代码加到尾部</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 使用brew安装的[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.shsource $ZSH&#x2F;oh-my-zsh.sh# 使用git安装的[[ -s ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh</code></pre><p><strong>3.刷新配置</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">source ~&#x2F;.zshrc</code></pre><h2 id="安装-zsh-autosuggestion"><a href="#安装-zsh-autosuggestion" class="headerlink" title="安装 zsh-autosuggestion"></a>安装 zsh-autosuggestion</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions</code></pre><h2 id="安装-zsh-syntax-highlighting"><a href="#安装-zsh-syntax-highlighting" class="headerlink" title="安装 zsh-syntax-highlighting"></a>安装 zsh-syntax-highlighting</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom&#125;&#x2F;plugins&#x2F;zsh-syntax-highlighting</code></pre><h2 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h2><p>最后用 <code>source ~/.zshrc</code> 命令更新配置文件</p><h2 id="zshrc-配置如下："><a href="#zshrc-配置如下：" class="headerlink" title=".zshrc 配置如下："></a>.zshrc 配置如下：</h2><ul><li>自己电脑配置，下面截图是办公电脑截图<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># If you come from bash you might have to change your $PATH.# export PATH&#x3D;$HOME&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:$PATH# Path to your oh-my-zsh installation.export ZSH&#x3D;&quot;$HOME&#x2F;.oh-my-zsh&quot;# Set name of the theme to load --- if set to &quot;random&quot;, it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https:&#x2F;&#x2F;github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;wiki&#x2F;ThemesZSH_THEME&#x3D;&quot;robbyrussell&quot;# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME&#x3D;random will cause zsh to load# a theme from this variable instead of looking in $ZSH&#x2F;themes&#x2F;# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES&#x3D;( &quot;robbyrussell&quot; &quot;agnoster&quot; )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE&#x3D;&quot;true&quot;# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE&#x3D;&quot;true&quot;# Uncomment one of the following lines to change the auto-update behavior# zstyle &#39;:omz:update&#39; mode disabled  # disable automatic updates# zstyle &#39;:omz:update&#39; mode auto      # update automatically without asking# zstyle &#39;:omz:update&#39; mode reminder  # just remind me to update when it&#39;s time# Uncomment the following line to change how often to auto-update (in days).# zstyle &#39;:omz:update&#39; frequency 13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS&#x3D;&quot;true&quot;# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS&#x3D;&quot;true&quot;# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE&#x3D;&quot;true&quot;# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION&#x3D;&quot;true&quot;# Uncomment the following line to display red dots whilst waiting for completion.# You can also set it to another string to have that shown instead of the default red dots.# e.g. COMPLETION_WAITING_DOTS&#x3D;&quot;%F&#123;yellow&#125;waiting...%f&quot;# Caution: this setting can cause issues with multiline prompts in zsh &lt; 5.7.1 (see #5765)# COMPLETION_WAITING_DOTS&#x3D;&quot;true&quot;# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY&#x3D;&quot;true&quot;# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# &quot;mm&#x2F;dd&#x2F;yyyy&quot;|&quot;dd.mm.yyyy&quot;|&quot;yyyy-mm-dd&quot;# or set a custom format using the strftime function format specifications,# see &#39;man strftime&#39; for details.# HIST_STAMPS&#x3D;&quot;mm&#x2F;dd&#x2F;yyyy&quot;# Would you like to use another custom folder than $ZSH&#x2F;custom?# ZSH_CUSTOM&#x3D;&#x2F;path&#x2F;to&#x2F;new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in $ZSH&#x2F;plugins&#x2F;# Custom plugins may be added to $ZSH_CUSTOM&#x2F;plugins&#x2F;# Example format: plugins&#x3D;(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.# 插件信息plugins&#x3D;(  git  zsh-syntax-highlighting  zsh-autosuggestions  autojump)source $ZSH&#x2F;oh-my-zsh.sh[[ -s $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . $(brew --prefix)&#x2F;etc&#x2F;profile.d&#x2F;autojump.shsource $ZSH&#x2F;oh-my-zsh.sh# User configurationPROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d $ &quot;# PROMPT&#x3D;&quot;%(?:%&#123;$fg_bold[yellow]%&#125;♠ :%&#123;$fg_bold[red]%&#125;♠ )%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[magenta]%&#125;$ &quot;PROMPT+&#x3D;&#39;%&#123;$reset_color%&#125;&#39;ZSH_THEME_GIT_PROMPT_PREFIX&#x3D;&quot;%&#123;$fg_bold[blue]%&#125;&quot;ZSH_THEME_GIT_PROMPT_SUFFIX&#x3D;&quot;%&#123;$reset_color%&#125; &quot;ZSH_THEME_GIT_PROMPT_DIRTY&#x3D;&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;ZSH_THEME_GIT_PROMPT_CLEAN&#x3D;&quot;%&#123;$fg[blue]%&#125;)&quot;# 参考 https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b84d8b7b134e# codevalue# %T系统时间（时：分）# %*系统时间（时：分：秒）# %D系统日期（年-月-日）# %n用户名# %B - %b开始到结束使用粗体打印# %U - %u开始到结束使用下划线打印# %c仅当前文件夹路径# %d当前目录路径完整# %~当前目录相对于～的相对路径# %M计算机的主机名# %m计算机的主机名（在第一个句号之前截断# %l当前的tty# export MANPATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;man:$MANPATH&quot;# You may need to manually set your language environment# export LANG&#x3D;en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then#   export EDITOR&#x3D;&#39;vim&#39;# else#   export EDITOR&#x3D;&#39;mvim&#39;# fi# Compilation flags# export ARCHFLAGS&#x3D;&quot;-arch x86_64&quot;# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run &#96;alias&#96;.## Example aliases# alias zshconfig&#x3D;&quot;mate ~&#x2F;.zshrc&quot;# alias ohmyzsh&#x3D;&quot;mate ~&#x2F;.oh-my-zsh&quot;</code></pre><h2 id="推荐博客左岸博客"><a href="#推荐博客左岸博客" class="headerlink" title="推荐博客左岸博客"></a>推荐博客<a href="https://www.zrahh.com/archives/167.html">左岸博客</a></h2><h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><img src="http://t-blog-images.aijs.top/img/11460713-14c8ef376aabe04a.png"><br><img src="http://t-blog-images.aijs.top/img/11460713-ef2da0af46da7712.png"><br><img src="http://t-blog-images.aijs.top/img/11460713-e49ed15245409774.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 增效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量删除目录</title>
      <link href="//post/2019-10-30shell.html"/>
      <url>//post/2019-10-30shell.html</url>
      
        <content type="html"><![CDATA[<h2 id="删除某个目录下所有子目录的node-modules"><a href="#删除某个目录下所有子目录的node-modules" class="headerlink" title="删除某个目录下所有子目录的node_modules"></a>删除某个目录下所有子目录的node_modules</h2><pre class="line-numbers language-none"><code class="language-none"># 查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 modu 执行删除find &#x2F;tmp&#x2F;test&#x2F; -type d -name modu |xargs rm -rf</code></pre><pre class="line-numbers language-none"><code class="language-none"># 查找 &#x2F;tmp&#x2F;test&#x2F; 子目录下所有 node_modules 执行删除find &#x2F;tmp&#x2F;test&#x2F; -type d -name node_modules |xargs rm -rf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 增效 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layoffs</title>
      <link href="//post/2022-03-25Layoffs.html"/>
      <url>//post/2022-03-25Layoffs.html</url>
      
        <content type="html"><![CDATA[<h2 id="一家上市公司近期「B业」人数变化"><a href="#一家上市公司近期「B业」人数变化" class="headerlink" title="一家上市公司近期「B业」人数变化"></a>一家上市公司近期「B业」人数变化</h2><p><img src="http://t-blog-images.aijs.top/img/11460713-98eaa0e7b6e68c6f.png" alt="2022-03-30"><br><img src="http://t-blog-images.aijs.top/img/11460713-f2c5edfe1032663d.png" alt="2022-03-31"><br><img src="http://t-blog-images.aijs.top/img/11460713-0d1febc4e52867bd.png" alt="2022-04-01"><br><img src="http://t-blog-images.aijs.top/img/11460713-3c855f37997fca9d.png" alt="2022-04-02"><br><img src="http://t-blog-images.aijs.top/img/11460713-33ab1685e98181c5.png" alt="2022-04-07"><br><img src="http://t-blog-images.aijs.top/img/11460713-f6178de2c725ba0d.png" alt="2022-04-08"><br><img src="http://t-blog-images.aijs.top/img/11460713-1c49e477ebebdb04.png" alt="2022-04-11"><br><img src="http://t-blog-images.aijs.top/img/11460713-ff83505b93a40211.png" alt="2022-04-12"><br><img src="http://t-blog-images.aijs.top/img/11460713-6e26dc81d1bc1bb5.png" alt="2022-04-13"><br><img src="http://t-blog-images.aijs.top/img/11460713-6f19d0ccbc1470d1.png" alt="2022-04-14"><br><img src="http://t-blog-images.aijs.top/img/11460713-5fa4eb0d60075e10.png" alt="2022-04-15"><br><img src="http://t-blog-images.aijs.top/img/11460713-a75f3fa3bc0cc9ad.png" alt="2022-04-20"><br><img src="http://t-blog-images.aijs.top/img/11460713-2cb92c5f9a24df72.png" alt="2022-04-21"><br><img src="http://t-blog-images.aijs.top/img/11460713-ea85739148839bd2.png" alt="image.png"><br><img src="http://t-blog-images.aijs.top/img/11460713-cc82a2680e69dccd.png" alt="2022-04-26"><br><img src="http://t-blog-images.aijs.top/img/11460713-fdd722c44a598a88.png" alt="2022-04-27"><br><img src="http://t-blog-images.aijs.top/img/11460713-35395fd4c9b459ea.png" alt="2022-04-28"><br><img src="http://t-blog-images.aijs.top/img/20220505093216.webp" alt="2022-05-05"><br><img src="http://t-blog-images.aijs.top/img/20220509134022.webp" alt="2022-05-09"><br><img src="http://t-blog-images.aijs.top/img/20220510180811.webp" alt="2022-05-10"></p>]]></content>
      
      
      <categories>
          
          <category> Layoffs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Layoffs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nestjs服务端技术栈</title>
      <link href="//post/2021-06-30node.html"/>
      <url>//post/2021-06-30node.html</url>
      
        <content type="html"><![CDATA[<h2 id="NestJS中文文档"><a href="#NestJS中文文档" class="headerlink" title="NestJS中文文档"></a>NestJS中文文档</h2><p><a href="https://nestjs.bootcss.com/">NestJS中文文档</a><br><a href="https://docs.nestjs.cn/">NestJS中文文档</a><br><a href="https://github.com/nestjs/nest">github</a> 42.2K</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>A progressive Node.js framework for building efficient, scalable, and enterprise-grade server-side applications on top of TypeScript &amp; JavaScript (ES6, ES7, ES8) 🚀</p></blockquote><h2 id="TypeORM"><a href="#TypeORM" class="headerlink" title="TypeORM"></a>TypeORM</h2><p><a href="https://typeorm.biunav.com/zh/#%E5%AE%89%E8%A3%85">TypeORM中文文档</a><br><a href="https://github.com/typeorm/typeorm">github地址</a> 26.3K</p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>ORM for TypeScript and JavaScript (ES7, ES6, ES5). Supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, SAP Hana, WebSQL databases. Works in NodeJS, Browser, Ionic, Cordova and Electron platforms.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web office预览</title>
      <link href="//post/2021-09-07web.html"/>
      <url>//post/2021-09-07web.html</url>
      
        <content type="html"><![CDATA[<p>第一步<br>将文件上传到你的服务器里，并支持url下载这个文件。<br>第二步<br>访问：<a href="http://view.officeapps.live.com/op/view.aspx?src=%E8%A6%81%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6%E7%9A%84url%E5%9C%B0%E5%9D%80%EF%BC%88%E8%AE%B0%E5%BE%97url%E7%BC%96%E7%A0%81%E5%93%A6%EF%BC%89">http://view.officeapps.live.com/op/view.aspx?src=要预览文件的url地址（记得url编码哦）</a><br>第三步<br>可以使用iframe嵌入你的系统<br>更多<br>详情查看：<a href="https://www.microsoft.com/en-us/microsoft-365/blog/2013/04/10/office-web-viewer-view-office-documents-in-a-browser/?eu=true">https://www.microsoft.com/en-us/microsoft-365/blog/2013/04/10/office-web-viewer-view-office-documents-in-a-browser/?eu=true</a><br><img src="http://t-blog-images.aijs.top/img/11460713-93b26693cac5c2d8.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-dev</title>
      <link href="//post/2021-11-02node.html"/>
      <url>//post/2021-11-02node.html</url>
      
        <content type="html"><![CDATA[<h2 id="在幕后用ts-node调整node-dev"><a href="#在幕后用ts-node调整node-dev" class="headerlink" title="在幕后用ts-node调整node-dev"></a>在幕后用ts-node调整node-dev</h2><ul><li>作用：在幕后用ts-node调整node-dev</li><li>优点：<ul><li>任意依赖的文件改变时候，重启node process，但是共享ts编译线程。</li><li>因为不需要每次ts-node编译的实例化，而提升性能</li></ul></li><li>配置项：</li><li>注意事项：</li><li>截图：<br><img src="http://t-blog-images.aijs.top/img/11460713-10cfe41335cfeb5d.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简书迁移到OSS</title>
      <link href="//post/2022-04-27mv-blog-jianshu.html"/>
      <url>//post/2022-04-27mv-blog-jianshu.html</url>
      
        <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre class="line-numbers language-none"><code class="language-none">cat .&#x2F;* |grep uploadimages.jianshu.io &gt; image.txtmkdir img3dcd img3dwget -i ..&#x2F;image.txtsed -i&#39;&#39; -e &#39;s&#x2F;!\[image.png\](&#x2F;&#x2F;g&#39; image.txtsed -i&#39;&#39; -e &#39;s&#x2F;)&#x2F;&#x2F;g&#39; image.txt</code></pre><h2 id="迁移简书图片下载后重命名"><a href="#迁移简书图片下载后重命名" class="headerlink" title="迁移简书图片下载后重命名"></a>迁移简书图片下载后重命名</h2><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;bin&#x2F;shfor eachfile in &#96;ls -B&#96;do    # echo $&#123;eachfile%%\%3F*&#125; # 截掉最后.txt    # $ % https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b3bdc3b3968e  filename&#x3D;$&#123;eachfile%%\%3F*&#125;  filehead&#x3D;&#96;echo $eachfile | awk -F \%3F &#39;&#123;print $1 &#125;&#39;&#96;  filelast&#x3D;&#96;echo $eachfile | awk -F \%3F &#39;&#123;print $2 &#125;&#39;&#96;  # mv $filename.txt $&#123;filelast&#125;_$filehead.txt  # https:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1726788915185806701&amp;wfr&#x3D;spider&amp;for&#x3D;pc  echo &#39;--&#39;  # echo $filename  echo $filehead #分割字符左边部分  echo $filelast #分割字符右边部分  # 右边文件存在的情况下才处理  if [ &quot;$filelast&quot; !&#x3D; &quot;&quot; ]  then    echo &#39;执行rename &#39;    mv $eachfile $filehead  fidone</code></pre>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
